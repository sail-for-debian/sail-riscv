chapter \<open>Generated by Lem from \<open>generated_definitions/lem/RV64/riscv.lem\<close>.\<close>

theory "Riscv" 

imports
  Main
  "LEM.Lem_pervasives_extra"
  "Sail.Sail2_instr_kinds"
  "Sail.Sail2_values"
  "Sail.Sail2_operators_mwords"
  "Sail.Sail2_prompt_monad"
  "Sail.Sail2_prompt"
  "Sail.Sail2_string"
  "Riscv_types"
  "Mem_metadata"
  "Riscv_extras_fdext"
  "Riscv_extras"

begin 

\<comment> \<open>\<open>Generated by Sail from riscv.\<close>\<close>
\<comment> \<open>\<open>open import Pervasives_extra\<close>\<close>
\<comment> \<open>\<open>open import Sail2_instr_kinds\<close>\<close>
\<comment> \<open>\<open>open import Sail2_values\<close>\<close>
\<comment> \<open>\<open>open import Sail2_string\<close>\<close>
\<comment> \<open>\<open>open import Sail2_operators_mwords\<close>\<close>
\<comment> \<open>\<open>open import Sail2_prompt_monad\<close>\<close>
\<comment> \<open>\<open>open import Sail2_prompt\<close>\<close>
\<comment> \<open>\<open>open import Riscv_types\<close>\<close>
\<comment> \<open>\<open>open import Mem_metadata\<close>\<close>
\<comment> \<open>\<open>open import Riscv_extras_fdext\<close>\<close>
\<comment> \<open>\<open>open import Riscv_extras\<close>\<close>

\<comment> \<open>\<open>val is_none : forall 'a. maybe 'a -> bool\<close>\<close>

fun is_none  :: \<open> 'a option \<Rightarrow> bool \<close>  where 
     \<open> is_none (Some (_)) = ( False )\<close>
|\<open> is_none None = ( True )\<close>


\<comment> \<open>\<open>val is_some : forall 'a. maybe 'a -> bool\<close>\<close>

fun is_some  :: \<open> 'a option \<Rightarrow> bool \<close>  where 
     \<open> is_some (Some (_)) = ( True )\<close>
|\<open> is_some None = ( False )\<close>


\<comment> \<open>\<open>val eq_unit : unit -> unit -> bool\<close>\<close>

definition eq_unit  :: \<open> unit \<Rightarrow> unit \<Rightarrow> bool \<close>  where 
     \<open> eq_unit _ _ = ( True )\<close>




\<comment> \<open>\<open>val neq_bool : bool -> bool -> bool\<close>\<close>

definition neq_bool  :: \<open> bool \<Rightarrow> bool \<Rightarrow> bool \<close>  where 
     \<open> neq_bool x y = ( \<not> (((x = y))))\<close> 
  for  x  :: " bool " 
  and  y  :: " bool "


\<comment> \<open>\<open>val __id : integer -> integer\<close>\<close>

definition id0  :: \<open> int \<Rightarrow> int \<close>  where 
     \<open> id0 x = ( x )\<close> 
  for  x  :: " int "


\<comment> \<open>\<open>val _shl_int_general : ii -> ii -> ii\<close>\<close>

definition shl_int_general  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<close>  where 
     \<open> shl_int_general (m :: ii) (n :: ii) = (
   if ((n \<ge> (( 0 :: int)::ii))) then shl_int m n
   else shr_int m ((- n)))\<close> 
  for  m  :: " int " 
  and  n  :: " int "


\<comment> \<open>\<open>val _shr_int_general : ii -> ii -> ii\<close>\<close>

definition shr_int_general  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<close>  where 
     \<open> shr_int_general (m :: ii) (n :: ii) = (
   if ((n \<ge> (( 0 :: int)::ii))) then shr_int m n
   else shl_int m ((- n)))\<close> 
  for  m  :: " int " 
  and  n  :: " int "


\<comment> \<open>\<open>val fdiv_int : ii -> ii -> ii\<close>\<close>

definition fdiv_int  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<close>  where 
     \<open> fdiv_int (n :: ii) (m :: ii) = (
   if (((((n < (( 0 :: int)::ii))) \<and> ((m > (( 0 :: int)::ii)))))) then
     ((tdiv_int ((n + (( 1 :: int)::ii))) m)) - (( 1 :: int)::ii)
   else if (((((n > (( 0 :: int)::ii))) \<and> ((m < (( 0 :: int)::ii)))))) then
     ((tdiv_int ((n - (( 1 :: int)::ii))) m)) - (( 1 :: int)::ii)
   else tdiv_int n m )\<close> 
  for  n  :: " int " 
  and  m  :: " int "


\<comment> \<open>\<open>val fmod_int : ii -> ii -> ii\<close>\<close>

definition fmod_int  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<close>  where 
     \<open> fmod_int (n :: ii) (m :: ii) = ( n - ((m * ((fdiv_int n m)))))\<close> 
  for  n  :: " int " 
  and  m  :: " int "


\<comment> \<open>\<open>val concat_str_bits : forall 'n. Size 'n => string -> mword 'n -> string\<close>\<close>

definition concat_str_bits  :: \<open> string \<Rightarrow>('n::len)Word.word \<Rightarrow> string \<close>  where 
     \<open> concat_str_bits str x = ( (@) str ((string_of_bits x)))\<close> 
  for  str  :: " string " 
  and  x  :: "('n::len)Word.word "


\<comment> \<open>\<open>val concat_str_dec : string -> ii -> string\<close>\<close>

definition concat_str_dec  :: \<open> string \<Rightarrow> int \<Rightarrow> string \<close>  where 
     \<open> concat_str_dec str x = ( (@) str ((dec_str x)))\<close> 
  for  str  :: " string " 
  and  x  :: " int "




\<comment> \<open>\<open>val sail_mask : forall 'len 'v. Size 'len, Size 'v => integer -> mword 'v -> mword 'len\<close>\<close>

definition sail_mask  :: \<open> int \<Rightarrow>('v::len)Word.word \<Rightarrow>('len::len)Word.word \<close>  where 
     \<open> sail_mask len v = (
   if ((len \<le> ((int (size v))))) then (vector_truncate v len  :: ( 'len::len)Word.word)
   else (zero_extend v len  :: ( 'len::len)Word.word))\<close> 
  for  len  :: " int " 
  and  v  :: "('v::len)Word.word "


\<comment> \<open>\<open>val sail_ones : forall 'n. Size 'n => integer -> mword 'n\<close>\<close>

definition sail_ones  :: \<open> int \<Rightarrow>('n::len)Word.word \<close>  where 
     \<open> sail_ones n = ( (not_vec ((zeros n  :: ( 'n::len)Word.word))  :: ( 'n::len)Word.word))\<close> 
  for  n  :: " int "


\<comment> \<open>\<open>val slice_mask : forall 'n. Size 'n => integer -> ii -> ii -> mword 'n\<close>\<close>

definition slice_mask  :: \<open> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>('n::len)Word.word \<close>  where 
     \<open> slice_mask n i l = (
   if ((l \<ge> n)) then (shiftl ((sail_ones n  :: ( 'n::len)Word.word)) i  :: ( 'n::len)Word.word)
   else
     (let (one :: ( 'n::len)Word.word) = ((sail_mask n ( 0b1 ::  1 Word.word)  :: ( 'n::len)Word.word)) in
     (shiftl ((sub_vec ((shiftl one l  :: ( 'n::len)Word.word)) one  :: ( 'n::len)Word.word)) i  :: ( 'n::len)Word.word)))\<close> 
  for  n  :: " int " 
  and  i  :: " int " 
  and  l  :: " int "


\<comment> \<open>\<open>val read_kind_of_num : integer -> read_kind\<close>\<close>

definition read_kind_of_num  :: \<open> int \<Rightarrow> read_kind \<close>  where 
     \<open> read_kind_of_num arg1 = (
   (let l__292 = arg1 in
   if (((l__292 = (( 0 :: int)::ii)))) then Read_plain
   else if (((l__292 = (( 1 :: int)::ii)))) then Read_reserve
   else if (((l__292 = (( 2 :: int)::ii)))) then Read_acquire
   else if (((l__292 = (( 3 :: int)::ii)))) then Read_exclusive
   else if (((l__292 = (( 4 :: int)::ii)))) then Read_exclusive_acquire
   else if (((l__292 = (( 5 :: int)::ii)))) then Read_stream
   else if (((l__292 = (( 6 :: int)::ii)))) then Read_RISCV_acquire
   else if (((l__292 = (( 7 :: int)::ii)))) then Read_RISCV_strong_acquire
   else if (((l__292 = (( 8 :: int)::ii)))) then Read_RISCV_reserved
   else if (((l__292 = (( 9 :: int)::ii)))) then Read_RISCV_reserved_acquire
   else if (((l__292 = (( 10 :: int)::ii)))) then Read_RISCV_reserved_strong_acquire
   else Read_X86_locked))\<close> 
  for  arg1  :: " int "


\<comment> \<open>\<open>val num_of_read_kind : read_kind -> integer\<close>\<close>

fun num_of_read_kind  :: \<open> read_kind \<Rightarrow> int \<close>  where 
     \<open> num_of_read_kind Read_plain = ( (( 0 :: int)::ii))\<close>
|\<open> num_of_read_kind Read_reserve = ( (( 1 :: int)::ii))\<close>
|\<open> num_of_read_kind Read_acquire = ( (( 2 :: int)::ii))\<close>
|\<open> num_of_read_kind Read_exclusive = ( (( 3 :: int)::ii))\<close>
|\<open> num_of_read_kind Read_exclusive_acquire = ( (( 4 :: int)::ii))\<close>
|\<open> num_of_read_kind Read_stream = ( (( 5 :: int)::ii))\<close>
|\<open> num_of_read_kind Read_RISCV_acquire = ( (( 6 :: int)::ii))\<close>
|\<open> num_of_read_kind Read_RISCV_strong_acquire = ( (( 7 :: int)::ii))\<close>
|\<open> num_of_read_kind Read_RISCV_reserved = ( (( 8 :: int)::ii))\<close>
|\<open> num_of_read_kind Read_RISCV_reserved_acquire = ( (( 9 :: int)::ii))\<close>
|\<open> num_of_read_kind Read_RISCV_reserved_strong_acquire = ( (( 10 :: int)::ii))\<close>
|\<open> num_of_read_kind Read_X86_locked = ( (( 11 :: int)::ii))\<close>


\<comment> \<open>\<open>val write_kind_of_num : integer -> write_kind\<close>\<close>

definition write_kind_of_num  :: \<open> int \<Rightarrow> write_kind \<close>  where 
     \<open> write_kind_of_num arg1 = (
   (let l__282 = arg1 in
   if (((l__282 = (( 0 :: int)::ii)))) then Write_plain
   else if (((l__282 = (( 1 :: int)::ii)))) then Write_conditional
   else if (((l__282 = (( 2 :: int)::ii)))) then Write_release
   else if (((l__282 = (( 3 :: int)::ii)))) then Write_exclusive
   else if (((l__282 = (( 4 :: int)::ii)))) then Write_exclusive_release
   else if (((l__282 = (( 5 :: int)::ii)))) then Write_RISCV_release
   else if (((l__282 = (( 6 :: int)::ii)))) then Write_RISCV_strong_release
   else if (((l__282 = (( 7 :: int)::ii)))) then Write_RISCV_conditional
   else if (((l__282 = (( 8 :: int)::ii)))) then Write_RISCV_conditional_release
   else if (((l__282 = (( 9 :: int)::ii)))) then Write_RISCV_conditional_strong_release
   else Write_X86_locked))\<close> 
  for  arg1  :: " int "


\<comment> \<open>\<open>val num_of_write_kind : write_kind -> integer\<close>\<close>

fun num_of_write_kind  :: \<open> write_kind \<Rightarrow> int \<close>  where 
     \<open> num_of_write_kind Write_plain = ( (( 0 :: int)::ii))\<close>
|\<open> num_of_write_kind Write_conditional = ( (( 1 :: int)::ii))\<close>
|\<open> num_of_write_kind Write_release = ( (( 2 :: int)::ii))\<close>
|\<open> num_of_write_kind Write_exclusive = ( (( 3 :: int)::ii))\<close>
|\<open> num_of_write_kind Write_exclusive_release = ( (( 4 :: int)::ii))\<close>
|\<open> num_of_write_kind Write_RISCV_release = ( (( 5 :: int)::ii))\<close>
|\<open> num_of_write_kind Write_RISCV_strong_release = ( (( 6 :: int)::ii))\<close>
|\<open> num_of_write_kind Write_RISCV_conditional = ( (( 7 :: int)::ii))\<close>
|\<open> num_of_write_kind Write_RISCV_conditional_release = ( (( 8 :: int)::ii))\<close>
|\<open> num_of_write_kind Write_RISCV_conditional_strong_release = ( (( 9 :: int)::ii))\<close>
|\<open> num_of_write_kind Write_X86_locked = ( (( 10 :: int)::ii))\<close>


\<comment> \<open>\<open>val a64_barrier_domain_of_num : integer -> a64_barrier_domain\<close>\<close>

definition a64_barrier_domain_of_num  :: \<open> int \<Rightarrow> a64_barrier_domain \<close>  where 
     \<open> a64_barrier_domain_of_num arg1 = (
   (let l__279 = arg1 in
   if (((l__279 = (( 0 :: int)::ii)))) then A64_FullShare
   else if (((l__279 = (( 1 :: int)::ii)))) then A64_InnerShare
   else if (((l__279 = (( 2 :: int)::ii)))) then A64_OuterShare
   else A64_NonShare))\<close> 
  for  arg1  :: " int "


\<comment> \<open>\<open>val num_of_a64_barrier_domain : a64_barrier_domain -> integer\<close>\<close>

fun num_of_a64_barrier_domain  :: \<open> a64_barrier_domain \<Rightarrow> int \<close>  where 
     \<open> num_of_a64_barrier_domain A64_FullShare = ( (( 0 :: int)::ii))\<close>
|\<open> num_of_a64_barrier_domain A64_InnerShare = ( (( 1 :: int)::ii))\<close>
|\<open> num_of_a64_barrier_domain A64_OuterShare = ( (( 2 :: int)::ii))\<close>
|\<open> num_of_a64_barrier_domain A64_NonShare = ( (( 3 :: int)::ii))\<close>


\<comment> \<open>\<open>val a64_barrier_type_of_num : integer -> a64_barrier_type\<close>\<close>

definition a64_barrier_type_of_num  :: \<open> int \<Rightarrow> a64_barrier_type \<close>  where 
     \<open> a64_barrier_type_of_num arg1 = (
   (let l__277 = arg1 in
   if (((l__277 = (( 0 :: int)::ii)))) then A64_barrier_all
   else if (((l__277 = (( 1 :: int)::ii)))) then A64_barrier_LD
   else A64_barrier_ST))\<close> 
  for  arg1  :: " int "


\<comment> \<open>\<open>val num_of_a64_barrier_type : a64_barrier_type -> integer\<close>\<close>

fun num_of_a64_barrier_type  :: \<open> a64_barrier_type \<Rightarrow> int \<close>  where 
     \<open> num_of_a64_barrier_type A64_barrier_all = ( (( 0 :: int)::ii))\<close>
|\<open> num_of_a64_barrier_type A64_barrier_LD = ( (( 1 :: int)::ii))\<close>
|\<open> num_of_a64_barrier_type A64_barrier_ST = ( (( 2 :: int)::ii))\<close>


\<comment> \<open>\<open>val trans_kind_of_num : integer -> trans_kind\<close>\<close>

definition trans_kind_of_num  :: \<open> int \<Rightarrow> trans_kind \<close>  where 
     \<open> trans_kind_of_num arg1 = (
   (let l__275 = arg1 in
   if (((l__275 = (( 0 :: int)::ii)))) then Transaction_start
   else if (((l__275 = (( 1 :: int)::ii)))) then Transaction_commit
   else Transaction_abort))\<close> 
  for  arg1  :: " int "


\<comment> \<open>\<open>val num_of_trans_kind : trans_kind -> integer\<close>\<close>

fun num_of_trans_kind  :: \<open> trans_kind \<Rightarrow> int \<close>  where 
     \<open> num_of_trans_kind Transaction_start = ( (( 0 :: int)::ii))\<close>
|\<open> num_of_trans_kind Transaction_commit = ( (( 1 :: int)::ii))\<close>
|\<open> num_of_trans_kind Transaction_abort = ( (( 2 :: int)::ii))\<close>


\<comment> \<open>\<open>val cache_op_kind_of_num : integer -> cache_op_kind\<close>\<close>

definition cache_op_kind_of_num  :: \<open> int \<Rightarrow> cache_op_kind \<close>  where 
     \<open> cache_op_kind_of_num arg1 = (
   (let l__265 = arg1 in
   if (((l__265 = (( 0 :: int)::ii)))) then Cache_op_D_IVAC
   else if (((l__265 = (( 1 :: int)::ii)))) then Cache_op_D_ISW
   else if (((l__265 = (( 2 :: int)::ii)))) then Cache_op_D_CSW
   else if (((l__265 = (( 3 :: int)::ii)))) then Cache_op_D_CISW
   else if (((l__265 = (( 4 :: int)::ii)))) then Cache_op_D_ZVA
   else if (((l__265 = (( 5 :: int)::ii)))) then Cache_op_D_CVAC
   else if (((l__265 = (( 6 :: int)::ii)))) then Cache_op_D_CVAU
   else if (((l__265 = (( 7 :: int)::ii)))) then Cache_op_D_CIVAC
   else if (((l__265 = (( 8 :: int)::ii)))) then Cache_op_I_IALLUIS
   else if (((l__265 = (( 9 :: int)::ii)))) then Cache_op_I_IALLU
   else Cache_op_I_IVAU))\<close> 
  for  arg1  :: " int "


\<comment> \<open>\<open>val num_of_cache_op_kind : cache_op_kind -> integer\<close>\<close>

fun num_of_cache_op_kind  :: \<open> cache_op_kind \<Rightarrow> int \<close>  where 
     \<open> num_of_cache_op_kind Cache_op_D_IVAC = ( (( 0 :: int)::ii))\<close>
|\<open> num_of_cache_op_kind Cache_op_D_ISW = ( (( 1 :: int)::ii))\<close>
|\<open> num_of_cache_op_kind Cache_op_D_CSW = ( (( 2 :: int)::ii))\<close>
|\<open> num_of_cache_op_kind Cache_op_D_CISW = ( (( 3 :: int)::ii))\<close>
|\<open> num_of_cache_op_kind Cache_op_D_ZVA = ( (( 4 :: int)::ii))\<close>
|\<open> num_of_cache_op_kind Cache_op_D_CVAC = ( (( 5 :: int)::ii))\<close>
|\<open> num_of_cache_op_kind Cache_op_D_CVAU = ( (( 6 :: int)::ii))\<close>
|\<open> num_of_cache_op_kind Cache_op_D_CIVAC = ( (( 7 :: int)::ii))\<close>
|\<open> num_of_cache_op_kind Cache_op_I_IALLUIS = ( (( 8 :: int)::ii))\<close>
|\<open> num_of_cache_op_kind Cache_op_I_IALLU = ( (( 9 :: int)::ii))\<close>
|\<open> num_of_cache_op_kind Cache_op_I_IVAU = ( (( 10 :: int)::ii))\<close>


\<comment> \<open>\<open>val not_bit : bitU -> bitU\<close>\<close>

definition not_bit0  :: \<open> bitU \<Rightarrow> bitU \<close>  where 
     \<open> not_bit0 b = ( if (((b = B1))) then B0 else B1 )\<close> 
  for  b  :: " bitU "






\<comment> \<open>\<open>val string_of_bit : bitU -> string\<close>\<close>

fun string_of_bit  :: \<open> bitU \<Rightarrow> string \<close>  where 
     \<open> string_of_bit B0 = ( (''0b0''))\<close>
|\<open> string_of_bit B1 = ( (''0b1''))\<close>


\<comment> \<open>\<open>val get_config_print_instr : unit -> bool\<close>\<close>

\<comment> \<open>\<open>val get_config_print_reg : unit -> bool\<close>\<close>

\<comment> \<open>\<open>val get_config_print_mem : unit -> bool\<close>\<close>

\<comment> \<open>\<open>val get_config_print_platform : unit -> bool\<close>\<close>

definition get_config_print_instr  :: \<open> unit \<Rightarrow> bool \<close>  where 
     \<open> get_config_print_instr _ = ( False )\<close>


definition get_config_print_reg  :: \<open> unit \<Rightarrow> bool \<close>  where 
     \<open> get_config_print_reg _ = ( False )\<close>


definition get_config_print_mem  :: \<open> unit \<Rightarrow> bool \<close>  where 
     \<open> get_config_print_mem _ = ( False )\<close>


definition get_config_print_platform  :: \<open> unit \<Rightarrow> bool \<close>  where 
     \<open> get_config_print_platform _ = ( False )\<close>


\<comment> \<open>\<open>val EXTS : forall 'm 'n. Size 'm, Size 'n => integer -> mword 'n -> mword 'm\<close>\<close>

\<comment> \<open>\<open>val EXTZ : forall 'm 'n. Size 'm, Size 'n => integer -> mword 'n -> mword 'm\<close>\<close>

definition EXTS  :: \<open> int \<Rightarrow>('n::len)Word.word \<Rightarrow>('m::len)Word.word \<close>  where 
     \<open> EXTS m v = ( (sign_extend v m  :: ( 'm::len)Word.word))\<close> 
  for  m  :: " int " 
  and  v  :: "('n::len)Word.word "


definition EXTZ  :: \<open> int \<Rightarrow>('n::len)Word.word \<Rightarrow>('m::len)Word.word \<close>  where 
     \<open> EXTZ m v = ( (zero_extend v m  :: ( 'm::len)Word.word))\<close> 
  for  m  :: " int " 
  and  v  :: "('n::len)Word.word "


\<comment> \<open>\<open>val zeros_implicit : forall 'n. Size 'n => integer -> mword 'n\<close>\<close>

definition zeros_implicit  :: \<open> int \<Rightarrow>('n::len)Word.word \<close>  where 
     \<open> zeros_implicit n = ( (zeros n  :: ( 'n::len)Word.word))\<close> 
  for  n  :: " int "


\<comment> \<open>\<open>val ones : forall 'n. Size 'n => integer -> mword 'n\<close>\<close>

definition ones  :: \<open> int \<Rightarrow>('n::len)Word.word \<close>  where 
     \<open> ones n = ( (sail_ones n  :: ( 'n::len)Word.word))\<close> 
  for  n  :: " int "


\<comment> \<open>\<open>val bool_to_bits : bool -> mword ty1\<close>\<close>

definition bool_to_bits  :: \<open> bool \<Rightarrow>(1)Word.word \<close>  where 
     \<open> bool_to_bits x = ( if x then ( 0b1 ::  1 Word.word) else ( 0b0 ::  1 Word.word))\<close> 
  for  x  :: " bool "


\<comment> \<open>\<open>val bit_to_bool : bitU -> bool\<close>\<close>

fun bit_to_bool  :: \<open> bitU \<Rightarrow> bool \<close>  where 
     \<open> bit_to_bool B1 = ( True )\<close>
|\<open> bit_to_bool B0 = ( False )\<close>


\<comment> \<open>\<open>val to_bits : forall 'l. Size 'l => integer -> ii -> mword 'l\<close>\<close>

definition to_bits  :: \<open> int \<Rightarrow> int \<Rightarrow>('l::len)Word.word \<close>  where 
     \<open> to_bits l n = ( (get_slice_int l n (( 0 :: int)::ii)  :: ( 'l::len)Word.word))\<close> 
  for  l  :: " int " 
  and  n  :: " int "


\<comment> \<open>\<open>val zopz0zI_s : forall 'n. Size 'n => mword 'n -> mword 'n -> bool\<close>\<close>

\<comment> \<open>\<open>val zopz0zKzJ_s : forall 'n. Size 'n => mword 'n -> mword 'n -> bool\<close>\<close>

\<comment> \<open>\<open>val zopz0zI_u : forall 'n. Size 'n => mword 'n -> mword 'n -> bool\<close>\<close>

\<comment> \<open>\<open>val zopz0zKzJ_u : forall 'n. Size 'n => mword 'n -> mword 'n -> bool\<close>\<close>

\<comment> \<open>\<open>val zopz0zIzJ_u : forall 'n. Size 'n => mword 'n -> mword 'n -> bool\<close>\<close>

definition zopz0zI_s  :: \<open>('n::len)Word.word \<Rightarrow>('n::len)Word.word \<Rightarrow> bool \<close>  where 
     \<open> zopz0zI_s x y = ( ((Word.sint x)) < ((Word.sint y)))\<close> 
  for  x  :: "('n::len)Word.word " 
  and  y  :: "('n::len)Word.word "


definition zopz0zKzJ_s  :: \<open>('n::len)Word.word \<Rightarrow>('n::len)Word.word \<Rightarrow> bool \<close>  where 
     \<open> zopz0zKzJ_s x y = ( ((Word.sint x)) \<ge> ((Word.sint y)))\<close> 
  for  x  :: "('n::len)Word.word " 
  and  y  :: "('n::len)Word.word "


definition zopz0zI_u  :: \<open>('n::len)Word.word \<Rightarrow>('n::len)Word.word \<Rightarrow> bool \<close>  where 
     \<open> zopz0zI_u x y = ( ((Word.uint x)) < ((Word.uint y)))\<close> 
  for  x  :: "('n::len)Word.word " 
  and  y  :: "('n::len)Word.word "


definition zopz0zKzJ_u  :: \<open>('n::len)Word.word \<Rightarrow>('n::len)Word.word \<Rightarrow> bool \<close>  where 
     \<open> zopz0zKzJ_u x y = ( ((Word.uint x)) \<ge> ((Word.uint y)))\<close> 
  for  x  :: "('n::len)Word.word " 
  and  y  :: "('n::len)Word.word "


definition zopz0zIzJ_u  :: \<open>('n::len)Word.word \<Rightarrow>('n::len)Word.word \<Rightarrow> bool \<close>  where 
     \<open> zopz0zIzJ_u x y = ( ((Word.uint x)) \<le> ((Word.uint y)))\<close> 
  for  x  :: "('n::len)Word.word " 
  and  y  :: "('n::len)Word.word "


\<comment> \<open>\<open>val shift_right_arith64 : mword ty64 -> mword ty6 -> mword ty64\<close>\<close>

definition shift_right_arith64  :: \<open>(64)Word.word \<Rightarrow>(6)Word.word \<Rightarrow>(64)Word.word \<close>  where 
     \<open> shift_right_arith64 (v :: 64 bits) (shift :: 6 bits) = (
   (let (v128 :: 128 bits) = ((EXTS (( 128 :: int)::ii) v  ::  128 Word.word)) in
   (subrange_vec_dec ((shift_bits_right v128 shift  ::  128 Word.word)) (( 63 :: int)::ii) (( 0 :: int)::ii)  ::  64 Word.word)))\<close> 
  for  v  :: "(64)Word.word " 
  and  shift  :: "(6)Word.word "


\<comment> \<open>\<open>val shift_right_arith32 : mword ty32 -> mword ty5 -> mword ty32\<close>\<close>

definition shift_right_arith32  :: \<open>(32)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(32)Word.word \<close>  where 
     \<open> shift_right_arith32 (v :: 32 bits) (shift :: 5 bits) = (
   (let (v64 :: 64 bits) = ((EXTS (( 64 :: int)::ii) v  ::  64 Word.word)) in
   (subrange_vec_dec ((shift_bits_right v64 shift  ::  64 Word.word)) (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)))\<close> 
  for  v  :: "(32)Word.word " 
  and  shift  :: "(5)Word.word "


\<comment> \<open>\<open>val spc_forwards : unit -> string\<close>\<close>

\<comment> \<open>\<open>val spc_backwards : string -> unit\<close>\<close>

\<comment> \<open>\<open>val spc_forwards_matches : unit -> bool\<close>\<close>

\<comment> \<open>\<open>val spc_backwards_matches : string -> bool\<close>\<close>

\<comment> \<open>\<open>val spc_matches_prefix : string -> maybe ((unit * ii))\<close>\<close>

\<comment> \<open>\<open>val opt_spc_forwards : unit -> string\<close>\<close>

\<comment> \<open>\<open>val opt_spc_backwards : string -> unit\<close>\<close>

\<comment> \<open>\<open>val opt_spc_forwards_matches : unit -> bool\<close>\<close>

\<comment> \<open>\<open>val opt_spc_backwards_matches : string -> bool\<close>\<close>

\<comment> \<open>\<open>val opt_spc_matches_prefix : string -> maybe ((unit * ii))\<close>\<close>

\<comment> \<open>\<open>val def_spc_forwards : unit -> string\<close>\<close>

\<comment> \<open>\<open>val def_spc_backwards : string -> unit\<close>\<close>

\<comment> \<open>\<open>val def_spc_forwards_matches : unit -> bool\<close>\<close>

\<comment> \<open>\<open>val def_spc_backwards_matches : string -> bool\<close>\<close>

\<comment> \<open>\<open>val def_spc_matches_prefix : string -> maybe ((unit * ii))\<close>\<close>

\<comment> \<open>\<open>val hex_bits_forwards : forall 'n. Size 'n => (integer * mword 'n) -> string\<close>\<close>

\<comment> \<open>\<open>val hex_bits_backwards : forall 'n. Size 'n => string -> (integer * mword 'n)\<close>\<close>

\<comment> \<open>\<open>val hex_bits_forwards_matches : forall 'n. Size 'n => (integer * mword 'n) -> bool\<close>\<close>

\<comment> \<open>\<open>val hex_bits_backwards_matches : string -> bool\<close>\<close>

\<comment> \<open>\<open>val hex_bits_matches_prefix : forall 'n. Size 'n => string -> maybe (((integer * mword 'n) * ii))\<close>\<close>

\<comment> \<open>\<open>val n_leading_spaces : string -> ii\<close>\<close>

function (sequential,domintros)  n_leading_spaces0  :: \<open> string \<Rightarrow> int \<close>  where 
     \<open> n_leading_spaces0 s = (
   (let p00 = s in
   if (((p00 = ('''')))) then (( 0 :: int)::ii)
   else
     (let p00 = (string_take s (( 1 :: int)::ii)) in
     if (((p00 = ('' '')))) then (( 1 :: int)::ii) + ((n_leading_spaces0 ((string_drop s (( 1 :: int)::ii)))))
     else (( 0 :: int)::ii))))\<close> 
  for  s  :: " string " 
by pat_completeness (auto intro!: let_cong bind_cong MemoryOpResult.case_cong)


definition spc_forwards  :: \<open> unit \<Rightarrow> string \<close>  where 
     \<open> spc_forwards _ = ( ('' ''))\<close>


definition spc_backwards  :: \<open> string \<Rightarrow> unit \<close>  where 
     \<open> spc_backwards s = ( ()  )\<close> 
  for  s  :: " string "


definition spc_matches_prefix0  :: \<open> string \<Rightarrow>(unit*int)option \<close>  where 
     \<open> spc_matches_prefix0 s = (
   (let n = (n_leading_spaces0 s) in
   (let l__264 = n in
   if (((l__264 = (( 0 :: int)::ii)))) then None
   else Some (() , n))))\<close> 
  for  s  :: " string "


definition opt_spc_forwards  :: \<open> unit \<Rightarrow> string \<close>  where 
     \<open> opt_spc_forwards _ = ( (''''))\<close>


definition opt_spc_backwards  :: \<open> string \<Rightarrow> unit \<close>  where 
     \<open> opt_spc_backwards s = ( ()  )\<close> 
  for  s  :: " string "


definition opt_spc_matches_prefix0  :: \<open> string \<Rightarrow>(unit*int)option \<close>  where 
     \<open> opt_spc_matches_prefix0 s = ( Some (() , n_leading_spaces0 s))\<close> 
  for  s  :: " string "


definition def_spc_forwards  :: \<open> unit \<Rightarrow> string \<close>  where 
     \<open> def_spc_forwards _ = ( ('' ''))\<close>


definition def_spc_backwards  :: \<open> string \<Rightarrow> unit \<close>  where 
     \<open> def_spc_backwards s = ( ()  )\<close> 
  for  s  :: " string "


definition def_spc_matches_prefix  :: \<open> string \<Rightarrow>(unit*ii)option \<close>  where 
     \<open> def_spc_matches_prefix s = ( opt_spc_matches_prefix0 s )\<close> 
  for  s  :: " string "


\<comment> \<open>\<open>val hex_bits_1_backwards : string -> M (mword ty1)\<close>\<close>

\<comment> \<open>\<open>val hex_bits_1_forwards_matches : mword ty1 -> bool\<close>\<close>

\<comment> \<open>\<open>val hex_bits_1_backwards_matches : string -> bool\<close>\<close>

definition hex_bits_1_forwards_matches  :: \<open>(1)Word.word \<Rightarrow> bool \<close>  where 
     \<open> hex_bits_1_forwards_matches bv = ( True )\<close> 
  for  bv  :: "(1)Word.word "


definition hex_bits_1_backwards_matches  :: \<open> string \<Rightarrow> bool \<close>  where 
     \<open> hex_bits_1_backwards_matches s = (
      if ((case  ((hex_bits_1_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 1 Word.word * ii))option)) of
          Some ((g__373, n)) => if (((n = ((string_length s))))) then True else False
        | _ => False
        )) then
        True
      else False )\<close> 
  for  s  :: " string "


definition hex_bits_1_backwards  :: \<open> string \<Rightarrow>((register_value),((1)Word.word),(exception))monad \<close>  where 
     \<open> hex_bits_1_backwards s = (
   (case  ((hex_bits_1_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 1 Word.word * ii))option)) of
     Some ((bv, n)) =>
      if (((n = ((string_length s))))) then return bv
      else
        assert_exp False (''Pattern match failure at model/prelude_mapping.sail 49:2 - 51:3'') \<then>
        exit0 () 
   | _ =>
      assert_exp False (''Pattern match failure at model/prelude_mapping.sail 49:2 - 51:3'') \<then> exit0 () 
   ))\<close> 
  for  s  :: " string "


\<comment> \<open>\<open>val hex_bits_2_backwards : string -> M (mword ty2)\<close>\<close>

\<comment> \<open>\<open>val hex_bits_2_forwards_matches : mword ty2 -> bool\<close>\<close>

\<comment> \<open>\<open>val hex_bits_2_backwards_matches : string -> bool\<close>\<close>

definition hex_bits_2_forwards_matches  :: \<open>(2)Word.word \<Rightarrow> bool \<close>  where 
     \<open> hex_bits_2_forwards_matches bv = ( True )\<close> 
  for  bv  :: "(2)Word.word "


definition hex_bits_2_backwards_matches  :: \<open> string \<Rightarrow> bool \<close>  where 
     \<open> hex_bits_2_backwards_matches s = (
      if ((case  ((hex_bits_2_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 2 Word.word * ii))option)) of
          Some ((g__372, n)) => if (((n = ((string_length s))))) then True else False
        | _ => False
        )) then
        True
      else False )\<close> 
  for  s  :: " string "


definition hex_bits_2_backwards  :: \<open> string \<Rightarrow>((register_value),((2)Word.word),(exception))monad \<close>  where 
     \<open> hex_bits_2_backwards s = (
   (case  ((hex_bits_2_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 2 Word.word * ii))option)) of
     Some ((bv, n)) =>
      if (((n = ((string_length s))))) then return bv
      else
        assert_exp False (''Pattern match failure at model/prelude_mapping.sail 68:2 - 70:3'') \<then>
        exit0 () 
   | _ =>
      assert_exp False (''Pattern match failure at model/prelude_mapping.sail 68:2 - 70:3'') \<then> exit0 () 
   ))\<close> 
  for  s  :: " string "


\<comment> \<open>\<open>val hex_bits_3_backwards : string -> M (mword ty3)\<close>\<close>

\<comment> \<open>\<open>val hex_bits_3_forwards_matches : mword ty3 -> bool\<close>\<close>

\<comment> \<open>\<open>val hex_bits_3_backwards_matches : string -> bool\<close>\<close>

definition hex_bits_3_forwards_matches  :: \<open>(3)Word.word \<Rightarrow> bool \<close>  where 
     \<open> hex_bits_3_forwards_matches bv = ( True )\<close> 
  for  bv  :: "(3)Word.word "


definition hex_bits_3_backwards_matches  :: \<open> string \<Rightarrow> bool \<close>  where 
     \<open> hex_bits_3_backwards_matches s = (
      if ((case  ((hex_bits_3_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 3 Word.word * ii))option)) of
          Some ((g__371, n)) => if (((n = ((string_length s))))) then True else False
        | _ => False
        )) then
        True
      else False )\<close> 
  for  s  :: " string "


definition hex_bits_3_backwards  :: \<open> string \<Rightarrow>((register_value),((3)Word.word),(exception))monad \<close>  where 
     \<open> hex_bits_3_backwards s = (
   (case  ((hex_bits_3_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 3 Word.word * ii))option)) of
     Some ((bv, n)) =>
      if (((n = ((string_length s))))) then return bv
      else
        assert_exp False (''Pattern match failure at model/prelude_mapping.sail 87:2 - 89:3'') \<then>
        exit0 () 
   | _ =>
      assert_exp False (''Pattern match failure at model/prelude_mapping.sail 87:2 - 89:3'') \<then> exit0 () 
   ))\<close> 
  for  s  :: " string "


\<comment> \<open>\<open>val hex_bits_4_backwards : string -> M (mword ty4)\<close>\<close>

\<comment> \<open>\<open>val hex_bits_4_forwards_matches : mword ty4 -> bool\<close>\<close>

\<comment> \<open>\<open>val hex_bits_4_backwards_matches : string -> bool\<close>\<close>

definition hex_bits_4_forwards_matches  :: \<open>(4)Word.word \<Rightarrow> bool \<close>  where 
     \<open> hex_bits_4_forwards_matches bv = ( True )\<close> 
  for  bv  :: "(4)Word.word "


definition hex_bits_4_backwards_matches  :: \<open> string \<Rightarrow> bool \<close>  where 
     \<open> hex_bits_4_backwards_matches s = (
      if ((case  ((hex_bits_4_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 4 Word.word * ii))option)) of
          Some ((g__370, n)) => if (((n = ((string_length s))))) then True else False
        | _ => False
        )) then
        True
      else False )\<close> 
  for  s  :: " string "


definition hex_bits_4_backwards  :: \<open> string \<Rightarrow>((register_value),((4)Word.word),(exception))monad \<close>  where 
     \<open> hex_bits_4_backwards s = (
   (case  ((hex_bits_4_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 4 Word.word * ii))option)) of
     Some ((bv, n)) =>
      if (((n = ((string_length s))))) then return bv
      else
        assert_exp False (''Pattern match failure at model/prelude_mapping.sail 106:2 - 108:3'') \<then>
        exit0 () 
   | _ =>
      assert_exp False (''Pattern match failure at model/prelude_mapping.sail 106:2 - 108:3'') \<then>
      exit0 () 
   ))\<close> 
  for  s  :: " string "


\<comment> \<open>\<open>val hex_bits_5_backwards : string -> M (mword ty5)\<close>\<close>

\<comment> \<open>\<open>val hex_bits_5_forwards_matches : mword ty5 -> bool\<close>\<close>

\<comment> \<open>\<open>val hex_bits_5_backwards_matches : string -> bool\<close>\<close>

definition hex_bits_5_forwards_matches  :: \<open>(5)Word.word \<Rightarrow> bool \<close>  where 
     \<open> hex_bits_5_forwards_matches bv = ( True )\<close> 
  for  bv  :: "(5)Word.word "


definition hex_bits_5_backwards_matches  :: \<open> string \<Rightarrow> bool \<close>  where 
     \<open> hex_bits_5_backwards_matches s = (
      if ((case  ((hex_bits_5_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 5 Word.word * ii))option)) of
          Some ((g__369, n)) => if (((n = ((string_length s))))) then True else False
        | _ => False
        )) then
        True
      else False )\<close> 
  for  s  :: " string "


definition hex_bits_5_backwards  :: \<open> string \<Rightarrow>((register_value),((5)Word.word),(exception))monad \<close>  where 
     \<open> hex_bits_5_backwards s = (
   (case  ((hex_bits_5_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 5 Word.word * ii))option)) of
     Some ((bv, n)) =>
      if (((n = ((string_length s))))) then return bv
      else
        assert_exp False (''Pattern match failure at model/prelude_mapping.sail 125:2 - 127:3'') \<then>
        exit0 () 
   | _ =>
      assert_exp False (''Pattern match failure at model/prelude_mapping.sail 125:2 - 127:3'') \<then>
      exit0 () 
   ))\<close> 
  for  s  :: " string "


\<comment> \<open>\<open>val hex_bits_6_backwards : string -> M (mword ty6)\<close>\<close>

\<comment> \<open>\<open>val hex_bits_6_forwards_matches : mword ty6 -> bool\<close>\<close>

\<comment> \<open>\<open>val hex_bits_6_backwards_matches : string -> bool\<close>\<close>

definition hex_bits_6_forwards_matches  :: \<open>(6)Word.word \<Rightarrow> bool \<close>  where 
     \<open> hex_bits_6_forwards_matches bv = ( True )\<close> 
  for  bv  :: "(6)Word.word "


definition hex_bits_6_backwards_matches  :: \<open> string \<Rightarrow> bool \<close>  where 
     \<open> hex_bits_6_backwards_matches s = (
      if ((case  ((hex_bits_6_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 6 Word.word * ii))option)) of
          Some ((g__368, n)) => if (((n = ((string_length s))))) then True else False
        | _ => False
        )) then
        True
      else False )\<close> 
  for  s  :: " string "


definition hex_bits_6_backwards  :: \<open> string \<Rightarrow>((register_value),((6)Word.word),(exception))monad \<close>  where 
     \<open> hex_bits_6_backwards s = (
   (case  ((hex_bits_6_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 6 Word.word * ii))option)) of
     Some ((bv, n)) =>
      if (((n = ((string_length s))))) then return bv
      else
        assert_exp False (''Pattern match failure at model/prelude_mapping.sail 144:2 - 146:3'') \<then>
        exit0 () 
   | _ =>
      assert_exp False (''Pattern match failure at model/prelude_mapping.sail 144:2 - 146:3'') \<then>
      exit0 () 
   ))\<close> 
  for  s  :: " string "


\<comment> \<open>\<open>val hex_bits_7_backwards : string -> M (mword ty7)\<close>\<close>

\<comment> \<open>\<open>val hex_bits_7_forwards_matches : mword ty7 -> bool\<close>\<close>

\<comment> \<open>\<open>val hex_bits_7_backwards_matches : string -> bool\<close>\<close>

definition hex_bits_7_forwards_matches  :: \<open>(7)Word.word \<Rightarrow> bool \<close>  where 
     \<open> hex_bits_7_forwards_matches bv = ( True )\<close> 
  for  bv  :: "(7)Word.word "


definition hex_bits_7_backwards_matches  :: \<open> string \<Rightarrow> bool \<close>  where 
     \<open> hex_bits_7_backwards_matches s = (
      if ((case  ((hex_bits_7_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 7 Word.word * ii))option)) of
          Some ((g__367, n)) => if (((n = ((string_length s))))) then True else False
        | _ => False
        )) then
        True
      else False )\<close> 
  for  s  :: " string "


definition hex_bits_7_backwards  :: \<open> string \<Rightarrow>((register_value),((7)Word.word),(exception))monad \<close>  where 
     \<open> hex_bits_7_backwards s = (
   (case  ((hex_bits_7_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 7 Word.word * ii))option)) of
     Some ((bv, n)) =>
      if (((n = ((string_length s))))) then return bv
      else
        assert_exp False (''Pattern match failure at model/prelude_mapping.sail 163:2 - 165:3'') \<then>
        exit0 () 
   | _ =>
      assert_exp False (''Pattern match failure at model/prelude_mapping.sail 163:2 - 165:3'') \<then>
      exit0 () 
   ))\<close> 
  for  s  :: " string "


\<comment> \<open>\<open>val hex_bits_8_backwards : string -> M (mword ty8)\<close>\<close>

\<comment> \<open>\<open>val hex_bits_8_forwards_matches : mword ty8 -> bool\<close>\<close>

\<comment> \<open>\<open>val hex_bits_8_backwards_matches : string -> bool\<close>\<close>

definition hex_bits_8_forwards_matches  :: \<open>(8)Word.word \<Rightarrow> bool \<close>  where 
     \<open> hex_bits_8_forwards_matches bv = ( True )\<close> 
  for  bv  :: "(8)Word.word "


definition hex_bits_8_backwards_matches  :: \<open> string \<Rightarrow> bool \<close>  where 
     \<open> hex_bits_8_backwards_matches s = (
      if ((case  ((hex_bits_8_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 8 Word.word * ii))option)) of
          Some ((g__366, n)) => if (((n = ((string_length s))))) then True else False
        | _ => False
        )) then
        True
      else False )\<close> 
  for  s  :: " string "


definition hex_bits_8_backwards  :: \<open> string \<Rightarrow>((register_value),((8)Word.word),(exception))monad \<close>  where 
     \<open> hex_bits_8_backwards s = (
   (case  ((hex_bits_8_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 8 Word.word * ii))option)) of
     Some ((bv, n)) =>
      if (((n = ((string_length s))))) then return bv
      else
        assert_exp False (''Pattern match failure at model/prelude_mapping.sail 182:2 - 184:3'') \<then>
        exit0 () 
   | _ =>
      assert_exp False (''Pattern match failure at model/prelude_mapping.sail 182:2 - 184:3'') \<then>
      exit0 () 
   ))\<close> 
  for  s  :: " string "


\<comment> \<open>\<open>val hex_bits_9_backwards : string -> M (mword ty9)\<close>\<close>

\<comment> \<open>\<open>val hex_bits_9_forwards_matches : mword ty9 -> bool\<close>\<close>

\<comment> \<open>\<open>val hex_bits_9_backwards_matches : string -> bool\<close>\<close>

definition hex_bits_9_forwards_matches  :: \<open>(9)Word.word \<Rightarrow> bool \<close>  where 
     \<open> hex_bits_9_forwards_matches bv = ( True )\<close> 
  for  bv  :: "(9)Word.word "


definition hex_bits_9_backwards_matches  :: \<open> string \<Rightarrow> bool \<close>  where 
     \<open> hex_bits_9_backwards_matches s = (
      if ((case  ((hex_bits_9_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 9 Word.word * ii))option)) of
          Some ((g__365, n)) => if (((n = ((string_length s))))) then True else False
        | _ => False
        )) then
        True
      else False )\<close> 
  for  s  :: " string "


definition hex_bits_9_backwards  :: \<open> string \<Rightarrow>((register_value),((9)Word.word),(exception))monad \<close>  where 
     \<open> hex_bits_9_backwards s = (
   (case  ((hex_bits_9_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 9 Word.word * ii))option)) of
     Some ((bv, n)) =>
      if (((n = ((string_length s))))) then return bv
      else
        assert_exp False (''Pattern match failure at model/prelude_mapping.sail 201:2 - 203:3'') \<then>
        exit0 () 
   | _ =>
      assert_exp False (''Pattern match failure at model/prelude_mapping.sail 201:2 - 203:3'') \<then>
      exit0 () 
   ))\<close> 
  for  s  :: " string "


\<comment> \<open>\<open>val hex_bits_10_backwards : string -> M (mword ty10)\<close>\<close>

\<comment> \<open>\<open>val hex_bits_10_forwards_matches : mword ty10 -> bool\<close>\<close>

\<comment> \<open>\<open>val hex_bits_10_backwards_matches : string -> bool\<close>\<close>

definition hex_bits_10_forwards_matches  :: \<open>(10)Word.word \<Rightarrow> bool \<close>  where 
     \<open> hex_bits_10_forwards_matches bv = ( True )\<close> 
  for  bv  :: "(10)Word.word "


definition hex_bits_10_backwards_matches  :: \<open> string \<Rightarrow> bool \<close>  where 
     \<open> hex_bits_10_backwards_matches s = (
      if ((case  ((hex_bits_10_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 10 Word.word * ii))option)) of
          Some ((g__364, n)) => if (((n = ((string_length s))))) then True else False
        | _ => False
        )) then
        True
      else False )\<close> 
  for  s  :: " string "


definition hex_bits_10_backwards  :: \<open> string \<Rightarrow>((register_value),((10)Word.word),(exception))monad \<close>  where 
     \<open> hex_bits_10_backwards s = (
   (case  ((hex_bits_10_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 10 Word.word * ii))option)) of
     Some ((bv, n)) =>
      if (((n = ((string_length s))))) then return bv
      else
        assert_exp False (''Pattern match failure at model/prelude_mapping.sail 220:2 - 222:3'') \<then>
        exit0 () 
   | _ =>
      assert_exp False (''Pattern match failure at model/prelude_mapping.sail 220:2 - 222:3'') \<then>
      exit0 () 
   ))\<close> 
  for  s  :: " string "


\<comment> \<open>\<open>val hex_bits_11_backwards : string -> M (mword ty11)\<close>\<close>

\<comment> \<open>\<open>val hex_bits_11_forwards_matches : mword ty11 -> bool\<close>\<close>

\<comment> \<open>\<open>val hex_bits_11_backwards_matches : string -> bool\<close>\<close>

definition hex_bits_11_forwards_matches  :: \<open>(11)Word.word \<Rightarrow> bool \<close>  where 
     \<open> hex_bits_11_forwards_matches bv = ( True )\<close> 
  for  bv  :: "(11)Word.word "


definition hex_bits_11_backwards_matches  :: \<open> string \<Rightarrow> bool \<close>  where 
     \<open> hex_bits_11_backwards_matches s = (
      if ((case  ((hex_bits_11_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 11 Word.word * ii))option)) of
          Some ((g__363, n)) => if (((n = ((string_length s))))) then True else False
        | _ => False
        )) then
        True
      else False )\<close> 
  for  s  :: " string "


definition hex_bits_11_backwards  :: \<open> string \<Rightarrow>((register_value),((11)Word.word),(exception))monad \<close>  where 
     \<open> hex_bits_11_backwards s = (
   (case  ((hex_bits_11_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 11 Word.word * ii))option)) of
     Some ((bv, n)) =>
      if (((n = ((string_length s))))) then return bv
      else
        assert_exp False (''Pattern match failure at model/prelude_mapping.sail 239:2 - 241:3'') \<then>
        exit0 () 
   | _ =>
      assert_exp False (''Pattern match failure at model/prelude_mapping.sail 239:2 - 241:3'') \<then>
      exit0 () 
   ))\<close> 
  for  s  :: " string "


\<comment> \<open>\<open>val hex_bits_12_backwards : string -> M (mword ty12)\<close>\<close>

\<comment> \<open>\<open>val hex_bits_12_forwards_matches : mword ty12 -> bool\<close>\<close>

\<comment> \<open>\<open>val hex_bits_12_backwards_matches : string -> bool\<close>\<close>

\<comment> \<open>\<open>val hex_bits_12_matches_prefix : string -> maybe ((mword ty12 * ii))\<close>\<close>

definition hex_bits_12_forwards_matches  :: \<open>(12)Word.word \<Rightarrow> bool \<close>  where 
     \<open> hex_bits_12_forwards_matches bv = ( True )\<close> 
  for  bv  :: "(12)Word.word "


definition hex_bits_12_matches_prefix0  :: \<open> string \<Rightarrow>((12)Word.word*ii)option \<close>  where 
     \<open> hex_bits_12_matches_prefix0 s = ( None )\<close> 
  for  s  :: " string "


definition hex_bits_12_backwards_matches  :: \<open> string \<Rightarrow> bool \<close>  where 
     \<open> hex_bits_12_backwards_matches s = (
      if ((case  ((hex_bits_12_matches_prefix0 s  ::  (( 12 Word.word * ii))option)) of
          Some ((g__362, n)) => if (((n = ((string_length s))))) then True else False
        | _ => False
        )) then
        True
      else False )\<close> 
  for  s  :: " string "


definition hex_bits_12_backwards  :: \<open> string \<Rightarrow>((register_value),((12)Word.word),(exception))monad \<close>  where 
     \<open> hex_bits_12_backwards s = (
   (case  ((hex_bits_12_matches_prefix0 s  ::  (( 12 Word.word * ii))option)) of
     Some ((bv, n)) =>
      if (((n = ((string_length s))))) then return bv
      else
        assert_exp False (''Pattern match failure at model/prelude_mapping.sail 262:2 - 264:3'') \<then>
        exit0 () 
   | _ =>
      assert_exp False (''Pattern match failure at model/prelude_mapping.sail 262:2 - 264:3'') \<then>
      exit0 () 
   ))\<close> 
  for  s  :: " string "


\<comment> \<open>\<open>val hex_bits_13_backwards : string -> M (mword ty13)\<close>\<close>

\<comment> \<open>\<open>val hex_bits_13_forwards_matches : mword ty13 -> bool\<close>\<close>

\<comment> \<open>\<open>val hex_bits_13_backwards_matches : string -> bool\<close>\<close>

definition hex_bits_13_forwards_matches  :: \<open>(13)Word.word \<Rightarrow> bool \<close>  where 
     \<open> hex_bits_13_forwards_matches bv = ( True )\<close> 
  for  bv  :: "(13)Word.word "


definition hex_bits_13_backwards_matches  :: \<open> string \<Rightarrow> bool \<close>  where 
     \<open> hex_bits_13_backwards_matches s = (
      if ((case  ((hex_bits_13_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 13 Word.word * ii))option)) of
          Some ((g__361, n)) => if (((n = ((string_length s))))) then True else False
        | _ => False
        )) then
        True
      else False )\<close> 
  for  s  :: " string "


definition hex_bits_13_backwards  :: \<open> string \<Rightarrow>((register_value),((13)Word.word),(exception))monad \<close>  where 
     \<open> hex_bits_13_backwards s = (
   (case  ((hex_bits_13_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 13 Word.word * ii))option)) of
     Some ((bv, n)) =>
      if (((n = ((string_length s))))) then return bv
      else
        assert_exp False (''Pattern match failure at model/prelude_mapping.sail 281:2 - 283:3'') \<then>
        exit0 () 
   | _ =>
      assert_exp False (''Pattern match failure at model/prelude_mapping.sail 281:2 - 283:3'') \<then>
      exit0 () 
   ))\<close> 
  for  s  :: " string "


\<comment> \<open>\<open>val hex_bits_14_backwards : string -> M (mword ty14)\<close>\<close>

\<comment> \<open>\<open>val hex_bits_14_forwards_matches : mword ty14 -> bool\<close>\<close>

\<comment> \<open>\<open>val hex_bits_14_backwards_matches : string -> bool\<close>\<close>

definition hex_bits_14_forwards_matches  :: \<open>(14)Word.word \<Rightarrow> bool \<close>  where 
     \<open> hex_bits_14_forwards_matches bv = ( True )\<close> 
  for  bv  :: "(14)Word.word "


definition hex_bits_14_backwards_matches  :: \<open> string \<Rightarrow> bool \<close>  where 
     \<open> hex_bits_14_backwards_matches s = (
      if ((case  ((hex_bits_14_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 14 Word.word * ii))option)) of
          Some ((g__360, n)) => if (((n = ((string_length s))))) then True else False
        | _ => False
        )) then
        True
      else False )\<close> 
  for  s  :: " string "


definition hex_bits_14_backwards  :: \<open> string \<Rightarrow>((register_value),((14)Word.word),(exception))monad \<close>  where 
     \<open> hex_bits_14_backwards s = (
   (case  ((hex_bits_14_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 14 Word.word * ii))option)) of
     Some ((bv, n)) =>
      if (((n = ((string_length s))))) then return bv
      else
        assert_exp False (''Pattern match failure at model/prelude_mapping.sail 300:2 - 302:3'') \<then>
        exit0 () 
   | _ =>
      assert_exp False (''Pattern match failure at model/prelude_mapping.sail 300:2 - 302:3'') \<then>
      exit0 () 
   ))\<close> 
  for  s  :: " string "


\<comment> \<open>\<open>val hex_bits_15_backwards : string -> M (mword ty15)\<close>\<close>

\<comment> \<open>\<open>val hex_bits_15_forwards_matches : mword ty15 -> bool\<close>\<close>

\<comment> \<open>\<open>val hex_bits_15_backwards_matches : string -> bool\<close>\<close>

definition hex_bits_15_forwards_matches  :: \<open>(15)Word.word \<Rightarrow> bool \<close>  where 
     \<open> hex_bits_15_forwards_matches bv = ( True )\<close> 
  for  bv  :: "(15)Word.word "


definition hex_bits_15_backwards_matches  :: \<open> string \<Rightarrow> bool \<close>  where 
     \<open> hex_bits_15_backwards_matches s = (
      if ((case  ((hex_bits_15_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 15 Word.word * ii))option)) of
          Some ((g__359, n)) => if (((n = ((string_length s))))) then True else False
        | _ => False
        )) then
        True
      else False )\<close> 
  for  s  :: " string "


definition hex_bits_15_backwards  :: \<open> string \<Rightarrow>((register_value),((15)Word.word),(exception))monad \<close>  where 
     \<open> hex_bits_15_backwards s = (
   (case  ((hex_bits_15_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 15 Word.word * ii))option)) of
     Some ((bv, n)) =>
      if (((n = ((string_length s))))) then return bv
      else
        assert_exp False (''Pattern match failure at model/prelude_mapping.sail 319:2 - 321:3'') \<then>
        exit0 () 
   | _ =>
      assert_exp False (''Pattern match failure at model/prelude_mapping.sail 319:2 - 321:3'') \<then>
      exit0 () 
   ))\<close> 
  for  s  :: " string "


\<comment> \<open>\<open>val hex_bits_16_backwards : string -> M (mword ty16)\<close>\<close>

\<comment> \<open>\<open>val hex_bits_16_forwards_matches : mword ty16 -> bool\<close>\<close>

\<comment> \<open>\<open>val hex_bits_16_backwards_matches : string -> bool\<close>\<close>

definition hex_bits_16_forwards_matches  :: \<open>(16)Word.word \<Rightarrow> bool \<close>  where 
     \<open> hex_bits_16_forwards_matches bv = ( True )\<close> 
  for  bv  :: "(16)Word.word "


definition hex_bits_16_backwards_matches  :: \<open> string \<Rightarrow> bool \<close>  where 
     \<open> hex_bits_16_backwards_matches s = (
      if ((case  ((hex_bits_16_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 16 Word.word * ii))option)) of
          Some ((g__358, n)) => if (((n = ((string_length s))))) then True else False
        | _ => False
        )) then
        True
      else False )\<close> 
  for  s  :: " string "


definition hex_bits_16_backwards  :: \<open> string \<Rightarrow>((register_value),((16)Word.word),(exception))monad \<close>  where 
     \<open> hex_bits_16_backwards s = (
   (case  ((hex_bits_16_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 16 Word.word * ii))option)) of
     Some ((bv, n)) =>
      if (((n = ((string_length s))))) then return bv
      else
        assert_exp False (''Pattern match failure at model/prelude_mapping.sail 338:2 - 340:3'') \<then>
        exit0 () 
   | _ =>
      assert_exp False (''Pattern match failure at model/prelude_mapping.sail 338:2 - 340:3'') \<then>
      exit0 () 
   ))\<close> 
  for  s  :: " string "


\<comment> \<open>\<open>val hex_bits_17_backwards : string -> M (mword ty17)\<close>\<close>

\<comment> \<open>\<open>val hex_bits_17_forwards_matches : mword ty17 -> bool\<close>\<close>

\<comment> \<open>\<open>val hex_bits_17_backwards_matches : string -> bool\<close>\<close>

definition hex_bits_17_forwards_matches  :: \<open>(17)Word.word \<Rightarrow> bool \<close>  where 
     \<open> hex_bits_17_forwards_matches bv = ( True )\<close> 
  for  bv  :: "(17)Word.word "


definition hex_bits_17_backwards_matches  :: \<open> string \<Rightarrow> bool \<close>  where 
     \<open> hex_bits_17_backwards_matches s = (
      if ((case  ((hex_bits_17_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 17 Word.word * ii))option)) of
          Some ((g__357, n)) => if (((n = ((string_length s))))) then True else False
        | _ => False
        )) then
        True
      else False )\<close> 
  for  s  :: " string "


definition hex_bits_17_backwards  :: \<open> string \<Rightarrow>((register_value),((17)Word.word),(exception))monad \<close>  where 
     \<open> hex_bits_17_backwards s = (
   (case  ((hex_bits_17_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 17 Word.word * ii))option)) of
     Some ((bv, n)) =>
      if (((n = ((string_length s))))) then return bv
      else
        assert_exp False (''Pattern match failure at model/prelude_mapping.sail 357:2 - 359:3'') \<then>
        exit0 () 
   | _ =>
      assert_exp False (''Pattern match failure at model/prelude_mapping.sail 357:2 - 359:3'') \<then>
      exit0 () 
   ))\<close> 
  for  s  :: " string "


\<comment> \<open>\<open>val hex_bits_18_backwards : string -> M (mword ty18)\<close>\<close>

\<comment> \<open>\<open>val hex_bits_18_forwards_matches : mword ty18 -> bool\<close>\<close>

\<comment> \<open>\<open>val hex_bits_18_backwards_matches : string -> bool\<close>\<close>

definition hex_bits_18_forwards_matches  :: \<open>(18)Word.word \<Rightarrow> bool \<close>  where 
     \<open> hex_bits_18_forwards_matches bv = ( True )\<close> 
  for  bv  :: "(18)Word.word "


definition hex_bits_18_backwards_matches  :: \<open> string \<Rightarrow> bool \<close>  where 
     \<open> hex_bits_18_backwards_matches s = (
      if ((case  ((hex_bits_18_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 18 Word.word * ii))option)) of
          Some ((g__356, n)) => if (((n = ((string_length s))))) then True else False
        | _ => False
        )) then
        True
      else False )\<close> 
  for  s  :: " string "


definition hex_bits_18_backwards  :: \<open> string \<Rightarrow>((register_value),((18)Word.word),(exception))monad \<close>  where 
     \<open> hex_bits_18_backwards s = (
   (case  ((hex_bits_18_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 18 Word.word * ii))option)) of
     Some ((bv, n)) =>
      if (((n = ((string_length s))))) then return bv
      else
        assert_exp False (''Pattern match failure at model/prelude_mapping.sail 376:2 - 378:3'') \<then>
        exit0 () 
   | _ =>
      assert_exp False (''Pattern match failure at model/prelude_mapping.sail 376:2 - 378:3'') \<then>
      exit0 () 
   ))\<close> 
  for  s  :: " string "


\<comment> \<open>\<open>val hex_bits_19_backwards : string -> M (mword ty19)\<close>\<close>

\<comment> \<open>\<open>val hex_bits_19_forwards_matches : mword ty19 -> bool\<close>\<close>

\<comment> \<open>\<open>val hex_bits_19_backwards_matches : string -> bool\<close>\<close>

definition hex_bits_19_forwards_matches  :: \<open>(19)Word.word \<Rightarrow> bool \<close>  where 
     \<open> hex_bits_19_forwards_matches bv = ( True )\<close> 
  for  bv  :: "(19)Word.word "


definition hex_bits_19_backwards_matches  :: \<open> string \<Rightarrow> bool \<close>  where 
     \<open> hex_bits_19_backwards_matches s = (
      if ((case  ((hex_bits_19_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 19 Word.word * ii))option)) of
          Some ((g__355, n)) => if (((n = ((string_length s))))) then True else False
        | _ => False
        )) then
        True
      else False )\<close> 
  for  s  :: " string "


definition hex_bits_19_backwards  :: \<open> string \<Rightarrow>((register_value),((19)Word.word),(exception))monad \<close>  where 
     \<open> hex_bits_19_backwards s = (
   (case  ((hex_bits_19_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 19 Word.word * ii))option)) of
     Some ((bv, n)) =>
      if (((n = ((string_length s))))) then return bv
      else
        assert_exp False (''Pattern match failure at model/prelude_mapping.sail 395:2 - 397:3'') \<then>
        exit0 () 
   | _ =>
      assert_exp False (''Pattern match failure at model/prelude_mapping.sail 395:2 - 397:3'') \<then>
      exit0 () 
   ))\<close> 
  for  s  :: " string "


\<comment> \<open>\<open>val hex_bits_20_backwards : string -> M (mword ty20)\<close>\<close>

\<comment> \<open>\<open>val hex_bits_20_forwards_matches : mword ty20 -> bool\<close>\<close>

\<comment> \<open>\<open>val hex_bits_20_backwards_matches : string -> bool\<close>\<close>

definition hex_bits_20_forwards_matches  :: \<open>(20)Word.word \<Rightarrow> bool \<close>  where 
     \<open> hex_bits_20_forwards_matches bv = ( True )\<close> 
  for  bv  :: "(20)Word.word "


definition hex_bits_20_backwards_matches  :: \<open> string \<Rightarrow> bool \<close>  where 
     \<open> hex_bits_20_backwards_matches s = (
      if ((case  ((hex_bits_20_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 20 Word.word * ii))option)) of
          Some ((g__354, n)) => if (((n = ((string_length s))))) then True else False
        | _ => False
        )) then
        True
      else False )\<close> 
  for  s  :: " string "


definition hex_bits_20_backwards  :: \<open> string \<Rightarrow>((register_value),((20)Word.word),(exception))monad \<close>  where 
     \<open> hex_bits_20_backwards s = (
   (case  ((hex_bits_20_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 20 Word.word * ii))option)) of
     Some ((bv, n)) =>
      if (((n = ((string_length s))))) then return bv
      else
        assert_exp False (''Pattern match failure at model/prelude_mapping.sail 414:2 - 416:3'') \<then>
        exit0 () 
   | _ =>
      assert_exp False (''Pattern match failure at model/prelude_mapping.sail 414:2 - 416:3'') \<then>
      exit0 () 
   ))\<close> 
  for  s  :: " string "


\<comment> \<open>\<open>val hex_bits_21_backwards : string -> M (mword ty21)\<close>\<close>

\<comment> \<open>\<open>val hex_bits_21_forwards_matches : mword ty21 -> bool\<close>\<close>

\<comment> \<open>\<open>val hex_bits_21_backwards_matches : string -> bool\<close>\<close>

definition hex_bits_21_forwards_matches  :: \<open>(21)Word.word \<Rightarrow> bool \<close>  where 
     \<open> hex_bits_21_forwards_matches bv = ( True )\<close> 
  for  bv  :: "(21)Word.word "


definition hex_bits_21_backwards_matches  :: \<open> string \<Rightarrow> bool \<close>  where 
     \<open> hex_bits_21_backwards_matches s = (
      if ((case  ((hex_bits_21_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 21 Word.word * ii))option)) of
          Some ((g__353, n)) => if (((n = ((string_length s))))) then True else False
        | _ => False
        )) then
        True
      else False )\<close> 
  for  s  :: " string "


definition hex_bits_21_backwards  :: \<open> string \<Rightarrow>((register_value),((21)Word.word),(exception))monad \<close>  where 
     \<open> hex_bits_21_backwards s = (
   (case  ((hex_bits_21_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 21 Word.word * ii))option)) of
     Some ((bv, n)) =>
      if (((n = ((string_length s))))) then return bv
      else
        assert_exp False (''Pattern match failure at model/prelude_mapping.sail 433:2 - 435:3'') \<then>
        exit0 () 
   | _ =>
      assert_exp False (''Pattern match failure at model/prelude_mapping.sail 433:2 - 435:3'') \<then>
      exit0 () 
   ))\<close> 
  for  s  :: " string "


\<comment> \<open>\<open>val hex_bits_22_backwards : string -> M (mword ty22)\<close>\<close>

\<comment> \<open>\<open>val hex_bits_22_forwards_matches : mword ty22 -> bool\<close>\<close>

\<comment> \<open>\<open>val hex_bits_22_backwards_matches : string -> bool\<close>\<close>

definition hex_bits_22_forwards_matches  :: \<open>(22)Word.word \<Rightarrow> bool \<close>  where 
     \<open> hex_bits_22_forwards_matches bv = ( True )\<close> 
  for  bv  :: "(22)Word.word "


definition hex_bits_22_backwards_matches  :: \<open> string \<Rightarrow> bool \<close>  where 
     \<open> hex_bits_22_backwards_matches s = (
      if ((case  ((hex_bits_22_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 22 Word.word * ii))option)) of
          Some ((g__352, n)) => if (((n = ((string_length s))))) then True else False
        | _ => False
        )) then
        True
      else False )\<close> 
  for  s  :: " string "


definition hex_bits_22_backwards  :: \<open> string \<Rightarrow>((register_value),((22)Word.word),(exception))monad \<close>  where 
     \<open> hex_bits_22_backwards s = (
   (case  ((hex_bits_22_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 22 Word.word * ii))option)) of
     Some ((bv, n)) =>
      if (((n = ((string_length s))))) then return bv
      else
        assert_exp False (''Pattern match failure at model/prelude_mapping.sail 452:2 - 454:3'') \<then>
        exit0 () 
   | _ =>
      assert_exp False (''Pattern match failure at model/prelude_mapping.sail 452:2 - 454:3'') \<then>
      exit0 () 
   ))\<close> 
  for  s  :: " string "


\<comment> \<open>\<open>val hex_bits_23_backwards : string -> M (mword ty23)\<close>\<close>

\<comment> \<open>\<open>val hex_bits_23_forwards_matches : mword ty23 -> bool\<close>\<close>

\<comment> \<open>\<open>val hex_bits_23_backwards_matches : string -> bool\<close>\<close>

definition hex_bits_23_forwards_matches  :: \<open>(23)Word.word \<Rightarrow> bool \<close>  where 
     \<open> hex_bits_23_forwards_matches bv = ( True )\<close> 
  for  bv  :: "(23)Word.word "


definition hex_bits_23_backwards_matches  :: \<open> string \<Rightarrow> bool \<close>  where 
     \<open> hex_bits_23_backwards_matches s = (
      if ((case  ((hex_bits_23_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 23 Word.word * ii))option)) of
          Some ((g__351, n)) => if (((n = ((string_length s))))) then True else False
        | _ => False
        )) then
        True
      else False )\<close> 
  for  s  :: " string "


definition hex_bits_23_backwards  :: \<open> string \<Rightarrow>((register_value),((23)Word.word),(exception))monad \<close>  where 
     \<open> hex_bits_23_backwards s = (
   (case  ((hex_bits_23_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 23 Word.word * ii))option)) of
     Some ((bv, n)) =>
      if (((n = ((string_length s))))) then return bv
      else
        assert_exp False (''Pattern match failure at model/prelude_mapping.sail 471:2 - 473:3'') \<then>
        exit0 () 
   | _ =>
      assert_exp False (''Pattern match failure at model/prelude_mapping.sail 471:2 - 473:3'') \<then>
      exit0 () 
   ))\<close> 
  for  s  :: " string "


\<comment> \<open>\<open>val hex_bits_24_backwards : string -> M (mword ty24)\<close>\<close>

\<comment> \<open>\<open>val hex_bits_24_forwards_matches : mword ty24 -> bool\<close>\<close>

\<comment> \<open>\<open>val hex_bits_24_backwards_matches : string -> bool\<close>\<close>

definition hex_bits_24_forwards_matches  :: \<open>(24)Word.word \<Rightarrow> bool \<close>  where 
     \<open> hex_bits_24_forwards_matches bv = ( True )\<close> 
  for  bv  :: "(24)Word.word "


definition hex_bits_24_backwards_matches  :: \<open> string \<Rightarrow> bool \<close>  where 
     \<open> hex_bits_24_backwards_matches s = (
      if ((case  ((hex_bits_24_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 24 Word.word * ii))option)) of
          Some ((g__350, n)) => if (((n = ((string_length s))))) then True else False
        | _ => False
        )) then
        True
      else False )\<close> 
  for  s  :: " string "


definition hex_bits_24_backwards  :: \<open> string \<Rightarrow>((register_value),((24)Word.word),(exception))monad \<close>  where 
     \<open> hex_bits_24_backwards s = (
   (case  ((hex_bits_24_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 24 Word.word * ii))option)) of
     Some ((bv, n)) =>
      if (((n = ((string_length s))))) then return bv
      else
        assert_exp False (''Pattern match failure at model/prelude_mapping.sail 490:2 - 492:3'') \<then>
        exit0 () 
   | _ =>
      assert_exp False (''Pattern match failure at model/prelude_mapping.sail 490:2 - 492:3'') \<then>
      exit0 () 
   ))\<close> 
  for  s  :: " string "


\<comment> \<open>\<open>val hex_bits_25_backwards : string -> M (mword ty25)\<close>\<close>

\<comment> \<open>\<open>val hex_bits_25_forwards_matches : mword ty25 -> bool\<close>\<close>

\<comment> \<open>\<open>val hex_bits_25_backwards_matches : string -> bool\<close>\<close>

definition hex_bits_25_forwards_matches  :: \<open>(25)Word.word \<Rightarrow> bool \<close>  where 
     \<open> hex_bits_25_forwards_matches bv = ( True )\<close> 
  for  bv  :: "(25)Word.word "


definition hex_bits_25_backwards_matches  :: \<open> string \<Rightarrow> bool \<close>  where 
     \<open> hex_bits_25_backwards_matches s = (
      if ((case  ((hex_bits_25_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 25 Word.word * ii))option)) of
          Some ((g__349, n)) => if (((n = ((string_length s))))) then True else False
        | _ => False
        )) then
        True
      else False )\<close> 
  for  s  :: " string "


definition hex_bits_25_backwards  :: \<open> string \<Rightarrow>((register_value),((25)Word.word),(exception))monad \<close>  where 
     \<open> hex_bits_25_backwards s = (
   (case  ((hex_bits_25_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 25 Word.word * ii))option)) of
     Some ((bv, n)) =>
      if (((n = ((string_length s))))) then return bv
      else
        assert_exp False (''Pattern match failure at model/prelude_mapping.sail 509:2 - 511:3'') \<then>
        exit0 () 
   | _ =>
      assert_exp False (''Pattern match failure at model/prelude_mapping.sail 509:2 - 511:3'') \<then>
      exit0 () 
   ))\<close> 
  for  s  :: " string "


\<comment> \<open>\<open>val hex_bits_26_backwards : string -> M (mword ty26)\<close>\<close>

\<comment> \<open>\<open>val hex_bits_26_forwards_matches : mword ty26 -> bool\<close>\<close>

\<comment> \<open>\<open>val hex_bits_26_backwards_matches : string -> bool\<close>\<close>

definition hex_bits_26_forwards_matches  :: \<open>(26)Word.word \<Rightarrow> bool \<close>  where 
     \<open> hex_bits_26_forwards_matches bv = ( True )\<close> 
  for  bv  :: "(26)Word.word "


definition hex_bits_26_backwards_matches  :: \<open> string \<Rightarrow> bool \<close>  where 
     \<open> hex_bits_26_backwards_matches s = (
      if ((case  ((hex_bits_26_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 26 Word.word * ii))option)) of
          Some ((g__348, n)) => if (((n = ((string_length s))))) then True else False
        | _ => False
        )) then
        True
      else False )\<close> 
  for  s  :: " string "


definition hex_bits_26_backwards  :: \<open> string \<Rightarrow>((register_value),((26)Word.word),(exception))monad \<close>  where 
     \<open> hex_bits_26_backwards s = (
   (case  ((hex_bits_26_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 26 Word.word * ii))option)) of
     Some ((bv, n)) =>
      if (((n = ((string_length s))))) then return bv
      else
        assert_exp False (''Pattern match failure at model/prelude_mapping.sail 528:2 - 530:3'') \<then>
        exit0 () 
   | _ =>
      assert_exp False (''Pattern match failure at model/prelude_mapping.sail 528:2 - 530:3'') \<then>
      exit0 () 
   ))\<close> 
  for  s  :: " string "


\<comment> \<open>\<open>val hex_bits_27_backwards : string -> M (mword ty27)\<close>\<close>

\<comment> \<open>\<open>val hex_bits_27_forwards_matches : mword ty27 -> bool\<close>\<close>

\<comment> \<open>\<open>val hex_bits_27_backwards_matches : string -> bool\<close>\<close>

definition hex_bits_27_forwards_matches  :: \<open>(27)Word.word \<Rightarrow> bool \<close>  where 
     \<open> hex_bits_27_forwards_matches bv = ( True )\<close> 
  for  bv  :: "(27)Word.word "


definition hex_bits_27_backwards_matches  :: \<open> string \<Rightarrow> bool \<close>  where 
     \<open> hex_bits_27_backwards_matches s = (
      if ((case  ((hex_bits_27_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 27 Word.word * ii))option)) of
          Some ((g__347, n)) => if (((n = ((string_length s))))) then True else False
        | _ => False
        )) then
        True
      else False )\<close> 
  for  s  :: " string "


definition hex_bits_27_backwards  :: \<open> string \<Rightarrow>((register_value),((27)Word.word),(exception))monad \<close>  where 
     \<open> hex_bits_27_backwards s = (
   (case  ((hex_bits_27_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 27 Word.word * ii))option)) of
     Some ((bv, n)) =>
      if (((n = ((string_length s))))) then return bv
      else
        assert_exp False (''Pattern match failure at model/prelude_mapping.sail 547:2 - 549:3'') \<then>
        exit0 () 
   | _ =>
      assert_exp False (''Pattern match failure at model/prelude_mapping.sail 547:2 - 549:3'') \<then>
      exit0 () 
   ))\<close> 
  for  s  :: " string "


\<comment> \<open>\<open>val hex_bits_28_backwards : string -> M (mword ty28)\<close>\<close>

\<comment> \<open>\<open>val hex_bits_28_forwards_matches : mword ty28 -> bool\<close>\<close>

\<comment> \<open>\<open>val hex_bits_28_backwards_matches : string -> bool\<close>\<close>

definition hex_bits_28_forwards_matches  :: \<open>(28)Word.word \<Rightarrow> bool \<close>  where 
     \<open> hex_bits_28_forwards_matches bv = ( True )\<close> 
  for  bv  :: "(28)Word.word "


definition hex_bits_28_backwards_matches  :: \<open> string \<Rightarrow> bool \<close>  where 
     \<open> hex_bits_28_backwards_matches s = (
      if ((case  ((hex_bits_28_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 28 Word.word * ii))option)) of
          Some ((g__346, n)) => if (((n = ((string_length s))))) then True else False
        | _ => False
        )) then
        True
      else False )\<close> 
  for  s  :: " string "


definition hex_bits_28_backwards  :: \<open> string \<Rightarrow>((register_value),((28)Word.word),(exception))monad \<close>  where 
     \<open> hex_bits_28_backwards s = (
   (case  ((hex_bits_28_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 28 Word.word * ii))option)) of
     Some ((bv, n)) =>
      if (((n = ((string_length s))))) then return bv
      else
        assert_exp False (''Pattern match failure at model/prelude_mapping.sail 566:2 - 568:3'') \<then>
        exit0 () 
   | _ =>
      assert_exp False (''Pattern match failure at model/prelude_mapping.sail 566:2 - 568:3'') \<then>
      exit0 () 
   ))\<close> 
  for  s  :: " string "


\<comment> \<open>\<open>val hex_bits_29_backwards : string -> M (mword ty29)\<close>\<close>

\<comment> \<open>\<open>val hex_bits_29_forwards_matches : mword ty29 -> bool\<close>\<close>

\<comment> \<open>\<open>val hex_bits_29_backwards_matches : string -> bool\<close>\<close>

definition hex_bits_29_forwards_matches  :: \<open>(29)Word.word \<Rightarrow> bool \<close>  where 
     \<open> hex_bits_29_forwards_matches bv = ( True )\<close> 
  for  bv  :: "(29)Word.word "


definition hex_bits_29_backwards_matches  :: \<open> string \<Rightarrow> bool \<close>  where 
     \<open> hex_bits_29_backwards_matches s = (
      if ((case  ((hex_bits_29_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 29 Word.word * ii))option)) of
          Some ((g__345, n)) => if (((n = ((string_length s))))) then True else False
        | _ => False
        )) then
        True
      else False )\<close> 
  for  s  :: " string "


definition hex_bits_29_backwards  :: \<open> string \<Rightarrow>((register_value),((29)Word.word),(exception))monad \<close>  where 
     \<open> hex_bits_29_backwards s = (
   (case  ((hex_bits_29_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 29 Word.word * ii))option)) of
     Some ((bv, n)) =>
      if (((n = ((string_length s))))) then return bv
      else
        assert_exp False (''Pattern match failure at model/prelude_mapping.sail 585:2 - 587:3'') \<then>
        exit0 () 
   | _ =>
      assert_exp False (''Pattern match failure at model/prelude_mapping.sail 585:2 - 587:3'') \<then>
      exit0 () 
   ))\<close> 
  for  s  :: " string "


\<comment> \<open>\<open>val hex_bits_30_backwards : string -> M (mword ty30)\<close>\<close>

\<comment> \<open>\<open>val hex_bits_30_forwards_matches : mword ty30 -> bool\<close>\<close>

\<comment> \<open>\<open>val hex_bits_30_backwards_matches : string -> bool\<close>\<close>

definition hex_bits_30_forwards_matches  :: \<open>(30)Word.word \<Rightarrow> bool \<close>  where 
     \<open> hex_bits_30_forwards_matches bv = ( True )\<close> 
  for  bv  :: "(30)Word.word "


definition hex_bits_30_backwards_matches  :: \<open> string \<Rightarrow> bool \<close>  where 
     \<open> hex_bits_30_backwards_matches s = (
      if ((case  ((hex_bits_30_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 30 Word.word * ii))option)) of
          Some ((g__344, n)) => if (((n = ((string_length s))))) then True else False
        | _ => False
        )) then
        True
      else False )\<close> 
  for  s  :: " string "


definition hex_bits_30_backwards  :: \<open> string \<Rightarrow>((register_value),((30)Word.word),(exception))monad \<close>  where 
     \<open> hex_bits_30_backwards s = (
   (case  ((hex_bits_30_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 30 Word.word * ii))option)) of
     Some ((bv, n)) =>
      if (((n = ((string_length s))))) then return bv
      else
        assert_exp False (''Pattern match failure at model/prelude_mapping.sail 604:2 - 606:3'') \<then>
        exit0 () 
   | _ =>
      assert_exp False (''Pattern match failure at model/prelude_mapping.sail 604:2 - 606:3'') \<then>
      exit0 () 
   ))\<close> 
  for  s  :: " string "


\<comment> \<open>\<open>val hex_bits_31_backwards : string -> M (mword ty31)\<close>\<close>

\<comment> \<open>\<open>val hex_bits_31_forwards_matches : mword ty31 -> bool\<close>\<close>

\<comment> \<open>\<open>val hex_bits_31_backwards_matches : string -> bool\<close>\<close>

definition hex_bits_31_forwards_matches  :: \<open>(31)Word.word \<Rightarrow> bool \<close>  where 
     \<open> hex_bits_31_forwards_matches bv = ( True )\<close> 
  for  bv  :: "(31)Word.word "


definition hex_bits_31_backwards_matches  :: \<open> string \<Rightarrow> bool \<close>  where 
     \<open> hex_bits_31_backwards_matches s = (
      if ((case  ((hex_bits_31_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 31 Word.word * ii))option)) of
          Some ((g__343, n)) => if (((n = ((string_length s))))) then True else False
        | _ => False
        )) then
        True
      else False )\<close> 
  for  s  :: " string "


definition hex_bits_31_backwards  :: \<open> string \<Rightarrow>((register_value),((31)Word.word),(exception))monad \<close>  where 
     \<open> hex_bits_31_backwards s = (
   (case  ((hex_bits_31_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 31 Word.word * ii))option)) of
     Some ((bv, n)) =>
      if (((n = ((string_length s))))) then return bv
      else
        assert_exp False (''Pattern match failure at model/prelude_mapping.sail 623:2 - 625:3'') \<then>
        exit0 () 
   | _ =>
      assert_exp False (''Pattern match failure at model/prelude_mapping.sail 623:2 - 625:3'') \<then>
      exit0 () 
   ))\<close> 
  for  s  :: " string "


\<comment> \<open>\<open>val hex_bits_32_backwards : string -> M (mword ty32)\<close>\<close>

\<comment> \<open>\<open>val hex_bits_32_forwards_matches : mword ty32 -> bool\<close>\<close>

\<comment> \<open>\<open>val hex_bits_32_backwards_matches : string -> bool\<close>\<close>

definition hex_bits_32_forwards_matches  :: \<open>(32)Word.word \<Rightarrow> bool \<close>  where 
     \<open> hex_bits_32_forwards_matches bv = ( True )\<close> 
  for  bv  :: "(32)Word.word "


definition hex_bits_32_backwards_matches  :: \<open> string \<Rightarrow> bool \<close>  where 
     \<open> hex_bits_32_backwards_matches s = (
      if ((case  ((hex_bits_32_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 32 Word.word * ii))option)) of
          Some ((g__342, n)) => if (((n = ((string_length s))))) then True else False
        | _ => False
        )) then
        True
      else False )\<close> 
  for  s  :: " string "


definition hex_bits_32_backwards  :: \<open> string \<Rightarrow>((register_value),((32)Word.word),(exception))monad \<close>  where 
     \<open> hex_bits_32_backwards s = (
   (case  ((hex_bits_32_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 32 Word.word * ii))option)) of
     Some ((bv, n)) =>
      if (((n = ((string_length s))))) then return bv
      else
        assert_exp False (''Pattern match failure at model/prelude_mapping.sail 642:2 - 644:3'') \<then>
        exit0 () 
   | _ =>
      assert_exp False (''Pattern match failure at model/prelude_mapping.sail 642:2 - 644:3'') \<then>
      exit0 () 
   ))\<close> 
  for  s  :: " string "


\<comment> \<open>\<open>val hex_bits_33_backwards : string -> M (mword ty33)\<close>\<close>

\<comment> \<open>\<open>val hex_bits_33_forwards_matches : mword ty33 -> bool\<close>\<close>

\<comment> \<open>\<open>val hex_bits_33_backwards_matches : string -> bool\<close>\<close>

definition hex_bits_33_forwards_matches  :: \<open>(33)Word.word \<Rightarrow> bool \<close>  where 
     \<open> hex_bits_33_forwards_matches bv = ( True )\<close> 
  for  bv  :: "(33)Word.word "


definition hex_bits_33_backwards_matches  :: \<open> string \<Rightarrow> bool \<close>  where 
     \<open> hex_bits_33_backwards_matches s = (
      if ((case  ((hex_bits_33_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 33 Word.word * ii))option)) of
          Some ((g__341, n)) => if (((n = ((string_length s))))) then True else False
        | _ => False
        )) then
        True
      else False )\<close> 
  for  s  :: " string "


definition hex_bits_33_backwards  :: \<open> string \<Rightarrow>((register_value),((33)Word.word),(exception))monad \<close>  where 
     \<open> hex_bits_33_backwards s = (
   (case  ((hex_bits_33_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 33 Word.word * ii))option)) of
     Some ((bv, n)) =>
      if (((n = ((string_length s))))) then return bv
      else
        assert_exp False (''Pattern match failure at model/prelude_mapping.sail 661:2 - 663:3'') \<then>
        exit0 () 
   | _ =>
      assert_exp False (''Pattern match failure at model/prelude_mapping.sail 661:2 - 663:3'') \<then>
      exit0 () 
   ))\<close> 
  for  s  :: " string "


\<comment> \<open>\<open>val hex_bits_48_backwards : string -> M (mword ty48)\<close>\<close>

\<comment> \<open>\<open>val hex_bits_48_forwards_matches : mword ty48 -> bool\<close>\<close>

\<comment> \<open>\<open>val hex_bits_48_backwards_matches : string -> bool\<close>\<close>

definition hex_bits_48_forwards_matches  :: \<open>(48)Word.word \<Rightarrow> bool \<close>  where 
     \<open> hex_bits_48_forwards_matches bv = ( True )\<close> 
  for  bv  :: "(48)Word.word "


definition hex_bits_48_backwards_matches  :: \<open> string \<Rightarrow> bool \<close>  where 
     \<open> hex_bits_48_backwards_matches s = (
      if ((case  ((hex_bits_48_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 48 Word.word * ii))option)) of
          Some ((g__340, n)) => if (((n = ((string_length s))))) then True else False
        | _ => False
        )) then
        True
      else False )\<close> 
  for  s  :: " string "


definition hex_bits_48_backwards  :: \<open> string \<Rightarrow>((register_value),((48)Word.word),(exception))monad \<close>  where 
     \<open> hex_bits_48_backwards s = (
   (case  ((hex_bits_48_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 48 Word.word * ii))option)) of
     Some ((bv, n)) =>
      if (((n = ((string_length s))))) then return bv
      else
        assert_exp False (''Pattern match failure at model/prelude_mapping.sail 680:2 - 682:3'') \<then>
        exit0 () 
   | _ =>
      assert_exp False (''Pattern match failure at model/prelude_mapping.sail 680:2 - 682:3'') \<then>
      exit0 () 
   ))\<close> 
  for  s  :: " string "


\<comment> \<open>\<open>val hex_bits_64_backwards : string -> M (mword ty64)\<close>\<close>

\<comment> \<open>\<open>val hex_bits_64_forwards_matches : mword ty64 -> bool\<close>\<close>

\<comment> \<open>\<open>val hex_bits_64_backwards_matches : string -> bool\<close>\<close>

definition hex_bits_64_forwards_matches  :: \<open>(64)Word.word \<Rightarrow> bool \<close>  where 
     \<open> hex_bits_64_forwards_matches bv = ( True )\<close> 
  for  bv  :: "(64)Word.word "


definition hex_bits_64_backwards_matches  :: \<open> string \<Rightarrow> bool \<close>  where 
     \<open> hex_bits_64_backwards_matches s = (
      if ((case  ((hex_bits_64_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 64 Word.word * ii))option)) of
          Some ((g__339, n)) => if (((n = ((string_length s))))) then True else False
        | _ => False
        )) then
        True
      else False )\<close> 
  for  s  :: " string "


definition hex_bits_64_backwards  :: \<open> string \<Rightarrow>((register_value),((64)Word.word),(exception))monad \<close>  where 
     \<open> hex_bits_64_backwards s = (
   (case  ((hex_bits_64_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 64 Word.word * ii))option)) of
     Some ((bv, n)) =>
      if (((n = ((string_length s))))) then return bv
      else
        assert_exp False (''Pattern match failure at model/prelude_mapping.sail 699:2 - 701:3'') \<then>
        exit0 () 
   | _ =>
      assert_exp False (''Pattern match failure at model/prelude_mapping.sail 699:2 - 701:3'') \<then>
      exit0 () 
   ))\<close> 
  for  s  :: " string "


definition default_meta  :: \<open> unit \<close>  where 
     \<open> default_meta = ( ()  )\<close>


\<comment> \<open>\<open>val __WriteRAM_Meta : mword ty64 -> integer -> unit -> M unit\<close>\<close>

definition WriteRAM_Meta  :: \<open>(64)Word.word \<Rightarrow> int \<Rightarrow> unit \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> WriteRAM_Meta addr width meta = ( return ()  )\<close> 
  for  addr  :: "(64)Word.word " 
  and  width  :: " int " 
  and  meta  :: " unit "


\<comment> \<open>\<open>val __ReadRAM_Meta : mword ty64 -> integer -> M unit\<close>\<close>

definition ReadRAM_Meta  :: \<open>(64)Word.word \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> ReadRAM_Meta addr width = ( return ()  )\<close> 
  for  addr  :: "(64)Word.word " 
  and  width  :: " int "




\<comment> \<open>\<open>val write_ram_ea : write_kind -> mword ty64 -> integer -> M unit\<close>\<close>

definition write_ram_ea  :: \<open> write_kind \<Rightarrow>(64)Word.word \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> write_ram_ea wk addr width = ( write_mem_ea 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict wk (( 64 :: int)::ii) addr width )\<close> 
  for  wk  :: " write_kind " 
  and  addr  :: "(64)Word.word " 
  and  width  :: " int "




\<comment> \<open>\<open>val __TraceMemoryWrite : forall 'm 'int8_times_n. Size 'm, Size 'int8_times_n => integer -> mword 'm -> mword 'int8_times_n -> unit\<close>\<close>

\<comment> \<open>\<open>val __TraceMemoryRead : forall 'm 'int8_times_n. Size 'm, Size 'int8_times_n => integer -> mword 'm -> mword 'int8_times_n -> unit\<close>\<close>

definition init_ext_ptw  :: \<open> unit \<close>  where 
     \<open> init_ext_ptw = ( ()  )\<close>


\<comment> \<open>\<open>val ext_translate_exception : unit -> unit\<close>\<close>

definition ext_translate_exception  :: \<open> unit \<Rightarrow> unit \<close>  where 
     \<open> ext_translate_exception e = ( e )\<close> 
  for  e  :: " unit "


\<comment> \<open>\<open>val ext_exc_type_to_bits : unit -> mword ty8\<close>\<close>

definition ext_exc_type_to_bits  :: \<open> unit \<Rightarrow>(8)Word.word \<close>  where 
     \<open> ext_exc_type_to_bits e = ( ( 0x18 ::  8 Word.word))\<close> 
  for  e  :: " unit "


\<comment> \<open>\<open>val num_of_ext_exc_type : unit -> integer\<close>\<close>

definition num_of_ext_exc_type  :: \<open> unit \<Rightarrow> int \<close>  where 
     \<open> num_of_ext_exc_type e = ( (( 24 :: int)::ii))\<close> 
  for  e  :: " unit "


\<comment> \<open>\<open>val ext_exc_type_to_str : unit -> string\<close>\<close>

definition ext_exc_type_to_str  :: \<open> unit \<Rightarrow> string \<close>  where 
     \<open> ext_exc_type_to_str e = ( (''extension-exception''))\<close> 
  for  e  :: " unit "


definition xlen_val  :: \<open> int \<close>  where 
     \<open> xlen_val = ( (( 64 :: int)::ii))\<close>


definition xlen_max_unsigned  :: \<open> int \<close>  where 
     \<open> xlen_max_unsigned = ( (( 18446744073709551615 :: int)::ii))\<close>


definition xlen_max_signed  :: \<open> int \<close>  where 
     \<open> xlen_max_signed = ( (( 9223372036854775807 :: int)::ii))\<close>


definition xlen_min_signed  :: \<open> int \<close>  where 
     \<open> xlen_min_signed = ( ((( 0 :: int)-( 9223372036854775808 :: int))::ii))\<close>


\<comment> \<open>\<open>val regidx_to_regno : mword ty5 -> integer\<close>\<close>

definition regidx_to_regno  :: \<open>(5)Word.word \<Rightarrow> int \<close>  where 
     \<open> regidx_to_regno b = (
   (let r = (Word.uint b) in
   r))\<close> 
  for  b  :: "(5)Word.word "


\<comment> \<open>\<open>val creg2reg_idx : mword ty3 -> mword ty5\<close>\<close>

definition creg2reg_idx  :: \<open>(3)Word.word \<Rightarrow>(5)Word.word \<close>  where 
     \<open> creg2reg_idx creg = ( (concat_vec ( 0b01 ::  2 Word.word) creg  ::  5 Word.word))\<close> 
  for  creg  :: "(3)Word.word "


definition zreg  :: \<open>(5)Word.word \<close>  where 
     \<open> zreg = ( ( 0b00000 ::  5 Word.word))\<close>


definition ra  :: \<open>(5)Word.word \<close>  where 
     \<open> ra = ( ( 0b00001 ::  5 Word.word))\<close>


definition sp  :: \<open>(5)Word.word \<close>  where 
     \<open> sp = ( ( 0b00010 ::  5 Word.word))\<close>


\<comment> \<open>\<open>val Architecture_of_num : integer -> Architecture\<close>\<close>

definition Architecture_of_num  :: \<open> int \<Rightarrow> Architecture \<close>  where 
     \<open> Architecture_of_num arg1 = (
   (let l__262 = arg1 in
   if (((l__262 = (( 0 :: int)::ii)))) then RV32
   else if (((l__262 = (( 1 :: int)::ii)))) then RV64
   else RV128))\<close> 
  for  arg1  :: " int "


\<comment> \<open>\<open>val num_of_Architecture : Architecture -> integer\<close>\<close>

fun num_of_Architecture  :: \<open> Architecture \<Rightarrow> int \<close>  where 
     \<open> num_of_Architecture RV32 = ( (( 0 :: int)::ii))\<close>
|\<open> num_of_Architecture RV64 = ( (( 1 :: int)::ii))\<close>
|\<open> num_of_Architecture RV128 = ( (( 2 :: int)::ii))\<close>


\<comment> \<open>\<open>val architecture : mword ty2 -> maybe Architecture\<close>\<close>

definition architecture  :: \<open>(2)Word.word \<Rightarrow>(Architecture)option \<close>  where 
     \<open> architecture a = (
   (let b__0 = a in
   if (((b__0 = ( 0b01 ::  2 Word.word)))) then Some RV32
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then Some RV64
   else if (((b__0 = ( 0b11 ::  2 Word.word)))) then Some RV128
   else None))\<close> 
  for  a  :: "(2)Word.word "


\<comment> \<open>\<open>val arch_to_bits : Architecture -> mword ty2\<close>\<close>

fun arch_to_bits  :: \<open> Architecture \<Rightarrow>(2)Word.word \<close>  where 
     \<open> arch_to_bits RV32 = ( ( 0b01 ::  2 Word.word))\<close>
|\<open> arch_to_bits RV64 = ( ( 0b10 ::  2 Word.word))\<close>
|\<open> arch_to_bits RV128 = ( ( 0b11 ::  2 Word.word))\<close>


\<comment> \<open>\<open>val Privilege_of_num : integer -> Privilege\<close>\<close>

definition Privilege_of_num  :: \<open> int \<Rightarrow> Privilege \<close>  where 
     \<open> Privilege_of_num arg1 = (
   (let l__260 = arg1 in
   if (((l__260 = (( 0 :: int)::ii)))) then User
   else if (((l__260 = (( 1 :: int)::ii)))) then Supervisor
   else Machine))\<close> 
  for  arg1  :: " int "


\<comment> \<open>\<open>val num_of_Privilege : Privilege -> integer\<close>\<close>

fun num_of_Privilege  :: \<open> Privilege \<Rightarrow> int \<close>  where 
     \<open> num_of_Privilege User = ( (( 0 :: int)::ii))\<close>
|\<open> num_of_Privilege Supervisor = ( (( 1 :: int)::ii))\<close>
|\<open> num_of_Privilege Machine = ( (( 2 :: int)::ii))\<close>


\<comment> \<open>\<open>val privLevel_to_bits : Privilege -> mword ty2\<close>\<close>

fun privLevel_to_bits  :: \<open> Privilege \<Rightarrow>(2)Word.word \<close>  where 
     \<open> privLevel_to_bits User = ( ( 0b00 ::  2 Word.word))\<close>
|\<open> privLevel_to_bits Supervisor = ( ( 0b01 ::  2 Word.word))\<close>
|\<open> privLevel_to_bits Machine = ( ( 0b11 ::  2 Word.word))\<close>


\<comment> \<open>\<open>val privLevel_of_bits : mword ty2 -> M Privilege\<close>\<close>

definition privLevel_of_bits  :: \<open>(2)Word.word \<Rightarrow>((register_value),(Privilege),(exception))monad \<close>  where 
     \<open> privLevel_of_bits p = (
   (let b__0 = p in
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then return User
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then return Supervisor
   else if (((b__0 = ( 0b11 ::  2 Word.word)))) then return Machine
   else assert_exp False (''Pattern match failure at model/riscv_types.sail 78:2 - 82:3'') \<then> exit0 () ))\<close> 
  for  p  :: "(2)Word.word "


\<comment> \<open>\<open>val privLevel_to_str : Privilege -> string\<close>\<close>

fun privLevel_to_str  :: \<open> Privilege \<Rightarrow> string \<close>  where 
     \<open> privLevel_to_str User = ( (''U''))\<close>
|\<open> privLevel_to_str Supervisor = ( (''S''))\<close>
|\<open> privLevel_to_str Machine = ( (''M''))\<close>


\<comment> \<open>\<open>val accessType_to_str : AccessType unit -> string\<close>\<close>

\<comment> \<open>\<open>val csr_name : mword ty12 -> string\<close>\<close>

\<comment> \<open>\<open>val exceptionType_to_str : ExceptionType -> string\<close>\<close>

\<comment> \<open>\<open>val print_insn : ast -> M string\<close>\<close>

\<comment> \<open>\<open>val ptw_error_to_str : PTW_Error -> string\<close>\<close>

\<comment> \<open>\<open>val reg_name_abi : mword ty5 -> M string\<close>\<close>

\<comment> \<open>\<open>val Retired_of_num : integer -> Retired\<close>\<close>

definition Retired_of_num  :: \<open> int \<Rightarrow> Retired \<close>  where 
     \<open> Retired_of_num arg1 = (
   (let l__259 = arg1 in
   if (((l__259 = (( 0 :: int)::ii)))) then RETIRE_SUCCESS
   else RETIRE_FAIL))\<close> 
  for  arg1  :: " int "


\<comment> \<open>\<open>val num_of_Retired : Retired -> integer\<close>\<close>

fun num_of_Retired  :: \<open> Retired \<Rightarrow> int \<close>  where 
     \<open> num_of_Retired RETIRE_SUCCESS = ( (( 0 :: int)::ii))\<close>
|\<open> num_of_Retired RETIRE_FAIL = ( (( 1 :: int)::ii))\<close>


\<comment> \<open>\<open>val word_width_of_num : integer -> word_width\<close>\<close>

definition word_width_of_num  :: \<open> int \<Rightarrow> word_width \<close>  where 
     \<open> word_width_of_num arg1 = (
   (let l__256 = arg1 in
   if (((l__256 = (( 0 :: int)::ii)))) then BYTE
   else if (((l__256 = (( 1 :: int)::ii)))) then HALF
   else if (((l__256 = (( 2 :: int)::ii)))) then WORD
   else DOUBLE))\<close> 
  for  arg1  :: " int "


\<comment> \<open>\<open>val num_of_word_width : word_width -> integer\<close>\<close>

fun num_of_word_width  :: \<open> word_width \<Rightarrow> int \<close>  where 
     \<open> num_of_word_width BYTE = ( (( 0 :: int)::ii))\<close>
|\<open> num_of_word_width HALF = ( (( 1 :: int)::ii))\<close>
|\<open> num_of_word_width WORD = ( (( 2 :: int)::ii))\<close>
|\<open> num_of_word_width DOUBLE = ( (( 3 :: int)::ii))\<close>


\<comment> \<open>\<open>val InterruptType_of_num : integer -> InterruptType\<close>\<close>

definition InterruptType_of_num  :: \<open> int \<Rightarrow> InterruptType \<close>  where 
     \<open> InterruptType_of_num arg1 = (
   (let l__248 = arg1 in
   if (((l__248 = (( 0 :: int)::ii)))) then I_U_Software
   else if (((l__248 = (( 1 :: int)::ii)))) then I_S_Software
   else if (((l__248 = (( 2 :: int)::ii)))) then I_M_Software
   else if (((l__248 = (( 3 :: int)::ii)))) then I_U_Timer
   else if (((l__248 = (( 4 :: int)::ii)))) then I_S_Timer
   else if (((l__248 = (( 5 :: int)::ii)))) then I_M_Timer
   else if (((l__248 = (( 6 :: int)::ii)))) then I_U_External
   else if (((l__248 = (( 7 :: int)::ii)))) then I_S_External
   else I_M_External))\<close> 
  for  arg1  :: " int "


\<comment> \<open>\<open>val num_of_InterruptType : InterruptType -> integer\<close>\<close>

fun num_of_InterruptType  :: \<open> InterruptType \<Rightarrow> int \<close>  where 
     \<open> num_of_InterruptType I_U_Software = ( (( 0 :: int)::ii))\<close>
|\<open> num_of_InterruptType I_S_Software = ( (( 1 :: int)::ii))\<close>
|\<open> num_of_InterruptType I_M_Software = ( (( 2 :: int)::ii))\<close>
|\<open> num_of_InterruptType I_U_Timer = ( (( 3 :: int)::ii))\<close>
|\<open> num_of_InterruptType I_S_Timer = ( (( 4 :: int)::ii))\<close>
|\<open> num_of_InterruptType I_M_Timer = ( (( 5 :: int)::ii))\<close>
|\<open> num_of_InterruptType I_U_External = ( (( 6 :: int)::ii))\<close>
|\<open> num_of_InterruptType I_S_External = ( (( 7 :: int)::ii))\<close>
|\<open> num_of_InterruptType I_M_External = ( (( 8 :: int)::ii))\<close>


\<comment> \<open>\<open>val interruptType_to_bits : InterruptType -> mword ty8\<close>\<close>

fun interruptType_to_bits  :: \<open> InterruptType \<Rightarrow>(8)Word.word \<close>  where 
     \<open> interruptType_to_bits I_U_Software = ( ( 0x00 ::  8 Word.word))\<close>
|\<open> interruptType_to_bits I_S_Software = ( ( 0x01 ::  8 Word.word))\<close>
|\<open> interruptType_to_bits I_M_Software = ( ( 0x03 ::  8 Word.word))\<close>
|\<open> interruptType_to_bits I_U_Timer = ( ( 0x04 ::  8 Word.word))\<close>
|\<open> interruptType_to_bits I_S_Timer = ( ( 0x05 ::  8 Word.word))\<close>
|\<open> interruptType_to_bits I_M_Timer = ( ( 0x07 ::  8 Word.word))\<close>
|\<open> interruptType_to_bits I_U_External = ( ( 0x08 ::  8 Word.word))\<close>
|\<open> interruptType_to_bits I_S_External = ( ( 0x09 ::  8 Word.word))\<close>
|\<open> interruptType_to_bits I_M_External = ( ( 0x0B ::  8 Word.word))\<close>


\<comment> \<open>\<open>val exceptionType_to_bits : ExceptionType -> mword ty8\<close>\<close>

fun exceptionType_to_bits  :: \<open> ExceptionType \<Rightarrow>(8)Word.word \<close>  where 
     \<open> exceptionType_to_bits (E_Fetch_Addr_Align (_)) = ( ( 0x00 ::  8 Word.word))\<close>
|\<open> exceptionType_to_bits (E_Fetch_Access_Fault (_)) = ( ( 0x01 ::  8 Word.word))\<close>
|\<open> exceptionType_to_bits (E_Illegal_Instr (_)) = ( ( 0x02 ::  8 Word.word))\<close>
|\<open> exceptionType_to_bits (E_Breakpoint (_)) = ( ( 0x03 ::  8 Word.word))\<close>
|\<open> exceptionType_to_bits (E_Load_Addr_Align (_)) = ( ( 0x04 ::  8 Word.word))\<close>
|\<open> exceptionType_to_bits (E_Load_Access_Fault (_)) = ( ( 0x05 ::  8 Word.word))\<close>
|\<open> exceptionType_to_bits (E_SAMO_Addr_Align (_)) = ( ( 0x06 ::  8 Word.word))\<close>
|\<open> exceptionType_to_bits (E_SAMO_Access_Fault (_)) = ( ( 0x07 ::  8 Word.word))\<close>
|\<open> exceptionType_to_bits (E_U_EnvCall (_)) = ( ( 0x08 ::  8 Word.word))\<close>
|\<open> exceptionType_to_bits (E_S_EnvCall (_)) = ( ( 0x09 ::  8 Word.word))\<close>
|\<open> exceptionType_to_bits (E_Reserved_10 (_)) = ( ( 0x0A ::  8 Word.word))\<close>
|\<open> exceptionType_to_bits (E_M_EnvCall (_)) = ( ( 0x0B ::  8 Word.word))\<close>
|\<open> exceptionType_to_bits (E_Fetch_Page_Fault (_)) = ( ( 0x0C ::  8 Word.word))\<close>
|\<open> exceptionType_to_bits (E_Load_Page_Fault (_)) = ( ( 0x0D ::  8 Word.word))\<close>
|\<open> exceptionType_to_bits (E_Reserved_14 (_)) = ( ( 0x0E ::  8 Word.word))\<close>
|\<open> exceptionType_to_bits (E_SAMO_Page_Fault (_)) = ( ( 0x0F ::  8 Word.word))\<close>
|\<open> exceptionType_to_bits (E_Extension (e)) = ( (ext_exc_type_to_bits e  ::  8 Word.word))\<close> 
  for  e  :: " unit "


\<comment> \<open>\<open>val num_of_ExceptionType : ExceptionType -> integer\<close>\<close>

fun num_of_ExceptionType  :: \<open> ExceptionType \<Rightarrow> int \<close>  where 
     \<open> num_of_ExceptionType (E_Fetch_Addr_Align (_)) = ( (( 0 :: int)::ii))\<close>
|\<open> num_of_ExceptionType (E_Fetch_Access_Fault (_)) = ( (( 1 :: int)::ii))\<close>
|\<open> num_of_ExceptionType (E_Illegal_Instr (_)) = ( (( 2 :: int)::ii))\<close>
|\<open> num_of_ExceptionType (E_Breakpoint (_)) = ( (( 3 :: int)::ii))\<close>
|\<open> num_of_ExceptionType (E_Load_Addr_Align (_)) = ( (( 4 :: int)::ii))\<close>
|\<open> num_of_ExceptionType (E_Load_Access_Fault (_)) = ( (( 5 :: int)::ii))\<close>
|\<open> num_of_ExceptionType (E_SAMO_Addr_Align (_)) = ( (( 6 :: int)::ii))\<close>
|\<open> num_of_ExceptionType (E_SAMO_Access_Fault (_)) = ( (( 7 :: int)::ii))\<close>
|\<open> num_of_ExceptionType (E_U_EnvCall (_)) = ( (( 8 :: int)::ii))\<close>
|\<open> num_of_ExceptionType (E_S_EnvCall (_)) = ( (( 9 :: int)::ii))\<close>
|\<open> num_of_ExceptionType (E_Reserved_10 (_)) = ( (( 10 :: int)::ii))\<close>
|\<open> num_of_ExceptionType (E_M_EnvCall (_)) = ( (( 11 :: int)::ii))\<close>
|\<open> num_of_ExceptionType (E_Fetch_Page_Fault (_)) = ( (( 12 :: int)::ii))\<close>
|\<open> num_of_ExceptionType (E_Load_Page_Fault (_)) = ( (( 13 :: int)::ii))\<close>
|\<open> num_of_ExceptionType (E_Reserved_14 (_)) = ( (( 14 :: int)::ii))\<close>
|\<open> num_of_ExceptionType (E_SAMO_Page_Fault (_)) = ( (( 15 :: int)::ii))\<close>
|\<open> num_of_ExceptionType (E_Extension (e)) = ( num_of_ext_exc_type e )\<close> 
  for  e  :: " unit "


fun exceptionType_to_str  :: \<open> ExceptionType \<Rightarrow> string \<close>  where 
     \<open> exceptionType_to_str (E_Fetch_Addr_Align (_)) = ( (''misaligned-fetch''))\<close>
|\<open> exceptionType_to_str (E_Fetch_Access_Fault (_)) = ( (''fetch-access-fault''))\<close>
|\<open> exceptionType_to_str (E_Illegal_Instr (_)) = ( (''illegal-instruction''))\<close>
|\<open> exceptionType_to_str (E_Breakpoint (_)) = ( (''breakpoint''))\<close>
|\<open> exceptionType_to_str (E_Load_Addr_Align (_)) = ( (''misaligned-load''))\<close>
|\<open> exceptionType_to_str (E_Load_Access_Fault (_)) = ( (''load-access-fault''))\<close>
|\<open> exceptionType_to_str (E_SAMO_Addr_Align (_)) = ( (''misaliged-store/amo''))\<close>
|\<open> exceptionType_to_str (E_SAMO_Access_Fault (_)) = ( (''store/amo-access-fault''))\<close>
|\<open> exceptionType_to_str (E_U_EnvCall (_)) = ( (''u-call''))\<close>
|\<open> exceptionType_to_str (E_S_EnvCall (_)) = ( (''s-call''))\<close>
|\<open> exceptionType_to_str (E_Reserved_10 (_)) = ( (''reserved-0''))\<close>
|\<open> exceptionType_to_str (E_M_EnvCall (_)) = ( (''m-call''))\<close>
|\<open> exceptionType_to_str (E_Fetch_Page_Fault (_)) = ( (''fetch-page-fault''))\<close>
|\<open> exceptionType_to_str (E_Load_Page_Fault (_)) = ( (''load-page-fault''))\<close>
|\<open> exceptionType_to_str (E_Reserved_14 (_)) = ( (''reserved-1''))\<close>
|\<open> exceptionType_to_str (E_SAMO_Page_Fault (_)) = ( (''store/amo-page-fault''))\<close>
|\<open> exceptionType_to_str (E_Extension (e)) = ( ext_exc_type_to_str e )\<close> 
  for  e  :: " unit "


\<comment> \<open>\<open>val not_implemented : forall 'a. string -> M 'a\<close>\<close>

definition not_implemented  :: \<open> string \<Rightarrow>((register_value),'a,(exception))monad \<close>  where 
     \<open> not_implemented message = ( throw (Error_not_implemented message))\<close> 
  for  message  :: " string "


\<comment> \<open>\<open>val internal_error : forall 'a. string -> M 'a\<close>\<close>

definition internal_error  :: \<open> string \<Rightarrow>((register_value),'a,(exception))monad \<close>  where 
     \<open> internal_error s = ( assert_exp False s \<then> exit0 ()  )\<close> 
  for  s  :: " string "


\<comment> \<open>\<open>val TrapVectorMode_of_num : integer -> TrapVectorMode\<close>\<close>

definition TrapVectorMode_of_num  :: \<open> int \<Rightarrow> TrapVectorMode \<close>  where 
     \<open> TrapVectorMode_of_num arg1 = (
   (let l__246 = arg1 in
   if (((l__246 = (( 0 :: int)::ii)))) then TV_Direct
   else if (((l__246 = (( 1 :: int)::ii)))) then TV_Vector
   else TV_Reserved))\<close> 
  for  arg1  :: " int "


\<comment> \<open>\<open>val num_of_TrapVectorMode : TrapVectorMode -> integer\<close>\<close>

fun num_of_TrapVectorMode  :: \<open> TrapVectorMode \<Rightarrow> int \<close>  where 
     \<open> num_of_TrapVectorMode TV_Direct = ( (( 0 :: int)::ii))\<close>
|\<open> num_of_TrapVectorMode TV_Vector = ( (( 1 :: int)::ii))\<close>
|\<open> num_of_TrapVectorMode TV_Reserved = ( (( 2 :: int)::ii))\<close>


\<comment> \<open>\<open>val trapVectorMode_of_bits : mword ty2 -> TrapVectorMode\<close>\<close>

definition trapVectorMode_of_bits  :: \<open>(2)Word.word \<Rightarrow> TrapVectorMode \<close>  where 
     \<open> trapVectorMode_of_bits m = (
   (let b__0 = m in
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then TV_Direct
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then TV_Vector
   else TV_Reserved))\<close> 
  for  m  :: "(2)Word.word "


\<comment> \<open>\<open>val ExtStatus_of_num : integer -> ExtStatus\<close>\<close>

definition ExtStatus_of_num  :: \<open> int \<Rightarrow> ExtStatus \<close>  where 
     \<open> ExtStatus_of_num arg1 = (
   (let l__243 = arg1 in
   if (((l__243 = (( 0 :: int)::ii)))) then Off
   else if (((l__243 = (( 1 :: int)::ii)))) then Initial
   else if (((l__243 = (( 2 :: int)::ii)))) then Clean
   else Dirty))\<close> 
  for  arg1  :: " int "


\<comment> \<open>\<open>val num_of_ExtStatus : ExtStatus -> integer\<close>\<close>

fun num_of_ExtStatus  :: \<open> ExtStatus \<Rightarrow> int \<close>  where 
     \<open> num_of_ExtStatus Off = ( (( 0 :: int)::ii))\<close>
|\<open> num_of_ExtStatus Initial = ( (( 1 :: int)::ii))\<close>
|\<open> num_of_ExtStatus Clean = ( (( 2 :: int)::ii))\<close>
|\<open> num_of_ExtStatus Dirty = ( (( 3 :: int)::ii))\<close>


\<comment> \<open>\<open>val extStatus_to_bits : ExtStatus -> mword ty2\<close>\<close>

fun extStatus_to_bits  :: \<open> ExtStatus \<Rightarrow>(2)Word.word \<close>  where 
     \<open> extStatus_to_bits Off = ( ( 0b00 ::  2 Word.word))\<close>
|\<open> extStatus_to_bits Initial = ( ( 0b01 ::  2 Word.word))\<close>
|\<open> extStatus_to_bits Clean = ( ( 0b10 ::  2 Word.word))\<close>
|\<open> extStatus_to_bits Dirty = ( ( 0b11 ::  2 Word.word))\<close>


\<comment> \<open>\<open>val extStatus_of_bits : mword ty2 -> M ExtStatus\<close>\<close>

definition extStatus_of_bits  :: \<open>(2)Word.word \<Rightarrow>((register_value),(ExtStatus),(exception))monad \<close>  where 
     \<open> extStatus_of_bits e = (
   (let b__0 = e in
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then return Off
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then return Initial
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then return Clean
   else if (((b__0 = ( 0b11 ::  2 Word.word)))) then return Dirty
   else assert_exp False (''Pattern match failure at model/riscv_types.sail 281:2 - 286:3'') \<then> exit0 () ))\<close> 
  for  e  :: "(2)Word.word "


\<comment> \<open>\<open>val SATPMode_of_num : integer -> SATPMode\<close>\<close>

definition SATPMode_of_num  :: \<open> int \<Rightarrow> SATPMode \<close>  where 
     \<open> SATPMode_of_num arg1 = (
   (let l__240 = arg1 in
   if (((l__240 = (( 0 :: int)::ii)))) then Sbare
   else if (((l__240 = (( 1 :: int)::ii)))) then Sv32
   else if (((l__240 = (( 2 :: int)::ii)))) then Sv39
   else Sv48))\<close> 
  for  arg1  :: " int "


\<comment> \<open>\<open>val num_of_SATPMode : SATPMode -> integer\<close>\<close>

fun num_of_SATPMode  :: \<open> SATPMode \<Rightarrow> int \<close>  where 
     \<open> num_of_SATPMode Sbare = ( (( 0 :: int)::ii))\<close>
|\<open> num_of_SATPMode Sv32 = ( (( 1 :: int)::ii))\<close>
|\<open> num_of_SATPMode Sv39 = ( (( 2 :: int)::ii))\<close>
|\<open> num_of_SATPMode Sv48 = ( (( 3 :: int)::ii))\<close>


\<comment> \<open>\<open>val satp64Mode_of_bits : Architecture -> mword ty4 -> maybe SATPMode\<close>\<close>

definition satp64Mode_of_bits  :: \<open> Architecture \<Rightarrow>(4)Word.word \<Rightarrow>(SATPMode)option \<close>  where 
     \<open> satp64Mode_of_bits (g__338 :: Architecture) (b__0 :: satp_mode) = (
      if (((b__0 = ( 0x0 ::  4 Word.word)))) then Some Sbare
      else
        (case  (g__338, b__0) of
          (RV32, b__0) =>
           if (((b__0 = ( 0x1 ::  4 Word.word)))) then Some Sv32
           else (case  (RV32, b__0) of   (_, _) => None )
        | (RV64, b__0) =>
           if (((b__0 = ( 0x8 ::  4 Word.word)))) then Some Sv39
           else if (((b__0 = ( 0x9 ::  4 Word.word)))) then Some Sv48
           else (case  (RV64, b__0) of   (_, _) => None )
        | (_, _) => None
        ))\<close> 
  for  g__338  :: " Architecture " 
  and  b__0  :: "(4)Word.word "


\<comment> \<open>\<open>val uop_of_num : integer -> uop\<close>\<close>

definition uop_of_num  :: \<open> int \<Rightarrow> uop \<close>  where 
     \<open> uop_of_num arg1 = (
   (let l__239 = arg1 in
   if (((l__239 = (( 0 :: int)::ii)))) then RISCV_LUI
   else RISCV_AUIPC))\<close> 
  for  arg1  :: " int "


\<comment> \<open>\<open>val num_of_uop : uop -> integer\<close>\<close>

fun num_of_uop  :: \<open> uop \<Rightarrow> int \<close>  where 
     \<open> num_of_uop RISCV_LUI = ( (( 0 :: int)::ii))\<close>
|\<open> num_of_uop RISCV_AUIPC = ( (( 1 :: int)::ii))\<close>


\<comment> \<open>\<open>val bop_of_num : integer -> bop\<close>\<close>

definition bop_of_num  :: \<open> int \<Rightarrow> bop \<close>  where 
     \<open> bop_of_num arg1 = (
   (let l__234 = arg1 in
   if (((l__234 = (( 0 :: int)::ii)))) then RISCV_BEQ
   else if (((l__234 = (( 1 :: int)::ii)))) then RISCV_BNE
   else if (((l__234 = (( 2 :: int)::ii)))) then RISCV_BLT
   else if (((l__234 = (( 3 :: int)::ii)))) then RISCV_BGE
   else if (((l__234 = (( 4 :: int)::ii)))) then RISCV_BLTU
   else RISCV_BGEU))\<close> 
  for  arg1  :: " int "


\<comment> \<open>\<open>val num_of_bop : bop -> integer\<close>\<close>

fun num_of_bop  :: \<open> bop \<Rightarrow> int \<close>  where 
     \<open> num_of_bop RISCV_BEQ = ( (( 0 :: int)::ii))\<close>
|\<open> num_of_bop RISCV_BNE = ( (( 1 :: int)::ii))\<close>
|\<open> num_of_bop RISCV_BLT = ( (( 2 :: int)::ii))\<close>
|\<open> num_of_bop RISCV_BGE = ( (( 3 :: int)::ii))\<close>
|\<open> num_of_bop RISCV_BLTU = ( (( 4 :: int)::ii))\<close>
|\<open> num_of_bop RISCV_BGEU = ( (( 5 :: int)::ii))\<close>


\<comment> \<open>\<open>val iop_of_num : integer -> iop\<close>\<close>

definition iop_of_num  :: \<open> int \<Rightarrow> iop \<close>  where 
     \<open> iop_of_num arg1 = (
   (let l__229 = arg1 in
   if (((l__229 = (( 0 :: int)::ii)))) then RISCV_ADDI
   else if (((l__229 = (( 1 :: int)::ii)))) then RISCV_SLTI
   else if (((l__229 = (( 2 :: int)::ii)))) then RISCV_SLTIU
   else if (((l__229 = (( 3 :: int)::ii)))) then RISCV_XORI
   else if (((l__229 = (( 4 :: int)::ii)))) then RISCV_ORI
   else RISCV_ANDI))\<close> 
  for  arg1  :: " int "


\<comment> \<open>\<open>val num_of_iop : iop -> integer\<close>\<close>

fun num_of_iop  :: \<open> iop \<Rightarrow> int \<close>  where 
     \<open> num_of_iop RISCV_ADDI = ( (( 0 :: int)::ii))\<close>
|\<open> num_of_iop RISCV_SLTI = ( (( 1 :: int)::ii))\<close>
|\<open> num_of_iop RISCV_SLTIU = ( (( 2 :: int)::ii))\<close>
|\<open> num_of_iop RISCV_XORI = ( (( 3 :: int)::ii))\<close>
|\<open> num_of_iop RISCV_ORI = ( (( 4 :: int)::ii))\<close>
|\<open> num_of_iop RISCV_ANDI = ( (( 5 :: int)::ii))\<close>


\<comment> \<open>\<open>val sop_of_num : integer -> sop\<close>\<close>

definition sop_of_num  :: \<open> int \<Rightarrow> sop \<close>  where 
     \<open> sop_of_num arg1 = (
   (let l__227 = arg1 in
   if (((l__227 = (( 0 :: int)::ii)))) then RISCV_SLLI
   else if (((l__227 = (( 1 :: int)::ii)))) then RISCV_SRLI
   else RISCV_SRAI))\<close> 
  for  arg1  :: " int "


\<comment> \<open>\<open>val num_of_sop : sop -> integer\<close>\<close>

fun num_of_sop  :: \<open> sop \<Rightarrow> int \<close>  where 
     \<open> num_of_sop RISCV_SLLI = ( (( 0 :: int)::ii))\<close>
|\<open> num_of_sop RISCV_SRLI = ( (( 1 :: int)::ii))\<close>
|\<open> num_of_sop RISCV_SRAI = ( (( 2 :: int)::ii))\<close>


\<comment> \<open>\<open>val rop_of_num : integer -> rop\<close>\<close>

definition rop_of_num  :: \<open> int \<Rightarrow> rop \<close>  where 
     \<open> rop_of_num arg1 = (
   (let l__218 = arg1 in
   if (((l__218 = (( 0 :: int)::ii)))) then RISCV_ADD
   else if (((l__218 = (( 1 :: int)::ii)))) then RISCV_SUB
   else if (((l__218 = (( 2 :: int)::ii)))) then RISCV_SLL
   else if (((l__218 = (( 3 :: int)::ii)))) then RISCV_SLT
   else if (((l__218 = (( 4 :: int)::ii)))) then RISCV_SLTU
   else if (((l__218 = (( 5 :: int)::ii)))) then RISCV_XOR
   else if (((l__218 = (( 6 :: int)::ii)))) then RISCV_SRL
   else if (((l__218 = (( 7 :: int)::ii)))) then RISCV_SRA
   else if (((l__218 = (( 8 :: int)::ii)))) then RISCV_OR
   else RISCV_AND))\<close> 
  for  arg1  :: " int "


\<comment> \<open>\<open>val num_of_rop : rop -> integer\<close>\<close>

fun num_of_rop  :: \<open> rop \<Rightarrow> int \<close>  where 
     \<open> num_of_rop RISCV_ADD = ( (( 0 :: int)::ii))\<close>
|\<open> num_of_rop RISCV_SUB = ( (( 1 :: int)::ii))\<close>
|\<open> num_of_rop RISCV_SLL = ( (( 2 :: int)::ii))\<close>
|\<open> num_of_rop RISCV_SLT = ( (( 3 :: int)::ii))\<close>
|\<open> num_of_rop RISCV_SLTU = ( (( 4 :: int)::ii))\<close>
|\<open> num_of_rop RISCV_XOR = ( (( 5 :: int)::ii))\<close>
|\<open> num_of_rop RISCV_SRL = ( (( 6 :: int)::ii))\<close>
|\<open> num_of_rop RISCV_SRA = ( (( 7 :: int)::ii))\<close>
|\<open> num_of_rop RISCV_OR = ( (( 8 :: int)::ii))\<close>
|\<open> num_of_rop RISCV_AND = ( (( 9 :: int)::ii))\<close>


\<comment> \<open>\<open>val ropw_of_num : integer -> ropw\<close>\<close>

definition ropw_of_num  :: \<open> int \<Rightarrow> ropw \<close>  where 
     \<open> ropw_of_num arg1 = (
   (let l__214 = arg1 in
   if (((l__214 = (( 0 :: int)::ii)))) then RISCV_ADDW
   else if (((l__214 = (( 1 :: int)::ii)))) then RISCV_SUBW
   else if (((l__214 = (( 2 :: int)::ii)))) then RISCV_SLLW
   else if (((l__214 = (( 3 :: int)::ii)))) then RISCV_SRLW
   else RISCV_SRAW))\<close> 
  for  arg1  :: " int "


\<comment> \<open>\<open>val num_of_ropw : ropw -> integer\<close>\<close>

fun num_of_ropw  :: \<open> ropw \<Rightarrow> int \<close>  where 
     \<open> num_of_ropw RISCV_ADDW = ( (( 0 :: int)::ii))\<close>
|\<open> num_of_ropw RISCV_SUBW = ( (( 1 :: int)::ii))\<close>
|\<open> num_of_ropw RISCV_SLLW = ( (( 2 :: int)::ii))\<close>
|\<open> num_of_ropw RISCV_SRLW = ( (( 3 :: int)::ii))\<close>
|\<open> num_of_ropw RISCV_SRAW = ( (( 4 :: int)::ii))\<close>


\<comment> \<open>\<open>val sopw_of_num : integer -> sopw\<close>\<close>

definition sopw_of_num  :: \<open> int \<Rightarrow> sopw \<close>  where 
     \<open> sopw_of_num arg1 = (
   (let l__212 = arg1 in
   if (((l__212 = (( 0 :: int)::ii)))) then RISCV_SLLIW
   else if (((l__212 = (( 1 :: int)::ii)))) then RISCV_SRLIW
   else RISCV_SRAIW))\<close> 
  for  arg1  :: " int "


\<comment> \<open>\<open>val num_of_sopw : sopw -> integer\<close>\<close>

fun num_of_sopw  :: \<open> sopw \<Rightarrow> int \<close>  where 
     \<open> num_of_sopw RISCV_SLLIW = ( (( 0 :: int)::ii))\<close>
|\<open> num_of_sopw RISCV_SRLIW = ( (( 1 :: int)::ii))\<close>
|\<open> num_of_sopw RISCV_SRAIW = ( (( 2 :: int)::ii))\<close>


\<comment> \<open>\<open>val amoop_of_num : integer -> amoop\<close>\<close>

definition amoop_of_num  :: \<open> int \<Rightarrow> amoop \<close>  where 
     \<open> amoop_of_num arg1 = (
   (let l__204 = arg1 in
   if (((l__204 = (( 0 :: int)::ii)))) then AMOSWAP
   else if (((l__204 = (( 1 :: int)::ii)))) then AMOADD
   else if (((l__204 = (( 2 :: int)::ii)))) then AMOXOR
   else if (((l__204 = (( 3 :: int)::ii)))) then AMOAND
   else if (((l__204 = (( 4 :: int)::ii)))) then AMOOR
   else if (((l__204 = (( 5 :: int)::ii)))) then AMOMIN
   else if (((l__204 = (( 6 :: int)::ii)))) then AMOMAX
   else if (((l__204 = (( 7 :: int)::ii)))) then AMOMINU
   else AMOMAXU))\<close> 
  for  arg1  :: " int "


\<comment> \<open>\<open>val num_of_amoop : amoop -> integer\<close>\<close>

fun num_of_amoop  :: \<open> amoop \<Rightarrow> int \<close>  where 
     \<open> num_of_amoop AMOSWAP = ( (( 0 :: int)::ii))\<close>
|\<open> num_of_amoop AMOADD = ( (( 1 :: int)::ii))\<close>
|\<open> num_of_amoop AMOXOR = ( (( 2 :: int)::ii))\<close>
|\<open> num_of_amoop AMOAND = ( (( 3 :: int)::ii))\<close>
|\<open> num_of_amoop AMOOR = ( (( 4 :: int)::ii))\<close>
|\<open> num_of_amoop AMOMIN = ( (( 5 :: int)::ii))\<close>
|\<open> num_of_amoop AMOMAX = ( (( 6 :: int)::ii))\<close>
|\<open> num_of_amoop AMOMINU = ( (( 7 :: int)::ii))\<close>
|\<open> num_of_amoop AMOMAXU = ( (( 8 :: int)::ii))\<close>


\<comment> \<open>\<open>val csrop_of_num : integer -> csrop\<close>\<close>

definition csrop_of_num  :: \<open> int \<Rightarrow> csrop \<close>  where 
     \<open> csrop_of_num arg1 = (
   (let l__202 = arg1 in
   if (((l__202 = (( 0 :: int)::ii)))) then CSRRW
   else if (((l__202 = (( 1 :: int)::ii)))) then CSRRS
   else CSRRC))\<close> 
  for  arg1  :: " int "


\<comment> \<open>\<open>val num_of_csrop : csrop -> integer\<close>\<close>

fun num_of_csrop  :: \<open> csrop \<Rightarrow> int \<close>  where 
     \<open> num_of_csrop CSRRW = ( (( 0 :: int)::ii))\<close>
|\<open> num_of_csrop CSRRS = ( (( 1 :: int)::ii))\<close>
|\<open> num_of_csrop CSRRC = ( (( 2 :: int)::ii))\<close>


\<comment> \<open>\<open>val sep_forwards : unit -> string\<close>\<close>

\<comment> \<open>\<open>val sep_backwards : string -> M unit\<close>\<close>

\<comment> \<open>\<open>val sep_forwards_matches : unit -> bool\<close>\<close>

\<comment> \<open>\<open>val sep_backwards_matches : string -> bool\<close>\<close>

\<comment> \<open>\<open>val sep_matches_prefix : string -> maybe ((unit * ii))\<close>\<close>

definition sep_forwards  :: \<open> unit \<Rightarrow> string \<close>  where 
     \<open> sep_forwards _ = (
      string_append ((opt_spc_forwards () ))
        ((string_append ('','') ((string_append ((def_spc_forwards () )) (''''))))))\<close>


\<comment> \<open>\<open>val _s0_ : string -> maybe unit\<close>\<close>

definition s0  :: \<open> string \<Rightarrow>(unit)option \<close>  where 
     \<open> s0 s20 = (
      (case  ((opt_spc_matches_prefix0 s20)) of
        Some ((_, s30)) =>
         (let s41 = (string_drop s20 s30) in
         if ((string_startswith s41 ('',''))) then  
  (case  ((string_drop s41 ((string_length ('',''))))) of
        s50 =>
  (case  ((def_spc_matches_prefix s50)) of
        Some ((_, s61)) =>
  (let p00 = (string_drop s50 s61) in
  if (((p00 = ('''')))) then Some ()  else None)
    | _ => None
  )
  )
         else None)
      | _ => None
      ))\<close> 
  for  s20  :: " string "


definition sep_backwards  :: \<open> string \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> sep_backwards arg1 = (
   (let s70 = arg1 in
   if ((case  ((s0 s70)) of   Some (_) => True | _ => False )) then  
  (case  s0 s70 of (Some (_)) => return ()  )
   else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))\<close> 
  for  arg1  :: " string "


definition sep_forwards_matches  :: \<open> unit \<Rightarrow> bool \<close>  where 
     \<open> sep_forwards_matches _ = ( True )\<close>


\<comment> \<open>\<open>val _s8_ : string -> maybe unit\<close>\<close>

definition s8  :: \<open> string \<Rightarrow>(unit)option \<close>  where 
     \<open> s8 s101 = (
      (case  ((opt_spc_matches_prefix0 s101)) of
        Some ((_, s110)) =>
         (let s121 = (string_drop s101 s110) in
         if ((string_startswith s121 ('',''))) then  
  (case  ((string_drop s121 ((string_length ('',''))))) of
        s130 =>
  (case  ((def_spc_matches_prefix s130)) of
        Some ((_, s141)) =>
  (let p00 = (string_drop s130 s141) in
  if (((p00 = ('''')))) then Some ()  else None)
    | _ => None
  )
  )
         else None)
      | _ => None
      ))\<close> 
  for  s101  :: " string "


definition sep_backwards_matches  :: \<open> string \<Rightarrow> bool \<close>  where 
     \<open> sep_backwards_matches arg1 = (
   (let s150 = arg1 in
   if ((case  ((s8 s150)) of   Some (_) => True | _ => False )) then  
  (case  s8 s150 of (Some (_)) => True )
   else False))\<close> 
  for  arg1  :: " string "


\<comment> \<open>\<open>val _s16_ : string -> maybe string\<close>\<close>

definition s16  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s16 s181 = (
      (case  ((opt_spc_matches_prefix0 s181)) of
        Some ((_, s190)) =>
         (let s201 = (string_drop s181 s190) in
         if ((string_startswith s201 ('',''))) then  
  (case  ((string_drop s201 ((string_length ('',''))))) of
        s210 =>
  (case  ((def_spc_matches_prefix s210)) of
        Some ((_, s221)) =>
  (case  ((string_drop s210 s221)) of   s1 => Some s1 )
    | _ => None
  )
  )
         else None)
      | _ => None
      ))\<close> 
  for  s181  :: " string "


definition sep_matches_prefix  :: \<open> string \<Rightarrow>(unit*int)option \<close>  where 
     \<open> sep_matches_prefix arg1 = (
   (let s230 = arg1 in
   if ((case  ((s16 s230)) of   Some (s1) => True | _ => False )) then  
  (case  s16 s230 of
      (Some (s1)) =>
  Some (() , ((string_length arg1)) - ((string_length s1)))
  )
   else None))\<close> 
  for  arg1  :: " string "


\<comment> \<open>\<open>val bool_bits_forwards : bool -> mword ty1\<close>\<close>

\<comment> \<open>\<open>val bool_bits_backwards : mword ty1 -> M bool\<close>\<close>

\<comment> \<open>\<open>val bool_bits_forwards_matches : bool -> bool\<close>\<close>

\<comment> \<open>\<open>val bool_bits_backwards_matches : mword ty1 -> bool\<close>\<close>

fun bool_bits_forwards  :: \<open> bool \<Rightarrow>(1)Word.word \<close>  where 
     \<open> bool_bits_forwards True = ( ( 0b1 ::  1 Word.word))\<close>
|\<open> bool_bits_forwards False = ( ( 0b0 ::  1 Word.word))\<close>


definition bool_bits_backwards  :: \<open>(1)Word.word \<Rightarrow>((register_value),(bool),(exception))monad \<close>  where 
     \<open> bool_bits_backwards arg1 = (
   (let b__0 = arg1 in
   if (((b__0 = ( 0b1 ::  1 Word.word)))) then return True
   else if (((b__0 = ( 0b0 ::  1 Word.word)))) then return False
   else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))\<close> 
  for  arg1  :: "(1)Word.word "


fun bool_bits_forwards_matches  :: \<open> bool \<Rightarrow> bool \<close>  where 
     \<open> bool_bits_forwards_matches True = ( True )\<close>
|\<open> bool_bits_forwards_matches False = ( True )\<close>


definition bool_bits_backwards_matches  :: \<open>(1)Word.word \<Rightarrow> bool \<close>  where 
     \<open> bool_bits_backwards_matches arg1 = (
   (let b__0 = arg1 in
   if (((b__0 = ( 0b1 ::  1 Word.word)))) then True
   else if (((b__0 = ( 0b0 ::  1 Word.word)))) then True
   else False))\<close> 
  for  arg1  :: "(1)Word.word "


\<comment> \<open>\<open>val bool_not_bits_forwards : bool -> mword ty1\<close>\<close>

\<comment> \<open>\<open>val bool_not_bits_backwards : mword ty1 -> M bool\<close>\<close>

\<comment> \<open>\<open>val bool_not_bits_forwards_matches : bool -> bool\<close>\<close>

\<comment> \<open>\<open>val bool_not_bits_backwards_matches : mword ty1 -> bool\<close>\<close>

fun bool_not_bits_forwards  :: \<open> bool \<Rightarrow>(1)Word.word \<close>  where 
     \<open> bool_not_bits_forwards True = ( ( 0b0 ::  1 Word.word))\<close>
|\<open> bool_not_bits_forwards False = ( ( 0b1 ::  1 Word.word))\<close>


definition bool_not_bits_backwards  :: \<open>(1)Word.word \<Rightarrow>((register_value),(bool),(exception))monad \<close>  where 
     \<open> bool_not_bits_backwards arg1 = (
   (let b__0 = arg1 in
   if (((b__0 = ( 0b0 ::  1 Word.word)))) then return True
   else if (((b__0 = ( 0b1 ::  1 Word.word)))) then return False
   else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))\<close> 
  for  arg1  :: "(1)Word.word "


fun bool_not_bits_forwards_matches  :: \<open> bool \<Rightarrow> bool \<close>  where 
     \<open> bool_not_bits_forwards_matches True = ( True )\<close>
|\<open> bool_not_bits_forwards_matches False = ( True )\<close>


definition bool_not_bits_backwards_matches  :: \<open>(1)Word.word \<Rightarrow> bool \<close>  where 
     \<open> bool_not_bits_backwards_matches arg1 = (
   (let b__0 = arg1 in
   if (((b__0 = ( 0b0 ::  1 Word.word)))) then True
   else if (((b__0 = ( 0b1 ::  1 Word.word)))) then True
   else False))\<close> 
  for  arg1  :: "(1)Word.word "


\<comment> \<open>\<open>val size_bits_forwards : word_width -> mword ty2\<close>\<close>

\<comment> \<open>\<open>val size_bits_backwards : mword ty2 -> M word_width\<close>\<close>

\<comment> \<open>\<open>val size_bits_forwards_matches : word_width -> bool\<close>\<close>

\<comment> \<open>\<open>val size_bits_backwards_matches : mword ty2 -> bool\<close>\<close>

fun size_bits_forwards  :: \<open> word_width \<Rightarrow>(2)Word.word \<close>  where 
     \<open> size_bits_forwards BYTE = ( ( 0b00 ::  2 Word.word))\<close>
|\<open> size_bits_forwards HALF = ( ( 0b01 ::  2 Word.word))\<close>
|\<open> size_bits_forwards WORD = ( ( 0b10 ::  2 Word.word))\<close>
|\<open> size_bits_forwards DOUBLE = ( ( 0b11 ::  2 Word.word))\<close>


definition size_bits_backwards  :: \<open>(2)Word.word \<Rightarrow>((register_value),(word_width),(exception))monad \<close>  where 
     \<open> size_bits_backwards arg1 = (
   (let b__0 = arg1 in
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then return BYTE
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then return HALF
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then return WORD
   else if (((b__0 = ( 0b11 ::  2 Word.word)))) then return DOUBLE
   else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))\<close> 
  for  arg1  :: "(2)Word.word "


fun size_bits_forwards_matches  :: \<open> word_width \<Rightarrow> bool \<close>  where 
     \<open> size_bits_forwards_matches BYTE = ( True )\<close>
|\<open> size_bits_forwards_matches HALF = ( True )\<close>
|\<open> size_bits_forwards_matches WORD = ( True )\<close>
|\<open> size_bits_forwards_matches DOUBLE = ( True )\<close>


definition size_bits_backwards_matches  :: \<open>(2)Word.word \<Rightarrow> bool \<close>  where 
     \<open> size_bits_backwards_matches arg1 = (
   (let b__0 = arg1 in
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then True
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then True
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then True
   else if (((b__0 = ( 0b11 ::  2 Word.word)))) then True
   else False))\<close> 
  for  arg1  :: "(2)Word.word "


\<comment> \<open>\<open>val size_mnemonic_forwards : word_width -> string\<close>\<close>

\<comment> \<open>\<open>val size_mnemonic_backwards : string -> M word_width\<close>\<close>

\<comment> \<open>\<open>val size_mnemonic_forwards_matches : word_width -> bool\<close>\<close>

\<comment> \<open>\<open>val size_mnemonic_backwards_matches : string -> bool\<close>\<close>

\<comment> \<open>\<open>val size_mnemonic_matches_prefix : string -> maybe ((word_width * ii))\<close>\<close>

fun size_mnemonic_forwards  :: \<open> word_width \<Rightarrow> string \<close>  where 
     \<open> size_mnemonic_forwards BYTE = ( (''b''))\<close>
|\<open> size_mnemonic_forwards HALF = ( (''h''))\<close>
|\<open> size_mnemonic_forwards WORD = ( (''w''))\<close>
|\<open> size_mnemonic_forwards DOUBLE = ( (''d''))\<close>


definition size_mnemonic_backwards  :: \<open> string \<Rightarrow>((register_value),(word_width),(exception))monad \<close>  where 
     \<open> size_mnemonic_backwards arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''b'')))) then return BYTE
   else if (((p00 = (''h'')))) then return HALF
   else if (((p00 = (''w'')))) then return WORD
   else if (((p00 = (''d'')))) then return DOUBLE
   else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))\<close> 
  for  arg1  :: " string "


fun size_mnemonic_forwards_matches  :: \<open> word_width \<Rightarrow> bool \<close>  where 
     \<open> size_mnemonic_forwards_matches BYTE = ( True )\<close>
|\<open> size_mnemonic_forwards_matches HALF = ( True )\<close>
|\<open> size_mnemonic_forwards_matches WORD = ( True )\<close>
|\<open> size_mnemonic_forwards_matches DOUBLE = ( True )\<close>


definition size_mnemonic_backwards_matches  :: \<open> string \<Rightarrow> bool \<close>  where 
     \<open> size_mnemonic_backwards_matches arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''b'')))) then True
   else if (((p00 = (''h'')))) then True
   else if (((p00 = (''w'')))) then True
   else if (((p00 = (''d'')))) then True
   else False))\<close> 
  for  arg1  :: " string "


\<comment> \<open>\<open>val _s36_ : string -> maybe string\<close>\<close>

definition s36  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s36 s370 = (
   (let s381 = s370 in
   if ((string_startswith s381 (''d''))) then  
  (case  ((string_drop s381 ((string_length (''d''))))) of   s1 => Some s1 )
   else None))\<close> 
  for  s370  :: " string "


\<comment> \<open>\<open>val _s32_ : string -> maybe string\<close>\<close>

definition s32  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s32 s330 = (
   (let s341 = s330 in
   if ((string_startswith s341 (''w''))) then  
  (case  ((string_drop s341 ((string_length (''w''))))) of   s1 => Some s1 )
   else None))\<close> 
  for  s330  :: " string "


\<comment> \<open>\<open>val _s28_ : string -> maybe string\<close>\<close>

definition s28  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s28 s290 = (
   (let s301 = s290 in
   if ((string_startswith s301 (''h''))) then  
  (case  ((string_drop s301 ((string_length (''h''))))) of   s1 => Some s1 )
   else None))\<close> 
  for  s290  :: " string "


\<comment> \<open>\<open>val _s24_ : string -> maybe string\<close>\<close>

definition s24  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s24 s250 = (
   (let s261 = s250 in
   if ((string_startswith s261 (''b''))) then  
  (case  ((string_drop s261 ((string_length (''b''))))) of   s1 => Some s1 )
   else None))\<close> 
  for  s250  :: " string "


definition size_mnemonic_matches_prefix  :: \<open> string \<Rightarrow>(word_width*int)option \<close>  where 
     \<open> size_mnemonic_matches_prefix arg1 = (
   (let s270 = arg1 in
   if ((case  ((s24 s270)) of   Some (s1) => True | _ => False )) then  
  (case  s24 s270 of
      (Some (s1)) =>
  Some (BYTE, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s28 s270)) of   Some (s1) => True | _ => False )) then  
  (case  s28 s270 of
      (Some (s1)) =>
  Some (HALF, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s32 s270)) of   Some (s1) => True | _ => False )) then  
  (case  s32 s270 of
      (Some (s1)) =>
  Some (WORD, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s36 s270)) of   Some (s1) => True | _ => False )) then  
  (case  s36 s270 of
      (Some (s1)) =>
  Some (DOUBLE, ((string_length arg1)) - ((string_length s1)))
  )
   else None))\<close> 
  for  arg1  :: " string "


\<comment> \<open>\<open>val word_width_bytes : word_width -> integer\<close>\<close>

fun word_width_bytes  :: \<open> word_width \<Rightarrow> int \<close>  where 
     \<open> word_width_bytes BYTE = ( (( 1 :: int)::ii))\<close>
|\<open> word_width_bytes HALF = ( (( 2 :: int)::ii))\<close>
|\<open> word_width_bytes WORD = ( (( 4 :: int)::ii))\<close>
|\<open> word_width_bytes DOUBLE = ( (( 8 :: int)::ii))\<close>


definition Data  :: \<open> unit \<close>  where 
     \<open> Data = ( ()  )\<close>


definition default_write_acc  :: \<open> unit \<close>  where 
     \<open> default_write_acc = ( ()  )\<close>


fun accessType_to_str  :: \<open>(unit)AccessType \<Rightarrow> string \<close>  where 
     \<open> accessType_to_str (Read (_)) = ( (''R''))\<close>
|\<open> accessType_to_str (Write (_)) = ( (''W''))\<close>
|\<open> accessType_to_str (ReadWrite ((_, _))) = ( (''RW''))\<close>
|\<open> accessType_to_str (Execute (_)) = ( (''X''))\<close>


definition zero_reg  :: \<open>(64)Word.word \<close>  where 
     \<open> zero_reg = ( ( 0x0000000000000000 ::  64 Word.word))\<close>


\<comment> \<open>\<open>val RegStr : mword ty64 -> string\<close>\<close>

definition RegStr  :: \<open>(64)Word.word \<Rightarrow> string \<close>  where 
     \<open> RegStr r = ( string_of_bits r )\<close> 
  for  r  :: "(64)Word.word "


\<comment> \<open>\<open>val regval_from_reg : mword ty64 -> mword ty64\<close>\<close>

definition regval_from_reg  :: \<open>(64)Word.word \<Rightarrow>(64)Word.word \<close>  where 
     \<open> regval_from_reg r = ( r )\<close> 
  for  r  :: "(64)Word.word "


\<comment> \<open>\<open>val regval_into_reg : mword ty64 -> mword ty64\<close>\<close>

definition regval_into_reg  :: \<open>(64)Word.word \<Rightarrow>(64)Word.word \<close>  where 
     \<open> regval_into_reg v = ( v )\<close> 
  for  v  :: "(64)Word.word "


definition zero_freg  :: \<open>(64)Word.word \<close>  where 
     \<open> zero_freg = ( ( 0x0000000000000000 ::  64 Word.word))\<close>


\<comment> \<open>\<open>val FRegStr : mword ty64 -> string\<close>\<close>

definition FRegStr  :: \<open>(64)Word.word \<Rightarrow> string \<close>  where 
     \<open> FRegStr r = ( string_of_bits r )\<close> 
  for  r  :: "(64)Word.word "


\<comment> \<open>\<open>val fregval_from_freg : mword ty64 -> mword ty64\<close>\<close>

definition fregval_from_freg  :: \<open>(64)Word.word \<Rightarrow>(64)Word.word \<close>  where 
     \<open> fregval_from_freg r = ( r )\<close> 
  for  r  :: "(64)Word.word "


\<comment> \<open>\<open>val fregval_into_freg : mword ty64 -> mword ty64\<close>\<close>

definition fregval_into_freg  :: \<open>(64)Word.word \<Rightarrow>(64)Word.word \<close>  where 
     \<open> fregval_into_freg v = ( v )\<close> 
  for  v  :: "(64)Word.word "


\<comment> \<open>\<open>val rounding_mode_of_num : integer -> rounding_mode\<close>\<close>

definition rounding_mode_of_num  :: \<open> int \<Rightarrow> rounding_mode \<close>  where 
     \<open> rounding_mode_of_num arg1 = (
   (let l__197 = arg1 in
   if (((l__197 = (( 0 :: int)::ii)))) then RM_RNE
   else if (((l__197 = (( 1 :: int)::ii)))) then RM_RTZ
   else if (((l__197 = (( 2 :: int)::ii)))) then RM_RDN
   else if (((l__197 = (( 3 :: int)::ii)))) then RM_RUP
   else if (((l__197 = (( 4 :: int)::ii)))) then RM_RMM
   else RM_DYN))\<close> 
  for  arg1  :: " int "


\<comment> \<open>\<open>val num_of_rounding_mode : rounding_mode -> integer\<close>\<close>

fun num_of_rounding_mode  :: \<open> rounding_mode \<Rightarrow> int \<close>  where 
     \<open> num_of_rounding_mode RM_RNE = ( (( 0 :: int)::ii))\<close>
|\<open> num_of_rounding_mode RM_RTZ = ( (( 1 :: int)::ii))\<close>
|\<open> num_of_rounding_mode RM_RDN = ( (( 2 :: int)::ii))\<close>
|\<open> num_of_rounding_mode RM_RUP = ( (( 3 :: int)::ii))\<close>
|\<open> num_of_rounding_mode RM_RMM = ( (( 4 :: int)::ii))\<close>
|\<open> num_of_rounding_mode RM_DYN = ( (( 5 :: int)::ii))\<close>


\<comment> \<open>\<open>val f_madd_op_S_of_num : integer -> f_madd_op_S\<close>\<close>

definition f_madd_op_S_of_num  :: \<open> int \<Rightarrow> f_madd_op_S \<close>  where 
     \<open> f_madd_op_S_of_num arg1 = (
   (let l__194 = arg1 in
   if (((l__194 = (( 0 :: int)::ii)))) then FMADD_S
   else if (((l__194 = (( 1 :: int)::ii)))) then FMSUB_S
   else if (((l__194 = (( 2 :: int)::ii)))) then FNMSUB_S
   else FNMADD_S))\<close> 
  for  arg1  :: " int "


\<comment> \<open>\<open>val num_of_f_madd_op_S : f_madd_op_S -> integer\<close>\<close>

fun num_of_f_madd_op_S  :: \<open> f_madd_op_S \<Rightarrow> int \<close>  where 
     \<open> num_of_f_madd_op_S FMADD_S = ( (( 0 :: int)::ii))\<close>
|\<open> num_of_f_madd_op_S FMSUB_S = ( (( 1 :: int)::ii))\<close>
|\<open> num_of_f_madd_op_S FNMSUB_S = ( (( 2 :: int)::ii))\<close>
|\<open> num_of_f_madd_op_S FNMADD_S = ( (( 3 :: int)::ii))\<close>


\<comment> \<open>\<open>val f_bin_rm_op_S_of_num : integer -> f_bin_rm_op_S\<close>\<close>

definition f_bin_rm_op_S_of_num  :: \<open> int \<Rightarrow> f_bin_rm_op_S \<close>  where 
     \<open> f_bin_rm_op_S_of_num arg1 = (
   (let l__191 = arg1 in
   if (((l__191 = (( 0 :: int)::ii)))) then FADD_S
   else if (((l__191 = (( 1 :: int)::ii)))) then FSUB_S
   else if (((l__191 = (( 2 :: int)::ii)))) then FMUL_S
   else FDIV_S))\<close> 
  for  arg1  :: " int "


\<comment> \<open>\<open>val num_of_f_bin_rm_op_S : f_bin_rm_op_S -> integer\<close>\<close>

fun num_of_f_bin_rm_op_S  :: \<open> f_bin_rm_op_S \<Rightarrow> int \<close>  where 
     \<open> num_of_f_bin_rm_op_S FADD_S = ( (( 0 :: int)::ii))\<close>
|\<open> num_of_f_bin_rm_op_S FSUB_S = ( (( 1 :: int)::ii))\<close>
|\<open> num_of_f_bin_rm_op_S FMUL_S = ( (( 2 :: int)::ii))\<close>
|\<open> num_of_f_bin_rm_op_S FDIV_S = ( (( 3 :: int)::ii))\<close>


\<comment> \<open>\<open>val f_un_rm_op_S_of_num : integer -> f_un_rm_op_S\<close>\<close>

definition f_un_rm_op_S_of_num  :: \<open> int \<Rightarrow> f_un_rm_op_S \<close>  where 
     \<open> f_un_rm_op_S_of_num arg1 = (
   (let l__183 = arg1 in
   if (((l__183 = (( 0 :: int)::ii)))) then FSQRT_S
   else if (((l__183 = (( 1 :: int)::ii)))) then FCVT_W_S
   else if (((l__183 = (( 2 :: int)::ii)))) then FCVT_WU_S
   else if (((l__183 = (( 3 :: int)::ii)))) then FCVT_S_W
   else if (((l__183 = (( 4 :: int)::ii)))) then FCVT_S_WU
   else if (((l__183 = (( 5 :: int)::ii)))) then FCVT_L_S
   else if (((l__183 = (( 6 :: int)::ii)))) then FCVT_LU_S
   else if (((l__183 = (( 7 :: int)::ii)))) then FCVT_S_L
   else FCVT_S_LU))\<close> 
  for  arg1  :: " int "


\<comment> \<open>\<open>val num_of_f_un_rm_op_S : f_un_rm_op_S -> integer\<close>\<close>

fun num_of_f_un_rm_op_S  :: \<open> f_un_rm_op_S \<Rightarrow> int \<close>  where 
     \<open> num_of_f_un_rm_op_S FSQRT_S = ( (( 0 :: int)::ii))\<close>
|\<open> num_of_f_un_rm_op_S FCVT_W_S = ( (( 1 :: int)::ii))\<close>
|\<open> num_of_f_un_rm_op_S FCVT_WU_S = ( (( 2 :: int)::ii))\<close>
|\<open> num_of_f_un_rm_op_S FCVT_S_W = ( (( 3 :: int)::ii))\<close>
|\<open> num_of_f_un_rm_op_S FCVT_S_WU = ( (( 4 :: int)::ii))\<close>
|\<open> num_of_f_un_rm_op_S FCVT_L_S = ( (( 5 :: int)::ii))\<close>
|\<open> num_of_f_un_rm_op_S FCVT_LU_S = ( (( 6 :: int)::ii))\<close>
|\<open> num_of_f_un_rm_op_S FCVT_S_L = ( (( 7 :: int)::ii))\<close>
|\<open> num_of_f_un_rm_op_S FCVT_S_LU = ( (( 8 :: int)::ii))\<close>


\<comment> \<open>\<open>val f_un_op_S_of_num : integer -> f_un_op_S\<close>\<close>

definition f_un_op_S_of_num  :: \<open> int \<Rightarrow> f_un_op_S \<close>  where 
     \<open> f_un_op_S_of_num arg1 = (
   (let l__181 = arg1 in
   if (((l__181 = (( 0 :: int)::ii)))) then FCLASS_S
   else if (((l__181 = (( 1 :: int)::ii)))) then FMV_X_W
   else FMV_W_X))\<close> 
  for  arg1  :: " int "


\<comment> \<open>\<open>val num_of_f_un_op_S : f_un_op_S -> integer\<close>\<close>

fun num_of_f_un_op_S  :: \<open> f_un_op_S \<Rightarrow> int \<close>  where 
     \<open> num_of_f_un_op_S FCLASS_S = ( (( 0 :: int)::ii))\<close>
|\<open> num_of_f_un_op_S FMV_X_W = ( (( 1 :: int)::ii))\<close>
|\<open> num_of_f_un_op_S FMV_W_X = ( (( 2 :: int)::ii))\<close>


\<comment> \<open>\<open>val f_bin_op_S_of_num : integer -> f_bin_op_S\<close>\<close>

definition f_bin_op_S_of_num  :: \<open> int \<Rightarrow> f_bin_op_S \<close>  where 
     \<open> f_bin_op_S_of_num arg1 = (
   (let l__174 = arg1 in
   if (((l__174 = (( 0 :: int)::ii)))) then FSGNJ_S
   else if (((l__174 = (( 1 :: int)::ii)))) then FSGNJN_S
   else if (((l__174 = (( 2 :: int)::ii)))) then FSGNJX_S
   else if (((l__174 = (( 3 :: int)::ii)))) then FMIN_S
   else if (((l__174 = (( 4 :: int)::ii)))) then FMAX_S
   else if (((l__174 = (( 5 :: int)::ii)))) then FEQ_S
   else if (((l__174 = (( 6 :: int)::ii)))) then FLT_S
   else FLE_S))\<close> 
  for  arg1  :: " int "


\<comment> \<open>\<open>val num_of_f_bin_op_S : f_bin_op_S -> integer\<close>\<close>

fun num_of_f_bin_op_S  :: \<open> f_bin_op_S \<Rightarrow> int \<close>  where 
     \<open> num_of_f_bin_op_S FSGNJ_S = ( (( 0 :: int)::ii))\<close>
|\<open> num_of_f_bin_op_S FSGNJN_S = ( (( 1 :: int)::ii))\<close>
|\<open> num_of_f_bin_op_S FSGNJX_S = ( (( 2 :: int)::ii))\<close>
|\<open> num_of_f_bin_op_S FMIN_S = ( (( 3 :: int)::ii))\<close>
|\<open> num_of_f_bin_op_S FMAX_S = ( (( 4 :: int)::ii))\<close>
|\<open> num_of_f_bin_op_S FEQ_S = ( (( 5 :: int)::ii))\<close>
|\<open> num_of_f_bin_op_S FLT_S = ( (( 6 :: int)::ii))\<close>
|\<open> num_of_f_bin_op_S FLE_S = ( (( 7 :: int)::ii))\<close>


\<comment> \<open>\<open>val f_madd_op_D_of_num : integer -> f_madd_op_D\<close>\<close>

definition f_madd_op_D_of_num  :: \<open> int \<Rightarrow> f_madd_op_D \<close>  where 
     \<open> f_madd_op_D_of_num arg1 = (
   (let l__171 = arg1 in
   if (((l__171 = (( 0 :: int)::ii)))) then FMADD_D
   else if (((l__171 = (( 1 :: int)::ii)))) then FMSUB_D
   else if (((l__171 = (( 2 :: int)::ii)))) then FNMSUB_D
   else FNMADD_D))\<close> 
  for  arg1  :: " int "


\<comment> \<open>\<open>val num_of_f_madd_op_D : f_madd_op_D -> integer\<close>\<close>

fun num_of_f_madd_op_D  :: \<open> f_madd_op_D \<Rightarrow> int \<close>  where 
     \<open> num_of_f_madd_op_D FMADD_D = ( (( 0 :: int)::ii))\<close>
|\<open> num_of_f_madd_op_D FMSUB_D = ( (( 1 :: int)::ii))\<close>
|\<open> num_of_f_madd_op_D FNMSUB_D = ( (( 2 :: int)::ii))\<close>
|\<open> num_of_f_madd_op_D FNMADD_D = ( (( 3 :: int)::ii))\<close>


\<comment> \<open>\<open>val f_bin_rm_op_D_of_num : integer -> f_bin_rm_op_D\<close>\<close>

definition f_bin_rm_op_D_of_num  :: \<open> int \<Rightarrow> f_bin_rm_op_D \<close>  where 
     \<open> f_bin_rm_op_D_of_num arg1 = (
   (let l__168 = arg1 in
   if (((l__168 = (( 0 :: int)::ii)))) then FADD_D
   else if (((l__168 = (( 1 :: int)::ii)))) then FSUB_D
   else if (((l__168 = (( 2 :: int)::ii)))) then FMUL_D
   else FDIV_D))\<close> 
  for  arg1  :: " int "


\<comment> \<open>\<open>val num_of_f_bin_rm_op_D : f_bin_rm_op_D -> integer\<close>\<close>

fun num_of_f_bin_rm_op_D  :: \<open> f_bin_rm_op_D \<Rightarrow> int \<close>  where 
     \<open> num_of_f_bin_rm_op_D FADD_D = ( (( 0 :: int)::ii))\<close>
|\<open> num_of_f_bin_rm_op_D FSUB_D = ( (( 1 :: int)::ii))\<close>
|\<open> num_of_f_bin_rm_op_D FMUL_D = ( (( 2 :: int)::ii))\<close>
|\<open> num_of_f_bin_rm_op_D FDIV_D = ( (( 3 :: int)::ii))\<close>


\<comment> \<open>\<open>val f_un_rm_op_D_of_num : integer -> f_un_rm_op_D\<close>\<close>

definition f_un_rm_op_D_of_num  :: \<open> int \<Rightarrow> f_un_rm_op_D \<close>  where 
     \<open> f_un_rm_op_D_of_num arg1 = (
   (let l__158 = arg1 in
   if (((l__158 = (( 0 :: int)::ii)))) then FSQRT_D
   else if (((l__158 = (( 1 :: int)::ii)))) then FCVT_W_D
   else if (((l__158 = (( 2 :: int)::ii)))) then FCVT_WU_D
   else if (((l__158 = (( 3 :: int)::ii)))) then FCVT_D_W
   else if (((l__158 = (( 4 :: int)::ii)))) then FCVT_D_WU
   else if (((l__158 = (( 5 :: int)::ii)))) then FCVT_S_D
   else if (((l__158 = (( 6 :: int)::ii)))) then FCVT_D_S
   else if (((l__158 = (( 7 :: int)::ii)))) then FCVT_L_D
   else if (((l__158 = (( 8 :: int)::ii)))) then FCVT_LU_D
   else if (((l__158 = (( 9 :: int)::ii)))) then FCVT_D_L
   else FCVT_D_LU))\<close> 
  for  arg1  :: " int "


\<comment> \<open>\<open>val num_of_f_un_rm_op_D : f_un_rm_op_D -> integer\<close>\<close>

fun num_of_f_un_rm_op_D  :: \<open> f_un_rm_op_D \<Rightarrow> int \<close>  where 
     \<open> num_of_f_un_rm_op_D FSQRT_D = ( (( 0 :: int)::ii))\<close>
|\<open> num_of_f_un_rm_op_D FCVT_W_D = ( (( 1 :: int)::ii))\<close>
|\<open> num_of_f_un_rm_op_D FCVT_WU_D = ( (( 2 :: int)::ii))\<close>
|\<open> num_of_f_un_rm_op_D FCVT_D_W = ( (( 3 :: int)::ii))\<close>
|\<open> num_of_f_un_rm_op_D FCVT_D_WU = ( (( 4 :: int)::ii))\<close>
|\<open> num_of_f_un_rm_op_D FCVT_S_D = ( (( 5 :: int)::ii))\<close>
|\<open> num_of_f_un_rm_op_D FCVT_D_S = ( (( 6 :: int)::ii))\<close>
|\<open> num_of_f_un_rm_op_D FCVT_L_D = ( (( 7 :: int)::ii))\<close>
|\<open> num_of_f_un_rm_op_D FCVT_LU_D = ( (( 8 :: int)::ii))\<close>
|\<open> num_of_f_un_rm_op_D FCVT_D_L = ( (( 9 :: int)::ii))\<close>
|\<open> num_of_f_un_rm_op_D FCVT_D_LU = ( (( 10 :: int)::ii))\<close>


\<comment> \<open>\<open>val f_bin_op_D_of_num : integer -> f_bin_op_D\<close>\<close>

definition f_bin_op_D_of_num  :: \<open> int \<Rightarrow> f_bin_op_D \<close>  where 
     \<open> f_bin_op_D_of_num arg1 = (
   (let l__151 = arg1 in
   if (((l__151 = (( 0 :: int)::ii)))) then FSGNJ_D
   else if (((l__151 = (( 1 :: int)::ii)))) then FSGNJN_D
   else if (((l__151 = (( 2 :: int)::ii)))) then FSGNJX_D
   else if (((l__151 = (( 3 :: int)::ii)))) then FMIN_D
   else if (((l__151 = (( 4 :: int)::ii)))) then FMAX_D
   else if (((l__151 = (( 5 :: int)::ii)))) then FEQ_D
   else if (((l__151 = (( 6 :: int)::ii)))) then FLT_D
   else FLE_D))\<close> 
  for  arg1  :: " int "


\<comment> \<open>\<open>val num_of_f_bin_op_D : f_bin_op_D -> integer\<close>\<close>

fun num_of_f_bin_op_D  :: \<open> f_bin_op_D \<Rightarrow> int \<close>  where 
     \<open> num_of_f_bin_op_D FSGNJ_D = ( (( 0 :: int)::ii))\<close>
|\<open> num_of_f_bin_op_D FSGNJN_D = ( (( 1 :: int)::ii))\<close>
|\<open> num_of_f_bin_op_D FSGNJX_D = ( (( 2 :: int)::ii))\<close>
|\<open> num_of_f_bin_op_D FMIN_D = ( (( 3 :: int)::ii))\<close>
|\<open> num_of_f_bin_op_D FMAX_D = ( (( 4 :: int)::ii))\<close>
|\<open> num_of_f_bin_op_D FEQ_D = ( (( 5 :: int)::ii))\<close>
|\<open> num_of_f_bin_op_D FLT_D = ( (( 6 :: int)::ii))\<close>
|\<open> num_of_f_bin_op_D FLE_D = ( (( 7 :: int)::ii))\<close>


\<comment> \<open>\<open>val f_un_op_D_of_num : integer -> f_un_op_D\<close>\<close>

definition f_un_op_D_of_num  :: \<open> int \<Rightarrow> f_un_op_D \<close>  where 
     \<open> f_un_op_D_of_num arg1 = (
   (let l__149 = arg1 in
   if (((l__149 = (( 0 :: int)::ii)))) then FCLASS_D
   else if (((l__149 = (( 1 :: int)::ii)))) then FMV_X_D
   else FMV_D_X))\<close> 
  for  arg1  :: " int "


\<comment> \<open>\<open>val num_of_f_un_op_D : f_un_op_D -> integer\<close>\<close>

fun num_of_f_un_op_D  :: \<open> f_un_op_D \<Rightarrow> int \<close>  where 
     \<open> num_of_f_un_op_D FCLASS_D = ( (( 0 :: int)::ii))\<close>
|\<open> num_of_f_un_op_D FMV_X_D = ( (( 1 :: int)::ii))\<close>
|\<open> num_of_f_un_op_D FMV_D_X = ( (( 2 :: int)::ii))\<close>


\<comment> \<open>\<open>val rX : integer -> M (mword ty64)\<close>\<close>

definition rX  :: \<open> int \<Rightarrow>((register_value),((64)Word.word),(exception))monad \<close>  where 
     \<open> rX r = (
   (let l__117 = r in
   (if (((l__117 = (( 0 :: int)::ii)))) then return zero_reg
    else if (((l__117 = (( 1 :: int)::ii)))) then (read_reg x1_ref  :: ( 64 Word.word) M)
    else if (((l__117 = (( 2 :: int)::ii)))) then (read_reg x2_ref  :: ( 64 Word.word) M)
    else if (((l__117 = (( 3 :: int)::ii)))) then (read_reg x3_ref  :: ( 64 Word.word) M)
    else if (((l__117 = (( 4 :: int)::ii)))) then (read_reg x4_ref  :: ( 64 Word.word) M)
    else if (((l__117 = (( 5 :: int)::ii)))) then (read_reg x5_ref  :: ( 64 Word.word) M)
    else if (((l__117 = (( 6 :: int)::ii)))) then (read_reg x6_ref  :: ( 64 Word.word) M)
    else if (((l__117 = (( 7 :: int)::ii)))) then (read_reg x7_ref  :: ( 64 Word.word) M)
    else if (((l__117 = (( 8 :: int)::ii)))) then (read_reg x8_ref  :: ( 64 Word.word) M)
    else if (((l__117 = (( 9 :: int)::ii)))) then (read_reg x9_ref  :: ( 64 Word.word) M)
    else if (((l__117 = (( 10 :: int)::ii)))) then (read_reg x10_ref  :: ( 64 Word.word) M)
    else if (((l__117 = (( 11 :: int)::ii)))) then (read_reg x11_ref  :: ( 64 Word.word) M)
    else if (((l__117 = (( 12 :: int)::ii)))) then (read_reg x12_ref  :: ( 64 Word.word) M)
    else if (((l__117 = (( 13 :: int)::ii)))) then (read_reg x13_ref  :: ( 64 Word.word) M)
    else if (((l__117 = (( 14 :: int)::ii)))) then (read_reg x14_ref  :: ( 64 Word.word) M)
    else if (((l__117 = (( 15 :: int)::ii)))) then (read_reg x15_ref  :: ( 64 Word.word) M)
    else if (((l__117 = (( 16 :: int)::ii)))) then (read_reg x16_ref  :: ( 64 Word.word) M)
    else if (((l__117 = (( 17 :: int)::ii)))) then (read_reg x17_ref  :: ( 64 Word.word) M)
    else if (((l__117 = (( 18 :: int)::ii)))) then (read_reg x18_ref  :: ( 64 Word.word) M)
    else if (((l__117 = (( 19 :: int)::ii)))) then (read_reg x19_ref  :: ( 64 Word.word) M)
    else if (((l__117 = (( 20 :: int)::ii)))) then (read_reg x20_ref  :: ( 64 Word.word) M)
    else if (((l__117 = (( 21 :: int)::ii)))) then (read_reg x21_ref  :: ( 64 Word.word) M)
    else if (((l__117 = (( 22 :: int)::ii)))) then (read_reg x22_ref  :: ( 64 Word.word) M)
    else if (((l__117 = (( 23 :: int)::ii)))) then (read_reg x23_ref  :: ( 64 Word.word) M)
    else if (((l__117 = (( 24 :: int)::ii)))) then (read_reg x24_ref  :: ( 64 Word.word) M)
    else if (((l__117 = (( 25 :: int)::ii)))) then (read_reg x25_ref  :: ( 64 Word.word) M)
    else if (((l__117 = (( 26 :: int)::ii)))) then (read_reg x26_ref  :: ( 64 Word.word) M)
    else if (((l__117 = (( 27 :: int)::ii)))) then (read_reg x27_ref  :: ( 64 Word.word) M)
    else if (((l__117 = (( 28 :: int)::ii)))) then (read_reg x28_ref  :: ( 64 Word.word) M)
    else if (((l__117 = (( 29 :: int)::ii)))) then (read_reg x29_ref  :: ( 64 Word.word) M)
    else if (((l__117 = (( 30 :: int)::ii)))) then (read_reg x30_ref  :: ( 64 Word.word) M)
    else if (((l__117 = (( 31 :: int)::ii)))) then (read_reg x31_ref  :: ( 64 Word.word) M)
    else assert_exp False (''invalid register number'') \<then> exit0 () ) \<bind> ((\<lambda> (v :: regtype) . 
   return ((regval_from_reg v  ::  64 Word.word))))))\<close> 
  for  r  :: " int "


\<comment> \<open>\<open>val rvfi_wX : integer -> mword ty64 -> unit\<close>\<close>

definition rvfi_wX  :: \<open> int \<Rightarrow>(64)Word.word \<Rightarrow> unit \<close>  where 
     \<open> rvfi_wX r v = ( ()  )\<close> 
  for  r  :: " int " 
  and  v  :: "(64)Word.word "


\<comment> \<open>\<open>val wX : integer -> mword ty64 -> M unit\<close>\<close>

definition wX  :: \<open> int \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> wX r in_v = (
   (let v = ((regval_into_reg in_v  ::  64 Word.word)) in
   (let l__85 = r in
   (if (((l__85 = (( 0 :: int)::ii)))) then return () 
    else if (((l__85 = (( 1 :: int)::ii)))) then write_reg x1_ref v
    else if (((l__85 = (( 2 :: int)::ii)))) then write_reg x2_ref v
    else if (((l__85 = (( 3 :: int)::ii)))) then write_reg x3_ref v
    else if (((l__85 = (( 4 :: int)::ii)))) then write_reg x4_ref v
    else if (((l__85 = (( 5 :: int)::ii)))) then write_reg x5_ref v
    else if (((l__85 = (( 6 :: int)::ii)))) then write_reg x6_ref v
    else if (((l__85 = (( 7 :: int)::ii)))) then write_reg x7_ref v
    else if (((l__85 = (( 8 :: int)::ii)))) then write_reg x8_ref v
    else if (((l__85 = (( 9 :: int)::ii)))) then write_reg x9_ref v
    else if (((l__85 = (( 10 :: int)::ii)))) then write_reg x10_ref v
    else if (((l__85 = (( 11 :: int)::ii)))) then write_reg x11_ref v
    else if (((l__85 = (( 12 :: int)::ii)))) then write_reg x12_ref v
    else if (((l__85 = (( 13 :: int)::ii)))) then write_reg x13_ref v
    else if (((l__85 = (( 14 :: int)::ii)))) then write_reg x14_ref v
    else if (((l__85 = (( 15 :: int)::ii)))) then write_reg x15_ref v
    else if (((l__85 = (( 16 :: int)::ii)))) then write_reg x16_ref v
    else if (((l__85 = (( 17 :: int)::ii)))) then write_reg x17_ref v
    else if (((l__85 = (( 18 :: int)::ii)))) then write_reg x18_ref v
    else if (((l__85 = (( 19 :: int)::ii)))) then write_reg x19_ref v
    else if (((l__85 = (( 20 :: int)::ii)))) then write_reg x20_ref v
    else if (((l__85 = (( 21 :: int)::ii)))) then write_reg x21_ref v
    else if (((l__85 = (( 22 :: int)::ii)))) then write_reg x22_ref v
    else if (((l__85 = (( 23 :: int)::ii)))) then write_reg x23_ref v
    else if (((l__85 = (( 24 :: int)::ii)))) then write_reg x24_ref v
    else if (((l__85 = (( 25 :: int)::ii)))) then write_reg x25_ref v
    else if (((l__85 = (( 26 :: int)::ii)))) then write_reg x26_ref v
    else if (((l__85 = (( 27 :: int)::ii)))) then write_reg x27_ref v
    else if (((l__85 = (( 28 :: int)::ii)))) then write_reg x28_ref v
    else if (((l__85 = (( 29 :: int)::ii)))) then write_reg x29_ref v
    else if (((l__85 = (( 30 :: int)::ii)))) then write_reg x30_ref v
    else if (((l__85 = (( 31 :: int)::ii)))) then write_reg x31_ref v
    else assert_exp False (''invalid register number'') \<then> exit0 () ) \<then>
   return (if (((r \<noteq> (( 0 :: int)::ii)))) then
             (let (_ :: unit) = (rvfi_wX r in_v) in
             if ((get_config_print_reg () )) then
               print_dbg
                 (((@) (''x'')
                     (((@) ((stringFromInteger r)) (((@) ('' <- '') ((RegStr v))))))))
             else () )
           else () ))))\<close> 
  for  r  :: " int " 
  and  in_v  :: "(64)Word.word "


\<comment> \<open>\<open>val rX_bits : mword ty5 -> M (mword ty64)\<close>\<close>

definition rX_bits  :: \<open>(5)Word.word \<Rightarrow>((register_value),((64)Word.word),(exception))monad \<close>  where 
     \<open> rX_bits i = ( (rX ((Word.uint i))  :: ( 64 Word.word) M))\<close> 
  for  i  :: "(5)Word.word "


\<comment> \<open>\<open>val wX_bits : mword ty5 -> mword ty64 -> M unit\<close>\<close>

definition wX_bits  :: \<open>(5)Word.word \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> wX_bits (i :: 5 bits) (data :: xlenbits) = ( wX ((Word.uint i)) data )\<close> 
  for  i  :: "(5)Word.word " 
  and  data  :: "(64)Word.word "


definition reg_name_abi  :: \<open>(5)Word.word \<Rightarrow>((register_value),(string),(exception))monad \<close>  where 
     \<open> reg_name_abi r = (
   (let b__0 = r in
   if (((b__0 = ( 0b00000 ::  5 Word.word)))) then return (''zero'')
   else if (((b__0 = ( 0b00001 ::  5 Word.word)))) then return (''ra'')
   else if (((b__0 = ( 0b00010 ::  5 Word.word)))) then return (''sp'')
   else if (((b__0 = ( 0b00011 ::  5 Word.word)))) then return (''gp'')
   else if (((b__0 = ( 0b00100 ::  5 Word.word)))) then return (''tp'')
   else if (((b__0 = ( 0b00101 ::  5 Word.word)))) then return (''t0'')
   else if (((b__0 = ( 0b00110 ::  5 Word.word)))) then return (''t1'')
   else if (((b__0 = ( 0b00111 ::  5 Word.word)))) then return (''t2'')
   else if (((b__0 = ( 0b01000 ::  5 Word.word)))) then return (''fp'')
   else if (((b__0 = ( 0b01001 ::  5 Word.word)))) then return (''s1'')
   else if (((b__0 = ( 0b01010 ::  5 Word.word)))) then return (''a0'')
   else if (((b__0 = ( 0b01011 ::  5 Word.word)))) then return (''a1'')
   else if (((b__0 = ( 0b01100 ::  5 Word.word)))) then return (''a2'')
   else if (((b__0 = ( 0b01101 ::  5 Word.word)))) then return (''a3'')
   else if (((b__0 = ( 0b01110 ::  5 Word.word)))) then return (''a4'')
   else if (((b__0 = ( 0b01111 ::  5 Word.word)))) then return (''a5'')
   else if (((b__0 = ( 0b10000 ::  5 Word.word)))) then return (''a6'')
   else if (((b__0 = ( 0b10001 ::  5 Word.word)))) then return (''a7'')
   else if (((b__0 = ( 0b10010 ::  5 Word.word)))) then return (''s2'')
   else if (((b__0 = ( 0b10011 ::  5 Word.word)))) then return (''s3'')
   else if (((b__0 = ( 0b10100 ::  5 Word.word)))) then return (''s4'')
   else if (((b__0 = ( 0b10101 ::  5 Word.word)))) then return (''s5'')
   else if (((b__0 = ( 0b10110 ::  5 Word.word)))) then return (''s6'')
   else if (((b__0 = ( 0b10111 ::  5 Word.word)))) then return (''s7'')
   else if (((b__0 = ( 0b11000 ::  5 Word.word)))) then return (''s8'')
   else if (((b__0 = ( 0b11001 ::  5 Word.word)))) then return (''s9'')
   else if (((b__0 = ( 0b11010 ::  5 Word.word)))) then return (''s10'')
   else if (((b__0 = ( 0b11011 ::  5 Word.word)))) then return (''s11'')
   else if (((b__0 = ( 0b11100 ::  5 Word.word)))) then return (''t3'')
   else if (((b__0 = ( 0b11101 ::  5 Word.word)))) then return (''t4'')
   else if (((b__0 = ( 0b11110 ::  5 Word.word)))) then return (''t5'')
   else if (((b__0 = ( 0b11111 ::  5 Word.word)))) then return (''t6'')
   else assert_exp False (''Pattern match failure at model/riscv_regs.sail 154:2 - 187:3'') \<then> exit0 () ))\<close> 
  for  r  :: "(5)Word.word "


\<comment> \<open>\<open>val reg_name_forwards : mword ty5 -> M string\<close>\<close>

\<comment> \<open>\<open>val reg_name_backwards : string -> M (mword ty5)\<close>\<close>

\<comment> \<open>\<open>val reg_name_forwards_matches : mword ty5 -> bool\<close>\<close>

\<comment> \<open>\<open>val reg_name_backwards_matches : string -> bool\<close>\<close>

\<comment> \<open>\<open>val reg_name_matches_prefix : string -> maybe ((mword ty5 * ii))\<close>\<close>

definition reg_name_forwards  :: \<open>(5)Word.word \<Rightarrow>((register_value),(string),(exception))monad \<close>  where 
     \<open> reg_name_forwards arg1 = (
   (let b__0 = arg1 in
   if (((b__0 = ( 0b00000 ::  5 Word.word)))) then return (''zero'')
   else if (((b__0 = ( 0b00001 ::  5 Word.word)))) then return (''ra'')
   else if (((b__0 = ( 0b00010 ::  5 Word.word)))) then return (''sp'')
   else if (((b__0 = ( 0b00011 ::  5 Word.word)))) then return (''gp'')
   else if (((b__0 = ( 0b00100 ::  5 Word.word)))) then return (''tp'')
   else if (((b__0 = ( 0b00101 ::  5 Word.word)))) then return (''t0'')
   else if (((b__0 = ( 0b00110 ::  5 Word.word)))) then return (''t1'')
   else if (((b__0 = ( 0b00111 ::  5 Word.word)))) then return (''t2'')
   else if (((b__0 = ( 0b01000 ::  5 Word.word)))) then return (''fp'')
   else if (((b__0 = ( 0b01001 ::  5 Word.word)))) then return (''s1'')
   else if (((b__0 = ( 0b01010 ::  5 Word.word)))) then return (''a0'')
   else if (((b__0 = ( 0b01011 ::  5 Word.word)))) then return (''a1'')
   else if (((b__0 = ( 0b01100 ::  5 Word.word)))) then return (''a2'')
   else if (((b__0 = ( 0b01101 ::  5 Word.word)))) then return (''a3'')
   else if (((b__0 = ( 0b01110 ::  5 Word.word)))) then return (''a4'')
   else if (((b__0 = ( 0b01111 ::  5 Word.word)))) then return (''a5'')
   else if (((b__0 = ( 0b10000 ::  5 Word.word)))) then return (''a6'')
   else if (((b__0 = ( 0b10001 ::  5 Word.word)))) then return (''a7'')
   else if (((b__0 = ( 0b10010 ::  5 Word.word)))) then return (''s2'')
   else if (((b__0 = ( 0b10011 ::  5 Word.word)))) then return (''s3'')
   else if (((b__0 = ( 0b10100 ::  5 Word.word)))) then return (''s4'')
   else if (((b__0 = ( 0b10101 ::  5 Word.word)))) then return (''s5'')
   else if (((b__0 = ( 0b10110 ::  5 Word.word)))) then return (''s6'')
   else if (((b__0 = ( 0b10111 ::  5 Word.word)))) then return (''s7'')
   else if (((b__0 = ( 0b11000 ::  5 Word.word)))) then return (''s8'')
   else if (((b__0 = ( 0b11001 ::  5 Word.word)))) then return (''s9'')
   else if (((b__0 = ( 0b11010 ::  5 Word.word)))) then return (''s10'')
   else if (((b__0 = ( 0b11011 ::  5 Word.word)))) then return (''s11'')
   else if (((b__0 = ( 0b11100 ::  5 Word.word)))) then return (''t3'')
   else if (((b__0 = ( 0b11101 ::  5 Word.word)))) then return (''t4'')
   else if (((b__0 = ( 0b11110 ::  5 Word.word)))) then return (''t5'')
   else if (((b__0 = ( 0b11111 ::  5 Word.word)))) then return (''t6'')
   else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))\<close> 
  for  arg1  :: "(5)Word.word "


definition reg_name_backwards  :: \<open> string \<Rightarrow>((register_value),((5)Word.word),(exception))monad \<close>  where 
     \<open> reg_name_backwards arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''zero'')))) then return ( 0b00000 ::  5 Word.word)
   else if (((p00 = (''ra'')))) then return ( 0b00001 ::  5 Word.word)
   else if (((p00 = (''sp'')))) then return ( 0b00010 ::  5 Word.word)
   else if (((p00 = (''gp'')))) then return ( 0b00011 ::  5 Word.word)
   else if (((p00 = (''tp'')))) then return ( 0b00100 ::  5 Word.word)
   else if (((p00 = (''t0'')))) then return ( 0b00101 ::  5 Word.word)
   else if (((p00 = (''t1'')))) then return ( 0b00110 ::  5 Word.word)
   else if (((p00 = (''t2'')))) then return ( 0b00111 ::  5 Word.word)
   else if (((p00 = (''fp'')))) then return ( 0b01000 ::  5 Word.word)
   else if (((p00 = (''s1'')))) then return ( 0b01001 ::  5 Word.word)
   else if (((p00 = (''a0'')))) then return ( 0b01010 ::  5 Word.word)
   else if (((p00 = (''a1'')))) then return ( 0b01011 ::  5 Word.word)
   else if (((p00 = (''a2'')))) then return ( 0b01100 ::  5 Word.word)
   else if (((p00 = (''a3'')))) then return ( 0b01101 ::  5 Word.word)
   else if (((p00 = (''a4'')))) then return ( 0b01110 ::  5 Word.word)
   else if (((p00 = (''a5'')))) then return ( 0b01111 ::  5 Word.word)
   else if (((p00 = (''a6'')))) then return ( 0b10000 ::  5 Word.word)
   else if (((p00 = (''a7'')))) then return ( 0b10001 ::  5 Word.word)
   else if (((p00 = (''s2'')))) then return ( 0b10010 ::  5 Word.word)
   else if (((p00 = (''s3'')))) then return ( 0b10011 ::  5 Word.word)
   else if (((p00 = (''s4'')))) then return ( 0b10100 ::  5 Word.word)
   else if (((p00 = (''s5'')))) then return ( 0b10101 ::  5 Word.word)
   else if (((p00 = (''s6'')))) then return ( 0b10110 ::  5 Word.word)
   else if (((p00 = (''s7'')))) then return ( 0b10111 ::  5 Word.word)
   else if (((p00 = (''s8'')))) then return ( 0b11000 ::  5 Word.word)
   else if (((p00 = (''s9'')))) then return ( 0b11001 ::  5 Word.word)
   else if (((p00 = (''s10'')))) then return ( 0b11010 ::  5 Word.word)
   else if (((p00 = (''s11'')))) then return ( 0b11011 ::  5 Word.word)
   else if (((p00 = (''t3'')))) then return ( 0b11100 ::  5 Word.word)
   else if (((p00 = (''t4'')))) then return ( 0b11101 ::  5 Word.word)
   else if (((p00 = (''t5'')))) then return ( 0b11110 ::  5 Word.word)
   else if (((p00 = (''t6'')))) then return ( 0b11111 ::  5 Word.word)
   else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))\<close> 
  for  arg1  :: " string "


definition reg_name_forwards_matches  :: \<open>(5)Word.word \<Rightarrow> bool \<close>  where 
     \<open> reg_name_forwards_matches arg1 = (
   (let b__0 = arg1 in
   if (((b__0 = ( 0b00000 ::  5 Word.word)))) then True
   else if (((b__0 = ( 0b00001 ::  5 Word.word)))) then True
   else if (((b__0 = ( 0b00010 ::  5 Word.word)))) then True
   else if (((b__0 = ( 0b00011 ::  5 Word.word)))) then True
   else if (((b__0 = ( 0b00100 ::  5 Word.word)))) then True
   else if (((b__0 = ( 0b00101 ::  5 Word.word)))) then True
   else if (((b__0 = ( 0b00110 ::  5 Word.word)))) then True
   else if (((b__0 = ( 0b00111 ::  5 Word.word)))) then True
   else if (((b__0 = ( 0b01000 ::  5 Word.word)))) then True
   else if (((b__0 = ( 0b01001 ::  5 Word.word)))) then True
   else if (((b__0 = ( 0b01010 ::  5 Word.word)))) then True
   else if (((b__0 = ( 0b01011 ::  5 Word.word)))) then True
   else if (((b__0 = ( 0b01100 ::  5 Word.word)))) then True
   else if (((b__0 = ( 0b01101 ::  5 Word.word)))) then True
   else if (((b__0 = ( 0b01110 ::  5 Word.word)))) then True
   else if (((b__0 = ( 0b01111 ::  5 Word.word)))) then True
   else if (((b__0 = ( 0b10000 ::  5 Word.word)))) then True
   else if (((b__0 = ( 0b10001 ::  5 Word.word)))) then True
   else if (((b__0 = ( 0b10010 ::  5 Word.word)))) then True
   else if (((b__0 = ( 0b10011 ::  5 Word.word)))) then True
   else if (((b__0 = ( 0b10100 ::  5 Word.word)))) then True
   else if (((b__0 = ( 0b10101 ::  5 Word.word)))) then True
   else if (((b__0 = ( 0b10110 ::  5 Word.word)))) then True
   else if (((b__0 = ( 0b10111 ::  5 Word.word)))) then True
   else if (((b__0 = ( 0b11000 ::  5 Word.word)))) then True
   else if (((b__0 = ( 0b11001 ::  5 Word.word)))) then True
   else if (((b__0 = ( 0b11010 ::  5 Word.word)))) then True
   else if (((b__0 = ( 0b11011 ::  5 Word.word)))) then True
   else if (((b__0 = ( 0b11100 ::  5 Word.word)))) then True
   else if (((b__0 = ( 0b11101 ::  5 Word.word)))) then True
   else if (((b__0 = ( 0b11110 ::  5 Word.word)))) then True
   else if (((b__0 = ( 0b11111 ::  5 Word.word)))) then True
   else False))\<close> 
  for  arg1  :: "(5)Word.word "


definition reg_name_backwards_matches  :: \<open> string \<Rightarrow> bool \<close>  where 
     \<open> reg_name_backwards_matches arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''zero'')))) then True
   else if (((p00 = (''ra'')))) then True
   else if (((p00 = (''sp'')))) then True
   else if (((p00 = (''gp'')))) then True
   else if (((p00 = (''tp'')))) then True
   else if (((p00 = (''t0'')))) then True
   else if (((p00 = (''t1'')))) then True
   else if (((p00 = (''t2'')))) then True
   else if (((p00 = (''fp'')))) then True
   else if (((p00 = (''s1'')))) then True
   else if (((p00 = (''a0'')))) then True
   else if (((p00 = (''a1'')))) then True
   else if (((p00 = (''a2'')))) then True
   else if (((p00 = (''a3'')))) then True
   else if (((p00 = (''a4'')))) then True
   else if (((p00 = (''a5'')))) then True
   else if (((p00 = (''a6'')))) then True
   else if (((p00 = (''a7'')))) then True
   else if (((p00 = (''s2'')))) then True
   else if (((p00 = (''s3'')))) then True
   else if (((p00 = (''s4'')))) then True
   else if (((p00 = (''s5'')))) then True
   else if (((p00 = (''s6'')))) then True
   else if (((p00 = (''s7'')))) then True
   else if (((p00 = (''s8'')))) then True
   else if (((p00 = (''s9'')))) then True
   else if (((p00 = (''s10'')))) then True
   else if (((p00 = (''s11'')))) then True
   else if (((p00 = (''t3'')))) then True
   else if (((p00 = (''t4'')))) then True
   else if (((p00 = (''t5'')))) then True
   else if (((p00 = (''t6'')))) then True
   else False))\<close> 
  for  arg1  :: " string "


\<comment> \<open>\<open>val _s164_ : string -> maybe string\<close>\<close>

definition s164  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s164 s1650 = (
   (let s1660 = s1650 in
   if ((string_startswith s1660 (''t6''))) then  
  (case  ((string_drop s1660 ((string_length (''t6''))))) of   s1 => Some s1 )
   else None))\<close> 
  for  s1650  :: " string "


\<comment> \<open>\<open>val _s160_ : string -> maybe string\<close>\<close>

definition s160  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s160 s1610 = (
   (let s1620 = s1610 in
   if ((string_startswith s1620 (''t5''))) then  
  (case  ((string_drop s1620 ((string_length (''t5''))))) of   s1 => Some s1 )
   else None))\<close> 
  for  s1610  :: " string "


\<comment> \<open>\<open>val _s156_ : string -> maybe string\<close>\<close>

definition s156  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s156 s1570 = (
   (let s1581 = s1570 in
   if ((string_startswith s1581 (''t4''))) then  
  (case  ((string_drop s1581 ((string_length (''t4''))))) of   s1 => Some s1 )
   else None))\<close> 
  for  s1570  :: " string "


\<comment> \<open>\<open>val _s152_ : string -> maybe string\<close>\<close>

definition s152  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s152 s1530 = (
   (let s1540 = s1530 in
   if ((string_startswith s1540 (''t3''))) then  
  (case  ((string_drop s1540 ((string_length (''t3''))))) of   s1 => Some s1 )
   else None))\<close> 
  for  s1530  :: " string "


\<comment> \<open>\<open>val _s148_ : string -> maybe string\<close>\<close>

definition s148  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s148 s1490 = (
   (let s1500 = s1490 in
   if ((string_startswith s1500 (''s11''))) then  
  (case  ((string_drop s1500 ((string_length (''s11''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s1490  :: " string "


\<comment> \<open>\<open>val _s144_ : string -> maybe string\<close>\<close>

definition s144  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s144 s1450 = (
   (let s1460 = s1450 in
   if ((string_startswith s1460 (''s10''))) then  
  (case  ((string_drop s1460 ((string_length (''s10''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s1450  :: " string "


\<comment> \<open>\<open>val _s140_ : string -> maybe string\<close>\<close>

definition s140  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s140 s1410 = (
   (let s1420 = s1410 in
   if ((string_startswith s1420 (''s9''))) then  
  (case  ((string_drop s1420 ((string_length (''s9''))))) of   s1 => Some s1 )
   else None))\<close> 
  for  s1410  :: " string "


\<comment> \<open>\<open>val _s136_ : string -> maybe string\<close>\<close>

definition s136  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s136 s1370 = (
   (let s1380 = s1370 in
   if ((string_startswith s1380 (''s8''))) then  
  (case  ((string_drop s1380 ((string_length (''s8''))))) of   s1 => Some s1 )
   else None))\<close> 
  for  s1370  :: " string "


\<comment> \<open>\<open>val _s132_ : string -> maybe string\<close>\<close>

definition s132  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s132 s1331 = (
   (let s1340 = s1331 in
   if ((string_startswith s1340 (''s7''))) then  
  (case  ((string_drop s1340 ((string_length (''s7''))))) of   s1 => Some s1 )
   else None))\<close> 
  for  s1331  :: " string "


\<comment> \<open>\<open>val _s128_ : string -> maybe string\<close>\<close>

definition s128  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s128 s1291 = (
   (let s1300 = s1291 in
   if ((string_startswith s1300 (''s6''))) then  
  (case  ((string_drop s1300 ((string_length (''s6''))))) of   s1 => Some s1 )
   else None))\<close> 
  for  s1291  :: " string "


\<comment> \<open>\<open>val _s124_ : string -> maybe string\<close>\<close>

definition s124  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s124 s1251 = (
   (let s1260 = s1251 in
   if ((string_startswith s1260 (''s5''))) then  
  (case  ((string_drop s1260 ((string_length (''s5''))))) of   s1 => Some s1 )
   else None))\<close> 
  for  s1251  :: " string "


\<comment> \<open>\<open>val _s120_ : string -> maybe string\<close>\<close>

definition s120  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s120 s1211 = (
   (let s1220 = s1211 in
   if ((string_startswith s1220 (''s4''))) then  
  (case  ((string_drop s1220 ((string_length (''s4''))))) of   s1 => Some s1 )
   else None))\<close> 
  for  s1211  :: " string "


\<comment> \<open>\<open>val _s116_ : string -> maybe string\<close>\<close>

definition s116  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s116 s1171 = (
   (let s1180 = s1171 in
   if ((string_startswith s1180 (''s3''))) then  
  (case  ((string_drop s1180 ((string_length (''s3''))))) of   s1 => Some s1 )
   else None))\<close> 
  for  s1171  :: " string "


\<comment> \<open>\<open>val _s112_ : string -> maybe string\<close>\<close>

definition s112  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s112 s1131 = (
   (let s1140 = s1131 in
   if ((string_startswith s1140 (''s2''))) then  
  (case  ((string_drop s1140 ((string_length (''s2''))))) of   s1 => Some s1 )
   else None))\<close> 
  for  s1131  :: " string "


\<comment> \<open>\<open>val _s108_ : string -> maybe string\<close>\<close>

definition s108  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s108 s1091 = (
   (let s1100 = s1091 in
   if ((string_startswith s1100 (''a7''))) then  
  (case  ((string_drop s1100 ((string_length (''a7''))))) of   s1 => Some s1 )
   else None))\<close> 
  for  s1091  :: " string "


\<comment> \<open>\<open>val _s104_ : string -> maybe string\<close>\<close>

definition s104  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s104 s1051 = (
   (let s1060 = s1051 in
   if ((string_startswith s1060 (''a6''))) then  
  (case  ((string_drop s1060 ((string_length (''a6''))))) of   s1 => Some s1 )
   else None))\<close> 
  for  s1051  :: " string "


\<comment> \<open>\<open>val _s100_ : string -> maybe string\<close>\<close>

definition s100  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s100 s1011 = (
   (let s1020 = s1011 in
   if ((string_startswith s1020 (''a5''))) then  
  (case  ((string_drop s1020 ((string_length (''a5''))))) of   s1 => Some s1 )
   else None))\<close> 
  for  s1011  :: " string "


\<comment> \<open>\<open>val _s96_ : string -> maybe string\<close>\<close>

definition s96  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s96 s970 = (
   (let s980 = s970 in
   if ((string_startswith s980 (''a4''))) then  
  (case  ((string_drop s980 ((string_length (''a4''))))) of   s1 => Some s1 )
   else None))\<close> 
  for  s970  :: " string "


\<comment> \<open>\<open>val _s92_ : string -> maybe string\<close>\<close>

definition s92  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s92 s930 = (
   (let s940 = s930 in
   if ((string_startswith s940 (''a3''))) then  
  (case  ((string_drop s940 ((string_length (''a3''))))) of   s1 => Some s1 )
   else None))\<close> 
  for  s930  :: " string "


\<comment> \<open>\<open>val _s88_ : string -> maybe string\<close>\<close>

definition s88  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s88 s890 = (
   (let s900 = s890 in
   if ((string_startswith s900 (''a2''))) then  
  (case  ((string_drop s900 ((string_length (''a2''))))) of   s1 => Some s1 )
   else None))\<close> 
  for  s890  :: " string "


\<comment> \<open>\<open>val _s84_ : string -> maybe string\<close>\<close>

definition s84  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s84 s850 = (
   (let s860 = s850 in
   if ((string_startswith s860 (''a1''))) then  
  (case  ((string_drop s860 ((string_length (''a1''))))) of   s1 => Some s1 )
   else None))\<close> 
  for  s850  :: " string "


\<comment> \<open>\<open>val _s80_ : string -> maybe string\<close>\<close>

definition s80  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s80 s810 = (
   (let s820 = s810 in
   if ((string_startswith s820 (''a0''))) then  
  (case  ((string_drop s820 ((string_length (''a0''))))) of   s1 => Some s1 )
   else None))\<close> 
  for  s810  :: " string "


\<comment> \<open>\<open>val _s76_ : string -> maybe string\<close>\<close>

definition s76  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s76 s770 = (
   (let s780 = s770 in
   if ((string_startswith s780 (''s1''))) then  
  (case  ((string_drop s780 ((string_length (''s1''))))) of   s1 => Some s1 )
   else None))\<close> 
  for  s770  :: " string "


\<comment> \<open>\<open>val _s72_ : string -> maybe string\<close>\<close>

definition s72  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s72 s730 = (
   (let s741 = s730 in
   if ((string_startswith s741 (''fp''))) then  
  (case  ((string_drop s741 ((string_length (''fp''))))) of   s1 => Some s1 )
   else None))\<close> 
  for  s730  :: " string "


\<comment> \<open>\<open>val _s68_ : string -> maybe string\<close>\<close>

definition s68  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s68 s690 = (
   (let s701 = s690 in
   if ((string_startswith s701 (''t2''))) then  
  (case  ((string_drop s701 ((string_length (''t2''))))) of   s1 => Some s1 )
   else None))\<close> 
  for  s690  :: " string "


\<comment> \<open>\<open>val _s64_ : string -> maybe string\<close>\<close>

definition s64  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s64 s650 = (
   (let s661 = s650 in
   if ((string_startswith s661 (''t1''))) then  
  (case  ((string_drop s661 ((string_length (''t1''))))) of   s1 => Some s1 )
   else None))\<close> 
  for  s650  :: " string "


\<comment> \<open>\<open>val _s60_ : string -> maybe string\<close>\<close>

definition s60  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s60 s610 = (
   (let s621 = s610 in
   if ((string_startswith s621 (''t0''))) then  
  (case  ((string_drop s621 ((string_length (''t0''))))) of   s1 => Some s1 )
   else None))\<close> 
  for  s610  :: " string "


\<comment> \<open>\<open>val _s56_ : string -> maybe string\<close>\<close>

definition s56  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s56 s570 = (
   (let s581 = s570 in
   if ((string_startswith s581 (''tp''))) then  
  (case  ((string_drop s581 ((string_length (''tp''))))) of   s1 => Some s1 )
   else None))\<close> 
  for  s570  :: " string "


\<comment> \<open>\<open>val _s52_ : string -> maybe string\<close>\<close>

definition s52  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s52 s530 = (
   (let s541 = s530 in
   if ((string_startswith s541 (''gp''))) then  
  (case  ((string_drop s541 ((string_length (''gp''))))) of   s1 => Some s1 )
   else None))\<close> 
  for  s530  :: " string "


\<comment> \<open>\<open>val _s48_ : string -> maybe string\<close>\<close>

definition s48  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s48 s490 = (
   (let s501 = s490 in
   if ((string_startswith s501 (''sp''))) then  
  (case  ((string_drop s501 ((string_length (''sp''))))) of   s1 => Some s1 )
   else None))\<close> 
  for  s490  :: " string "


\<comment> \<open>\<open>val _s44_ : string -> maybe string\<close>\<close>

definition s44  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s44 s450 = (
   (let s461 = s450 in
   if ((string_startswith s461 (''ra''))) then  
  (case  ((string_drop s461 ((string_length (''ra''))))) of   s1 => Some s1 )
   else None))\<close> 
  for  s450  :: " string "


\<comment> \<open>\<open>val _s40_ : string -> maybe string\<close>\<close>

definition s40  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s40 s410 = (
   (let s421 = s410 in
   if ((string_startswith s421 (''zero''))) then  
  (case  ((string_drop s421 ((string_length (''zero''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s410  :: " string "


definition reg_name_matches_prefix  :: \<open> string \<Rightarrow>((5)Word.word*int)option \<close>  where 
     \<open> reg_name_matches_prefix arg1 = (
   (let s430 = arg1 in
   if ((case  ((s40 s430)) of   Some (s1) => True | _ => False )) then  
  (case  s40 s430 of
      (Some (s1)) =>
  Some
    (( 0b00000 :: 5 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s44 s430)) of   Some (s1) => True | _ => False )) then  
  (case  s44 s430 of
      (Some (s1)) =>
  Some
    (( 0b00001 :: 5 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s48 s430)) of   Some (s1) => True | _ => False )) then  
  (case  s48 s430 of
      (Some (s1)) =>
  Some
    (( 0b00010 :: 5 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s52 s430)) of   Some (s1) => True | _ => False )) then  
  (case  s52 s430 of
      (Some (s1)) =>
  Some
    (( 0b00011 :: 5 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s56 s430)) of   Some (s1) => True | _ => False )) then  
  (case  s56 s430 of
      (Some (s1)) =>
  Some
    (( 0b00100 :: 5 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s60 s430)) of   Some (s1) => True | _ => False )) then  
  (case  s60 s430 of
      (Some (s1)) =>
  Some
    (( 0b00101 :: 5 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s64 s430)) of   Some (s1) => True | _ => False )) then  
  (case  s64 s430 of
      (Some (s1)) =>
  Some
    (( 0b00110 :: 5 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s68 s430)) of   Some (s1) => True | _ => False )) then  
  (case  s68 s430 of
      (Some (s1)) =>
  Some
    (( 0b00111 :: 5 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s72 s430)) of   Some (s1) => True | _ => False )) then  
  (case  s72 s430 of
      (Some (s1)) =>
  Some
    (( 0b01000 :: 5 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s76 s430)) of   Some (s1) => True | _ => False )) then  
  (case  s76 s430 of
      (Some (s1)) =>
  Some
    (( 0b01001 :: 5 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s80 s430)) of   Some (s1) => True | _ => False )) then  
  (case  s80 s430 of
      (Some (s1)) =>
  Some
    (( 0b01010 :: 5 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s84 s430)) of   Some (s1) => True | _ => False )) then  
  (case  s84 s430 of
      (Some (s1)) =>
  Some
    (( 0b01011 :: 5 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s88 s430)) of   Some (s1) => True | _ => False )) then  
  (case  s88 s430 of
      (Some (s1)) =>
  Some
    (( 0b01100 :: 5 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s92 s430)) of   Some (s1) => True | _ => False )) then  
  (case  s92 s430 of
      (Some (s1)) =>
  Some
    (( 0b01101 :: 5 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s96 s430)) of   Some (s1) => True | _ => False )) then  
  (case  s96 s430 of
      (Some (s1)) =>
  Some
    (( 0b01110 :: 5 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s100 s430)) of   Some (s1) => True | _ => False )) then  
  (case  s100 s430 of
      (Some (s1)) =>
  Some
    (( 0b01111 :: 5 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s104 s430)) of   Some (s1) => True | _ => False )) then  
  (case  s104 s430 of
      (Some (s1)) =>
  Some
    (( 0b10000 :: 5 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s108 s430)) of   Some (s1) => True | _ => False )) then  
  (case  s108 s430 of
      (Some (s1)) =>
  Some
    (( 0b10001 :: 5 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s112 s430)) of   Some (s1) => True | _ => False )) then  
  (case  s112 s430 of
      (Some (s1)) =>
  Some
    (( 0b10010 :: 5 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s116 s430)) of   Some (s1) => True | _ => False )) then  
  (case  s116 s430 of
      (Some (s1)) =>
  Some
    (( 0b10011 :: 5 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s120 s430)) of   Some (s1) => True | _ => False )) then  
  (case  s120 s430 of
      (Some (s1)) =>
  Some
    (( 0b10100 :: 5 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s124 s430)) of   Some (s1) => True | _ => False )) then  
  (case  s124 s430 of
      (Some (s1)) =>
  Some
    (( 0b10101 :: 5 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s128 s430)) of   Some (s1) => True | _ => False )) then  
  (case  s128 s430 of
      (Some (s1)) =>
  Some
    (( 0b10110 :: 5 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s132 s430)) of   Some (s1) => True | _ => False )) then  
  (case  s132 s430 of
      (Some (s1)) =>
  Some
    (( 0b10111 :: 5 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s136 s430)) of   Some (s1) => True | _ => False )) then  
  (case  s136 s430 of
      (Some (s1)) =>
  Some
    (( 0b11000 :: 5 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s140 s430)) of   Some (s1) => True | _ => False )) then  
  (case  s140 s430 of
      (Some (s1)) =>
  Some
    (( 0b11001 :: 5 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s144 s430)) of   Some (s1) => True | _ => False )) then  
  (case  s144 s430 of
      (Some (s1)) =>
  Some
    (( 0b11010 :: 5 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s148 s430)) of   Some (s1) => True | _ => False )) then  
  (case  s148 s430 of
      (Some (s1)) =>
  Some
    (( 0b11011 :: 5 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s152 s430)) of   Some (s1) => True | _ => False )) then  
  (case  s152 s430 of
      (Some (s1)) =>
  Some
    (( 0b11100 :: 5 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s156 s430)) of   Some (s1) => True | _ => False )) then  
  (case  s156 s430 of
      (Some (s1)) =>
  Some
    (( 0b11101 :: 5 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s160 s430)) of   Some (s1) => True | _ => False )) then  
  (case  s160 s430 of
      (Some (s1)) =>
  Some
    (( 0b11110 :: 5 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s164 s430)) of   Some (s1) => True | _ => False )) then  
  (case  s164 s430 of
      (Some (s1)) =>
  Some
    (( 0b11111 :: 5 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else None))\<close> 
  for  arg1  :: " string "


\<comment> \<open>\<open>val creg_name_forwards : mword ty3 -> M string\<close>\<close>

\<comment> \<open>\<open>val creg_name_backwards : string -> M (mword ty3)\<close>\<close>

\<comment> \<open>\<open>val creg_name_forwards_matches : mword ty3 -> bool\<close>\<close>

\<comment> \<open>\<open>val creg_name_backwards_matches : string -> bool\<close>\<close>

\<comment> \<open>\<open>val creg_name_matches_prefix : string -> maybe ((mword ty3 * ii))\<close>\<close>

definition creg_name_forwards  :: \<open>(3)Word.word \<Rightarrow>((register_value),(string),(exception))monad \<close>  where 
     \<open> creg_name_forwards arg1 = (
   (let b__0 = arg1 in
   if (((b__0 = ( 0b000 ::  3 Word.word)))) then return (''s0'')
   else if (((b__0 = ( 0b001 ::  3 Word.word)))) then return (''s1'')
   else if (((b__0 = ( 0b010 ::  3 Word.word)))) then return (''a0'')
   else if (((b__0 = ( 0b011 ::  3 Word.word)))) then return (''a1'')
   else if (((b__0 = ( 0b100 ::  3 Word.word)))) then return (''a2'')
   else if (((b__0 = ( 0b101 ::  3 Word.word)))) then return (''a3'')
   else if (((b__0 = ( 0b110 ::  3 Word.word)))) then return (''a4'')
   else if (((b__0 = ( 0b111 ::  3 Word.word)))) then return (''a5'')
   else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))\<close> 
  for  arg1  :: "(3)Word.word "


definition creg_name_backwards  :: \<open> string \<Rightarrow>((register_value),((3)Word.word),(exception))monad \<close>  where 
     \<open> creg_name_backwards arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''s0'')))) then return ( 0b000 ::  3 Word.word)
   else if (((p00 = (''s1'')))) then return ( 0b001 ::  3 Word.word)
   else if (((p00 = (''a0'')))) then return ( 0b010 ::  3 Word.word)
   else if (((p00 = (''a1'')))) then return ( 0b011 ::  3 Word.word)
   else if (((p00 = (''a2'')))) then return ( 0b100 ::  3 Word.word)
   else if (((p00 = (''a3'')))) then return ( 0b101 ::  3 Word.word)
   else if (((p00 = (''a4'')))) then return ( 0b110 ::  3 Word.word)
   else if (((p00 = (''a5'')))) then return ( 0b111 ::  3 Word.word)
   else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))\<close> 
  for  arg1  :: " string "


definition creg_name_forwards_matches  :: \<open>(3)Word.word \<Rightarrow> bool \<close>  where 
     \<open> creg_name_forwards_matches arg1 = (
   (let b__0 = arg1 in
   if (((b__0 = ( 0b000 ::  3 Word.word)))) then True
   else if (((b__0 = ( 0b001 ::  3 Word.word)))) then True
   else if (((b__0 = ( 0b010 ::  3 Word.word)))) then True
   else if (((b__0 = ( 0b011 ::  3 Word.word)))) then True
   else if (((b__0 = ( 0b100 ::  3 Word.word)))) then True
   else if (((b__0 = ( 0b101 ::  3 Word.word)))) then True
   else if (((b__0 = ( 0b110 ::  3 Word.word)))) then True
   else if (((b__0 = ( 0b111 ::  3 Word.word)))) then True
   else False))\<close> 
  for  arg1  :: "(3)Word.word "


definition creg_name_backwards_matches  :: \<open> string \<Rightarrow> bool \<close>  where 
     \<open> creg_name_backwards_matches arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''s0'')))) then True
   else if (((p00 = (''s1'')))) then True
   else if (((p00 = (''a0'')))) then True
   else if (((p00 = (''a1'')))) then True
   else if (((p00 = (''a2'')))) then True
   else if (((p00 = (''a3'')))) then True
   else if (((p00 = (''a4'')))) then True
   else if (((p00 = (''a5'')))) then True
   else False))\<close> 
  for  arg1  :: " string "


\<comment> \<open>\<open>val _s196_ : string -> maybe string\<close>\<close>

definition s196  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s196 s1970 = (
   (let s1980 = s1970 in
   if ((string_startswith s1980 (''a5''))) then  
  (case  ((string_drop s1980 ((string_length (''a5''))))) of   s1 => Some s1 )
   else None))\<close> 
  for  s1970  :: " string "


\<comment> \<open>\<open>val _s192_ : string -> maybe string\<close>\<close>

definition s192  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s192 s1930 = (
   (let s1940 = s1930 in
   if ((string_startswith s1940 (''a4''))) then  
  (case  ((string_drop s1940 ((string_length (''a4''))))) of   s1 => Some s1 )
   else None))\<close> 
  for  s1930  :: " string "


\<comment> \<open>\<open>val _s188_ : string -> maybe string\<close>\<close>

definition s188  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s188 s1890 = (
   (let s1900 = s1890 in
   if ((string_startswith s1900 (''a3''))) then  
  (case  ((string_drop s1900 ((string_length (''a3''))))) of   s1 => Some s1 )
   else None))\<close> 
  for  s1890  :: " string "


\<comment> \<open>\<open>val _s184_ : string -> maybe string\<close>\<close>

definition s184  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s184 s1850 = (
   (let s1860 = s1850 in
   if ((string_startswith s1860 (''a2''))) then  
  (case  ((string_drop s1860 ((string_length (''a2''))))) of   s1 => Some s1 )
   else None))\<close> 
  for  s1850  :: " string "


\<comment> \<open>\<open>val _s180_ : string -> maybe string\<close>\<close>

definition s180  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s180 s1811 = (
   (let s1820 = s1811 in
   if ((string_startswith s1820 (''a1''))) then  
  (case  ((string_drop s1820 ((string_length (''a1''))))) of   s1 => Some s1 )
   else None))\<close> 
  for  s1811  :: " string "


\<comment> \<open>\<open>val _s176_ : string -> maybe string\<close>\<close>

definition s176  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s176 s1770 = (
   (let s1780 = s1770 in
   if ((string_startswith s1780 (''a0''))) then  
  (case  ((string_drop s1780 ((string_length (''a0''))))) of   s1 => Some s1 )
   else None))\<close> 
  for  s1770  :: " string "


\<comment> \<open>\<open>val _s172_ : string -> maybe string\<close>\<close>

definition s172  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s172 s1731 = (
   (let s1740 = s1731 in
   if ((string_startswith s1740 (''s1''))) then  
  (case  ((string_drop s1740 ((string_length (''s1''))))) of   s1 => Some s1 )
   else None))\<close> 
  for  s1731  :: " string "


\<comment> \<open>\<open>val _s168_ : string -> maybe string\<close>\<close>

definition s168  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s168 s1690 = (
   (let s1700 = s1690 in
   if ((string_startswith s1700 (''s0''))) then  
  (case  ((string_drop s1700 ((string_length (''s0''))))) of   s1 => Some s1 )
   else None))\<close> 
  for  s1690  :: " string "


definition creg_name_matches_prefix  :: \<open> string \<Rightarrow>((3)Word.word*int)option \<close>  where 
     \<open> creg_name_matches_prefix arg1 = (
   (let s1710 = arg1 in
   if ((case  ((s168 s1710)) of   Some (s1) => True | _ => False )) then  
  (case  s168 s1710 of
      (Some (s1)) =>
  Some
    (( 0b000 :: 3 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s172 s1710)) of   Some (s1) => True | _ => False )) then  
  (case  s172 s1710 of
      (Some (s1)) =>
  Some
    (( 0b001 :: 3 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s176 s1710)) of   Some (s1) => True | _ => False )) then  
  (case  s176 s1710 of
      (Some (s1)) =>
  Some
    (( 0b010 :: 3 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s180 s1710)) of   Some (s1) => True | _ => False )) then  
  (case  s180 s1710 of
      (Some (s1)) =>
  Some
    (( 0b011 :: 3 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s184 s1710)) of   Some (s1) => True | _ => False )) then  
  (case  s184 s1710 of
      (Some (s1)) =>
  Some
    (( 0b100 :: 3 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s188 s1710)) of   Some (s1) => True | _ => False )) then  
  (case  s188 s1710 of
      (Some (s1)) =>
  Some
    (( 0b101 :: 3 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s192 s1710)) of   Some (s1) => True | _ => False )) then  
  (case  s192 s1710 of
      (Some (s1)) =>
  Some
    (( 0b110 :: 3 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s196 s1710)) of   Some (s1) => True | _ => False )) then  
  (case  s196 s1710 of
      (Some (s1)) =>
  Some
    (( 0b111 :: 3 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else None))\<close> 
  for  arg1  :: " string "


\<comment> \<open>\<open>val init_base_regs : unit -> M unit\<close>\<close>

definition init_base_regs  :: \<open> unit \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> init_base_regs _ = (
   (((((((((((((((((((((((((((((write_reg x1_ref zero_reg \<then>
   write_reg x2_ref zero_reg) \<then>
   write_reg x3_ref zero_reg) \<then>
   write_reg x4_ref zero_reg) \<then>
   write_reg x5_ref zero_reg) \<then>
   write_reg x6_ref zero_reg) \<then>
   write_reg x7_ref zero_reg) \<then>
   write_reg x8_ref zero_reg) \<then>
   write_reg x9_ref zero_reg) \<then>
   write_reg x10_ref zero_reg) \<then>
   write_reg x11_ref zero_reg) \<then>
   write_reg x12_ref zero_reg) \<then>
   write_reg x13_ref zero_reg) \<then>
   write_reg x14_ref zero_reg) \<then>
   write_reg x15_ref zero_reg) \<then>
   write_reg x16_ref zero_reg) \<then>
   write_reg x17_ref zero_reg) \<then>
   write_reg x18_ref zero_reg) \<then>
   write_reg x19_ref zero_reg) \<then>
   write_reg x20_ref zero_reg) \<then>
   write_reg x21_ref zero_reg) \<then>
   write_reg x22_ref zero_reg) \<then>
   write_reg x23_ref zero_reg) \<then>
   write_reg x24_ref zero_reg) \<then>
   write_reg x25_ref zero_reg) \<then>
   write_reg x26_ref zero_reg) \<then>
   write_reg x27_ref zero_reg) \<then>
   write_reg x28_ref zero_reg) \<then>
   write_reg x29_ref zero_reg) \<then> write_reg x30_ref zero_reg) \<then> write_reg x31_ref zero_reg )\<close>


\<comment> \<open>\<open>
  Retrieves the architectural PC value. This is not necessarily the value
  found in the PC register as extensions may choose to override this function.
  The value in the PC register is the absolute virtual address of the instruction
  to fetch.
\<close>\<close>
\<comment> \<open>\<open>val get_arch_pc : unit -> M (mword ty64)\<close>\<close>

definition get_arch_pc  :: \<open> unit \<Rightarrow>((register_value),((64)Word.word),(exception))monad \<close>  where 
     \<open> get_arch_pc _ = ( (read_reg PC_ref  :: ( 64 Word.word) M))\<close>


\<comment> \<open>\<open>val get_next_pc : unit -> M (mword ty64)\<close>\<close>

definition get_next_pc  :: \<open> unit \<Rightarrow>((register_value),((64)Word.word),(exception))monad \<close>  where 
     \<open> get_next_pc _ = ( (read_reg nextPC_ref  :: ( 64 Word.word) M))\<close>


\<comment> \<open>\<open>val set_next_pc : mword ty64 -> M unit\<close>\<close>

definition set_next_pc  :: \<open>(64)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_next_pc pc = ( write_reg nextPC_ref pc )\<close> 
  for  pc  :: "(64)Word.word "


\<comment> \<open>\<open>val tick_pc : unit -> M unit\<close>\<close>

definition tick_pc  :: \<open> unit \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> tick_pc _ = (
   (read_reg nextPC_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) .  write_reg PC_ref w__0)))\<close>


\<comment> \<open>\<open>val undefined_Misa : unit -> M Misa\<close>\<close>

definition undefined_Misa  :: \<open> unit \<Rightarrow>((register_value),(Misa),(exception))monad \<close>  where 
     \<open> undefined_Misa _ = (
   ((return (failwith (''undefined value of unsupported type''))) :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::
      64 Word.word) . 
   return ((| Misa_bits = w__0 |)))))\<close>


\<comment> \<open>\<open>val Mk_Misa : mword ty64 -> Misa\<close>\<close>

definition Mk_Misa  :: \<open>(64)Word.word \<Rightarrow> Misa \<close>  where 
     \<open> Mk_Misa v = ( (| Misa_bits = v |) )\<close> 
  for  v  :: "(64)Word.word "


\<comment> \<open>\<open>val _get_Misa_bits : Misa -> mword ty64\<close>\<close>

definition get_Misa_bits  :: \<open> Misa \<Rightarrow>(64)Word.word \<close>  where 
     \<open> get_Misa_bits v = ( (subrange_vec_dec(Misa_bits   v) (( 63 :: int)::ii) (( 0 :: int)::ii)  ::  64 Word.word))\<close> 
  for  v  :: " Misa "


\<comment> \<open>\<open>val _set_Misa_bits : register_ref regstate register_value Misa -> mword ty64 -> M unit\<close>\<close>

definition set_Misa_bits  :: \<open>((regstate),(register_value),(Misa))register_ref \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Misa_bits r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (| Misa_bits := ((update_subrange_vec_dec(Misa_bits   r) (( 63 :: int)::ii) (( 0 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Misa))register_ref " 
  and  v  :: "(64)Word.word "


\<comment> \<open>\<open>val _update_Misa_bits : Misa -> mword ty64 -> Misa\<close>\<close>

definition update_Misa_bits  :: \<open> Misa \<Rightarrow>(64)Word.word \<Rightarrow> Misa \<close>  where 
     \<open> update_Misa_bits v x = (
   ( v (| Misa_bits := ((update_subrange_vec_dec(Misa_bits   v) (( 63 :: int)::ii) (( 0 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Misa " 
  and  x  :: "(64)Word.word "


\<comment> \<open>\<open>val _update_Counteren_bits : Counteren -> mword ty32 -> Counteren\<close>\<close>

\<comment> \<open>\<open>val _update_Counterin_bits : Counterin -> mword ty32 -> Counterin\<close>\<close>

\<comment> \<open>\<open>val _update_Fcsr_bits : Fcsr -> mword ty32 -> Fcsr\<close>\<close>

\<comment> \<open>\<open>val _update_Mcause_bits : Mcause -> mword ty64 -> Mcause\<close>\<close>

\<comment> \<open>\<open>val _update_Medeleg_bits : Medeleg -> mword ty64 -> Medeleg\<close>\<close>

\<comment> \<open>\<open>val _update_Minterrupts_bits : Minterrupts -> mword ty64 -> Minterrupts\<close>\<close>

\<comment> \<open>\<open>val _update_Mstatus_bits : Mstatus -> mword ty64 -> Mstatus\<close>\<close>

\<comment> \<open>\<open>val _update_Mstatush_bits : Mstatush -> mword ty32 -> Mstatush\<close>\<close>

\<comment> \<open>\<open>val _update_Mtvec_bits : Mtvec -> mword ty64 -> Mtvec\<close>\<close>

\<comment> \<open>\<open>val _update_PTE_Bits_bits : PTE_Bits -> mword ty8 -> PTE_Bits\<close>\<close>

\<comment> \<open>\<open>val _update_Pmpcfg_ent_bits : Pmpcfg_ent -> mword ty8 -> Pmpcfg_ent\<close>\<close>

\<comment> \<open>\<open>val _update_SV32_PTE_bits : SV32_PTE -> mword ty32 -> SV32_PTE\<close>\<close>

\<comment> \<open>\<open>val _update_SV32_Paddr_bits : SV32_Paddr -> mword ty34 -> SV32_Paddr\<close>\<close>

\<comment> \<open>\<open>val _update_SV32_Vaddr_bits : SV32_Vaddr -> mword ty32 -> SV32_Vaddr\<close>\<close>

\<comment> \<open>\<open>val _update_SV39_PTE_bits : SV39_PTE -> mword ty64 -> SV39_PTE\<close>\<close>

\<comment> \<open>\<open>val _update_SV39_Paddr_bits : SV39_Paddr -> mword ty56 -> SV39_Paddr\<close>\<close>

\<comment> \<open>\<open>val _update_SV39_Vaddr_bits : SV39_Vaddr -> mword ty39 -> SV39_Vaddr\<close>\<close>

\<comment> \<open>\<open>val _update_SV48_PTE_bits : SV48_PTE -> mword ty64 -> SV48_PTE\<close>\<close>

\<comment> \<open>\<open>val _update_SV48_Paddr_bits : SV48_Paddr -> mword ty56 -> SV48_Paddr\<close>\<close>

\<comment> \<open>\<open>val _update_SV48_Vaddr_bits : SV48_Vaddr -> mword ty48 -> SV48_Vaddr\<close>\<close>

\<comment> \<open>\<open>val _update_Satp32_bits : Satp32 -> mword ty32 -> Satp32\<close>\<close>

\<comment> \<open>\<open>val _update_Satp64_bits : Satp64 -> mword ty64 -> Satp64\<close>\<close>

\<comment> \<open>\<open>val _update_Sedeleg_bits : Sedeleg -> mword ty64 -> Sedeleg\<close>\<close>

\<comment> \<open>\<open>val _update_Sinterrupts_bits : Sinterrupts -> mword ty64 -> Sinterrupts\<close>\<close>

\<comment> \<open>\<open>val _update_Sstatus_bits : Sstatus -> mword ty64 -> Sstatus\<close>\<close>

\<comment> \<open>\<open>val _update_Uinterrupts_bits : Uinterrupts -> mword ty64 -> Uinterrupts\<close>\<close>

\<comment> \<open>\<open>val _update_Ustatus_bits : Ustatus -> mword ty64 -> Ustatus\<close>\<close>

\<comment> \<open>\<open>val _update_htif_cmd_bits : htif_cmd -> mword ty64 -> htif_cmd\<close>\<close>

\<comment> \<open>\<open>val _get_Counteren_bits : Counteren -> mword ty32\<close>\<close>

\<comment> \<open>\<open>val _get_Counterin_bits : Counterin -> mword ty32\<close>\<close>

\<comment> \<open>\<open>val _get_Fcsr_bits : Fcsr -> mword ty32\<close>\<close>

\<comment> \<open>\<open>val _get_Mcause_bits : Mcause -> mword ty64\<close>\<close>

\<comment> \<open>\<open>val _get_Medeleg_bits : Medeleg -> mword ty64\<close>\<close>

\<comment> \<open>\<open>val _get_Minterrupts_bits : Minterrupts -> mword ty64\<close>\<close>

\<comment> \<open>\<open>val _get_Mstatus_bits : Mstatus -> mword ty64\<close>\<close>

\<comment> \<open>\<open>val _get_Mstatush_bits : Mstatush -> mword ty32\<close>\<close>

\<comment> \<open>\<open>val _get_Mtvec_bits : Mtvec -> mword ty64\<close>\<close>

\<comment> \<open>\<open>val _get_PTE_Bits_bits : PTE_Bits -> mword ty8\<close>\<close>

\<comment> \<open>\<open>val _get_Pmpcfg_ent_bits : Pmpcfg_ent -> mword ty8\<close>\<close>

\<comment> \<open>\<open>val _get_SV32_PTE_bits : SV32_PTE -> mword ty32\<close>\<close>

\<comment> \<open>\<open>val _get_SV32_Paddr_bits : SV32_Paddr -> mword ty34\<close>\<close>

\<comment> \<open>\<open>val _get_SV32_Vaddr_bits : SV32_Vaddr -> mword ty32\<close>\<close>

\<comment> \<open>\<open>val _get_SV39_PTE_bits : SV39_PTE -> mword ty64\<close>\<close>

\<comment> \<open>\<open>val _get_SV39_Paddr_bits : SV39_Paddr -> mword ty56\<close>\<close>

\<comment> \<open>\<open>val _get_SV39_Vaddr_bits : SV39_Vaddr -> mword ty39\<close>\<close>

\<comment> \<open>\<open>val _get_SV48_PTE_bits : SV48_PTE -> mword ty64\<close>\<close>

\<comment> \<open>\<open>val _get_SV48_Paddr_bits : SV48_Paddr -> mword ty56\<close>\<close>

\<comment> \<open>\<open>val _get_SV48_Vaddr_bits : SV48_Vaddr -> mword ty48\<close>\<close>

\<comment> \<open>\<open>val _get_Satp32_bits : Satp32 -> mword ty32\<close>\<close>

\<comment> \<open>\<open>val _get_Satp64_bits : Satp64 -> mword ty64\<close>\<close>

\<comment> \<open>\<open>val _get_Sedeleg_bits : Sedeleg -> mword ty64\<close>\<close>

\<comment> \<open>\<open>val _get_Sinterrupts_bits : Sinterrupts -> mword ty64\<close>\<close>

\<comment> \<open>\<open>val _get_Sstatus_bits : Sstatus -> mword ty64\<close>\<close>

\<comment> \<open>\<open>val _get_Uinterrupts_bits : Uinterrupts -> mword ty64\<close>\<close>

\<comment> \<open>\<open>val _get_Ustatus_bits : Ustatus -> mword ty64\<close>\<close>

\<comment> \<open>\<open>val _get_htif_cmd_bits : htif_cmd -> mword ty64\<close>\<close>

\<comment> \<open>\<open>val _set_Counteren_bits : register_ref regstate register_value Counteren -> mword ty32 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _set_Counterin_bits : register_ref regstate register_value Counterin -> mword ty32 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _set_Fcsr_bits : register_ref regstate register_value Fcsr -> mword ty32 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _set_Mcause_bits : register_ref regstate register_value Mcause -> mword ty64 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _set_Medeleg_bits : register_ref regstate register_value Medeleg -> mword ty64 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _set_Minterrupts_bits : register_ref regstate register_value Minterrupts -> mword ty64 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _set_Mstatus_bits : register_ref regstate register_value Mstatus -> mword ty64 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _set_Mstatush_bits : register_ref regstate register_value Mstatush -> mword ty32 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _set_Mtvec_bits : register_ref regstate register_value Mtvec -> mword ty64 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _set_PTE_Bits_bits : register_ref regstate register_value PTE_Bits -> mword ty8 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _set_Pmpcfg_ent_bits : register_ref regstate register_value Pmpcfg_ent -> mword ty8 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _set_SV32_PTE_bits : register_ref regstate register_value SV32_PTE -> mword ty32 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _set_SV32_Paddr_bits : register_ref regstate register_value SV32_Paddr -> mword ty34 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _set_SV32_Vaddr_bits : register_ref regstate register_value SV32_Vaddr -> mword ty32 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _set_SV39_PTE_bits : register_ref regstate register_value SV39_PTE -> mword ty64 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _set_SV39_Paddr_bits : register_ref regstate register_value SV39_Paddr -> mword ty56 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _set_SV39_Vaddr_bits : register_ref regstate register_value SV39_Vaddr -> mword ty39 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _set_SV48_PTE_bits : register_ref regstate register_value SV48_PTE -> mword ty64 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _set_SV48_Paddr_bits : register_ref regstate register_value SV48_Paddr -> mword ty56 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _set_SV48_Vaddr_bits : register_ref regstate register_value SV48_Vaddr -> mword ty48 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _set_Satp32_bits : register_ref regstate register_value Satp32 -> mword ty32 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _set_Satp64_bits : register_ref regstate register_value Satp64 -> mword ty64 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _set_Sedeleg_bits : register_ref regstate register_value Sedeleg -> mword ty64 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _set_Sinterrupts_bits : register_ref regstate register_value Sinterrupts -> mword ty64 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _set_Sstatus_bits : register_ref regstate register_value Sstatus -> mword ty64 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _set_Uinterrupts_bits : register_ref regstate register_value Uinterrupts -> mword ty64 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _set_Ustatus_bits : register_ref regstate register_value Ustatus -> mword ty64 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _set_htif_cmd_bits : register_ref regstate register_value htif_cmd -> mword ty64 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _get_Misa_A : Misa -> mword ty1\<close>\<close>

definition get_Misa_A  :: \<open> Misa \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_Misa_A v = ( (subrange_vec_dec(Misa_bits   v) (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " Misa "


\<comment> \<open>\<open>val _set_Misa_A : register_ref regstate register_value Misa -> mword ty1 -> M unit\<close>\<close>

definition set_Misa_A  :: \<open>((regstate),(register_value),(Misa))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Misa_A r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (| Misa_bits := ((update_subrange_vec_dec(Misa_bits   r) (( 0 :: int)::ii) (( 0 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Misa))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Misa_A : Misa -> mword ty1 -> Misa\<close>\<close>

definition update_Misa_A  :: \<open> Misa \<Rightarrow>(1)Word.word \<Rightarrow> Misa \<close>  where 
     \<open> update_Misa_A v x = (
   ( v (| Misa_bits := ((update_subrange_vec_dec(Misa_bits   v) (( 0 :: int)::ii) (( 0 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Misa " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_PTE_Bits_A : PTE_Bits -> mword ty1 -> PTE_Bits\<close>\<close>

\<comment> \<open>\<open>val _update_Pmpcfg_ent_A : Pmpcfg_ent -> mword ty2 -> Pmpcfg_ent\<close>\<close>

\<comment> \<open>\<open>val _get_PTE_Bits_A : PTE_Bits -> mword ty1\<close>\<close>

\<comment> \<open>\<open>val _get_Pmpcfg_ent_A : Pmpcfg_ent -> mword ty2\<close>\<close>

\<comment> \<open>\<open>val _set_PTE_Bits_A : register_ref regstate register_value PTE_Bits -> mword ty1 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _set_Pmpcfg_ent_A : register_ref regstate register_value Pmpcfg_ent -> mword ty2 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _get_Misa_B : Misa -> mword ty1\<close>\<close>

definition get_Misa_B  :: \<open> Misa \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_Misa_B v = ( (subrange_vec_dec(Misa_bits   v) (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " Misa "


\<comment> \<open>\<open>val _set_Misa_B : register_ref regstate register_value Misa -> mword ty1 -> M unit\<close>\<close>

definition set_Misa_B  :: \<open>((regstate),(register_value),(Misa))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Misa_B r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (| Misa_bits := ((update_subrange_vec_dec(Misa_bits   r) (( 1 :: int)::ii) (( 1 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Misa))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Misa_B : Misa -> mword ty1 -> Misa\<close>\<close>

definition update_Misa_B  :: \<open> Misa \<Rightarrow>(1)Word.word \<Rightarrow> Misa \<close>  where 
     \<open> update_Misa_B v x = (
   ( v (| Misa_bits := ((update_subrange_vec_dec(Misa_bits   v) (( 1 :: int)::ii) (( 1 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Misa " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _get_Misa_C : Misa -> mword ty1\<close>\<close>

definition get_Misa_C  :: \<open> Misa \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_Misa_C v = ( (subrange_vec_dec(Misa_bits   v) (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " Misa "


\<comment> \<open>\<open>val _set_Misa_C : register_ref regstate register_value Misa -> mword ty1 -> M unit\<close>\<close>

definition set_Misa_C  :: \<open>((regstate),(register_value),(Misa))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Misa_C r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (| Misa_bits := ((update_subrange_vec_dec(Misa_bits   r) (( 2 :: int)::ii) (( 2 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Misa))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Misa_C : Misa -> mword ty1 -> Misa\<close>\<close>

definition update_Misa_C  :: \<open> Misa \<Rightarrow>(1)Word.word \<Rightarrow> Misa \<close>  where 
     \<open> update_Misa_C v x = (
   ( v (| Misa_bits := ((update_subrange_vec_dec(Misa_bits   v) (( 2 :: int)::ii) (( 2 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Misa " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _get_Misa_D : Misa -> mword ty1\<close>\<close>

definition get_Misa_D  :: \<open> Misa \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_Misa_D v = ( (subrange_vec_dec(Misa_bits   v) (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " Misa "


\<comment> \<open>\<open>val _set_Misa_D : register_ref regstate register_value Misa -> mword ty1 -> M unit\<close>\<close>

definition set_Misa_D  :: \<open>((regstate),(register_value),(Misa))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Misa_D r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (| Misa_bits := ((update_subrange_vec_dec(Misa_bits   r) (( 3 :: int)::ii) (( 3 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Misa))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Misa_D : Misa -> mword ty1 -> Misa\<close>\<close>

definition update_Misa_D  :: \<open> Misa \<Rightarrow>(1)Word.word \<Rightarrow> Misa \<close>  where 
     \<open> update_Misa_D v x = (
   ( v (| Misa_bits := ((update_subrange_vec_dec(Misa_bits   v) (( 3 :: int)::ii) (( 3 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Misa " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_PTE_Bits_D : PTE_Bits -> mword ty1 -> PTE_Bits\<close>\<close>

\<comment> \<open>\<open>val _get_PTE_Bits_D : PTE_Bits -> mword ty1\<close>\<close>

\<comment> \<open>\<open>val _set_PTE_Bits_D : register_ref regstate register_value PTE_Bits -> mword ty1 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _get_Misa_E : Misa -> mword ty1\<close>\<close>

definition get_Misa_E  :: \<open> Misa \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_Misa_E v = ( (subrange_vec_dec(Misa_bits   v) (( 4 :: int)::ii) (( 4 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " Misa "


\<comment> \<open>\<open>val _set_Misa_E : register_ref regstate register_value Misa -> mword ty1 -> M unit\<close>\<close>

definition set_Misa_E  :: \<open>((regstate),(register_value),(Misa))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Misa_E r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (| Misa_bits := ((update_subrange_vec_dec(Misa_bits   r) (( 4 :: int)::ii) (( 4 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Misa))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Misa_E : Misa -> mword ty1 -> Misa\<close>\<close>

definition update_Misa_E  :: \<open> Misa \<Rightarrow>(1)Word.word \<Rightarrow> Misa \<close>  where 
     \<open> update_Misa_E v x = (
   ( v (| Misa_bits := ((update_subrange_vec_dec(Misa_bits   v) (( 4 :: int)::ii) (( 4 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Misa " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _get_Misa_F : Misa -> mword ty1\<close>\<close>

definition get_Misa_F  :: \<open> Misa \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_Misa_F v = ( (subrange_vec_dec(Misa_bits   v) (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " Misa "


\<comment> \<open>\<open>val _set_Misa_F : register_ref regstate register_value Misa -> mword ty1 -> M unit\<close>\<close>

definition set_Misa_F  :: \<open>((regstate),(register_value),(Misa))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Misa_F r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (| Misa_bits := ((update_subrange_vec_dec(Misa_bits   r) (( 5 :: int)::ii) (( 5 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Misa))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Misa_F : Misa -> mword ty1 -> Misa\<close>\<close>

definition update_Misa_F  :: \<open> Misa \<Rightarrow>(1)Word.word \<Rightarrow> Misa \<close>  where 
     \<open> update_Misa_F v x = (
   ( v (| Misa_bits := ((update_subrange_vec_dec(Misa_bits   v) (( 5 :: int)::ii) (( 5 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Misa " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _get_Misa_G : Misa -> mword ty1\<close>\<close>

definition get_Misa_G  :: \<open> Misa \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_Misa_G v = ( (subrange_vec_dec(Misa_bits   v) (( 6 :: int)::ii) (( 6 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " Misa "


\<comment> \<open>\<open>val _set_Misa_G : register_ref regstate register_value Misa -> mword ty1 -> M unit\<close>\<close>

definition set_Misa_G  :: \<open>((regstate),(register_value),(Misa))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Misa_G r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (| Misa_bits := ((update_subrange_vec_dec(Misa_bits   r) (( 6 :: int)::ii) (( 6 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Misa))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Misa_G : Misa -> mword ty1 -> Misa\<close>\<close>

definition update_Misa_G  :: \<open> Misa \<Rightarrow>(1)Word.word \<Rightarrow> Misa \<close>  where 
     \<open> update_Misa_G v x = (
   ( v (| Misa_bits := ((update_subrange_vec_dec(Misa_bits   v) (( 6 :: int)::ii) (( 6 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Misa " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_PTE_Bits_G : PTE_Bits -> mword ty1 -> PTE_Bits\<close>\<close>

\<comment> \<open>\<open>val _get_PTE_Bits_G : PTE_Bits -> mword ty1\<close>\<close>

\<comment> \<open>\<open>val _set_PTE_Bits_G : register_ref regstate register_value PTE_Bits -> mword ty1 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _get_Misa_H : Misa -> mword ty1\<close>\<close>

definition get_Misa_H  :: \<open> Misa \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_Misa_H v = ( (subrange_vec_dec(Misa_bits   v) (( 7 :: int)::ii) (( 7 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " Misa "


\<comment> \<open>\<open>val _set_Misa_H : register_ref regstate register_value Misa -> mword ty1 -> M unit\<close>\<close>

definition set_Misa_H  :: \<open>((regstate),(register_value),(Misa))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Misa_H r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (| Misa_bits := ((update_subrange_vec_dec(Misa_bits   r) (( 7 :: int)::ii) (( 7 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Misa))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Misa_H : Misa -> mword ty1 -> Misa\<close>\<close>

definition update_Misa_H  :: \<open> Misa \<Rightarrow>(1)Word.word \<Rightarrow> Misa \<close>  where 
     \<open> update_Misa_H v x = (
   ( v (| Misa_bits := ((update_subrange_vec_dec(Misa_bits   v) (( 7 :: int)::ii) (( 7 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Misa " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _get_Misa_I : Misa -> mword ty1\<close>\<close>

definition get_Misa_I  :: \<open> Misa \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_Misa_I v = ( (subrange_vec_dec(Misa_bits   v) (( 8 :: int)::ii) (( 8 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " Misa "


\<comment> \<open>\<open>val _set_Misa_I : register_ref regstate register_value Misa -> mword ty1 -> M unit\<close>\<close>

definition set_Misa_I  :: \<open>((regstate),(register_value),(Misa))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Misa_I r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (| Misa_bits := ((update_subrange_vec_dec(Misa_bits   r) (( 8 :: int)::ii) (( 8 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Misa))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Misa_I : Misa -> mword ty1 -> Misa\<close>\<close>

definition update_Misa_I  :: \<open> Misa \<Rightarrow>(1)Word.word \<Rightarrow> Misa \<close>  where 
     \<open> update_Misa_I v x = (
   ( v (| Misa_bits := ((update_subrange_vec_dec(Misa_bits   v) (( 8 :: int)::ii) (( 8 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Misa " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _get_Misa_J : Misa -> mword ty1\<close>\<close>

definition get_Misa_J  :: \<open> Misa \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_Misa_J v = ( (subrange_vec_dec(Misa_bits   v) (( 9 :: int)::ii) (( 9 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " Misa "


\<comment> \<open>\<open>val _set_Misa_J : register_ref regstate register_value Misa -> mword ty1 -> M unit\<close>\<close>

definition set_Misa_J  :: \<open>((regstate),(register_value),(Misa))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Misa_J r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (| Misa_bits := ((update_subrange_vec_dec(Misa_bits   r) (( 9 :: int)::ii) (( 9 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Misa))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Misa_J : Misa -> mword ty1 -> Misa\<close>\<close>

definition update_Misa_J  :: \<open> Misa \<Rightarrow>(1)Word.word \<Rightarrow> Misa \<close>  where 
     \<open> update_Misa_J v x = (
   ( v (| Misa_bits := ((update_subrange_vec_dec(Misa_bits   v) (( 9 :: int)::ii) (( 9 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Misa " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _get_Misa_K : Misa -> mword ty1\<close>\<close>

definition get_Misa_K  :: \<open> Misa \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_Misa_K v = ( (subrange_vec_dec(Misa_bits   v) (( 10 :: int)::ii) (( 10 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " Misa "


\<comment> \<open>\<open>val _set_Misa_K : register_ref regstate register_value Misa -> mword ty1 -> M unit\<close>\<close>

definition set_Misa_K  :: \<open>((regstate),(register_value),(Misa))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Misa_K r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (| Misa_bits := ((update_subrange_vec_dec(Misa_bits   r) (( 10 :: int)::ii) (( 10 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Misa))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Misa_K : Misa -> mword ty1 -> Misa\<close>\<close>

definition update_Misa_K  :: \<open> Misa \<Rightarrow>(1)Word.word \<Rightarrow> Misa \<close>  where 
     \<open> update_Misa_K v x = (
   ( v (| Misa_bits := ((update_subrange_vec_dec(Misa_bits   v) (( 10 :: int)::ii) (( 10 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Misa " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _get_Misa_L : Misa -> mword ty1\<close>\<close>

definition get_Misa_L  :: \<open> Misa \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_Misa_L v = ( (subrange_vec_dec(Misa_bits   v) (( 11 :: int)::ii) (( 11 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " Misa "


\<comment> \<open>\<open>val _set_Misa_L : register_ref regstate register_value Misa -> mword ty1 -> M unit\<close>\<close>

definition set_Misa_L  :: \<open>((regstate),(register_value),(Misa))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Misa_L r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (| Misa_bits := ((update_subrange_vec_dec(Misa_bits   r) (( 11 :: int)::ii) (( 11 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Misa))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Misa_L : Misa -> mword ty1 -> Misa\<close>\<close>

definition update_Misa_L  :: \<open> Misa \<Rightarrow>(1)Word.word \<Rightarrow> Misa \<close>  where 
     \<open> update_Misa_L v x = (
   ( v (| Misa_bits := ((update_subrange_vec_dec(Misa_bits   v) (( 11 :: int)::ii) (( 11 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Misa " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Pmpcfg_ent_L : Pmpcfg_ent -> mword ty1 -> Pmpcfg_ent\<close>\<close>

\<comment> \<open>\<open>val _get_Pmpcfg_ent_L : Pmpcfg_ent -> mword ty1\<close>\<close>

\<comment> \<open>\<open>val _set_Pmpcfg_ent_L : register_ref regstate register_value Pmpcfg_ent -> mword ty1 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _get_Misa_M : Misa -> mword ty1\<close>\<close>

definition get_Misa_M  :: \<open> Misa \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_Misa_M v = ( (subrange_vec_dec(Misa_bits   v) (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " Misa "


\<comment> \<open>\<open>val _set_Misa_M : register_ref regstate register_value Misa -> mword ty1 -> M unit\<close>\<close>

definition set_Misa_M  :: \<open>((regstate),(register_value),(Misa))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Misa_M r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (| Misa_bits := ((update_subrange_vec_dec(Misa_bits   r) (( 12 :: int)::ii) (( 12 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Misa))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Misa_M : Misa -> mword ty1 -> Misa\<close>\<close>

definition update_Misa_M  :: \<open> Misa \<Rightarrow>(1)Word.word \<Rightarrow> Misa \<close>  where 
     \<open> update_Misa_M v x = (
   ( v (| Misa_bits := ((update_subrange_vec_dec(Misa_bits   v) (( 12 :: int)::ii) (( 12 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Misa " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _get_Misa_MXL : Misa -> mword ty2\<close>\<close>

definition get_Misa_MXL  :: \<open> Misa \<Rightarrow>(2)Word.word \<close>  where 
     \<open> get_Misa_MXL v = ( (subrange_vec_dec(Misa_bits   v) (( 63 :: int)::ii) (( 62 :: int)::ii)  ::  2 Word.word))\<close> 
  for  v  :: " Misa "


\<comment> \<open>\<open>val _set_Misa_MXL : register_ref regstate register_value Misa -> mword ty2 -> M unit\<close>\<close>

definition set_Misa_MXL  :: \<open>((regstate),(register_value),(Misa))register_ref \<Rightarrow>(2)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Misa_MXL r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (| Misa_bits := ((update_subrange_vec_dec(Misa_bits   r) (( 63 :: int)::ii) (( 62 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Misa))register_ref " 
  and  v  :: "(2)Word.word "


\<comment> \<open>\<open>val _update_Misa_MXL : Misa -> mword ty2 -> Misa\<close>\<close>

definition update_Misa_MXL  :: \<open> Misa \<Rightarrow>(2)Word.word \<Rightarrow> Misa \<close>  where 
     \<open> update_Misa_MXL v x = (
   ( v (| Misa_bits := ((update_subrange_vec_dec(Misa_bits   v) (( 63 :: int)::ii) (( 62 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Misa " 
  and  x  :: "(2)Word.word "


\<comment> \<open>\<open>val _get_Misa_N : Misa -> mword ty1\<close>\<close>

definition get_Misa_N  :: \<open> Misa \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_Misa_N v = ( (subrange_vec_dec(Misa_bits   v) (( 13 :: int)::ii) (( 13 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " Misa "


\<comment> \<open>\<open>val _set_Misa_N : register_ref regstate register_value Misa -> mword ty1 -> M unit\<close>\<close>

definition set_Misa_N  :: \<open>((regstate),(register_value),(Misa))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Misa_N r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (| Misa_bits := ((update_subrange_vec_dec(Misa_bits   r) (( 13 :: int)::ii) (( 13 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Misa))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Misa_N : Misa -> mword ty1 -> Misa\<close>\<close>

definition update_Misa_N  :: \<open> Misa \<Rightarrow>(1)Word.word \<Rightarrow> Misa \<close>  where 
     \<open> update_Misa_N v x = (
   ( v (| Misa_bits := ((update_subrange_vec_dec(Misa_bits   v) (( 13 :: int)::ii) (( 13 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Misa " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _get_Misa_O : Misa -> mword ty1\<close>\<close>

definition get_Misa_O  :: \<open> Misa \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_Misa_O v = ( (subrange_vec_dec(Misa_bits   v) (( 14 :: int)::ii) (( 14 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " Misa "


\<comment> \<open>\<open>val _set_Misa_O : register_ref regstate register_value Misa -> mword ty1 -> M unit\<close>\<close>

definition set_Misa_O  :: \<open>((regstate),(register_value),(Misa))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Misa_O r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (| Misa_bits := ((update_subrange_vec_dec(Misa_bits   r) (( 14 :: int)::ii) (( 14 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Misa))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Misa_O : Misa -> mword ty1 -> Misa\<close>\<close>

definition update_Misa_O  :: \<open> Misa \<Rightarrow>(1)Word.word \<Rightarrow> Misa \<close>  where 
     \<open> update_Misa_O v x = (
   ( v (| Misa_bits := ((update_subrange_vec_dec(Misa_bits   v) (( 14 :: int)::ii) (( 14 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Misa " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _get_Misa_P : Misa -> mword ty1\<close>\<close>

definition get_Misa_P  :: \<open> Misa \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_Misa_P v = ( (subrange_vec_dec(Misa_bits   v) (( 15 :: int)::ii) (( 15 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " Misa "


\<comment> \<open>\<open>val _set_Misa_P : register_ref regstate register_value Misa -> mword ty1 -> M unit\<close>\<close>

definition set_Misa_P  :: \<open>((regstate),(register_value),(Misa))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Misa_P r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (| Misa_bits := ((update_subrange_vec_dec(Misa_bits   r) (( 15 :: int)::ii) (( 15 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Misa))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Misa_P : Misa -> mword ty1 -> Misa\<close>\<close>

definition update_Misa_P  :: \<open> Misa \<Rightarrow>(1)Word.word \<Rightarrow> Misa \<close>  where 
     \<open> update_Misa_P v x = (
   ( v (| Misa_bits := ((update_subrange_vec_dec(Misa_bits   v) (( 15 :: int)::ii) (( 15 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Misa " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _get_Misa_Q : Misa -> mword ty1\<close>\<close>

definition get_Misa_Q  :: \<open> Misa \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_Misa_Q v = ( (subrange_vec_dec(Misa_bits   v) (( 16 :: int)::ii) (( 16 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " Misa "


\<comment> \<open>\<open>val _set_Misa_Q : register_ref regstate register_value Misa -> mword ty1 -> M unit\<close>\<close>

definition set_Misa_Q  :: \<open>((regstate),(register_value),(Misa))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Misa_Q r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (| Misa_bits := ((update_subrange_vec_dec(Misa_bits   r) (( 16 :: int)::ii) (( 16 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Misa))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Misa_Q : Misa -> mword ty1 -> Misa\<close>\<close>

definition update_Misa_Q  :: \<open> Misa \<Rightarrow>(1)Word.word \<Rightarrow> Misa \<close>  where 
     \<open> update_Misa_Q v x = (
   ( v (| Misa_bits := ((update_subrange_vec_dec(Misa_bits   v) (( 16 :: int)::ii) (( 16 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Misa " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _get_Misa_R : Misa -> mword ty1\<close>\<close>

definition get_Misa_R  :: \<open> Misa \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_Misa_R v = ( (subrange_vec_dec(Misa_bits   v) (( 17 :: int)::ii) (( 17 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " Misa "


\<comment> \<open>\<open>val _set_Misa_R : register_ref regstate register_value Misa -> mword ty1 -> M unit\<close>\<close>

definition set_Misa_R  :: \<open>((regstate),(register_value),(Misa))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Misa_R r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (| Misa_bits := ((update_subrange_vec_dec(Misa_bits   r) (( 17 :: int)::ii) (( 17 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Misa))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Misa_R : Misa -> mword ty1 -> Misa\<close>\<close>

definition update_Misa_R  :: \<open> Misa \<Rightarrow>(1)Word.word \<Rightarrow> Misa \<close>  where 
     \<open> update_Misa_R v x = (
   ( v (| Misa_bits := ((update_subrange_vec_dec(Misa_bits   v) (( 17 :: int)::ii) (( 17 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Misa " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_PTE_Bits_R : PTE_Bits -> mword ty1 -> PTE_Bits\<close>\<close>

\<comment> \<open>\<open>val _update_Pmpcfg_ent_R : Pmpcfg_ent -> mword ty1 -> Pmpcfg_ent\<close>\<close>

\<comment> \<open>\<open>val _get_PTE_Bits_R : PTE_Bits -> mword ty1\<close>\<close>

\<comment> \<open>\<open>val _get_Pmpcfg_ent_R : Pmpcfg_ent -> mword ty1\<close>\<close>

\<comment> \<open>\<open>val _set_PTE_Bits_R : register_ref regstate register_value PTE_Bits -> mword ty1 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _set_Pmpcfg_ent_R : register_ref regstate register_value Pmpcfg_ent -> mword ty1 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _get_Misa_S : Misa -> mword ty1\<close>\<close>

definition get_Misa_S  :: \<open> Misa \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_Misa_S v = ( (subrange_vec_dec(Misa_bits   v) (( 18 :: int)::ii) (( 18 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " Misa "


\<comment> \<open>\<open>val _set_Misa_S : register_ref regstate register_value Misa -> mword ty1 -> M unit\<close>\<close>

definition set_Misa_S  :: \<open>((regstate),(register_value),(Misa))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Misa_S r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (| Misa_bits := ((update_subrange_vec_dec(Misa_bits   r) (( 18 :: int)::ii) (( 18 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Misa))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Misa_S : Misa -> mword ty1 -> Misa\<close>\<close>

definition update_Misa_S  :: \<open> Misa \<Rightarrow>(1)Word.word \<Rightarrow> Misa \<close>  where 
     \<open> update_Misa_S v x = (
   ( v (| Misa_bits := ((update_subrange_vec_dec(Misa_bits   v) (( 18 :: int)::ii) (( 18 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Misa " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _get_Misa_T : Misa -> mword ty1\<close>\<close>

definition get_Misa_T  :: \<open> Misa \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_Misa_T v = ( (subrange_vec_dec(Misa_bits   v) (( 19 :: int)::ii) (( 19 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " Misa "


\<comment> \<open>\<open>val _set_Misa_T : register_ref regstate register_value Misa -> mword ty1 -> M unit\<close>\<close>

definition set_Misa_T  :: \<open>((regstate),(register_value),(Misa))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Misa_T r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (| Misa_bits := ((update_subrange_vec_dec(Misa_bits   r) (( 19 :: int)::ii) (( 19 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Misa))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Misa_T : Misa -> mword ty1 -> Misa\<close>\<close>

definition update_Misa_T  :: \<open> Misa \<Rightarrow>(1)Word.word \<Rightarrow> Misa \<close>  where 
     \<open> update_Misa_T v x = (
   ( v (| Misa_bits := ((update_subrange_vec_dec(Misa_bits   v) (( 19 :: int)::ii) (( 19 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Misa " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _get_Misa_U : Misa -> mword ty1\<close>\<close>

definition get_Misa_U  :: \<open> Misa \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_Misa_U v = ( (subrange_vec_dec(Misa_bits   v) (( 20 :: int)::ii) (( 20 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " Misa "


\<comment> \<open>\<open>val _set_Misa_U : register_ref regstate register_value Misa -> mword ty1 -> M unit\<close>\<close>

definition set_Misa_U  :: \<open>((regstate),(register_value),(Misa))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Misa_U r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (| Misa_bits := ((update_subrange_vec_dec(Misa_bits   r) (( 20 :: int)::ii) (( 20 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Misa))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Misa_U : Misa -> mword ty1 -> Misa\<close>\<close>

definition update_Misa_U  :: \<open> Misa \<Rightarrow>(1)Word.word \<Rightarrow> Misa \<close>  where 
     \<open> update_Misa_U v x = (
   ( v (| Misa_bits := ((update_subrange_vec_dec(Misa_bits   v) (( 20 :: int)::ii) (( 20 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Misa " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_PTE_Bits_U : PTE_Bits -> mword ty1 -> PTE_Bits\<close>\<close>

\<comment> \<open>\<open>val _get_PTE_Bits_U : PTE_Bits -> mword ty1\<close>\<close>

\<comment> \<open>\<open>val _set_PTE_Bits_U : register_ref regstate register_value PTE_Bits -> mword ty1 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _get_Misa_V : Misa -> mword ty1\<close>\<close>

definition get_Misa_V  :: \<open> Misa \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_Misa_V v = ( (subrange_vec_dec(Misa_bits   v) (( 21 :: int)::ii) (( 21 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " Misa "


\<comment> \<open>\<open>val _set_Misa_V : register_ref regstate register_value Misa -> mword ty1 -> M unit\<close>\<close>

definition set_Misa_V  :: \<open>((regstate),(register_value),(Misa))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Misa_V r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (| Misa_bits := ((update_subrange_vec_dec(Misa_bits   r) (( 21 :: int)::ii) (( 21 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Misa))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Misa_V : Misa -> mword ty1 -> Misa\<close>\<close>

definition update_Misa_V  :: \<open> Misa \<Rightarrow>(1)Word.word \<Rightarrow> Misa \<close>  where 
     \<open> update_Misa_V v x = (
   ( v (| Misa_bits := ((update_subrange_vec_dec(Misa_bits   v) (( 21 :: int)::ii) (( 21 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Misa " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_PTE_Bits_V : PTE_Bits -> mword ty1 -> PTE_Bits\<close>\<close>

\<comment> \<open>\<open>val _get_PTE_Bits_V : PTE_Bits -> mword ty1\<close>\<close>

\<comment> \<open>\<open>val _set_PTE_Bits_V : register_ref regstate register_value PTE_Bits -> mword ty1 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _get_Misa_W : Misa -> mword ty1\<close>\<close>

definition get_Misa_W  :: \<open> Misa \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_Misa_W v = ( (subrange_vec_dec(Misa_bits   v) (( 22 :: int)::ii) (( 22 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " Misa "


\<comment> \<open>\<open>val _set_Misa_W : register_ref regstate register_value Misa -> mword ty1 -> M unit\<close>\<close>

definition set_Misa_W  :: \<open>((regstate),(register_value),(Misa))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Misa_W r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (| Misa_bits := ((update_subrange_vec_dec(Misa_bits   r) (( 22 :: int)::ii) (( 22 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Misa))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Misa_W : Misa -> mword ty1 -> Misa\<close>\<close>

definition update_Misa_W  :: \<open> Misa \<Rightarrow>(1)Word.word \<Rightarrow> Misa \<close>  where 
     \<open> update_Misa_W v x = (
   ( v (| Misa_bits := ((update_subrange_vec_dec(Misa_bits   v) (( 22 :: int)::ii) (( 22 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Misa " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_PTE_Bits_W : PTE_Bits -> mword ty1 -> PTE_Bits\<close>\<close>

\<comment> \<open>\<open>val _update_Pmpcfg_ent_W : Pmpcfg_ent -> mword ty1 -> Pmpcfg_ent\<close>\<close>

\<comment> \<open>\<open>val _get_PTE_Bits_W : PTE_Bits -> mword ty1\<close>\<close>

\<comment> \<open>\<open>val _get_Pmpcfg_ent_W : Pmpcfg_ent -> mword ty1\<close>\<close>

\<comment> \<open>\<open>val _set_PTE_Bits_W : register_ref regstate register_value PTE_Bits -> mword ty1 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _set_Pmpcfg_ent_W : register_ref regstate register_value Pmpcfg_ent -> mword ty1 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _get_Misa_X : Misa -> mword ty1\<close>\<close>

definition get_Misa_X  :: \<open> Misa \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_Misa_X v = ( (subrange_vec_dec(Misa_bits   v) (( 23 :: int)::ii) (( 23 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " Misa "


\<comment> \<open>\<open>val _set_Misa_X : register_ref regstate register_value Misa -> mword ty1 -> M unit\<close>\<close>

definition set_Misa_X  :: \<open>((regstate),(register_value),(Misa))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Misa_X r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (| Misa_bits := ((update_subrange_vec_dec(Misa_bits   r) (( 23 :: int)::ii) (( 23 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Misa))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Misa_X : Misa -> mword ty1 -> Misa\<close>\<close>

definition update_Misa_X  :: \<open> Misa \<Rightarrow>(1)Word.word \<Rightarrow> Misa \<close>  where 
     \<open> update_Misa_X v x = (
   ( v (| Misa_bits := ((update_subrange_vec_dec(Misa_bits   v) (( 23 :: int)::ii) (( 23 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Misa " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_PTE_Bits_X : PTE_Bits -> mword ty1 -> PTE_Bits\<close>\<close>

\<comment> \<open>\<open>val _update_Pmpcfg_ent_X : Pmpcfg_ent -> mword ty1 -> Pmpcfg_ent\<close>\<close>

\<comment> \<open>\<open>val _get_PTE_Bits_X : PTE_Bits -> mword ty1\<close>\<close>

\<comment> \<open>\<open>val _get_Pmpcfg_ent_X : Pmpcfg_ent -> mword ty1\<close>\<close>

\<comment> \<open>\<open>val _set_PTE_Bits_X : register_ref regstate register_value PTE_Bits -> mword ty1 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _set_Pmpcfg_ent_X : register_ref regstate register_value Pmpcfg_ent -> mword ty1 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _get_Misa_Y : Misa -> mword ty1\<close>\<close>

definition get_Misa_Y  :: \<open> Misa \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_Misa_Y v = ( (subrange_vec_dec(Misa_bits   v) (( 24 :: int)::ii) (( 24 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " Misa "


\<comment> \<open>\<open>val _set_Misa_Y : register_ref regstate register_value Misa -> mword ty1 -> M unit\<close>\<close>

definition set_Misa_Y  :: \<open>((regstate),(register_value),(Misa))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Misa_Y r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (| Misa_bits := ((update_subrange_vec_dec(Misa_bits   r) (( 24 :: int)::ii) (( 24 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Misa))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Misa_Y : Misa -> mword ty1 -> Misa\<close>\<close>

definition update_Misa_Y  :: \<open> Misa \<Rightarrow>(1)Word.word \<Rightarrow> Misa \<close>  where 
     \<open> update_Misa_Y v x = (
   ( v (| Misa_bits := ((update_subrange_vec_dec(Misa_bits   v) (( 24 :: int)::ii) (( 24 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Misa " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _get_Misa_Z : Misa -> mword ty1\<close>\<close>

definition get_Misa_Z  :: \<open> Misa \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_Misa_Z v = ( (subrange_vec_dec(Misa_bits   v) (( 25 :: int)::ii) (( 25 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " Misa "


\<comment> \<open>\<open>val _set_Misa_Z : register_ref regstate register_value Misa -> mword ty1 -> M unit\<close>\<close>

definition set_Misa_Z  :: \<open>((regstate),(register_value),(Misa))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Misa_Z r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (| Misa_bits := ((update_subrange_vec_dec(Misa_bits   r) (( 25 :: int)::ii) (( 25 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Misa))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Misa_Z : Misa -> mword ty1 -> Misa\<close>\<close>

definition update_Misa_Z  :: \<open> Misa \<Rightarrow>(1)Word.word \<Rightarrow> Misa \<close>  where 
     \<open> update_Misa_Z v x = (
   ( v (| Misa_bits := ((update_subrange_vec_dec(Misa_bits   v) (( 25 :: int)::ii) (( 25 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Misa " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val ext_veto_disable_C : unit -> M bool\<close>\<close>

\<comment> \<open>\<open>val legalize_misa : Misa -> mword ty64 -> M Misa\<close>\<close>

definition ext_veto_disable_C  :: \<open> unit \<Rightarrow>((register_value),(bool),(exception))monad \<close>  where 
     \<open> ext_veto_disable_C _ = ( return False )\<close>


definition legalize_misa  :: \<open> Misa \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),(Misa),(exception))monad \<close>  where 
     \<open> legalize_misa (m :: Misa) (v :: xlenbits) = (
   if ((sys_enable_writable_misa () )) then
     (let v = (Mk_Misa v) in
     or_boolM
       (and_boolM (return (((((get_Misa_C v  ::  1 Word.word)) = ( 0b0 ::  1 Word.word)))))
          (or_boolM
             ((read_reg nextPC_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
              return (((((access_vec_dec w__0 (( 1 :: int)::ii))) = B1)))))) ((ext_veto_disable_C () ))))
       (return ((\<not> ((sys_enable_rvc () ))))) \<bind> ((\<lambda> (w__4 :: bool) . 
     (let m = (if w__4 then m else update_Misa_C m ((get_Misa_C v  ::  1 Word.word))) in
     return (if (((((\<not> ((sys_enable_fdext () )))) \<or> ((((((((get_Misa_D v  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))) \<and> (((((get_Misa_F v  ::  1 Word.word)) = ( 0b0 ::  1 Word.word)))))))))) then
               m
             else
               update_Misa_D ((update_Misa_F m ((get_Misa_F v  ::  1 Word.word))))
                 ((get_Misa_D v  ::  1 Word.word)))))))
   else return m )\<close> 
  for  m  :: " Misa " 
  and  v  :: "(64)Word.word "


\<comment> \<open>\<open>val haveAtomics : unit -> M bool\<close>\<close>

definition haveAtomics  :: \<open> unit \<Rightarrow>((register_value),(bool),(exception))monad \<close>  where 
     \<open> haveAtomics _ = (
   read_reg misa_ref \<bind> ((\<lambda> (w__0 :: Misa) . 
   return (((((get_Misa_A w__0  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))))))\<close>


\<comment> \<open>\<open>val haveRVC : unit -> M bool\<close>\<close>

definition haveRVC  :: \<open> unit \<Rightarrow>((register_value),(bool),(exception))monad \<close>  where 
     \<open> haveRVC _ = (
   read_reg misa_ref \<bind> ((\<lambda> (w__0 :: Misa) . 
   return (((((get_Misa_C w__0  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))))))\<close>


\<comment> \<open>\<open>val haveMulDiv : unit -> M bool\<close>\<close>

definition haveMulDiv  :: \<open> unit \<Rightarrow>((register_value),(bool),(exception))monad \<close>  where 
     \<open> haveMulDiv _ = (
   read_reg misa_ref \<bind> ((\<lambda> (w__0 :: Misa) . 
   return (((((get_Misa_M w__0  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))))))\<close>


\<comment> \<open>\<open>val haveSupMode : unit -> M bool\<close>\<close>

definition haveSupMode  :: \<open> unit \<Rightarrow>((register_value),(bool),(exception))monad \<close>  where 
     \<open> haveSupMode _ = (
   read_reg misa_ref \<bind> ((\<lambda> (w__0 :: Misa) . 
   return (((((get_Misa_S w__0  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))))))\<close>


\<comment> \<open>\<open>val haveUsrMode : unit -> M bool\<close>\<close>

definition haveUsrMode  :: \<open> unit \<Rightarrow>((register_value),(bool),(exception))monad \<close>  where 
     \<open> haveUsrMode _ = (
   read_reg misa_ref \<bind> ((\<lambda> (w__0 :: Misa) . 
   return (((((get_Misa_U w__0  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))))))\<close>


\<comment> \<open>\<open>val haveNExt : unit -> M bool\<close>\<close>

definition haveNExt  :: \<open> unit \<Rightarrow>((register_value),(bool),(exception))monad \<close>  where 
     \<open> haveNExt _ = (
   read_reg misa_ref \<bind> ((\<lambda> (w__0 :: Misa) . 
   return (((((get_Misa_N w__0  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))))))\<close>


\<comment> \<open>\<open>val undefined_Mstatush : unit -> M Mstatush\<close>\<close>

definition undefined_Mstatush  :: \<open> unit \<Rightarrow>((register_value),(Mstatush),(exception))monad \<close>  where 
     \<open> undefined_Mstatush _ = (
   ((return (failwith (''undefined value of unsupported type''))) :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::
      32 Word.word) . 
   return ((| Mstatush_bits = w__0 |)))))\<close>


\<comment> \<open>\<open>val Mk_Mstatush : mword ty32 -> Mstatush\<close>\<close>

definition Mk_Mstatush  :: \<open>(32)Word.word \<Rightarrow> Mstatush \<close>  where 
     \<open> Mk_Mstatush v = ( (| Mstatush_bits = v |) )\<close> 
  for  v  :: "(32)Word.word "


definition get_Mstatush_bits  :: \<open> Mstatush \<Rightarrow>(32)Word.word \<close>  where 
     \<open> get_Mstatush_bits v = ( (subrange_vec_dec(Mstatush_bits   v) (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))\<close> 
  for  v  :: " Mstatush "


definition set_Mstatush_bits  :: \<open>((regstate),(register_value),(Mstatush))register_ref \<Rightarrow>(32)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Mstatush_bits r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Mstatush_bits := ((update_subrange_vec_dec(Mstatush_bits   r) (( 31 :: int)::ii) (( 0 :: int)::ii) v  ::  32 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Mstatush))register_ref " 
  and  v  :: "(32)Word.word "


definition update_Mstatush_bits  :: \<open> Mstatush \<Rightarrow>(32)Word.word \<Rightarrow> Mstatush \<close>  where 
     \<open> update_Mstatush_bits v x = (
   ( v (|
     Mstatush_bits := ((update_subrange_vec_dec(Mstatush_bits   v) (( 31 :: int)::ii) (( 0 :: int)::ii) x  ::  32 Word.word)) |)))\<close> 
  for  v  :: " Mstatush " 
  and  x  :: "(32)Word.word "


\<comment> \<open>\<open>val _get_Mstatush_MBE : Mstatush -> mword ty1\<close>\<close>

definition get_Mstatush_MBE  :: \<open> Mstatush \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_Mstatush_MBE v = ( (subrange_vec_dec(Mstatush_bits   v) (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " Mstatush "


\<comment> \<open>\<open>val _set_Mstatush_MBE : register_ref regstate register_value Mstatush -> mword ty1 -> M unit\<close>\<close>

definition set_Mstatush_MBE  :: \<open>((regstate),(register_value),(Mstatush))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Mstatush_MBE r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Mstatush_bits := ((update_subrange_vec_dec(Mstatush_bits   r) (( 5 :: int)::ii) (( 5 :: int)::ii) v  ::  32 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Mstatush))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Mstatush_MBE : Mstatush -> mword ty1 -> Mstatush\<close>\<close>

definition update_Mstatush_MBE  :: \<open> Mstatush \<Rightarrow>(1)Word.word \<Rightarrow> Mstatush \<close>  where 
     \<open> update_Mstatush_MBE v x = (
   ( v (|
     Mstatush_bits := ((update_subrange_vec_dec(Mstatush_bits   v) (( 5 :: int)::ii) (( 5 :: int)::ii) x  ::  32 Word.word)) |)))\<close> 
  for  v  :: " Mstatush " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _get_Mstatush_SBE : Mstatush -> mword ty1\<close>\<close>

definition get_Mstatush_SBE  :: \<open> Mstatush \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_Mstatush_SBE v = ( (subrange_vec_dec(Mstatush_bits   v) (( 4 :: int)::ii) (( 4 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " Mstatush "


\<comment> \<open>\<open>val _set_Mstatush_SBE : register_ref regstate register_value Mstatush -> mword ty1 -> M unit\<close>\<close>

definition set_Mstatush_SBE  :: \<open>((regstate),(register_value),(Mstatush))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Mstatush_SBE r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Mstatush_bits := ((update_subrange_vec_dec(Mstatush_bits   r) (( 4 :: int)::ii) (( 4 :: int)::ii) v  ::  32 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Mstatush))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Mstatush_SBE : Mstatush -> mword ty1 -> Mstatush\<close>\<close>

definition update_Mstatush_SBE  :: \<open> Mstatush \<Rightarrow>(1)Word.word \<Rightarrow> Mstatush \<close>  where 
     \<open> update_Mstatush_SBE v x = (
   ( v (|
     Mstatush_bits := ((update_subrange_vec_dec(Mstatush_bits   v) (( 4 :: int)::ii) (( 4 :: int)::ii) x  ::  32 Word.word)) |)))\<close> 
  for  v  :: " Mstatush " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val undefined_Mstatus : unit -> M Mstatus\<close>\<close>

definition undefined_Mstatus  :: \<open> unit \<Rightarrow>((register_value),(Mstatus),(exception))monad \<close>  where 
     \<open> undefined_Mstatus _ = (
   ((return (failwith (''undefined value of unsupported type''))) :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::
      64 Word.word) . 
   return ((| Mstatus_bits = w__0 |)))))\<close>


\<comment> \<open>\<open>val Mk_Mstatus : mword ty64 -> Mstatus\<close>\<close>

definition Mk_Mstatus  :: \<open>(64)Word.word \<Rightarrow> Mstatus \<close>  where 
     \<open> Mk_Mstatus v = ( (| Mstatus_bits = v |) )\<close> 
  for  v  :: "(64)Word.word "


definition get_Mstatus_bits  :: \<open> Mstatus \<Rightarrow>(64)Word.word \<close>  where 
     \<open> get_Mstatus_bits v = ( (subrange_vec_dec(Mstatus_bits   v) (( 63 :: int)::ii) (( 0 :: int)::ii)  ::  64 Word.word))\<close> 
  for  v  :: " Mstatus "


definition set_Mstatus_bits  :: \<open>((regstate),(register_value),(Mstatus))register_ref \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Mstatus_bits r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Mstatus_bits := ((update_subrange_vec_dec(Mstatus_bits   r) (( 63 :: int)::ii) (( 0 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Mstatus))register_ref " 
  and  v  :: "(64)Word.word "


definition update_Mstatus_bits  :: \<open> Mstatus \<Rightarrow>(64)Word.word \<Rightarrow> Mstatus \<close>  where 
     \<open> update_Mstatus_bits v x = (
   ( v (|
     Mstatus_bits := ((update_subrange_vec_dec(Mstatus_bits   v) (( 63 :: int)::ii) (( 0 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Mstatus " 
  and  x  :: "(64)Word.word "


\<comment> \<open>\<open>val _get_Mstatus_FS : Mstatus -> mword ty2\<close>\<close>

definition get_Mstatus_FS  :: \<open> Mstatus \<Rightarrow>(2)Word.word \<close>  where 
     \<open> get_Mstatus_FS v = ( (subrange_vec_dec(Mstatus_bits   v) (( 14 :: int)::ii) (( 13 :: int)::ii)  ::  2 Word.word))\<close> 
  for  v  :: " Mstatus "


\<comment> \<open>\<open>val _set_Mstatus_FS : register_ref regstate register_value Mstatus -> mword ty2 -> M unit\<close>\<close>

definition set_Mstatus_FS  :: \<open>((regstate),(register_value),(Mstatus))register_ref \<Rightarrow>(2)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Mstatus_FS r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Mstatus_bits := ((update_subrange_vec_dec(Mstatus_bits   r) (( 14 :: int)::ii) (( 13 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Mstatus))register_ref " 
  and  v  :: "(2)Word.word "


\<comment> \<open>\<open>val _update_Mstatus_FS : Mstatus -> mword ty2 -> Mstatus\<close>\<close>

definition update_Mstatus_FS  :: \<open> Mstatus \<Rightarrow>(2)Word.word \<Rightarrow> Mstatus \<close>  where 
     \<open> update_Mstatus_FS v x = (
   ( v (|
     Mstatus_bits := ((update_subrange_vec_dec(Mstatus_bits   v) (( 14 :: int)::ii) (( 13 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Mstatus " 
  and  x  :: "(2)Word.word "


\<comment> \<open>\<open>val _update_Sstatus_FS : Sstatus -> mword ty2 -> Sstatus\<close>\<close>

\<comment> \<open>\<open>val _get_Sstatus_FS : Sstatus -> mword ty2\<close>\<close>

\<comment> \<open>\<open>val _set_Sstatus_FS : register_ref regstate register_value Sstatus -> mword ty2 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _get_Mstatus_MIE : Mstatus -> mword ty1\<close>\<close>

definition get_Mstatus_MIE  :: \<open> Mstatus \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_Mstatus_MIE v = ( (subrange_vec_dec(Mstatus_bits   v) (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " Mstatus "


\<comment> \<open>\<open>val _set_Mstatus_MIE : register_ref regstate register_value Mstatus -> mword ty1 -> M unit\<close>\<close>

definition set_Mstatus_MIE  :: \<open>((regstate),(register_value),(Mstatus))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Mstatus_MIE r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Mstatus_bits := ((update_subrange_vec_dec(Mstatus_bits   r) (( 3 :: int)::ii) (( 3 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Mstatus))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Mstatus_MIE : Mstatus -> mword ty1 -> Mstatus\<close>\<close>

definition update_Mstatus_MIE  :: \<open> Mstatus \<Rightarrow>(1)Word.word \<Rightarrow> Mstatus \<close>  where 
     \<open> update_Mstatus_MIE v x = (
   ( v (| Mstatus_bits := ((update_subrange_vec_dec(Mstatus_bits   v) (( 3 :: int)::ii) (( 3 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Mstatus " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _get_Mstatus_MPIE : Mstatus -> mword ty1\<close>\<close>

definition get_Mstatus_MPIE  :: \<open> Mstatus \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_Mstatus_MPIE v = ( (subrange_vec_dec(Mstatus_bits   v) (( 7 :: int)::ii) (( 7 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " Mstatus "


\<comment> \<open>\<open>val _set_Mstatus_MPIE : register_ref regstate register_value Mstatus -> mword ty1 -> M unit\<close>\<close>

definition set_Mstatus_MPIE  :: \<open>((regstate),(register_value),(Mstatus))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Mstatus_MPIE r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Mstatus_bits := ((update_subrange_vec_dec(Mstatus_bits   r) (( 7 :: int)::ii) (( 7 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Mstatus))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Mstatus_MPIE : Mstatus -> mword ty1 -> Mstatus\<close>\<close>

definition update_Mstatus_MPIE  :: \<open> Mstatus \<Rightarrow>(1)Word.word \<Rightarrow> Mstatus \<close>  where 
     \<open> update_Mstatus_MPIE v x = (
   ( v (| Mstatus_bits := ((update_subrange_vec_dec(Mstatus_bits   v) (( 7 :: int)::ii) (( 7 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Mstatus " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _get_Mstatus_MPP : Mstatus -> mword ty2\<close>\<close>

definition get_Mstatus_MPP  :: \<open> Mstatus \<Rightarrow>(2)Word.word \<close>  where 
     \<open> get_Mstatus_MPP v = ( (subrange_vec_dec(Mstatus_bits   v) (( 12 :: int)::ii) (( 11 :: int)::ii)  ::  2 Word.word))\<close> 
  for  v  :: " Mstatus "


\<comment> \<open>\<open>val _set_Mstatus_MPP : register_ref regstate register_value Mstatus -> mword ty2 -> M unit\<close>\<close>

definition set_Mstatus_MPP  :: \<open>((regstate),(register_value),(Mstatus))register_ref \<Rightarrow>(2)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Mstatus_MPP r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Mstatus_bits := ((update_subrange_vec_dec(Mstatus_bits   r) (( 12 :: int)::ii) (( 11 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Mstatus))register_ref " 
  and  v  :: "(2)Word.word "


\<comment> \<open>\<open>val _update_Mstatus_MPP : Mstatus -> mword ty2 -> Mstatus\<close>\<close>

definition update_Mstatus_MPP  :: \<open> Mstatus \<Rightarrow>(2)Word.word \<Rightarrow> Mstatus \<close>  where 
     \<open> update_Mstatus_MPP v x = (
   ( v (|
     Mstatus_bits := ((update_subrange_vec_dec(Mstatus_bits   v) (( 12 :: int)::ii) (( 11 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Mstatus " 
  and  x  :: "(2)Word.word "


\<comment> \<open>\<open>val _get_Mstatus_MPRV : Mstatus -> mword ty1\<close>\<close>

definition get_Mstatus_MPRV  :: \<open> Mstatus \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_Mstatus_MPRV v = ( (subrange_vec_dec(Mstatus_bits   v) (( 17 :: int)::ii) (( 17 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " Mstatus "


\<comment> \<open>\<open>val _set_Mstatus_MPRV : register_ref regstate register_value Mstatus -> mword ty1 -> M unit\<close>\<close>

definition set_Mstatus_MPRV  :: \<open>((regstate),(register_value),(Mstatus))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Mstatus_MPRV r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Mstatus_bits := ((update_subrange_vec_dec(Mstatus_bits   r) (( 17 :: int)::ii) (( 17 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Mstatus))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Mstatus_MPRV : Mstatus -> mword ty1 -> Mstatus\<close>\<close>

definition update_Mstatus_MPRV  :: \<open> Mstatus \<Rightarrow>(1)Word.word \<Rightarrow> Mstatus \<close>  where 
     \<open> update_Mstatus_MPRV v x = (
   ( v (|
     Mstatus_bits := ((update_subrange_vec_dec(Mstatus_bits   v) (( 17 :: int)::ii) (( 17 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Mstatus " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _get_Mstatus_MXR : Mstatus -> mword ty1\<close>\<close>

definition get_Mstatus_MXR  :: \<open> Mstatus \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_Mstatus_MXR v = ( (subrange_vec_dec(Mstatus_bits   v) (( 19 :: int)::ii) (( 19 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " Mstatus "


\<comment> \<open>\<open>val _set_Mstatus_MXR : register_ref regstate register_value Mstatus -> mword ty1 -> M unit\<close>\<close>

definition set_Mstatus_MXR  :: \<open>((regstate),(register_value),(Mstatus))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Mstatus_MXR r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Mstatus_bits := ((update_subrange_vec_dec(Mstatus_bits   r) (( 19 :: int)::ii) (( 19 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Mstatus))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Mstatus_MXR : Mstatus -> mword ty1 -> Mstatus\<close>\<close>

definition update_Mstatus_MXR  :: \<open> Mstatus \<Rightarrow>(1)Word.word \<Rightarrow> Mstatus \<close>  where 
     \<open> update_Mstatus_MXR v x = (
   ( v (|
     Mstatus_bits := ((update_subrange_vec_dec(Mstatus_bits   v) (( 19 :: int)::ii) (( 19 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Mstatus " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Sstatus_MXR : Sstatus -> mword ty1 -> Sstatus\<close>\<close>

\<comment> \<open>\<open>val _get_Sstatus_MXR : Sstatus -> mword ty1\<close>\<close>

\<comment> \<open>\<open>val _set_Sstatus_MXR : register_ref regstate register_value Sstatus -> mword ty1 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _get_Mstatus_SD : Mstatus -> mword ty1\<close>\<close>

definition get_Mstatus_SD  :: \<open> Mstatus \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_Mstatus_SD v = ( (subrange_vec_dec(Mstatus_bits   v) (( 63 :: int)::ii) (( 63 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " Mstatus "


\<comment> \<open>\<open>val _set_Mstatus_SD : register_ref regstate register_value Mstatus -> mword ty1 -> M unit\<close>\<close>

definition set_Mstatus_SD  :: \<open>((regstate),(register_value),(Mstatus))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Mstatus_SD r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Mstatus_bits := ((update_subrange_vec_dec(Mstatus_bits   r) (( 63 :: int)::ii) (( 63 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Mstatus))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Mstatus_SD : Mstatus -> mword ty1 -> Mstatus\<close>\<close>

definition update_Mstatus_SD  :: \<open> Mstatus \<Rightarrow>(1)Word.word \<Rightarrow> Mstatus \<close>  where 
     \<open> update_Mstatus_SD v x = (
   ( v (|
     Mstatus_bits := ((update_subrange_vec_dec(Mstatus_bits   v) (( 63 :: int)::ii) (( 63 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Mstatus " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Sstatus_SD : Sstatus -> mword ty1 -> Sstatus\<close>\<close>

\<comment> \<open>\<open>val _get_Sstatus_SD : Sstatus -> mword ty1\<close>\<close>

\<comment> \<open>\<open>val _set_Sstatus_SD : register_ref regstate register_value Sstatus -> mword ty1 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _get_Mstatus_SIE : Mstatus -> mword ty1\<close>\<close>

definition get_Mstatus_SIE  :: \<open> Mstatus \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_Mstatus_SIE v = ( (subrange_vec_dec(Mstatus_bits   v) (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " Mstatus "


\<comment> \<open>\<open>val _set_Mstatus_SIE : register_ref regstate register_value Mstatus -> mword ty1 -> M unit\<close>\<close>

definition set_Mstatus_SIE  :: \<open>((regstate),(register_value),(Mstatus))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Mstatus_SIE r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Mstatus_bits := ((update_subrange_vec_dec(Mstatus_bits   r) (( 1 :: int)::ii) (( 1 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Mstatus))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Mstatus_SIE : Mstatus -> mword ty1 -> Mstatus\<close>\<close>

definition update_Mstatus_SIE  :: \<open> Mstatus \<Rightarrow>(1)Word.word \<Rightarrow> Mstatus \<close>  where 
     \<open> update_Mstatus_SIE v x = (
   ( v (| Mstatus_bits := ((update_subrange_vec_dec(Mstatus_bits   v) (( 1 :: int)::ii) (( 1 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Mstatus " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Sstatus_SIE : Sstatus -> mword ty1 -> Sstatus\<close>\<close>

\<comment> \<open>\<open>val _get_Sstatus_SIE : Sstatus -> mword ty1\<close>\<close>

\<comment> \<open>\<open>val _set_Sstatus_SIE : register_ref regstate register_value Sstatus -> mword ty1 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _get_Mstatus_SPIE : Mstatus -> mword ty1\<close>\<close>

definition get_Mstatus_SPIE  :: \<open> Mstatus \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_Mstatus_SPIE v = ( (subrange_vec_dec(Mstatus_bits   v) (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " Mstatus "


\<comment> \<open>\<open>val _set_Mstatus_SPIE : register_ref regstate register_value Mstatus -> mword ty1 -> M unit\<close>\<close>

definition set_Mstatus_SPIE  :: \<open>((regstate),(register_value),(Mstatus))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Mstatus_SPIE r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Mstatus_bits := ((update_subrange_vec_dec(Mstatus_bits   r) (( 5 :: int)::ii) (( 5 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Mstatus))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Mstatus_SPIE : Mstatus -> mword ty1 -> Mstatus\<close>\<close>

definition update_Mstatus_SPIE  :: \<open> Mstatus \<Rightarrow>(1)Word.word \<Rightarrow> Mstatus \<close>  where 
     \<open> update_Mstatus_SPIE v x = (
   ( v (| Mstatus_bits := ((update_subrange_vec_dec(Mstatus_bits   v) (( 5 :: int)::ii) (( 5 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Mstatus " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Sstatus_SPIE : Sstatus -> mword ty1 -> Sstatus\<close>\<close>

\<comment> \<open>\<open>val _get_Sstatus_SPIE : Sstatus -> mword ty1\<close>\<close>

\<comment> \<open>\<open>val _set_Sstatus_SPIE : register_ref regstate register_value Sstatus -> mword ty1 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _get_Mstatus_SPP : Mstatus -> mword ty1\<close>\<close>

definition get_Mstatus_SPP  :: \<open> Mstatus \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_Mstatus_SPP v = ( (subrange_vec_dec(Mstatus_bits   v) (( 8 :: int)::ii) (( 8 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " Mstatus "


\<comment> \<open>\<open>val _set_Mstatus_SPP : register_ref regstate register_value Mstatus -> mword ty1 -> M unit\<close>\<close>

definition set_Mstatus_SPP  :: \<open>((regstate),(register_value),(Mstatus))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Mstatus_SPP r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Mstatus_bits := ((update_subrange_vec_dec(Mstatus_bits   r) (( 8 :: int)::ii) (( 8 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Mstatus))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Mstatus_SPP : Mstatus -> mword ty1 -> Mstatus\<close>\<close>

definition update_Mstatus_SPP  :: \<open> Mstatus \<Rightarrow>(1)Word.word \<Rightarrow> Mstatus \<close>  where 
     \<open> update_Mstatus_SPP v x = (
   ( v (| Mstatus_bits := ((update_subrange_vec_dec(Mstatus_bits   v) (( 8 :: int)::ii) (( 8 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Mstatus " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Sstatus_SPP : Sstatus -> mword ty1 -> Sstatus\<close>\<close>

\<comment> \<open>\<open>val _get_Sstatus_SPP : Sstatus -> mword ty1\<close>\<close>

\<comment> \<open>\<open>val _set_Sstatus_SPP : register_ref regstate register_value Sstatus -> mword ty1 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _get_Mstatus_SUM : Mstatus -> mword ty1\<close>\<close>

definition get_Mstatus_SUM  :: \<open> Mstatus \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_Mstatus_SUM v = ( (subrange_vec_dec(Mstatus_bits   v) (( 18 :: int)::ii) (( 18 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " Mstatus "


\<comment> \<open>\<open>val _set_Mstatus_SUM : register_ref regstate register_value Mstatus -> mword ty1 -> M unit\<close>\<close>

definition set_Mstatus_SUM  :: \<open>((regstate),(register_value),(Mstatus))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Mstatus_SUM r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Mstatus_bits := ((update_subrange_vec_dec(Mstatus_bits   r) (( 18 :: int)::ii) (( 18 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Mstatus))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Mstatus_SUM : Mstatus -> mword ty1 -> Mstatus\<close>\<close>

definition update_Mstatus_SUM  :: \<open> Mstatus \<Rightarrow>(1)Word.word \<Rightarrow> Mstatus \<close>  where 
     \<open> update_Mstatus_SUM v x = (
   ( v (|
     Mstatus_bits := ((update_subrange_vec_dec(Mstatus_bits   v) (( 18 :: int)::ii) (( 18 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Mstatus " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Sstatus_SUM : Sstatus -> mword ty1 -> Sstatus\<close>\<close>

\<comment> \<open>\<open>val _get_Sstatus_SUM : Sstatus -> mword ty1\<close>\<close>

\<comment> \<open>\<open>val _set_Sstatus_SUM : register_ref regstate register_value Sstatus -> mword ty1 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _get_Mstatus_TSR : Mstatus -> mword ty1\<close>\<close>

definition get_Mstatus_TSR  :: \<open> Mstatus \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_Mstatus_TSR v = ( (subrange_vec_dec(Mstatus_bits   v) (( 22 :: int)::ii) (( 22 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " Mstatus "


\<comment> \<open>\<open>val _set_Mstatus_TSR : register_ref regstate register_value Mstatus -> mword ty1 -> M unit\<close>\<close>

definition set_Mstatus_TSR  :: \<open>((regstate),(register_value),(Mstatus))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Mstatus_TSR r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Mstatus_bits := ((update_subrange_vec_dec(Mstatus_bits   r) (( 22 :: int)::ii) (( 22 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Mstatus))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Mstatus_TSR : Mstatus -> mword ty1 -> Mstatus\<close>\<close>

definition update_Mstatus_TSR  :: \<open> Mstatus \<Rightarrow>(1)Word.word \<Rightarrow> Mstatus \<close>  where 
     \<open> update_Mstatus_TSR v x = (
   ( v (|
     Mstatus_bits := ((update_subrange_vec_dec(Mstatus_bits   v) (( 22 :: int)::ii) (( 22 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Mstatus " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _get_Mstatus_TVM : Mstatus -> mword ty1\<close>\<close>

definition get_Mstatus_TVM  :: \<open> Mstatus \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_Mstatus_TVM v = ( (subrange_vec_dec(Mstatus_bits   v) (( 20 :: int)::ii) (( 20 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " Mstatus "


\<comment> \<open>\<open>val _set_Mstatus_TVM : register_ref regstate register_value Mstatus -> mword ty1 -> M unit\<close>\<close>

definition set_Mstatus_TVM  :: \<open>((regstate),(register_value),(Mstatus))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Mstatus_TVM r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Mstatus_bits := ((update_subrange_vec_dec(Mstatus_bits   r) (( 20 :: int)::ii) (( 20 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Mstatus))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Mstatus_TVM : Mstatus -> mword ty1 -> Mstatus\<close>\<close>

definition update_Mstatus_TVM  :: \<open> Mstatus \<Rightarrow>(1)Word.word \<Rightarrow> Mstatus \<close>  where 
     \<open> update_Mstatus_TVM v x = (
   ( v (|
     Mstatus_bits := ((update_subrange_vec_dec(Mstatus_bits   v) (( 20 :: int)::ii) (( 20 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Mstatus " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _get_Mstatus_TW : Mstatus -> mword ty1\<close>\<close>

definition get_Mstatus_TW  :: \<open> Mstatus \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_Mstatus_TW v = ( (subrange_vec_dec(Mstatus_bits   v) (( 21 :: int)::ii) (( 21 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " Mstatus "


\<comment> \<open>\<open>val _set_Mstatus_TW : register_ref regstate register_value Mstatus -> mword ty1 -> M unit\<close>\<close>

definition set_Mstatus_TW  :: \<open>((regstate),(register_value),(Mstatus))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Mstatus_TW r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Mstatus_bits := ((update_subrange_vec_dec(Mstatus_bits   r) (( 21 :: int)::ii) (( 21 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Mstatus))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Mstatus_TW : Mstatus -> mword ty1 -> Mstatus\<close>\<close>

definition update_Mstatus_TW  :: \<open> Mstatus \<Rightarrow>(1)Word.word \<Rightarrow> Mstatus \<close>  where 
     \<open> update_Mstatus_TW v x = (
   ( v (|
     Mstatus_bits := ((update_subrange_vec_dec(Mstatus_bits   v) (( 21 :: int)::ii) (( 21 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Mstatus " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _get_Mstatus_UIE : Mstatus -> mword ty1\<close>\<close>

definition get_Mstatus_UIE  :: \<open> Mstatus \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_Mstatus_UIE v = ( (subrange_vec_dec(Mstatus_bits   v) (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " Mstatus "


\<comment> \<open>\<open>val _set_Mstatus_UIE : register_ref regstate register_value Mstatus -> mword ty1 -> M unit\<close>\<close>

definition set_Mstatus_UIE  :: \<open>((regstate),(register_value),(Mstatus))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Mstatus_UIE r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Mstatus_bits := ((update_subrange_vec_dec(Mstatus_bits   r) (( 0 :: int)::ii) (( 0 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Mstatus))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Mstatus_UIE : Mstatus -> mword ty1 -> Mstatus\<close>\<close>

definition update_Mstatus_UIE  :: \<open> Mstatus \<Rightarrow>(1)Word.word \<Rightarrow> Mstatus \<close>  where 
     \<open> update_Mstatus_UIE v x = (
   ( v (| Mstatus_bits := ((update_subrange_vec_dec(Mstatus_bits   v) (( 0 :: int)::ii) (( 0 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Mstatus " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Sstatus_UIE : Sstatus -> mword ty1 -> Sstatus\<close>\<close>

\<comment> \<open>\<open>val _update_Ustatus_UIE : Ustatus -> mword ty1 -> Ustatus\<close>\<close>

\<comment> \<open>\<open>val _get_Sstatus_UIE : Sstatus -> mword ty1\<close>\<close>

\<comment> \<open>\<open>val _get_Ustatus_UIE : Ustatus -> mword ty1\<close>\<close>

\<comment> \<open>\<open>val _set_Sstatus_UIE : register_ref regstate register_value Sstatus -> mword ty1 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _set_Ustatus_UIE : register_ref regstate register_value Ustatus -> mword ty1 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _get_Mstatus_UPIE : Mstatus -> mword ty1\<close>\<close>

definition get_Mstatus_UPIE  :: \<open> Mstatus \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_Mstatus_UPIE v = ( (subrange_vec_dec(Mstatus_bits   v) (( 4 :: int)::ii) (( 4 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " Mstatus "


\<comment> \<open>\<open>val _set_Mstatus_UPIE : register_ref regstate register_value Mstatus -> mword ty1 -> M unit\<close>\<close>

definition set_Mstatus_UPIE  :: \<open>((regstate),(register_value),(Mstatus))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Mstatus_UPIE r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Mstatus_bits := ((update_subrange_vec_dec(Mstatus_bits   r) (( 4 :: int)::ii) (( 4 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Mstatus))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Mstatus_UPIE : Mstatus -> mword ty1 -> Mstatus\<close>\<close>

definition update_Mstatus_UPIE  :: \<open> Mstatus \<Rightarrow>(1)Word.word \<Rightarrow> Mstatus \<close>  where 
     \<open> update_Mstatus_UPIE v x = (
   ( v (| Mstatus_bits := ((update_subrange_vec_dec(Mstatus_bits   v) (( 4 :: int)::ii) (( 4 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Mstatus " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Sstatus_UPIE : Sstatus -> mword ty1 -> Sstatus\<close>\<close>

\<comment> \<open>\<open>val _update_Ustatus_UPIE : Ustatus -> mword ty1 -> Ustatus\<close>\<close>

\<comment> \<open>\<open>val _get_Sstatus_UPIE : Sstatus -> mword ty1\<close>\<close>

\<comment> \<open>\<open>val _get_Ustatus_UPIE : Ustatus -> mword ty1\<close>\<close>

\<comment> \<open>\<open>val _set_Sstatus_UPIE : register_ref regstate register_value Sstatus -> mword ty1 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _set_Ustatus_UPIE : register_ref regstate register_value Ustatus -> mword ty1 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _get_Mstatus_XS : Mstatus -> mword ty2\<close>\<close>

definition get_Mstatus_XS  :: \<open> Mstatus \<Rightarrow>(2)Word.word \<close>  where 
     \<open> get_Mstatus_XS v = ( (subrange_vec_dec(Mstatus_bits   v) (( 16 :: int)::ii) (( 15 :: int)::ii)  ::  2 Word.word))\<close> 
  for  v  :: " Mstatus "


\<comment> \<open>\<open>val _set_Mstatus_XS : register_ref regstate register_value Mstatus -> mword ty2 -> M unit\<close>\<close>

definition set_Mstatus_XS  :: \<open>((regstate),(register_value),(Mstatus))register_ref \<Rightarrow>(2)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Mstatus_XS r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Mstatus_bits := ((update_subrange_vec_dec(Mstatus_bits   r) (( 16 :: int)::ii) (( 15 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Mstatus))register_ref " 
  and  v  :: "(2)Word.word "


\<comment> \<open>\<open>val _update_Mstatus_XS : Mstatus -> mword ty2 -> Mstatus\<close>\<close>

definition update_Mstatus_XS  :: \<open> Mstatus \<Rightarrow>(2)Word.word \<Rightarrow> Mstatus \<close>  where 
     \<open> update_Mstatus_XS v x = (
   ( v (|
     Mstatus_bits := ((update_subrange_vec_dec(Mstatus_bits   v) (( 16 :: int)::ii) (( 15 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Mstatus " 
  and  x  :: "(2)Word.word "


\<comment> \<open>\<open>val _update_Sstatus_XS : Sstatus -> mword ty2 -> Sstatus\<close>\<close>

\<comment> \<open>\<open>val _get_Sstatus_XS : Sstatus -> mword ty2\<close>\<close>

\<comment> \<open>\<open>val _set_Sstatus_XS : register_ref regstate register_value Sstatus -> mword ty2 -> M unit\<close>\<close>

\<comment> \<open>\<open>val effectivePrivilege : AccessType unit -> Mstatus -> Privilege -> M Privilege\<close>\<close>

definition effectivePrivilege  :: \<open>(ext_access_type)AccessType \<Rightarrow> Mstatus \<Rightarrow> Privilege \<Rightarrow>((register_value),(Privilege),(exception))monad \<close>  where 
     \<open> effectivePrivilege (t :: ext_access_type AccessType) (m :: Mstatus) (priv :: Privilege) = (
   if ((((((t \<noteq> (Execute () )))) \<and> (((((get_Mstatus_MPRV m  ::  1 Word.word)) = ( 0b1 ::  1 Word.word))))))) then
     privLevel_of_bits ((get_Mstatus_MPP m  ::  2 Word.word))
   else return priv )\<close> 
  for  t  :: "(ext_access_type)AccessType " 
  and  m  :: " Mstatus " 
  and  priv  :: " Privilege "


\<comment> \<open>\<open>val get_mstatus_SXL : Mstatus -> mword ty2\<close>\<close>

definition get_mstatus_SXL  :: \<open> Mstatus \<Rightarrow>(2)Word.word \<close>  where 
     \<open> get_mstatus_SXL m = (
   (subrange_vec_dec ((get_Mstatus_bits m  ::  64 Word.word)) (( 35 :: int)::ii) (( 34 :: int)::ii)  ::  2 Word.word))\<close> 
  for  m  :: " Mstatus "


\<comment> \<open>\<open>val set_mstatus_SXL : Mstatus -> mword ty2 -> Mstatus\<close>\<close>

definition set_mstatus_SXL  :: \<open> Mstatus \<Rightarrow>(2)Word.word \<Rightarrow> Mstatus \<close>  where 
     \<open> set_mstatus_SXL (m :: Mstatus) (a :: arch_xlen) = (
   (let m =
     ((update_subrange_vec_dec ((get_Mstatus_bits m  ::  64 Word.word)) (( 35 :: int)::ii) (( 34 :: int)::ii) a  ::  64 Word.word)) in
   Mk_Mstatus m))\<close> 
  for  m  :: " Mstatus " 
  and  a  :: "(2)Word.word "


\<comment> \<open>\<open>val get_mstatus_UXL : Mstatus -> mword ty2\<close>\<close>

definition get_mstatus_UXL  :: \<open> Mstatus \<Rightarrow>(2)Word.word \<close>  where 
     \<open> get_mstatus_UXL m = (
   (subrange_vec_dec ((get_Mstatus_bits m  ::  64 Word.word)) (( 33 :: int)::ii) (( 32 :: int)::ii)  ::  2 Word.word))\<close> 
  for  m  :: " Mstatus "


\<comment> \<open>\<open>val set_mstatus_UXL : Mstatus -> mword ty2 -> Mstatus\<close>\<close>

definition set_mstatus_UXL  :: \<open> Mstatus \<Rightarrow>(2)Word.word \<Rightarrow> Mstatus \<close>  where 
     \<open> set_mstatus_UXL (m :: Mstatus) (a :: arch_xlen) = (
   (let m =
     ((update_subrange_vec_dec ((get_Mstatus_bits m  ::  64 Word.word)) (( 33 :: int)::ii) (( 32 :: int)::ii) a  ::  64 Word.word)) in
   Mk_Mstatus m))\<close> 
  for  m  :: " Mstatus " 
  and  a  :: "(2)Word.word "


\<comment> \<open>\<open>val legalize_mstatus : Mstatus -> mword ty64 -> M Mstatus\<close>\<close>

definition legalize_mstatus  :: \<open> Mstatus \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),(Mstatus),(exception))monad \<close>  where 
     \<open> legalize_mstatus (o1 :: Mstatus) (v :: xlenbits) = (
   (let (m :: Mstatus) =
     (Mk_Mstatus
       ((EXTZ (( 64 :: int)::ii)
           ((concat_vec ((subrange_vec_dec v (( 22 :: int)::ii) (( 11 :: int)::ii)  ::  12 Word.word))
               ((concat_vec ( 0b00 ::  2 Word.word)
                   ((concat_vec ((subrange_vec_dec v (( 8 :: int)::ii) (( 7 :: int)::ii)  ::  2 Word.word))
                       ((concat_vec ( 0b0 ::  1 Word.word)
                           ((concat_vec ((subrange_vec_dec v (( 5 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word))
                               ((concat_vec ( 0b0 ::  1 Word.word)
                                   ((subrange_vec_dec v (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word))
                                  ::  3 Word.word))
                              ::  6 Word.word))
                          ::  7 Word.word))
                      ::  9 Word.word))
                  ::  11 Word.word))
              ::  23 Word.word))
          ::  64 Word.word))) in
   (let m = (update_Mstatus_XS m ((extStatus_to_bits Off  ::  2 Word.word))) in
   or_boolM
     (extStatus_of_bits ((get_Mstatus_FS m  ::  2 Word.word)) \<bind> ((\<lambda> (w__0 :: ExtStatus) . 
      return (((w__0 = Dirty))))))
     (extStatus_of_bits ((get_Mstatus_XS m  ::  2 Word.word)) \<bind> ((\<lambda> (w__1 :: ExtStatus) . 
      return (((w__1 = Dirty)))))) \<bind> ((\<lambda> dirty . 
   (let m = (update_Mstatus_SD m ((bool_to_bits dirty  ::  1 Word.word))) in
   (let m = (set_mstatus_SXL m ((get_mstatus_SXL o1  ::  2 Word.word))) in
   (let m = (set_mstatus_UXL m ((get_mstatus_UXL o1  ::  2 Word.word))) in
   (let m =
     (Mk_Mstatus
       ((update_subrange_vec_dec ((get_Mstatus_bits m  ::  64 Word.word)) (( 37 :: int)::ii) (( 36 :: int)::ii)
           ( 0b00 ::  2 Word.word)
          ::  64 Word.word))) in
   haveNExt ()  \<bind> ((\<lambda> (w__2 :: bool) . 
   (let m =
     (if ((\<not> w__2)) then
       (let m = (update_Mstatus_UPIE m ( 0b0 ::  1 Word.word)) in
       update_Mstatus_UIE m ( 0b0 ::  1 Word.word))
     else m) in
   haveUsrMode ()  \<bind> ((\<lambda> (w__3 :: bool) . 
   return (if ((\<not> w__3)) then update_Mstatus_MPRV m ( 0b0 ::  1 Word.word)
           else m)))))))))))))))\<close> 
  for  o1  :: " Mstatus " 
  and  v  :: "(64)Word.word "


\<comment> \<open>\<open>val cur_Architecture : unit -> M Architecture\<close>\<close>

definition cur_Architecture  :: \<open> unit \<Rightarrow>((register_value),(Architecture),(exception))monad \<close>  where 
     \<open> cur_Architecture _ = (
   read_reg cur_privilege_ref \<bind> ((\<lambda> (w__0 :: Privilege) . 
   (case  w__0 of
     Machine =>
      read_reg misa_ref \<bind> ((\<lambda> (w__1 :: Misa) .  return ((get_Misa_MXL w__1  ::  2 Word.word))))
   | Supervisor =>
      read_reg mstatus_ref \<bind> ((\<lambda> (w__2 :: Mstatus) .  return ((get_mstatus_SXL w__2  ::  2 Word.word))))
   | User =>
      read_reg mstatus_ref \<bind> ((\<lambda> (w__3 :: Mstatus) .  return ((get_mstatus_UXL w__3  ::  2 Word.word))))
   ) \<bind> ((\<lambda> (a :: arch_xlen) . 
   (case  ((architecture a)) of
     Some (a) => return a
   | None => internal_error (''Invalid current architecture'')
   ))))))\<close>


\<comment> \<open>\<open>val in32BitMode : unit -> M bool\<close>\<close>

definition in32BitMode  :: \<open> unit \<Rightarrow>((register_value),(bool),(exception))monad \<close>  where 
     \<open> in32BitMode _ = ( cur_Architecture ()  \<bind> ((\<lambda> (w__0 :: Architecture) .  return (((w__0 = RV32))))))\<close>


\<comment> \<open>\<open>val haveFExt : unit -> M bool\<close>\<close>

definition haveFExt  :: \<open> unit \<Rightarrow>((register_value),(bool),(exception))monad \<close>  where 
     \<open> haveFExt _ = (
   and_boolM
     (read_reg misa_ref \<bind> ((\<lambda> (w__0 :: Misa) . 
      return (((((get_Misa_F w__0  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))))))
     (read_reg mstatus_ref \<bind> ((\<lambda> (w__1 :: Mstatus) . 
      return (((((get_Mstatus_FS w__1  ::  2 Word.word)) \<noteq> ( 0b00 ::  2 Word.word))))))))\<close>


\<comment> \<open>\<open>val haveDExt : unit -> M bool\<close>\<close>

definition haveDExt  :: \<open> unit \<Rightarrow>((register_value),(bool),(exception))monad \<close>  where 
     \<open> haveDExt _ = (
   and_boolM
     (read_reg misa_ref \<bind> ((\<lambda> (w__0 :: Misa) . 
      return (((((get_Misa_D w__0  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))))))
     (read_reg mstatus_ref \<bind> ((\<lambda> (w__1 :: Mstatus) . 
      return (((((get_Mstatus_FS w__1  ::  2 Word.word)) \<noteq> ( 0b00 ::  2 Word.word))))))))\<close>


\<comment> \<open>\<open>val undefined_Minterrupts : unit -> M Minterrupts\<close>\<close>

definition undefined_Minterrupts  :: \<open> unit \<Rightarrow>((register_value),(Minterrupts),(exception))monad \<close>  where 
     \<open> undefined_Minterrupts _ = (
   ((return (failwith (''undefined value of unsupported type''))) :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::
      64 Word.word) . 
   return ((| Minterrupts_bits = w__0 |)))))\<close>


\<comment> \<open>\<open>val Mk_Minterrupts : mword ty64 -> Minterrupts\<close>\<close>

definition Mk_Minterrupts  :: \<open>(64)Word.word \<Rightarrow> Minterrupts \<close>  where 
     \<open> Mk_Minterrupts v = ( (| Minterrupts_bits = v |) )\<close> 
  for  v  :: "(64)Word.word "


definition get_Minterrupts_bits  :: \<open> Minterrupts \<Rightarrow>(64)Word.word \<close>  where 
     \<open> get_Minterrupts_bits v = ( (subrange_vec_dec(Minterrupts_bits   v) (( 63 :: int)::ii) (( 0 :: int)::ii)  ::  64 Word.word))\<close> 
  for  v  :: " Minterrupts "


definition set_Minterrupts_bits  :: \<open>((regstate),(register_value),(Minterrupts))register_ref \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Minterrupts_bits r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Minterrupts_bits :=
         ((update_subrange_vec_dec(Minterrupts_bits   r) (( 63 :: int)::ii) (( 0 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Minterrupts))register_ref " 
  and  v  :: "(64)Word.word "


definition update_Minterrupts_bits  :: \<open> Minterrupts \<Rightarrow>(64)Word.word \<Rightarrow> Minterrupts \<close>  where 
     \<open> update_Minterrupts_bits v x = (
   ( v (|
     Minterrupts_bits :=
       ((update_subrange_vec_dec(Minterrupts_bits   v) (( 63 :: int)::ii) (( 0 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Minterrupts " 
  and  x  :: "(64)Word.word "


\<comment> \<open>\<open>val _get_Minterrupts_MEI : Minterrupts -> mword ty1\<close>\<close>

definition get_Minterrupts_MEI  :: \<open> Minterrupts \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_Minterrupts_MEI v = ( (subrange_vec_dec(Minterrupts_bits   v) (( 11 :: int)::ii) (( 11 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " Minterrupts "


\<comment> \<open>\<open>val _set_Minterrupts_MEI : register_ref regstate register_value Minterrupts -> mword ty1 -> M unit\<close>\<close>

definition set_Minterrupts_MEI  :: \<open>((regstate),(register_value),(Minterrupts))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Minterrupts_MEI r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Minterrupts_bits :=
         ((update_subrange_vec_dec(Minterrupts_bits   r) (( 11 :: int)::ii) (( 11 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Minterrupts))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Minterrupts_MEI : Minterrupts -> mword ty1 -> Minterrupts\<close>\<close>

definition update_Minterrupts_MEI  :: \<open> Minterrupts \<Rightarrow>(1)Word.word \<Rightarrow> Minterrupts \<close>  where 
     \<open> update_Minterrupts_MEI v x = (
   ( v (|
     Minterrupts_bits :=
       ((update_subrange_vec_dec(Minterrupts_bits   v) (( 11 :: int)::ii) (( 11 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Minterrupts " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _get_Minterrupts_MSI : Minterrupts -> mword ty1\<close>\<close>

definition get_Minterrupts_MSI  :: \<open> Minterrupts \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_Minterrupts_MSI v = ( (subrange_vec_dec(Minterrupts_bits   v) (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " Minterrupts "


\<comment> \<open>\<open>val _set_Minterrupts_MSI : register_ref regstate register_value Minterrupts -> mword ty1 -> M unit\<close>\<close>

definition set_Minterrupts_MSI  :: \<open>((regstate),(register_value),(Minterrupts))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Minterrupts_MSI r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Minterrupts_bits :=
         ((update_subrange_vec_dec(Minterrupts_bits   r) (( 3 :: int)::ii) (( 3 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Minterrupts))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Minterrupts_MSI : Minterrupts -> mword ty1 -> Minterrupts\<close>\<close>

definition update_Minterrupts_MSI  :: \<open> Minterrupts \<Rightarrow>(1)Word.word \<Rightarrow> Minterrupts \<close>  where 
     \<open> update_Minterrupts_MSI v x = (
   ( v (|
     Minterrupts_bits := ((update_subrange_vec_dec(Minterrupts_bits   v) (( 3 :: int)::ii) (( 3 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Minterrupts " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _get_Minterrupts_MTI : Minterrupts -> mword ty1\<close>\<close>

definition get_Minterrupts_MTI  :: \<open> Minterrupts \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_Minterrupts_MTI v = ( (subrange_vec_dec(Minterrupts_bits   v) (( 7 :: int)::ii) (( 7 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " Minterrupts "


\<comment> \<open>\<open>val _set_Minterrupts_MTI : register_ref regstate register_value Minterrupts -> mword ty1 -> M unit\<close>\<close>

definition set_Minterrupts_MTI  :: \<open>((regstate),(register_value),(Minterrupts))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Minterrupts_MTI r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Minterrupts_bits :=
         ((update_subrange_vec_dec(Minterrupts_bits   r) (( 7 :: int)::ii) (( 7 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Minterrupts))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Minterrupts_MTI : Minterrupts -> mword ty1 -> Minterrupts\<close>\<close>

definition update_Minterrupts_MTI  :: \<open> Minterrupts \<Rightarrow>(1)Word.word \<Rightarrow> Minterrupts \<close>  where 
     \<open> update_Minterrupts_MTI v x = (
   ( v (|
     Minterrupts_bits := ((update_subrange_vec_dec(Minterrupts_bits   v) (( 7 :: int)::ii) (( 7 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Minterrupts " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _get_Minterrupts_SEI : Minterrupts -> mword ty1\<close>\<close>

definition get_Minterrupts_SEI  :: \<open> Minterrupts \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_Minterrupts_SEI v = ( (subrange_vec_dec(Minterrupts_bits   v) (( 9 :: int)::ii) (( 9 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " Minterrupts "


\<comment> \<open>\<open>val _set_Minterrupts_SEI : register_ref regstate register_value Minterrupts -> mword ty1 -> M unit\<close>\<close>

definition set_Minterrupts_SEI  :: \<open>((regstate),(register_value),(Minterrupts))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Minterrupts_SEI r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Minterrupts_bits :=
         ((update_subrange_vec_dec(Minterrupts_bits   r) (( 9 :: int)::ii) (( 9 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Minterrupts))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Minterrupts_SEI : Minterrupts -> mword ty1 -> Minterrupts\<close>\<close>

definition update_Minterrupts_SEI  :: \<open> Minterrupts \<Rightarrow>(1)Word.word \<Rightarrow> Minterrupts \<close>  where 
     \<open> update_Minterrupts_SEI v x = (
   ( v (|
     Minterrupts_bits := ((update_subrange_vec_dec(Minterrupts_bits   v) (( 9 :: int)::ii) (( 9 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Minterrupts " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Sinterrupts_SEI : Sinterrupts -> mword ty1 -> Sinterrupts\<close>\<close>

\<comment> \<open>\<open>val _get_Sinterrupts_SEI : Sinterrupts -> mword ty1\<close>\<close>

\<comment> \<open>\<open>val _set_Sinterrupts_SEI : register_ref regstate register_value Sinterrupts -> mword ty1 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _get_Minterrupts_SSI : Minterrupts -> mword ty1\<close>\<close>

definition get_Minterrupts_SSI  :: \<open> Minterrupts \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_Minterrupts_SSI v = ( (subrange_vec_dec(Minterrupts_bits   v) (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " Minterrupts "


\<comment> \<open>\<open>val _set_Minterrupts_SSI : register_ref regstate register_value Minterrupts -> mword ty1 -> M unit\<close>\<close>

definition set_Minterrupts_SSI  :: \<open>((regstate),(register_value),(Minterrupts))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Minterrupts_SSI r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Minterrupts_bits :=
         ((update_subrange_vec_dec(Minterrupts_bits   r) (( 1 :: int)::ii) (( 1 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Minterrupts))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Minterrupts_SSI : Minterrupts -> mword ty1 -> Minterrupts\<close>\<close>

definition update_Minterrupts_SSI  :: \<open> Minterrupts \<Rightarrow>(1)Word.word \<Rightarrow> Minterrupts \<close>  where 
     \<open> update_Minterrupts_SSI v x = (
   ( v (|
     Minterrupts_bits := ((update_subrange_vec_dec(Minterrupts_bits   v) (( 1 :: int)::ii) (( 1 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Minterrupts " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Sinterrupts_SSI : Sinterrupts -> mword ty1 -> Sinterrupts\<close>\<close>

\<comment> \<open>\<open>val _get_Sinterrupts_SSI : Sinterrupts -> mword ty1\<close>\<close>

\<comment> \<open>\<open>val _set_Sinterrupts_SSI : register_ref regstate register_value Sinterrupts -> mword ty1 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _get_Minterrupts_STI : Minterrupts -> mword ty1\<close>\<close>

definition get_Minterrupts_STI  :: \<open> Minterrupts \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_Minterrupts_STI v = ( (subrange_vec_dec(Minterrupts_bits   v) (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " Minterrupts "


\<comment> \<open>\<open>val _set_Minterrupts_STI : register_ref regstate register_value Minterrupts -> mword ty1 -> M unit\<close>\<close>

definition set_Minterrupts_STI  :: \<open>((regstate),(register_value),(Minterrupts))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Minterrupts_STI r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Minterrupts_bits :=
         ((update_subrange_vec_dec(Minterrupts_bits   r) (( 5 :: int)::ii) (( 5 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Minterrupts))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Minterrupts_STI : Minterrupts -> mword ty1 -> Minterrupts\<close>\<close>

definition update_Minterrupts_STI  :: \<open> Minterrupts \<Rightarrow>(1)Word.word \<Rightarrow> Minterrupts \<close>  where 
     \<open> update_Minterrupts_STI v x = (
   ( v (|
     Minterrupts_bits := ((update_subrange_vec_dec(Minterrupts_bits   v) (( 5 :: int)::ii) (( 5 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Minterrupts " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Sinterrupts_STI : Sinterrupts -> mword ty1 -> Sinterrupts\<close>\<close>

\<comment> \<open>\<open>val _get_Sinterrupts_STI : Sinterrupts -> mword ty1\<close>\<close>

\<comment> \<open>\<open>val _set_Sinterrupts_STI : register_ref regstate register_value Sinterrupts -> mword ty1 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _get_Minterrupts_UEI : Minterrupts -> mword ty1\<close>\<close>

definition get_Minterrupts_UEI  :: \<open> Minterrupts \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_Minterrupts_UEI v = ( (subrange_vec_dec(Minterrupts_bits   v) (( 8 :: int)::ii) (( 8 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " Minterrupts "


\<comment> \<open>\<open>val _set_Minterrupts_UEI : register_ref regstate register_value Minterrupts -> mword ty1 -> M unit\<close>\<close>

definition set_Minterrupts_UEI  :: \<open>((regstate),(register_value),(Minterrupts))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Minterrupts_UEI r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Minterrupts_bits :=
         ((update_subrange_vec_dec(Minterrupts_bits   r) (( 8 :: int)::ii) (( 8 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Minterrupts))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Minterrupts_UEI : Minterrupts -> mword ty1 -> Minterrupts\<close>\<close>

definition update_Minterrupts_UEI  :: \<open> Minterrupts \<Rightarrow>(1)Word.word \<Rightarrow> Minterrupts \<close>  where 
     \<open> update_Minterrupts_UEI v x = (
   ( v (|
     Minterrupts_bits := ((update_subrange_vec_dec(Minterrupts_bits   v) (( 8 :: int)::ii) (( 8 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Minterrupts " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Sinterrupts_UEI : Sinterrupts -> mword ty1 -> Sinterrupts\<close>\<close>

\<comment> \<open>\<open>val _update_Uinterrupts_UEI : Uinterrupts -> mword ty1 -> Uinterrupts\<close>\<close>

\<comment> \<open>\<open>val _get_Sinterrupts_UEI : Sinterrupts -> mword ty1\<close>\<close>

\<comment> \<open>\<open>val _get_Uinterrupts_UEI : Uinterrupts -> mword ty1\<close>\<close>

\<comment> \<open>\<open>val _set_Sinterrupts_UEI : register_ref regstate register_value Sinterrupts -> mword ty1 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _set_Uinterrupts_UEI : register_ref regstate register_value Uinterrupts -> mword ty1 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _get_Minterrupts_USI : Minterrupts -> mword ty1\<close>\<close>

definition get_Minterrupts_USI  :: \<open> Minterrupts \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_Minterrupts_USI v = ( (subrange_vec_dec(Minterrupts_bits   v) (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " Minterrupts "


\<comment> \<open>\<open>val _set_Minterrupts_USI : register_ref regstate register_value Minterrupts -> mword ty1 -> M unit\<close>\<close>

definition set_Minterrupts_USI  :: \<open>((regstate),(register_value),(Minterrupts))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Minterrupts_USI r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Minterrupts_bits :=
         ((update_subrange_vec_dec(Minterrupts_bits   r) (( 0 :: int)::ii) (( 0 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Minterrupts))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Minterrupts_USI : Minterrupts -> mword ty1 -> Minterrupts\<close>\<close>

definition update_Minterrupts_USI  :: \<open> Minterrupts \<Rightarrow>(1)Word.word \<Rightarrow> Minterrupts \<close>  where 
     \<open> update_Minterrupts_USI v x = (
   ( v (|
     Minterrupts_bits := ((update_subrange_vec_dec(Minterrupts_bits   v) (( 0 :: int)::ii) (( 0 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Minterrupts " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Sinterrupts_USI : Sinterrupts -> mword ty1 -> Sinterrupts\<close>\<close>

\<comment> \<open>\<open>val _update_Uinterrupts_USI : Uinterrupts -> mword ty1 -> Uinterrupts\<close>\<close>

\<comment> \<open>\<open>val _get_Sinterrupts_USI : Sinterrupts -> mword ty1\<close>\<close>

\<comment> \<open>\<open>val _get_Uinterrupts_USI : Uinterrupts -> mword ty1\<close>\<close>

\<comment> \<open>\<open>val _set_Sinterrupts_USI : register_ref regstate register_value Sinterrupts -> mword ty1 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _set_Uinterrupts_USI : register_ref regstate register_value Uinterrupts -> mword ty1 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _get_Minterrupts_UTI : Minterrupts -> mword ty1\<close>\<close>

definition get_Minterrupts_UTI  :: \<open> Minterrupts \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_Minterrupts_UTI v = ( (subrange_vec_dec(Minterrupts_bits   v) (( 4 :: int)::ii) (( 4 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " Minterrupts "


\<comment> \<open>\<open>val _set_Minterrupts_UTI : register_ref regstate register_value Minterrupts -> mword ty1 -> M unit\<close>\<close>

definition set_Minterrupts_UTI  :: \<open>((regstate),(register_value),(Minterrupts))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Minterrupts_UTI r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Minterrupts_bits :=
         ((update_subrange_vec_dec(Minterrupts_bits   r) (( 4 :: int)::ii) (( 4 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Minterrupts))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Minterrupts_UTI : Minterrupts -> mword ty1 -> Minterrupts\<close>\<close>

definition update_Minterrupts_UTI  :: \<open> Minterrupts \<Rightarrow>(1)Word.word \<Rightarrow> Minterrupts \<close>  where 
     \<open> update_Minterrupts_UTI v x = (
   ( v (|
     Minterrupts_bits := ((update_subrange_vec_dec(Minterrupts_bits   v) (( 4 :: int)::ii) (( 4 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Minterrupts " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Sinterrupts_UTI : Sinterrupts -> mword ty1 -> Sinterrupts\<close>\<close>

\<comment> \<open>\<open>val _update_Uinterrupts_UTI : Uinterrupts -> mword ty1 -> Uinterrupts\<close>\<close>

\<comment> \<open>\<open>val _get_Sinterrupts_UTI : Sinterrupts -> mword ty1\<close>\<close>

\<comment> \<open>\<open>val _get_Uinterrupts_UTI : Uinterrupts -> mword ty1\<close>\<close>

\<comment> \<open>\<open>val _set_Sinterrupts_UTI : register_ref regstate register_value Sinterrupts -> mword ty1 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _set_Uinterrupts_UTI : register_ref regstate register_value Uinterrupts -> mword ty1 -> M unit\<close>\<close>

\<comment> \<open>\<open>val legalize_mip : Minterrupts -> mword ty64 -> M Minterrupts\<close>\<close>

definition legalize_mip  :: \<open> Minterrupts \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),(Minterrupts),(exception))monad \<close>  where 
     \<open> legalize_mip (o1 :: Minterrupts) (v :: xlenbits) = (
   (let v = (Mk_Minterrupts v) in
   (let m = (update_Minterrupts_SEI o1 ((get_Minterrupts_SEI v  ::  1 Word.word))) in
   (let m = (update_Minterrupts_STI m ((get_Minterrupts_STI v  ::  1 Word.word))) in
   (let m = (update_Minterrupts_SSI m ((get_Minterrupts_SSI v  ::  1 Word.word))) in
   and_boolM ((haveUsrMode () )) ((haveNExt () )) \<bind> ((\<lambda> (w__2 :: bool) . 
   return (if w__2 then
             (let m = (update_Minterrupts_UEI m ((get_Minterrupts_UEI v  ::  1 Word.word))) in
             (let m = (update_Minterrupts_UTI m ((get_Minterrupts_UTI v  ::  1 Word.word))) in
             update_Minterrupts_USI m ((get_Minterrupts_USI v  ::  1 Word.word))))
           else m))))))))\<close> 
  for  o1  :: " Minterrupts " 
  and  v  :: "(64)Word.word "


\<comment> \<open>\<open>val legalize_mie : Minterrupts -> mword ty64 -> M Minterrupts\<close>\<close>

definition legalize_mie  :: \<open> Minterrupts \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),(Minterrupts),(exception))monad \<close>  where 
     \<open> legalize_mie (o1 :: Minterrupts) (v :: xlenbits) = (
   (let v = (Mk_Minterrupts v) in
   (let m = (update_Minterrupts_MEI o1 ((get_Minterrupts_MEI v  ::  1 Word.word))) in
   (let m = (update_Minterrupts_MTI m ((get_Minterrupts_MTI v  ::  1 Word.word))) in
   (let m = (update_Minterrupts_MSI m ((get_Minterrupts_MSI v  ::  1 Word.word))) in
   (let m = (update_Minterrupts_SEI m ((get_Minterrupts_SEI v  ::  1 Word.word))) in
   (let m = (update_Minterrupts_STI m ((get_Minterrupts_STI v  ::  1 Word.word))) in
   (let m = (update_Minterrupts_SSI m ((get_Minterrupts_SSI v  ::  1 Word.word))) in
   and_boolM ((haveUsrMode () )) ((haveNExt () )) \<bind> ((\<lambda> (w__2 :: bool) . 
   return (if w__2 then
             (let m = (update_Minterrupts_UEI m ((get_Minterrupts_UEI v  ::  1 Word.word))) in
             (let m = (update_Minterrupts_UTI m ((get_Minterrupts_UTI v  ::  1 Word.word))) in
             update_Minterrupts_USI m ((get_Minterrupts_USI v  ::  1 Word.word))))
           else m)))))))))))\<close> 
  for  o1  :: " Minterrupts " 
  and  v  :: "(64)Word.word "


\<comment> \<open>\<open>val legalize_mideleg : Minterrupts -> mword ty64 -> Minterrupts\<close>\<close>

definition legalize_mideleg  :: \<open> Minterrupts \<Rightarrow>(64)Word.word \<Rightarrow> Minterrupts \<close>  where 
     \<open> legalize_mideleg (o1 :: Minterrupts) (v :: xlenbits) = (
   (let m = (Mk_Minterrupts v) in
   (let m = (update_Minterrupts_MEI m ( 0b0 ::  1 Word.word)) in
   (let m = (update_Minterrupts_MTI m ( 0b0 ::  1 Word.word)) in
   update_Minterrupts_MSI m ( 0b0 ::  1 Word.word)))))\<close> 
  for  o1  :: " Minterrupts " 
  and  v  :: "(64)Word.word "


\<comment> \<open>\<open>val undefined_Medeleg : unit -> M Medeleg\<close>\<close>

definition undefined_Medeleg  :: \<open> unit \<Rightarrow>((register_value),(Medeleg),(exception))monad \<close>  where 
     \<open> undefined_Medeleg _ = (
   ((return (failwith (''undefined value of unsupported type''))) :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::
      64 Word.word) . 
   return ((| Medeleg_bits = w__0 |)))))\<close>


\<comment> \<open>\<open>val Mk_Medeleg : mword ty64 -> Medeleg\<close>\<close>

definition Mk_Medeleg  :: \<open>(64)Word.word \<Rightarrow> Medeleg \<close>  where 
     \<open> Mk_Medeleg v = ( (| Medeleg_bits = v |) )\<close> 
  for  v  :: "(64)Word.word "


definition get_Medeleg_bits  :: \<open> Medeleg \<Rightarrow>(64)Word.word \<close>  where 
     \<open> get_Medeleg_bits v = ( (subrange_vec_dec(Medeleg_bits   v) (( 63 :: int)::ii) (( 0 :: int)::ii)  ::  64 Word.word))\<close> 
  for  v  :: " Medeleg "


definition set_Medeleg_bits  :: \<open>((regstate),(register_value),(Medeleg))register_ref \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Medeleg_bits r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Medeleg_bits := ((update_subrange_vec_dec(Medeleg_bits   r) (( 63 :: int)::ii) (( 0 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Medeleg))register_ref " 
  and  v  :: "(64)Word.word "


definition update_Medeleg_bits  :: \<open> Medeleg \<Rightarrow>(64)Word.word \<Rightarrow> Medeleg \<close>  where 
     \<open> update_Medeleg_bits v x = (
   ( v (|
     Medeleg_bits := ((update_subrange_vec_dec(Medeleg_bits   v) (( 63 :: int)::ii) (( 0 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Medeleg " 
  and  x  :: "(64)Word.word "


\<comment> \<open>\<open>val _get_Medeleg_Breakpoint : Medeleg -> mword ty1\<close>\<close>

definition get_Medeleg_Breakpoint  :: \<open> Medeleg \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_Medeleg_Breakpoint v = ( (subrange_vec_dec(Medeleg_bits   v) (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " Medeleg "


\<comment> \<open>\<open>val _set_Medeleg_Breakpoint : register_ref regstate register_value Medeleg -> mword ty1 -> M unit\<close>\<close>

definition set_Medeleg_Breakpoint  :: \<open>((regstate),(register_value),(Medeleg))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Medeleg_Breakpoint r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Medeleg_bits := ((update_subrange_vec_dec(Medeleg_bits   r) (( 3 :: int)::ii) (( 3 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Medeleg))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Medeleg_Breakpoint : Medeleg -> mword ty1 -> Medeleg\<close>\<close>

definition update_Medeleg_Breakpoint  :: \<open> Medeleg \<Rightarrow>(1)Word.word \<Rightarrow> Medeleg \<close>  where 
     \<open> update_Medeleg_Breakpoint v x = (
   ( v (| Medeleg_bits := ((update_subrange_vec_dec(Medeleg_bits   v) (( 3 :: int)::ii) (( 3 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Medeleg " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Sedeleg_Breakpoint : Sedeleg -> mword ty1 -> Sedeleg\<close>\<close>

\<comment> \<open>\<open>val _get_Sedeleg_Breakpoint : Sedeleg -> mword ty1\<close>\<close>

\<comment> \<open>\<open>val _set_Sedeleg_Breakpoint : register_ref regstate register_value Sedeleg -> mword ty1 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _get_Medeleg_Fetch_Access_Fault : Medeleg -> mword ty1\<close>\<close>

definition get_Medeleg_Fetch_Access_Fault  :: \<open> Medeleg \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_Medeleg_Fetch_Access_Fault v = ( (subrange_vec_dec(Medeleg_bits   v) (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " Medeleg "


\<comment> \<open>\<open>val _set_Medeleg_Fetch_Access_Fault : register_ref regstate register_value Medeleg -> mword ty1 -> M unit\<close>\<close>

definition set_Medeleg_Fetch_Access_Fault  :: \<open>((regstate),(register_value),(Medeleg))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Medeleg_Fetch_Access_Fault r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Medeleg_bits := ((update_subrange_vec_dec(Medeleg_bits   r) (( 1 :: int)::ii) (( 1 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Medeleg))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Medeleg_Fetch_Access_Fault : Medeleg -> mword ty1 -> Medeleg\<close>\<close>

definition update_Medeleg_Fetch_Access_Fault  :: \<open> Medeleg \<Rightarrow>(1)Word.word \<Rightarrow> Medeleg \<close>  where 
     \<open> update_Medeleg_Fetch_Access_Fault v x = (
   ( v (| Medeleg_bits := ((update_subrange_vec_dec(Medeleg_bits   v) (( 1 :: int)::ii) (( 1 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Medeleg " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Sedeleg_Fetch_Access_Fault : Sedeleg -> mword ty1 -> Sedeleg\<close>\<close>

\<comment> \<open>\<open>val _get_Sedeleg_Fetch_Access_Fault : Sedeleg -> mword ty1\<close>\<close>

\<comment> \<open>\<open>val _set_Sedeleg_Fetch_Access_Fault : register_ref regstate register_value Sedeleg -> mword ty1 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _get_Medeleg_Fetch_Addr_Align : Medeleg -> mword ty1\<close>\<close>

definition get_Medeleg_Fetch_Addr_Align  :: \<open> Medeleg \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_Medeleg_Fetch_Addr_Align v = ( (subrange_vec_dec(Medeleg_bits   v) (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " Medeleg "


\<comment> \<open>\<open>val _set_Medeleg_Fetch_Addr_Align : register_ref regstate register_value Medeleg -> mword ty1 -> M unit\<close>\<close>

definition set_Medeleg_Fetch_Addr_Align  :: \<open>((regstate),(register_value),(Medeleg))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Medeleg_Fetch_Addr_Align r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Medeleg_bits := ((update_subrange_vec_dec(Medeleg_bits   r) (( 0 :: int)::ii) (( 0 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Medeleg))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Medeleg_Fetch_Addr_Align : Medeleg -> mword ty1 -> Medeleg\<close>\<close>

definition update_Medeleg_Fetch_Addr_Align  :: \<open> Medeleg \<Rightarrow>(1)Word.word \<Rightarrow> Medeleg \<close>  where 
     \<open> update_Medeleg_Fetch_Addr_Align v x = (
   ( v (| Medeleg_bits := ((update_subrange_vec_dec(Medeleg_bits   v) (( 0 :: int)::ii) (( 0 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Medeleg " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Sedeleg_Fetch_Addr_Align : Sedeleg -> mword ty1 -> Sedeleg\<close>\<close>

\<comment> \<open>\<open>val _get_Sedeleg_Fetch_Addr_Align : Sedeleg -> mword ty1\<close>\<close>

\<comment> \<open>\<open>val _set_Sedeleg_Fetch_Addr_Align : register_ref regstate register_value Sedeleg -> mword ty1 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _get_Medeleg_Fetch_Page_Fault : Medeleg -> mword ty1\<close>\<close>

definition get_Medeleg_Fetch_Page_Fault  :: \<open> Medeleg \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_Medeleg_Fetch_Page_Fault v = ( (subrange_vec_dec(Medeleg_bits   v) (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " Medeleg "


\<comment> \<open>\<open>val _set_Medeleg_Fetch_Page_Fault : register_ref regstate register_value Medeleg -> mword ty1 -> M unit\<close>\<close>

definition set_Medeleg_Fetch_Page_Fault  :: \<open>((regstate),(register_value),(Medeleg))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Medeleg_Fetch_Page_Fault r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Medeleg_bits := ((update_subrange_vec_dec(Medeleg_bits   r) (( 12 :: int)::ii) (( 12 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Medeleg))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Medeleg_Fetch_Page_Fault : Medeleg -> mword ty1 -> Medeleg\<close>\<close>

definition update_Medeleg_Fetch_Page_Fault  :: \<open> Medeleg \<Rightarrow>(1)Word.word \<Rightarrow> Medeleg \<close>  where 
     \<open> update_Medeleg_Fetch_Page_Fault v x = (
   ( v (|
     Medeleg_bits := ((update_subrange_vec_dec(Medeleg_bits   v) (( 12 :: int)::ii) (( 12 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Medeleg " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _get_Medeleg_Illegal_Instr : Medeleg -> mword ty1\<close>\<close>

definition get_Medeleg_Illegal_Instr  :: \<open> Medeleg \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_Medeleg_Illegal_Instr v = ( (subrange_vec_dec(Medeleg_bits   v) (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " Medeleg "


\<comment> \<open>\<open>val _set_Medeleg_Illegal_Instr : register_ref regstate register_value Medeleg -> mword ty1 -> M unit\<close>\<close>

definition set_Medeleg_Illegal_Instr  :: \<open>((regstate),(register_value),(Medeleg))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Medeleg_Illegal_Instr r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Medeleg_bits := ((update_subrange_vec_dec(Medeleg_bits   r) (( 2 :: int)::ii) (( 2 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Medeleg))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Medeleg_Illegal_Instr : Medeleg -> mword ty1 -> Medeleg\<close>\<close>

definition update_Medeleg_Illegal_Instr  :: \<open> Medeleg \<Rightarrow>(1)Word.word \<Rightarrow> Medeleg \<close>  where 
     \<open> update_Medeleg_Illegal_Instr v x = (
   ( v (| Medeleg_bits := ((update_subrange_vec_dec(Medeleg_bits   v) (( 2 :: int)::ii) (( 2 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Medeleg " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Sedeleg_Illegal_Instr : Sedeleg -> mword ty1 -> Sedeleg\<close>\<close>

\<comment> \<open>\<open>val _get_Sedeleg_Illegal_Instr : Sedeleg -> mword ty1\<close>\<close>

\<comment> \<open>\<open>val _set_Sedeleg_Illegal_Instr : register_ref regstate register_value Sedeleg -> mword ty1 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _get_Medeleg_Load_Access_Fault : Medeleg -> mword ty1\<close>\<close>

definition get_Medeleg_Load_Access_Fault  :: \<open> Medeleg \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_Medeleg_Load_Access_Fault v = ( (subrange_vec_dec(Medeleg_bits   v) (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " Medeleg "


\<comment> \<open>\<open>val _set_Medeleg_Load_Access_Fault : register_ref regstate register_value Medeleg -> mword ty1 -> M unit\<close>\<close>

definition set_Medeleg_Load_Access_Fault  :: \<open>((regstate),(register_value),(Medeleg))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Medeleg_Load_Access_Fault r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Medeleg_bits := ((update_subrange_vec_dec(Medeleg_bits   r) (( 5 :: int)::ii) (( 5 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Medeleg))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Medeleg_Load_Access_Fault : Medeleg -> mword ty1 -> Medeleg\<close>\<close>

definition update_Medeleg_Load_Access_Fault  :: \<open> Medeleg \<Rightarrow>(1)Word.word \<Rightarrow> Medeleg \<close>  where 
     \<open> update_Medeleg_Load_Access_Fault v x = (
   ( v (| Medeleg_bits := ((update_subrange_vec_dec(Medeleg_bits   v) (( 5 :: int)::ii) (( 5 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Medeleg " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Sedeleg_Load_Access_Fault : Sedeleg -> mword ty1 -> Sedeleg\<close>\<close>

\<comment> \<open>\<open>val _get_Sedeleg_Load_Access_Fault : Sedeleg -> mword ty1\<close>\<close>

\<comment> \<open>\<open>val _set_Sedeleg_Load_Access_Fault : register_ref regstate register_value Sedeleg -> mword ty1 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _get_Medeleg_Load_Addr_Align : Medeleg -> mword ty1\<close>\<close>

definition get_Medeleg_Load_Addr_Align  :: \<open> Medeleg \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_Medeleg_Load_Addr_Align v = ( (subrange_vec_dec(Medeleg_bits   v) (( 4 :: int)::ii) (( 4 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " Medeleg "


\<comment> \<open>\<open>val _set_Medeleg_Load_Addr_Align : register_ref regstate register_value Medeleg -> mword ty1 -> M unit\<close>\<close>

definition set_Medeleg_Load_Addr_Align  :: \<open>((regstate),(register_value),(Medeleg))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Medeleg_Load_Addr_Align r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Medeleg_bits := ((update_subrange_vec_dec(Medeleg_bits   r) (( 4 :: int)::ii) (( 4 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Medeleg))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Medeleg_Load_Addr_Align : Medeleg -> mword ty1 -> Medeleg\<close>\<close>

definition update_Medeleg_Load_Addr_Align  :: \<open> Medeleg \<Rightarrow>(1)Word.word \<Rightarrow> Medeleg \<close>  where 
     \<open> update_Medeleg_Load_Addr_Align v x = (
   ( v (| Medeleg_bits := ((update_subrange_vec_dec(Medeleg_bits   v) (( 4 :: int)::ii) (( 4 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Medeleg " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Sedeleg_Load_Addr_Align : Sedeleg -> mword ty1 -> Sedeleg\<close>\<close>

\<comment> \<open>\<open>val _get_Sedeleg_Load_Addr_Align : Sedeleg -> mword ty1\<close>\<close>

\<comment> \<open>\<open>val _set_Sedeleg_Load_Addr_Align : register_ref regstate register_value Sedeleg -> mword ty1 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _get_Medeleg_Load_Page_Fault : Medeleg -> mword ty1\<close>\<close>

definition get_Medeleg_Load_Page_Fault  :: \<open> Medeleg \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_Medeleg_Load_Page_Fault v = ( (subrange_vec_dec(Medeleg_bits   v) (( 13 :: int)::ii) (( 13 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " Medeleg "


\<comment> \<open>\<open>val _set_Medeleg_Load_Page_Fault : register_ref regstate register_value Medeleg -> mword ty1 -> M unit\<close>\<close>

definition set_Medeleg_Load_Page_Fault  :: \<open>((regstate),(register_value),(Medeleg))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Medeleg_Load_Page_Fault r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Medeleg_bits := ((update_subrange_vec_dec(Medeleg_bits   r) (( 13 :: int)::ii) (( 13 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Medeleg))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Medeleg_Load_Page_Fault : Medeleg -> mword ty1 -> Medeleg\<close>\<close>

definition update_Medeleg_Load_Page_Fault  :: \<open> Medeleg \<Rightarrow>(1)Word.word \<Rightarrow> Medeleg \<close>  where 
     \<open> update_Medeleg_Load_Page_Fault v x = (
   ( v (|
     Medeleg_bits := ((update_subrange_vec_dec(Medeleg_bits   v) (( 13 :: int)::ii) (( 13 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Medeleg " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _get_Medeleg_MEnvCall : Medeleg -> mword ty1\<close>\<close>

definition get_Medeleg_MEnvCall  :: \<open> Medeleg \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_Medeleg_MEnvCall v = ( (subrange_vec_dec(Medeleg_bits   v) (( 10 :: int)::ii) (( 10 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " Medeleg "


\<comment> \<open>\<open>val _set_Medeleg_MEnvCall : register_ref regstate register_value Medeleg -> mword ty1 -> M unit\<close>\<close>

definition set_Medeleg_MEnvCall  :: \<open>((regstate),(register_value),(Medeleg))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Medeleg_MEnvCall r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Medeleg_bits := ((update_subrange_vec_dec(Medeleg_bits   r) (( 10 :: int)::ii) (( 10 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Medeleg))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Medeleg_MEnvCall : Medeleg -> mword ty1 -> Medeleg\<close>\<close>

definition update_Medeleg_MEnvCall  :: \<open> Medeleg \<Rightarrow>(1)Word.word \<Rightarrow> Medeleg \<close>  where 
     \<open> update_Medeleg_MEnvCall v x = (
   ( v (|
     Medeleg_bits := ((update_subrange_vec_dec(Medeleg_bits   v) (( 10 :: int)::ii) (( 10 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Medeleg " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _get_Medeleg_SAMO_Access_Fault : Medeleg -> mword ty1\<close>\<close>

definition get_Medeleg_SAMO_Access_Fault  :: \<open> Medeleg \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_Medeleg_SAMO_Access_Fault v = ( (subrange_vec_dec(Medeleg_bits   v) (( 7 :: int)::ii) (( 7 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " Medeleg "


\<comment> \<open>\<open>val _set_Medeleg_SAMO_Access_Fault : register_ref regstate register_value Medeleg -> mword ty1 -> M unit\<close>\<close>

definition set_Medeleg_SAMO_Access_Fault  :: \<open>((regstate),(register_value),(Medeleg))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Medeleg_SAMO_Access_Fault r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Medeleg_bits := ((update_subrange_vec_dec(Medeleg_bits   r) (( 7 :: int)::ii) (( 7 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Medeleg))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Medeleg_SAMO_Access_Fault : Medeleg -> mword ty1 -> Medeleg\<close>\<close>

definition update_Medeleg_SAMO_Access_Fault  :: \<open> Medeleg \<Rightarrow>(1)Word.word \<Rightarrow> Medeleg \<close>  where 
     \<open> update_Medeleg_SAMO_Access_Fault v x = (
   ( v (| Medeleg_bits := ((update_subrange_vec_dec(Medeleg_bits   v) (( 7 :: int)::ii) (( 7 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Medeleg " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Sedeleg_SAMO_Access_Fault : Sedeleg -> mword ty1 -> Sedeleg\<close>\<close>

\<comment> \<open>\<open>val _get_Sedeleg_SAMO_Access_Fault : Sedeleg -> mword ty1\<close>\<close>

\<comment> \<open>\<open>val _set_Sedeleg_SAMO_Access_Fault : register_ref regstate register_value Sedeleg -> mword ty1 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _get_Medeleg_SAMO_Addr_Align : Medeleg -> mword ty1\<close>\<close>

definition get_Medeleg_SAMO_Addr_Align  :: \<open> Medeleg \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_Medeleg_SAMO_Addr_Align v = ( (subrange_vec_dec(Medeleg_bits   v) (( 6 :: int)::ii) (( 6 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " Medeleg "


\<comment> \<open>\<open>val _set_Medeleg_SAMO_Addr_Align : register_ref regstate register_value Medeleg -> mword ty1 -> M unit\<close>\<close>

definition set_Medeleg_SAMO_Addr_Align  :: \<open>((regstate),(register_value),(Medeleg))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Medeleg_SAMO_Addr_Align r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Medeleg_bits := ((update_subrange_vec_dec(Medeleg_bits   r) (( 6 :: int)::ii) (( 6 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Medeleg))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Medeleg_SAMO_Addr_Align : Medeleg -> mword ty1 -> Medeleg\<close>\<close>

definition update_Medeleg_SAMO_Addr_Align  :: \<open> Medeleg \<Rightarrow>(1)Word.word \<Rightarrow> Medeleg \<close>  where 
     \<open> update_Medeleg_SAMO_Addr_Align v x = (
   ( v (| Medeleg_bits := ((update_subrange_vec_dec(Medeleg_bits   v) (( 6 :: int)::ii) (( 6 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Medeleg " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Sedeleg_SAMO_Addr_Align : Sedeleg -> mword ty1 -> Sedeleg\<close>\<close>

\<comment> \<open>\<open>val _get_Sedeleg_SAMO_Addr_Align : Sedeleg -> mword ty1\<close>\<close>

\<comment> \<open>\<open>val _set_Sedeleg_SAMO_Addr_Align : register_ref regstate register_value Sedeleg -> mword ty1 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _get_Medeleg_SAMO_Page_Fault : Medeleg -> mword ty1\<close>\<close>

definition get_Medeleg_SAMO_Page_Fault  :: \<open> Medeleg \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_Medeleg_SAMO_Page_Fault v = ( (subrange_vec_dec(Medeleg_bits   v) (( 15 :: int)::ii) (( 15 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " Medeleg "


\<comment> \<open>\<open>val _set_Medeleg_SAMO_Page_Fault : register_ref regstate register_value Medeleg -> mword ty1 -> M unit\<close>\<close>

definition set_Medeleg_SAMO_Page_Fault  :: \<open>((regstate),(register_value),(Medeleg))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Medeleg_SAMO_Page_Fault r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Medeleg_bits := ((update_subrange_vec_dec(Medeleg_bits   r) (( 15 :: int)::ii) (( 15 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Medeleg))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Medeleg_SAMO_Page_Fault : Medeleg -> mword ty1 -> Medeleg\<close>\<close>

definition update_Medeleg_SAMO_Page_Fault  :: \<open> Medeleg \<Rightarrow>(1)Word.word \<Rightarrow> Medeleg \<close>  where 
     \<open> update_Medeleg_SAMO_Page_Fault v x = (
   ( v (|
     Medeleg_bits := ((update_subrange_vec_dec(Medeleg_bits   v) (( 15 :: int)::ii) (( 15 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Medeleg " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _get_Medeleg_SEnvCall : Medeleg -> mword ty1\<close>\<close>

definition get_Medeleg_SEnvCall  :: \<open> Medeleg \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_Medeleg_SEnvCall v = ( (subrange_vec_dec(Medeleg_bits   v) (( 9 :: int)::ii) (( 9 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " Medeleg "


\<comment> \<open>\<open>val _set_Medeleg_SEnvCall : register_ref regstate register_value Medeleg -> mword ty1 -> M unit\<close>\<close>

definition set_Medeleg_SEnvCall  :: \<open>((regstate),(register_value),(Medeleg))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Medeleg_SEnvCall r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Medeleg_bits := ((update_subrange_vec_dec(Medeleg_bits   r) (( 9 :: int)::ii) (( 9 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Medeleg))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Medeleg_SEnvCall : Medeleg -> mword ty1 -> Medeleg\<close>\<close>

definition update_Medeleg_SEnvCall  :: \<open> Medeleg \<Rightarrow>(1)Word.word \<Rightarrow> Medeleg \<close>  where 
     \<open> update_Medeleg_SEnvCall v x = (
   ( v (| Medeleg_bits := ((update_subrange_vec_dec(Medeleg_bits   v) (( 9 :: int)::ii) (( 9 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Medeleg " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _get_Medeleg_UEnvCall : Medeleg -> mword ty1\<close>\<close>

definition get_Medeleg_UEnvCall  :: \<open> Medeleg \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_Medeleg_UEnvCall v = ( (subrange_vec_dec(Medeleg_bits   v) (( 8 :: int)::ii) (( 8 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " Medeleg "


\<comment> \<open>\<open>val _set_Medeleg_UEnvCall : register_ref regstate register_value Medeleg -> mword ty1 -> M unit\<close>\<close>

definition set_Medeleg_UEnvCall  :: \<open>((regstate),(register_value),(Medeleg))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Medeleg_UEnvCall r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Medeleg_bits := ((update_subrange_vec_dec(Medeleg_bits   r) (( 8 :: int)::ii) (( 8 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Medeleg))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Medeleg_UEnvCall : Medeleg -> mword ty1 -> Medeleg\<close>\<close>

definition update_Medeleg_UEnvCall  :: \<open> Medeleg \<Rightarrow>(1)Word.word \<Rightarrow> Medeleg \<close>  where 
     \<open> update_Medeleg_UEnvCall v x = (
   ( v (| Medeleg_bits := ((update_subrange_vec_dec(Medeleg_bits   v) (( 8 :: int)::ii) (( 8 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Medeleg " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Sedeleg_UEnvCall : Sedeleg -> mword ty1 -> Sedeleg\<close>\<close>

\<comment> \<open>\<open>val _get_Sedeleg_UEnvCall : Sedeleg -> mword ty1\<close>\<close>

\<comment> \<open>\<open>val _set_Sedeleg_UEnvCall : register_ref regstate register_value Sedeleg -> mword ty1 -> M unit\<close>\<close>

\<comment> \<open>\<open>val legalize_medeleg : Medeleg -> mword ty64 -> Medeleg\<close>\<close>

definition legalize_medeleg  :: \<open> Medeleg \<Rightarrow>(64)Word.word \<Rightarrow> Medeleg \<close>  where 
     \<open> legalize_medeleg (o1 :: Medeleg) (v :: xlenbits) = (
   (let m = (Mk_Medeleg v) in
   update_Medeleg_MEnvCall m ( 0b0 ::  1 Word.word)))\<close> 
  for  o1  :: " Medeleg " 
  and  v  :: "(64)Word.word "


\<comment> \<open>\<open>val undefined_Mtvec : unit -> M Mtvec\<close>\<close>

definition undefined_Mtvec  :: \<open> unit \<Rightarrow>((register_value),(Mtvec),(exception))monad \<close>  where 
     \<open> undefined_Mtvec _ = (
   ((return (failwith (''undefined value of unsupported type''))) :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::
      64 Word.word) . 
   return ((| Mtvec_bits = w__0 |)))))\<close>


\<comment> \<open>\<open>val Mk_Mtvec : mword ty64 -> Mtvec\<close>\<close>

definition Mk_Mtvec  :: \<open>(64)Word.word \<Rightarrow> Mtvec \<close>  where 
     \<open> Mk_Mtvec v = ( (| Mtvec_bits = v |) )\<close> 
  for  v  :: "(64)Word.word "


definition get_Mtvec_bits  :: \<open> Mtvec \<Rightarrow>(64)Word.word \<close>  where 
     \<open> get_Mtvec_bits v = ( (subrange_vec_dec(Mtvec_bits   v) (( 63 :: int)::ii) (( 0 :: int)::ii)  ::  64 Word.word))\<close> 
  for  v  :: " Mtvec "


definition set_Mtvec_bits  :: \<open>((regstate),(register_value),(Mtvec))register_ref \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Mtvec_bits r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (| Mtvec_bits := ((update_subrange_vec_dec(Mtvec_bits   r) (( 63 :: int)::ii) (( 0 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Mtvec))register_ref " 
  and  v  :: "(64)Word.word "


definition update_Mtvec_bits  :: \<open> Mtvec \<Rightarrow>(64)Word.word \<Rightarrow> Mtvec \<close>  where 
     \<open> update_Mtvec_bits v x = (
   ( v (| Mtvec_bits := ((update_subrange_vec_dec(Mtvec_bits   v) (( 63 :: int)::ii) (( 0 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Mtvec " 
  and  x  :: "(64)Word.word "


\<comment> \<open>\<open>val _get_Mtvec_Base : Mtvec -> mword ty62\<close>\<close>

definition get_Mtvec_Base  :: \<open> Mtvec \<Rightarrow>(62)Word.word \<close>  where 
     \<open> get_Mtvec_Base v = ( (subrange_vec_dec(Mtvec_bits   v) (( 63 :: int)::ii) (( 2 :: int)::ii)  ::  62 Word.word))\<close> 
  for  v  :: " Mtvec "


\<comment> \<open>\<open>val _set_Mtvec_Base : register_ref regstate register_value Mtvec -> mword ty62 -> M unit\<close>\<close>

definition set_Mtvec_Base  :: \<open>((regstate),(register_value),(Mtvec))register_ref \<Rightarrow>(62)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Mtvec_Base r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (| Mtvec_bits := ((update_subrange_vec_dec(Mtvec_bits   r) (( 63 :: int)::ii) (( 2 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Mtvec))register_ref " 
  and  v  :: "(62)Word.word "


\<comment> \<open>\<open>val _update_Mtvec_Base : Mtvec -> mword ty62 -> Mtvec\<close>\<close>

definition update_Mtvec_Base  :: \<open> Mtvec \<Rightarrow>(62)Word.word \<Rightarrow> Mtvec \<close>  where 
     \<open> update_Mtvec_Base v x = (
   ( v (| Mtvec_bits := ((update_subrange_vec_dec(Mtvec_bits   v) (( 63 :: int)::ii) (( 2 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Mtvec " 
  and  x  :: "(62)Word.word "


\<comment> \<open>\<open>val _get_Mtvec_Mode : Mtvec -> mword ty2\<close>\<close>

definition get_Mtvec_Mode  :: \<open> Mtvec \<Rightarrow>(2)Word.word \<close>  where 
     \<open> get_Mtvec_Mode v = ( (subrange_vec_dec(Mtvec_bits   v) (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word))\<close> 
  for  v  :: " Mtvec "


\<comment> \<open>\<open>val _set_Mtvec_Mode : register_ref regstate register_value Mtvec -> mword ty2 -> M unit\<close>\<close>

definition set_Mtvec_Mode  :: \<open>((regstate),(register_value),(Mtvec))register_ref \<Rightarrow>(2)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Mtvec_Mode r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (| Mtvec_bits := ((update_subrange_vec_dec(Mtvec_bits   r) (( 1 :: int)::ii) (( 0 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Mtvec))register_ref " 
  and  v  :: "(2)Word.word "


\<comment> \<open>\<open>val _update_Mtvec_Mode : Mtvec -> mword ty2 -> Mtvec\<close>\<close>

definition update_Mtvec_Mode  :: \<open> Mtvec \<Rightarrow>(2)Word.word \<Rightarrow> Mtvec \<close>  where 
     \<open> update_Mtvec_Mode v x = (
   ( v (| Mtvec_bits := ((update_subrange_vec_dec(Mtvec_bits   v) (( 1 :: int)::ii) (( 0 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Mtvec " 
  and  x  :: "(2)Word.word "


\<comment> \<open>\<open>val _update_Satp32_Mode : Satp32 -> mword ty1 -> Satp32\<close>\<close>

\<comment> \<open>\<open>val _update_Satp64_Mode : Satp64 -> mword ty4 -> Satp64\<close>\<close>

\<comment> \<open>\<open>val _get_Satp32_Mode : Satp32 -> mword ty1\<close>\<close>

\<comment> \<open>\<open>val _get_Satp64_Mode : Satp64 -> mword ty4\<close>\<close>

\<comment> \<open>\<open>val _set_Satp32_Mode : register_ref regstate register_value Satp32 -> mword ty1 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _set_Satp64_Mode : register_ref regstate register_value Satp64 -> mword ty4 -> M unit\<close>\<close>

\<comment> \<open>\<open>val legalize_tvec : Mtvec -> mword ty64 -> Mtvec\<close>\<close>

definition legalize_tvec  :: \<open> Mtvec \<Rightarrow>(64)Word.word \<Rightarrow> Mtvec \<close>  where 
     \<open> legalize_tvec (o1 :: Mtvec) (v :: xlenbits) = (
   (let v = (Mk_Mtvec v) in
   (case  ((trapVectorMode_of_bits ((get_Mtvec_Mode v  ::  2 Word.word)))) of
     TV_Direct => v
   | TV_Vector => v
   | _ => update_Mtvec_Mode v ((get_Mtvec_Mode o1  ::  2 Word.word))
   )))\<close> 
  for  o1  :: " Mtvec " 
  and  v  :: "(64)Word.word "


\<comment> \<open>\<open>val undefined_Mcause : unit -> M Mcause\<close>\<close>

definition undefined_Mcause  :: \<open> unit \<Rightarrow>((register_value),(Mcause),(exception))monad \<close>  where 
     \<open> undefined_Mcause _ = (
   ((return (failwith (''undefined value of unsupported type''))) :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::
      64 Word.word) . 
   return ((| Mcause_bits = w__0 |)))))\<close>


\<comment> \<open>\<open>val Mk_Mcause : mword ty64 -> Mcause\<close>\<close>

definition Mk_Mcause  :: \<open>(64)Word.word \<Rightarrow> Mcause \<close>  where 
     \<open> Mk_Mcause v = ( (| Mcause_bits = v |) )\<close> 
  for  v  :: "(64)Word.word "


definition get_Mcause_bits  :: \<open> Mcause \<Rightarrow>(64)Word.word \<close>  where 
     \<open> get_Mcause_bits v = ( (subrange_vec_dec(Mcause_bits   v) (( 63 :: int)::ii) (( 0 :: int)::ii)  ::  64 Word.word))\<close> 
  for  v  :: " Mcause "


definition set_Mcause_bits  :: \<open>((regstate),(register_value),(Mcause))register_ref \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Mcause_bits r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Mcause_bits := ((update_subrange_vec_dec(Mcause_bits   r) (( 63 :: int)::ii) (( 0 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Mcause))register_ref " 
  and  v  :: "(64)Word.word "


definition update_Mcause_bits  :: \<open> Mcause \<Rightarrow>(64)Word.word \<Rightarrow> Mcause \<close>  where 
     \<open> update_Mcause_bits v x = (
   ( v (| Mcause_bits := ((update_subrange_vec_dec(Mcause_bits   v) (( 63 :: int)::ii) (( 0 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Mcause " 
  and  x  :: "(64)Word.word "


\<comment> \<open>\<open>val _get_Mcause_Cause : Mcause -> mword ty63\<close>\<close>

definition get_Mcause_Cause  :: \<open> Mcause \<Rightarrow>(63)Word.word \<close>  where 
     \<open> get_Mcause_Cause v = ( (subrange_vec_dec(Mcause_bits   v) (( 62 :: int)::ii) (( 0 :: int)::ii)  ::  63 Word.word))\<close> 
  for  v  :: " Mcause "


\<comment> \<open>\<open>val _set_Mcause_Cause : register_ref regstate register_value Mcause -> mword ty63 -> M unit\<close>\<close>

definition set_Mcause_Cause  :: \<open>((regstate),(register_value),(Mcause))register_ref \<Rightarrow>(63)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Mcause_Cause r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Mcause_bits := ((update_subrange_vec_dec(Mcause_bits   r) (( 62 :: int)::ii) (( 0 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Mcause))register_ref " 
  and  v  :: "(63)Word.word "


\<comment> \<open>\<open>val _update_Mcause_Cause : Mcause -> mword ty63 -> Mcause\<close>\<close>

definition update_Mcause_Cause  :: \<open> Mcause \<Rightarrow>(63)Word.word \<Rightarrow> Mcause \<close>  where 
     \<open> update_Mcause_Cause v x = (
   ( v (| Mcause_bits := ((update_subrange_vec_dec(Mcause_bits   v) (( 62 :: int)::ii) (( 0 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Mcause " 
  and  x  :: "(63)Word.word "


\<comment> \<open>\<open>val _get_Mcause_IsInterrupt : Mcause -> mword ty1\<close>\<close>

definition get_Mcause_IsInterrupt  :: \<open> Mcause \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_Mcause_IsInterrupt v = ( (subrange_vec_dec(Mcause_bits   v) (( 63 :: int)::ii) (( 63 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " Mcause "


\<comment> \<open>\<open>val _set_Mcause_IsInterrupt : register_ref regstate register_value Mcause -> mword ty1 -> M unit\<close>\<close>

definition set_Mcause_IsInterrupt  :: \<open>((regstate),(register_value),(Mcause))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Mcause_IsInterrupt r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Mcause_bits := ((update_subrange_vec_dec(Mcause_bits   r) (( 63 :: int)::ii) (( 63 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Mcause))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Mcause_IsInterrupt : Mcause -> mword ty1 -> Mcause\<close>\<close>

definition update_Mcause_IsInterrupt  :: \<open> Mcause \<Rightarrow>(1)Word.word \<Rightarrow> Mcause \<close>  where 
     \<open> update_Mcause_IsInterrupt v x = (
   ( v (| Mcause_bits := ((update_subrange_vec_dec(Mcause_bits   v) (( 63 :: int)::ii) (( 63 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Mcause " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val tvec_addr : Mtvec -> Mcause -> maybe (mword ty64)\<close>\<close>

definition tvec_addr  :: \<open> Mtvec \<Rightarrow> Mcause \<Rightarrow>((64)Word.word)option \<close>  where 
     \<open> tvec_addr (m :: Mtvec) (c :: Mcause) = (
   (let (base :: xlenbits) =
     ((concat_vec ((get_Mtvec_Base m  ::  62 Word.word)) ( 0b00 ::  2 Word.word)  ::  64 Word.word)) in
   (case  ((trapVectorMode_of_bits ((get_Mtvec_Mode m  ::  2 Word.word)))) of
     TV_Direct => Some base
   | TV_Vector =>
      if (((((get_Mcause_IsInterrupt c  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))) then
        Some ((add_vec base
                 ((shiftl ((EXTZ (( 64 :: int)::ii) ((get_Mcause_Cause c  ::  63 Word.word))  ::  64 Word.word))
                     (( 2 :: int)::ii)
                    ::  64 Word.word))
                ::  64 Word.word))
      else Some base
   | TV_Reserved => None
   )))\<close> 
  for  m  :: " Mtvec " 
  and  c  :: " Mcause "


\<comment> \<open>\<open>val legalize_xepc : mword ty64 -> M (mword ty64)\<close>\<close>

definition legalize_xepc  :: \<open>(64)Word.word \<Rightarrow>((register_value),((64)Word.word),(exception))monad \<close>  where 
     \<open> legalize_xepc v = (
   or_boolM (return (((((sys_enable_writable_misa () )) \<and> ((sys_enable_rvc () ))))))
     (read_reg misa_ref \<bind> ((\<lambda> (w__0 :: Misa) . 
      return (((((get_Misa_C w__0  ::  1 Word.word)) = ( 0b1 ::  1 Word.word))))))) \<bind> ((\<lambda> (w__1 :: bool) . 
   return (if w__1 then (update_vec_dec v (( 0 :: int)::ii) B0  ::  64 Word.word)
           else (and_vec v ((EXTS (( 64 :: int)::ii) ( 0b100 ::  3 Word.word)  ::  64 Word.word))  ::  64 Word.word)))))\<close> 
  for  v  :: "(64)Word.word "


\<comment> \<open>\<open>val pc_alignment_mask : unit -> M (mword ty64)\<close>\<close>

definition pc_alignment_mask  :: \<open> unit \<Rightarrow>((register_value),((64)Word.word),(exception))monad \<close>  where 
     \<open> pc_alignment_mask _ = (
   read_reg misa_ref \<bind> ((\<lambda> (w__0 :: Misa) . 
   return ((not_vec
              ((EXTZ (( 64 :: int)::ii)
                  (if (((((get_Misa_C w__0  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))) then
                     ( 0b00 ::  2 Word.word)
                   else ( 0b10 ::  2 Word.word))
                 ::  64 Word.word))
             ::  64 Word.word)))))\<close>


\<comment> \<open>\<open>val undefined_Counteren : unit -> M Counteren\<close>\<close>

definition undefined_Counteren  :: \<open> unit \<Rightarrow>((register_value),(Counteren),(exception))monad \<close>  where 
     \<open> undefined_Counteren _ = (
   ((return (failwith (''undefined value of unsupported type''))) :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::
      32 Word.word) . 
   return ((| Counteren_bits = w__0 |)))))\<close>


\<comment> \<open>\<open>val Mk_Counteren : mword ty32 -> Counteren\<close>\<close>

definition Mk_Counteren  :: \<open>(32)Word.word \<Rightarrow> Counteren \<close>  where 
     \<open> Mk_Counteren v = ( (| Counteren_bits = v |) )\<close> 
  for  v  :: "(32)Word.word "


definition get_Counteren_bits  :: \<open> Counteren \<Rightarrow>(32)Word.word \<close>  where 
     \<open> get_Counteren_bits v = ( (subrange_vec_dec(Counteren_bits   v) (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))\<close> 
  for  v  :: " Counteren "


definition set_Counteren_bits  :: \<open>((regstate),(register_value),(Counteren))register_ref \<Rightarrow>(32)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Counteren_bits r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Counteren_bits := ((update_subrange_vec_dec(Counteren_bits   r) (( 31 :: int)::ii) (( 0 :: int)::ii) v  ::  32 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Counteren))register_ref " 
  and  v  :: "(32)Word.word "


definition update_Counteren_bits  :: \<open> Counteren \<Rightarrow>(32)Word.word \<Rightarrow> Counteren \<close>  where 
     \<open> update_Counteren_bits v x = (
   ( v (|
     Counteren_bits := ((update_subrange_vec_dec(Counteren_bits   v) (( 31 :: int)::ii) (( 0 :: int)::ii) x  ::  32 Word.word)) |)))\<close> 
  for  v  :: " Counteren " 
  and  x  :: "(32)Word.word "


\<comment> \<open>\<open>val _get_Counteren_CY : Counteren -> mword ty1\<close>\<close>

definition get_Counteren_CY  :: \<open> Counteren \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_Counteren_CY v = ( (subrange_vec_dec(Counteren_bits   v) (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " Counteren "


\<comment> \<open>\<open>val _set_Counteren_CY : register_ref regstate register_value Counteren -> mword ty1 -> M unit\<close>\<close>

definition set_Counteren_CY  :: \<open>((regstate),(register_value),(Counteren))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Counteren_CY r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Counteren_bits := ((update_subrange_vec_dec(Counteren_bits   r) (( 0 :: int)::ii) (( 0 :: int)::ii) v  ::  32 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Counteren))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Counteren_CY : Counteren -> mword ty1 -> Counteren\<close>\<close>

definition update_Counteren_CY  :: \<open> Counteren \<Rightarrow>(1)Word.word \<Rightarrow> Counteren \<close>  where 
     \<open> update_Counteren_CY v x = (
   ( v (|
     Counteren_bits := ((update_subrange_vec_dec(Counteren_bits   v) (( 0 :: int)::ii) (( 0 :: int)::ii) x  ::  32 Word.word)) |)))\<close> 
  for  v  :: " Counteren " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Counterin_CY : Counterin -> mword ty1 -> Counterin\<close>\<close>

\<comment> \<open>\<open>val _get_Counterin_CY : Counterin -> mword ty1\<close>\<close>

\<comment> \<open>\<open>val _set_Counterin_CY : register_ref regstate register_value Counterin -> mword ty1 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _get_Counteren_HPM : Counteren -> mword ty29\<close>\<close>

definition get_Counteren_HPM  :: \<open> Counteren \<Rightarrow>(29)Word.word \<close>  where 
     \<open> get_Counteren_HPM v = ( (subrange_vec_dec(Counteren_bits   v) (( 31 :: int)::ii) (( 3 :: int)::ii)  ::  29 Word.word))\<close> 
  for  v  :: " Counteren "


\<comment> \<open>\<open>val _set_Counteren_HPM : register_ref regstate register_value Counteren -> mword ty29 -> M unit\<close>\<close>

definition set_Counteren_HPM  :: \<open>((regstate),(register_value),(Counteren))register_ref \<Rightarrow>(29)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Counteren_HPM r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Counteren_bits := ((update_subrange_vec_dec(Counteren_bits   r) (( 31 :: int)::ii) (( 3 :: int)::ii) v  ::  32 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Counteren))register_ref " 
  and  v  :: "(29)Word.word "


\<comment> \<open>\<open>val _update_Counteren_HPM : Counteren -> mword ty29 -> Counteren\<close>\<close>

definition update_Counteren_HPM  :: \<open> Counteren \<Rightarrow>(29)Word.word \<Rightarrow> Counteren \<close>  where 
     \<open> update_Counteren_HPM v x = (
   ( v (|
     Counteren_bits := ((update_subrange_vec_dec(Counteren_bits   v) (( 31 :: int)::ii) (( 3 :: int)::ii) x  ::  32 Word.word)) |)))\<close> 
  for  v  :: " Counteren " 
  and  x  :: "(29)Word.word "


\<comment> \<open>\<open>val _get_Counteren_IR : Counteren -> mword ty1\<close>\<close>

definition get_Counteren_IR  :: \<open> Counteren \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_Counteren_IR v = ( (subrange_vec_dec(Counteren_bits   v) (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " Counteren "


\<comment> \<open>\<open>val _set_Counteren_IR : register_ref regstate register_value Counteren -> mword ty1 -> M unit\<close>\<close>

definition set_Counteren_IR  :: \<open>((regstate),(register_value),(Counteren))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Counteren_IR r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Counteren_bits := ((update_subrange_vec_dec(Counteren_bits   r) (( 2 :: int)::ii) (( 2 :: int)::ii) v  ::  32 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Counteren))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Counteren_IR : Counteren -> mword ty1 -> Counteren\<close>\<close>

definition update_Counteren_IR  :: \<open> Counteren \<Rightarrow>(1)Word.word \<Rightarrow> Counteren \<close>  where 
     \<open> update_Counteren_IR v x = (
   ( v (|
     Counteren_bits := ((update_subrange_vec_dec(Counteren_bits   v) (( 2 :: int)::ii) (( 2 :: int)::ii) x  ::  32 Word.word)) |)))\<close> 
  for  v  :: " Counteren " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Counterin_IR : Counterin -> mword ty1 -> Counterin\<close>\<close>

\<comment> \<open>\<open>val _get_Counterin_IR : Counterin -> mword ty1\<close>\<close>

\<comment> \<open>\<open>val _set_Counterin_IR : register_ref regstate register_value Counterin -> mword ty1 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _get_Counteren_TM : Counteren -> mword ty1\<close>\<close>

definition get_Counteren_TM  :: \<open> Counteren \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_Counteren_TM v = ( (subrange_vec_dec(Counteren_bits   v) (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " Counteren "


\<comment> \<open>\<open>val _set_Counteren_TM : register_ref regstate register_value Counteren -> mword ty1 -> M unit\<close>\<close>

definition set_Counteren_TM  :: \<open>((regstate),(register_value),(Counteren))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Counteren_TM r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Counteren_bits := ((update_subrange_vec_dec(Counteren_bits   r) (( 1 :: int)::ii) (( 1 :: int)::ii) v  ::  32 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Counteren))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Counteren_TM : Counteren -> mword ty1 -> Counteren\<close>\<close>

definition update_Counteren_TM  :: \<open> Counteren \<Rightarrow>(1)Word.word \<Rightarrow> Counteren \<close>  where 
     \<open> update_Counteren_TM v x = (
   ( v (|
     Counteren_bits := ((update_subrange_vec_dec(Counteren_bits   v) (( 1 :: int)::ii) (( 1 :: int)::ii) x  ::  32 Word.word)) |)))\<close> 
  for  v  :: " Counteren " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val legalize_mcounteren : Counteren -> mword ty64 -> Counteren\<close>\<close>

definition legalize_mcounteren  :: \<open> Counteren \<Rightarrow>(64)Word.word \<Rightarrow> Counteren \<close>  where 
     \<open> legalize_mcounteren (c :: Counteren) (v :: xlenbits) = (
   (let c = (update_Counteren_IR c (vec_of_bits [access_vec_dec v (( 2 :: int)::ii)]  ::  1 Word.word)) in
   (let c = (update_Counteren_TM c (vec_of_bits [access_vec_dec v (( 1 :: int)::ii)]  ::  1 Word.word)) in
   update_Counteren_CY c (vec_of_bits [access_vec_dec v (( 0 :: int)::ii)]  ::  1 Word.word))))\<close> 
  for  c  :: " Counteren " 
  and  v  :: "(64)Word.word "


\<comment> \<open>\<open>val legalize_scounteren : Counteren -> mword ty64 -> Counteren\<close>\<close>

definition legalize_scounteren  :: \<open> Counteren \<Rightarrow>(64)Word.word \<Rightarrow> Counteren \<close>  where 
     \<open> legalize_scounteren (c :: Counteren) (v :: xlenbits) = (
   (let c = (update_Counteren_IR c (vec_of_bits [access_vec_dec v (( 2 :: int)::ii)]  ::  1 Word.word)) in
   (let c = (update_Counteren_TM c (vec_of_bits [access_vec_dec v (( 1 :: int)::ii)]  ::  1 Word.word)) in
   update_Counteren_CY c (vec_of_bits [access_vec_dec v (( 0 :: int)::ii)]  ::  1 Word.word))))\<close> 
  for  c  :: " Counteren " 
  and  v  :: "(64)Word.word "


\<comment> \<open>\<open>val undefined_Counterin : unit -> M Counterin\<close>\<close>

definition undefined_Counterin  :: \<open> unit \<Rightarrow>((register_value),(Counterin),(exception))monad \<close>  where 
     \<open> undefined_Counterin _ = (
   ((return (failwith (''undefined value of unsupported type''))) :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::
      32 Word.word) . 
   return ((| Counterin_bits = w__0 |)))))\<close>


\<comment> \<open>\<open>val Mk_Counterin : mword ty32 -> Counterin\<close>\<close>

definition Mk_Counterin  :: \<open>(32)Word.word \<Rightarrow> Counterin \<close>  where 
     \<open> Mk_Counterin v = ( (| Counterin_bits = v |) )\<close> 
  for  v  :: "(32)Word.word "


definition get_Counterin_bits  :: \<open> Counterin \<Rightarrow>(32)Word.word \<close>  where 
     \<open> get_Counterin_bits v = ( (subrange_vec_dec(Counterin_bits   v) (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))\<close> 
  for  v  :: " Counterin "


definition set_Counterin_bits  :: \<open>((regstate),(register_value),(Counterin))register_ref \<Rightarrow>(32)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Counterin_bits r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Counterin_bits := ((update_subrange_vec_dec(Counterin_bits   r) (( 31 :: int)::ii) (( 0 :: int)::ii) v  ::  32 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Counterin))register_ref " 
  and  v  :: "(32)Word.word "


definition update_Counterin_bits  :: \<open> Counterin \<Rightarrow>(32)Word.word \<Rightarrow> Counterin \<close>  where 
     \<open> update_Counterin_bits v x = (
   ( v (|
     Counterin_bits := ((update_subrange_vec_dec(Counterin_bits   v) (( 31 :: int)::ii) (( 0 :: int)::ii) x  ::  32 Word.word)) |)))\<close> 
  for  v  :: " Counterin " 
  and  x  :: "(32)Word.word "


definition get_Counterin_CY  :: \<open> Counterin \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_Counterin_CY v = ( (subrange_vec_dec(Counterin_bits   v) (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " Counterin "


definition set_Counterin_CY  :: \<open>((regstate),(register_value),(Counterin))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Counterin_CY r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Counterin_bits := ((update_subrange_vec_dec(Counterin_bits   r) (( 0 :: int)::ii) (( 0 :: int)::ii) v  ::  32 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Counterin))register_ref " 
  and  v  :: "(1)Word.word "


definition update_Counterin_CY  :: \<open> Counterin \<Rightarrow>(1)Word.word \<Rightarrow> Counterin \<close>  where 
     \<open> update_Counterin_CY v x = (
   ( v (|
     Counterin_bits := ((update_subrange_vec_dec(Counterin_bits   v) (( 0 :: int)::ii) (( 0 :: int)::ii) x  ::  32 Word.word)) |)))\<close> 
  for  v  :: " Counterin " 
  and  x  :: "(1)Word.word "


definition get_Counterin_IR  :: \<open> Counterin \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_Counterin_IR v = ( (subrange_vec_dec(Counterin_bits   v) (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " Counterin "


definition set_Counterin_IR  :: \<open>((regstate),(register_value),(Counterin))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Counterin_IR r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Counterin_bits := ((update_subrange_vec_dec(Counterin_bits   r) (( 2 :: int)::ii) (( 2 :: int)::ii) v  ::  32 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Counterin))register_ref " 
  and  v  :: "(1)Word.word "


definition update_Counterin_IR  :: \<open> Counterin \<Rightarrow>(1)Word.word \<Rightarrow> Counterin \<close>  where 
     \<open> update_Counterin_IR v x = (
   ( v (|
     Counterin_bits := ((update_subrange_vec_dec(Counterin_bits   v) (( 2 :: int)::ii) (( 2 :: int)::ii) x  ::  32 Word.word)) |)))\<close> 
  for  v  :: " Counterin " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val legalize_mcountinhibit : Counterin -> mword ty64 -> Counterin\<close>\<close>

definition legalize_mcountinhibit  :: \<open> Counterin \<Rightarrow>(64)Word.word \<Rightarrow> Counterin \<close>  where 
     \<open> legalize_mcountinhibit (c :: Counterin) (v :: xlenbits) = (
   (let c = (update_Counterin_IR c (vec_of_bits [access_vec_dec v (( 2 :: int)::ii)]  ::  1 Word.word)) in
   update_Counterin_CY c (vec_of_bits [access_vec_dec v (( 0 :: int)::ii)]  ::  1 Word.word)))\<close> 
  for  c  :: " Counterin " 
  and  v  :: "(64)Word.word "


\<comment> \<open>\<open>val retire_instruction : unit -> M unit\<close>\<close>

definition retire_instruction  :: \<open> unit \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> retire_instruction _ = (
   read_reg minstret_written_ref \<bind> ((\<lambda> (w__0 :: bool) . 
   if (((w__0 = True))) then write_reg minstret_written_ref False
   else
   read_reg mcountinhibit_ref \<bind> ((\<lambda> (w__1 :: Counterin) . 
   if (((((get_Counterin_IR w__1  ::  1 Word.word)) = ( 0b0 ::  1 Word.word)))) then
     (read_reg minstret_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
     write_reg minstret_ref ((add_vec_int w__2 (( 1 :: int)::ii)  ::  64 Word.word))))
   else return () )))))\<close>


\<comment> \<open>\<open>val undefined_Sstatus : unit -> M Sstatus\<close>\<close>

definition undefined_Sstatus  :: \<open> unit \<Rightarrow>((register_value),(Sstatus),(exception))monad \<close>  where 
     \<open> undefined_Sstatus _ = (
   ((return (failwith (''undefined value of unsupported type''))) :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::
      64 Word.word) . 
   return ((| Sstatus_bits = w__0 |)))))\<close>


\<comment> \<open>\<open>val Mk_Sstatus : mword ty64 -> Sstatus\<close>\<close>

definition Mk_Sstatus  :: \<open>(64)Word.word \<Rightarrow> Sstatus \<close>  where 
     \<open> Mk_Sstatus v = ( (| Sstatus_bits = v |) )\<close> 
  for  v  :: "(64)Word.word "


definition get_Sstatus_bits  :: \<open> Sstatus \<Rightarrow>(64)Word.word \<close>  where 
     \<open> get_Sstatus_bits v = ( (subrange_vec_dec(Sstatus_bits   v) (( 63 :: int)::ii) (( 0 :: int)::ii)  ::  64 Word.word))\<close> 
  for  v  :: " Sstatus "


definition set_Sstatus_bits  :: \<open>((regstate),(register_value),(Sstatus))register_ref \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Sstatus_bits r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Sstatus_bits := ((update_subrange_vec_dec(Sstatus_bits   r) (( 63 :: int)::ii) (( 0 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Sstatus))register_ref " 
  and  v  :: "(64)Word.word "


definition update_Sstatus_bits  :: \<open> Sstatus \<Rightarrow>(64)Word.word \<Rightarrow> Sstatus \<close>  where 
     \<open> update_Sstatus_bits v x = (
   ( v (|
     Sstatus_bits := ((update_subrange_vec_dec(Sstatus_bits   v) (( 63 :: int)::ii) (( 0 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Sstatus " 
  and  x  :: "(64)Word.word "


definition get_Sstatus_FS  :: \<open> Sstatus \<Rightarrow>(2)Word.word \<close>  where 
     \<open> get_Sstatus_FS v = ( (subrange_vec_dec(Sstatus_bits   v) (( 14 :: int)::ii) (( 13 :: int)::ii)  ::  2 Word.word))\<close> 
  for  v  :: " Sstatus "


definition set_Sstatus_FS  :: \<open>((regstate),(register_value),(Sstatus))register_ref \<Rightarrow>(2)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Sstatus_FS r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Sstatus_bits := ((update_subrange_vec_dec(Sstatus_bits   r) (( 14 :: int)::ii) (( 13 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Sstatus))register_ref " 
  and  v  :: "(2)Word.word "


definition update_Sstatus_FS  :: \<open> Sstatus \<Rightarrow>(2)Word.word \<Rightarrow> Sstatus \<close>  where 
     \<open> update_Sstatus_FS v x = (
   ( v (|
     Sstatus_bits := ((update_subrange_vec_dec(Sstatus_bits   v) (( 14 :: int)::ii) (( 13 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Sstatus " 
  and  x  :: "(2)Word.word "


definition get_Sstatus_MXR  :: \<open> Sstatus \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_Sstatus_MXR v = ( (subrange_vec_dec(Sstatus_bits   v) (( 19 :: int)::ii) (( 19 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " Sstatus "


definition set_Sstatus_MXR  :: \<open>((regstate),(register_value),(Sstatus))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Sstatus_MXR r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Sstatus_bits := ((update_subrange_vec_dec(Sstatus_bits   r) (( 19 :: int)::ii) (( 19 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Sstatus))register_ref " 
  and  v  :: "(1)Word.word "


definition update_Sstatus_MXR  :: \<open> Sstatus \<Rightarrow>(1)Word.word \<Rightarrow> Sstatus \<close>  where 
     \<open> update_Sstatus_MXR v x = (
   ( v (|
     Sstatus_bits := ((update_subrange_vec_dec(Sstatus_bits   v) (( 19 :: int)::ii) (( 19 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Sstatus " 
  and  x  :: "(1)Word.word "


definition get_Sstatus_SD  :: \<open> Sstatus \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_Sstatus_SD v = ( (subrange_vec_dec(Sstatus_bits   v) (( 63 :: int)::ii) (( 63 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " Sstatus "


definition set_Sstatus_SD  :: \<open>((regstate),(register_value),(Sstatus))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Sstatus_SD r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Sstatus_bits := ((update_subrange_vec_dec(Sstatus_bits   r) (( 63 :: int)::ii) (( 63 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Sstatus))register_ref " 
  and  v  :: "(1)Word.word "


definition update_Sstatus_SD  :: \<open> Sstatus \<Rightarrow>(1)Word.word \<Rightarrow> Sstatus \<close>  where 
     \<open> update_Sstatus_SD v x = (
   ( v (|
     Sstatus_bits := ((update_subrange_vec_dec(Sstatus_bits   v) (( 63 :: int)::ii) (( 63 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Sstatus " 
  and  x  :: "(1)Word.word "


definition get_Sstatus_SIE  :: \<open> Sstatus \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_Sstatus_SIE v = ( (subrange_vec_dec(Sstatus_bits   v) (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " Sstatus "


definition set_Sstatus_SIE  :: \<open>((regstate),(register_value),(Sstatus))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Sstatus_SIE r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Sstatus_bits := ((update_subrange_vec_dec(Sstatus_bits   r) (( 1 :: int)::ii) (( 1 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Sstatus))register_ref " 
  and  v  :: "(1)Word.word "


definition update_Sstatus_SIE  :: \<open> Sstatus \<Rightarrow>(1)Word.word \<Rightarrow> Sstatus \<close>  where 
     \<open> update_Sstatus_SIE v x = (
   ( v (| Sstatus_bits := ((update_subrange_vec_dec(Sstatus_bits   v) (( 1 :: int)::ii) (( 1 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Sstatus " 
  and  x  :: "(1)Word.word "


definition get_Sstatus_SPIE  :: \<open> Sstatus \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_Sstatus_SPIE v = ( (subrange_vec_dec(Sstatus_bits   v) (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " Sstatus "


definition set_Sstatus_SPIE  :: \<open>((regstate),(register_value),(Sstatus))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Sstatus_SPIE r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Sstatus_bits := ((update_subrange_vec_dec(Sstatus_bits   r) (( 5 :: int)::ii) (( 5 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Sstatus))register_ref " 
  and  v  :: "(1)Word.word "


definition update_Sstatus_SPIE  :: \<open> Sstatus \<Rightarrow>(1)Word.word \<Rightarrow> Sstatus \<close>  where 
     \<open> update_Sstatus_SPIE v x = (
   ( v (| Sstatus_bits := ((update_subrange_vec_dec(Sstatus_bits   v) (( 5 :: int)::ii) (( 5 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Sstatus " 
  and  x  :: "(1)Word.word "


definition get_Sstatus_SPP  :: \<open> Sstatus \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_Sstatus_SPP v = ( (subrange_vec_dec(Sstatus_bits   v) (( 8 :: int)::ii) (( 8 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " Sstatus "


definition set_Sstatus_SPP  :: \<open>((regstate),(register_value),(Sstatus))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Sstatus_SPP r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Sstatus_bits := ((update_subrange_vec_dec(Sstatus_bits   r) (( 8 :: int)::ii) (( 8 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Sstatus))register_ref " 
  and  v  :: "(1)Word.word "


definition update_Sstatus_SPP  :: \<open> Sstatus \<Rightarrow>(1)Word.word \<Rightarrow> Sstatus \<close>  where 
     \<open> update_Sstatus_SPP v x = (
   ( v (| Sstatus_bits := ((update_subrange_vec_dec(Sstatus_bits   v) (( 8 :: int)::ii) (( 8 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Sstatus " 
  and  x  :: "(1)Word.word "


definition get_Sstatus_SUM  :: \<open> Sstatus \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_Sstatus_SUM v = ( (subrange_vec_dec(Sstatus_bits   v) (( 18 :: int)::ii) (( 18 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " Sstatus "


definition set_Sstatus_SUM  :: \<open>((regstate),(register_value),(Sstatus))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Sstatus_SUM r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Sstatus_bits := ((update_subrange_vec_dec(Sstatus_bits   r) (( 18 :: int)::ii) (( 18 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Sstatus))register_ref " 
  and  v  :: "(1)Word.word "


definition update_Sstatus_SUM  :: \<open> Sstatus \<Rightarrow>(1)Word.word \<Rightarrow> Sstatus \<close>  where 
     \<open> update_Sstatus_SUM v x = (
   ( v (|
     Sstatus_bits := ((update_subrange_vec_dec(Sstatus_bits   v) (( 18 :: int)::ii) (( 18 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Sstatus " 
  and  x  :: "(1)Word.word "


definition get_Sstatus_UIE  :: \<open> Sstatus \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_Sstatus_UIE v = ( (subrange_vec_dec(Sstatus_bits   v) (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " Sstatus "


definition set_Sstatus_UIE  :: \<open>((regstate),(register_value),(Sstatus))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Sstatus_UIE r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Sstatus_bits := ((update_subrange_vec_dec(Sstatus_bits   r) (( 0 :: int)::ii) (( 0 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Sstatus))register_ref " 
  and  v  :: "(1)Word.word "


definition update_Sstatus_UIE  :: \<open> Sstatus \<Rightarrow>(1)Word.word \<Rightarrow> Sstatus \<close>  where 
     \<open> update_Sstatus_UIE v x = (
   ( v (| Sstatus_bits := ((update_subrange_vec_dec(Sstatus_bits   v) (( 0 :: int)::ii) (( 0 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Sstatus " 
  and  x  :: "(1)Word.word "


definition get_Sstatus_UPIE  :: \<open> Sstatus \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_Sstatus_UPIE v = ( (subrange_vec_dec(Sstatus_bits   v) (( 4 :: int)::ii) (( 4 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " Sstatus "


definition set_Sstatus_UPIE  :: \<open>((regstate),(register_value),(Sstatus))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Sstatus_UPIE r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Sstatus_bits := ((update_subrange_vec_dec(Sstatus_bits   r) (( 4 :: int)::ii) (( 4 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Sstatus))register_ref " 
  and  v  :: "(1)Word.word "


definition update_Sstatus_UPIE  :: \<open> Sstatus \<Rightarrow>(1)Word.word \<Rightarrow> Sstatus \<close>  where 
     \<open> update_Sstatus_UPIE v x = (
   ( v (| Sstatus_bits := ((update_subrange_vec_dec(Sstatus_bits   v) (( 4 :: int)::ii) (( 4 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Sstatus " 
  and  x  :: "(1)Word.word "


definition get_Sstatus_XS  :: \<open> Sstatus \<Rightarrow>(2)Word.word \<close>  where 
     \<open> get_Sstatus_XS v = ( (subrange_vec_dec(Sstatus_bits   v) (( 16 :: int)::ii) (( 15 :: int)::ii)  ::  2 Word.word))\<close> 
  for  v  :: " Sstatus "


definition set_Sstatus_XS  :: \<open>((regstate),(register_value),(Sstatus))register_ref \<Rightarrow>(2)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Sstatus_XS r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Sstatus_bits := ((update_subrange_vec_dec(Sstatus_bits   r) (( 16 :: int)::ii) (( 15 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Sstatus))register_ref " 
  and  v  :: "(2)Word.word "


definition update_Sstatus_XS  :: \<open> Sstatus \<Rightarrow>(2)Word.word \<Rightarrow> Sstatus \<close>  where 
     \<open> update_Sstatus_XS v x = (
   ( v (|
     Sstatus_bits := ((update_subrange_vec_dec(Sstatus_bits   v) (( 16 :: int)::ii) (( 15 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Sstatus " 
  and  x  :: "(2)Word.word "


\<comment> \<open>\<open>val get_sstatus_UXL : Sstatus -> mword ty2\<close>\<close>

definition get_sstatus_UXL  :: \<open> Sstatus \<Rightarrow>(2)Word.word \<close>  where 
     \<open> get_sstatus_UXL s = (
   (let m = (Mk_Mstatus ((get_Sstatus_bits s  ::  64 Word.word))) in
   (get_mstatus_UXL m  ::  2 Word.word)))\<close> 
  for  s  :: " Sstatus "


\<comment> \<open>\<open>val set_sstatus_UXL : Sstatus -> mword ty2 -> Sstatus\<close>\<close>

definition set_sstatus_UXL  :: \<open> Sstatus \<Rightarrow>(2)Word.word \<Rightarrow> Sstatus \<close>  where 
     \<open> set_sstatus_UXL (s :: Sstatus) (a :: arch_xlen) = (
   (let m = (Mk_Mstatus ((get_Sstatus_bits s  ::  64 Word.word))) in
   (let m = (set_mstatus_UXL m a) in
   Mk_Sstatus ((get_Mstatus_bits m  ::  64 Word.word)))))\<close> 
  for  s  :: " Sstatus " 
  and  a  :: "(2)Word.word "


\<comment> \<open>\<open>val lower_mstatus : Mstatus -> Sstatus\<close>\<close>

definition lower_mstatus  :: \<open> Mstatus \<Rightarrow> Sstatus \<close>  where 
     \<open> lower_mstatus m = (
   (let s = (Mk_Sstatus ((EXTZ (( 64 :: int)::ii) ( 0b0 ::  1 Word.word)  ::  64 Word.word))) in
   (let s = (update_Sstatus_SD s ((get_Mstatus_SD m  ::  1 Word.word))) in
   (let s = (set_sstatus_UXL s ((get_mstatus_UXL m  ::  2 Word.word))) in
   (let s = (update_Sstatus_MXR s ((get_Mstatus_MXR m  ::  1 Word.word))) in
   (let s = (update_Sstatus_SUM s ((get_Mstatus_SUM m  ::  1 Word.word))) in
   (let s = (update_Sstatus_XS s ((get_Mstatus_XS m  ::  2 Word.word))) in
   (let s = (update_Sstatus_FS s ((get_Mstatus_FS m  ::  2 Word.word))) in
   (let s = (update_Sstatus_SPP s ((get_Mstatus_SPP m  ::  1 Word.word))) in
   (let s = (update_Sstatus_SPIE s ((get_Mstatus_SPIE m  ::  1 Word.word))) in
   (let s = (update_Sstatus_UPIE s ((get_Mstatus_UPIE m  ::  1 Word.word))) in
   (let s = (update_Sstatus_SIE s ((get_Mstatus_SIE m  ::  1 Word.word))) in
   update_Sstatus_UIE s ((get_Mstatus_UIE m  ::  1 Word.word))))))))))))))\<close> 
  for  m  :: " Mstatus "


\<comment> \<open>\<open>val lift_sstatus : Mstatus -> Sstatus -> M Mstatus\<close>\<close>

definition lift_sstatus  :: \<open> Mstatus \<Rightarrow> Sstatus \<Rightarrow>((register_value),(Mstatus),(exception))monad \<close>  where 
     \<open> lift_sstatus (m :: Mstatus) (s :: Sstatus) = (
   (let m = (update_Mstatus_MXR m ((get_Sstatus_MXR s  ::  1 Word.word))) in
   (let m = (update_Mstatus_SUM m ((get_Sstatus_SUM s  ::  1 Word.word))) in
   (let m = (update_Mstatus_XS m ((get_Sstatus_XS s  ::  2 Word.word))) in
   (let m = (update_Mstatus_FS m ((get_Sstatus_FS s  ::  2 Word.word))) in
   or_boolM
     (extStatus_of_bits ((get_Mstatus_FS m  ::  2 Word.word)) \<bind> ((\<lambda> (w__0 :: ExtStatus) . 
      return (((w__0 = Dirty))))))
     (extStatus_of_bits ((get_Mstatus_XS m  ::  2 Word.word)) \<bind> ((\<lambda> (w__1 :: ExtStatus) . 
      return (((w__1 = Dirty)))))) \<bind> ((\<lambda> dirty . 
   (let m = (update_Mstatus_SD m ((bool_to_bits dirty  ::  1 Word.word))) in
   (let m = (update_Mstatus_SPP m ((get_Sstatus_SPP s  ::  1 Word.word))) in
   (let m = (update_Mstatus_SPIE m ((get_Sstatus_SPIE s  ::  1 Word.word))) in
   (let m = (update_Mstatus_UPIE m ((get_Sstatus_UPIE s  ::  1 Word.word))) in
   (let m = (update_Mstatus_SIE m ((get_Sstatus_SIE s  ::  1 Word.word))) in
   (let m = (update_Mstatus_UIE m ((get_Sstatus_UIE s  ::  1 Word.word))) in
   return m)))))))))))))\<close> 
  for  m  :: " Mstatus " 
  and  s  :: " Sstatus "


\<comment> \<open>\<open>val legalize_sstatus : Mstatus -> mword ty64 -> M Mstatus\<close>\<close>

definition legalize_sstatus  :: \<open> Mstatus \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),(Mstatus),(exception))monad \<close>  where 
     \<open> legalize_sstatus (m :: Mstatus) (v :: xlenbits) = (
   lift_sstatus m ((Mk_Sstatus v)) \<bind> ((\<lambda> (w__0 :: Mstatus) . 
   legalize_mstatus m ((get_Mstatus_bits w__0  ::  64 Word.word)))))\<close> 
  for  m  :: " Mstatus " 
  and  v  :: "(64)Word.word "


\<comment> \<open>\<open>val undefined_Sedeleg : unit -> M Sedeleg\<close>\<close>

definition undefined_Sedeleg  :: \<open> unit \<Rightarrow>((register_value),(Sedeleg),(exception))monad \<close>  where 
     \<open> undefined_Sedeleg _ = (
   ((return (failwith (''undefined value of unsupported type''))) :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::
      64 Word.word) . 
   return ((| Sedeleg_bits = w__0 |)))))\<close>


\<comment> \<open>\<open>val Mk_Sedeleg : mword ty64 -> Sedeleg\<close>\<close>

definition Mk_Sedeleg  :: \<open>(64)Word.word \<Rightarrow> Sedeleg \<close>  where 
     \<open> Mk_Sedeleg v = ( (| Sedeleg_bits = v |) )\<close> 
  for  v  :: "(64)Word.word "


definition get_Sedeleg_bits  :: \<open> Sedeleg \<Rightarrow>(64)Word.word \<close>  where 
     \<open> get_Sedeleg_bits v = ( (subrange_vec_dec(Sedeleg_bits   v) (( 63 :: int)::ii) (( 0 :: int)::ii)  ::  64 Word.word))\<close> 
  for  v  :: " Sedeleg "


definition set_Sedeleg_bits  :: \<open>((regstate),(register_value),(Sedeleg))register_ref \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Sedeleg_bits r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Sedeleg_bits := ((update_subrange_vec_dec(Sedeleg_bits   r) (( 63 :: int)::ii) (( 0 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Sedeleg))register_ref " 
  and  v  :: "(64)Word.word "


definition update_Sedeleg_bits  :: \<open> Sedeleg \<Rightarrow>(64)Word.word \<Rightarrow> Sedeleg \<close>  where 
     \<open> update_Sedeleg_bits v x = (
   ( v (|
     Sedeleg_bits := ((update_subrange_vec_dec(Sedeleg_bits   v) (( 63 :: int)::ii) (( 0 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Sedeleg " 
  and  x  :: "(64)Word.word "


definition get_Sedeleg_Breakpoint  :: \<open> Sedeleg \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_Sedeleg_Breakpoint v = ( (subrange_vec_dec(Sedeleg_bits   v) (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " Sedeleg "


definition set_Sedeleg_Breakpoint  :: \<open>((regstate),(register_value),(Sedeleg))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Sedeleg_Breakpoint r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Sedeleg_bits := ((update_subrange_vec_dec(Sedeleg_bits   r) (( 3 :: int)::ii) (( 3 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Sedeleg))register_ref " 
  and  v  :: "(1)Word.word "


definition update_Sedeleg_Breakpoint  :: \<open> Sedeleg \<Rightarrow>(1)Word.word \<Rightarrow> Sedeleg \<close>  where 
     \<open> update_Sedeleg_Breakpoint v x = (
   ( v (| Sedeleg_bits := ((update_subrange_vec_dec(Sedeleg_bits   v) (( 3 :: int)::ii) (( 3 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Sedeleg " 
  and  x  :: "(1)Word.word "


definition get_Sedeleg_Fetch_Access_Fault  :: \<open> Sedeleg \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_Sedeleg_Fetch_Access_Fault v = ( (subrange_vec_dec(Sedeleg_bits   v) (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " Sedeleg "


definition set_Sedeleg_Fetch_Access_Fault  :: \<open>((regstate),(register_value),(Sedeleg))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Sedeleg_Fetch_Access_Fault r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Sedeleg_bits := ((update_subrange_vec_dec(Sedeleg_bits   r) (( 1 :: int)::ii) (( 1 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Sedeleg))register_ref " 
  and  v  :: "(1)Word.word "


definition update_Sedeleg_Fetch_Access_Fault  :: \<open> Sedeleg \<Rightarrow>(1)Word.word \<Rightarrow> Sedeleg \<close>  where 
     \<open> update_Sedeleg_Fetch_Access_Fault v x = (
   ( v (| Sedeleg_bits := ((update_subrange_vec_dec(Sedeleg_bits   v) (( 1 :: int)::ii) (( 1 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Sedeleg " 
  and  x  :: "(1)Word.word "


definition get_Sedeleg_Fetch_Addr_Align  :: \<open> Sedeleg \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_Sedeleg_Fetch_Addr_Align v = ( (subrange_vec_dec(Sedeleg_bits   v) (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " Sedeleg "


definition set_Sedeleg_Fetch_Addr_Align  :: \<open>((regstate),(register_value),(Sedeleg))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Sedeleg_Fetch_Addr_Align r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Sedeleg_bits := ((update_subrange_vec_dec(Sedeleg_bits   r) (( 0 :: int)::ii) (( 0 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Sedeleg))register_ref " 
  and  v  :: "(1)Word.word "


definition update_Sedeleg_Fetch_Addr_Align  :: \<open> Sedeleg \<Rightarrow>(1)Word.word \<Rightarrow> Sedeleg \<close>  where 
     \<open> update_Sedeleg_Fetch_Addr_Align v x = (
   ( v (| Sedeleg_bits := ((update_subrange_vec_dec(Sedeleg_bits   v) (( 0 :: int)::ii) (( 0 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Sedeleg " 
  and  x  :: "(1)Word.word "


definition get_Sedeleg_Illegal_Instr  :: \<open> Sedeleg \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_Sedeleg_Illegal_Instr v = ( (subrange_vec_dec(Sedeleg_bits   v) (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " Sedeleg "


definition set_Sedeleg_Illegal_Instr  :: \<open>((regstate),(register_value),(Sedeleg))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Sedeleg_Illegal_Instr r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Sedeleg_bits := ((update_subrange_vec_dec(Sedeleg_bits   r) (( 2 :: int)::ii) (( 2 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Sedeleg))register_ref " 
  and  v  :: "(1)Word.word "


definition update_Sedeleg_Illegal_Instr  :: \<open> Sedeleg \<Rightarrow>(1)Word.word \<Rightarrow> Sedeleg \<close>  where 
     \<open> update_Sedeleg_Illegal_Instr v x = (
   ( v (| Sedeleg_bits := ((update_subrange_vec_dec(Sedeleg_bits   v) (( 2 :: int)::ii) (( 2 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Sedeleg " 
  and  x  :: "(1)Word.word "


definition get_Sedeleg_Load_Access_Fault  :: \<open> Sedeleg \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_Sedeleg_Load_Access_Fault v = ( (subrange_vec_dec(Sedeleg_bits   v) (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " Sedeleg "


definition set_Sedeleg_Load_Access_Fault  :: \<open>((regstate),(register_value),(Sedeleg))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Sedeleg_Load_Access_Fault r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Sedeleg_bits := ((update_subrange_vec_dec(Sedeleg_bits   r) (( 5 :: int)::ii) (( 5 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Sedeleg))register_ref " 
  and  v  :: "(1)Word.word "


definition update_Sedeleg_Load_Access_Fault  :: \<open> Sedeleg \<Rightarrow>(1)Word.word \<Rightarrow> Sedeleg \<close>  where 
     \<open> update_Sedeleg_Load_Access_Fault v x = (
   ( v (| Sedeleg_bits := ((update_subrange_vec_dec(Sedeleg_bits   v) (( 5 :: int)::ii) (( 5 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Sedeleg " 
  and  x  :: "(1)Word.word "


definition get_Sedeleg_Load_Addr_Align  :: \<open> Sedeleg \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_Sedeleg_Load_Addr_Align v = ( (subrange_vec_dec(Sedeleg_bits   v) (( 4 :: int)::ii) (( 4 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " Sedeleg "


definition set_Sedeleg_Load_Addr_Align  :: \<open>((regstate),(register_value),(Sedeleg))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Sedeleg_Load_Addr_Align r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Sedeleg_bits := ((update_subrange_vec_dec(Sedeleg_bits   r) (( 4 :: int)::ii) (( 4 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Sedeleg))register_ref " 
  and  v  :: "(1)Word.word "


definition update_Sedeleg_Load_Addr_Align  :: \<open> Sedeleg \<Rightarrow>(1)Word.word \<Rightarrow> Sedeleg \<close>  where 
     \<open> update_Sedeleg_Load_Addr_Align v x = (
   ( v (| Sedeleg_bits := ((update_subrange_vec_dec(Sedeleg_bits   v) (( 4 :: int)::ii) (( 4 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Sedeleg " 
  and  x  :: "(1)Word.word "


definition get_Sedeleg_SAMO_Access_Fault  :: \<open> Sedeleg \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_Sedeleg_SAMO_Access_Fault v = ( (subrange_vec_dec(Sedeleg_bits   v) (( 7 :: int)::ii) (( 7 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " Sedeleg "


definition set_Sedeleg_SAMO_Access_Fault  :: \<open>((regstate),(register_value),(Sedeleg))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Sedeleg_SAMO_Access_Fault r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Sedeleg_bits := ((update_subrange_vec_dec(Sedeleg_bits   r) (( 7 :: int)::ii) (( 7 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Sedeleg))register_ref " 
  and  v  :: "(1)Word.word "


definition update_Sedeleg_SAMO_Access_Fault  :: \<open> Sedeleg \<Rightarrow>(1)Word.word \<Rightarrow> Sedeleg \<close>  where 
     \<open> update_Sedeleg_SAMO_Access_Fault v x = (
   ( v (| Sedeleg_bits := ((update_subrange_vec_dec(Sedeleg_bits   v) (( 7 :: int)::ii) (( 7 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Sedeleg " 
  and  x  :: "(1)Word.word "


definition get_Sedeleg_SAMO_Addr_Align  :: \<open> Sedeleg \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_Sedeleg_SAMO_Addr_Align v = ( (subrange_vec_dec(Sedeleg_bits   v) (( 6 :: int)::ii) (( 6 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " Sedeleg "


definition set_Sedeleg_SAMO_Addr_Align  :: \<open>((regstate),(register_value),(Sedeleg))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Sedeleg_SAMO_Addr_Align r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Sedeleg_bits := ((update_subrange_vec_dec(Sedeleg_bits   r) (( 6 :: int)::ii) (( 6 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Sedeleg))register_ref " 
  and  v  :: "(1)Word.word "


definition update_Sedeleg_SAMO_Addr_Align  :: \<open> Sedeleg \<Rightarrow>(1)Word.word \<Rightarrow> Sedeleg \<close>  where 
     \<open> update_Sedeleg_SAMO_Addr_Align v x = (
   ( v (| Sedeleg_bits := ((update_subrange_vec_dec(Sedeleg_bits   v) (( 6 :: int)::ii) (( 6 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Sedeleg " 
  and  x  :: "(1)Word.word "


definition get_Sedeleg_UEnvCall  :: \<open> Sedeleg \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_Sedeleg_UEnvCall v = ( (subrange_vec_dec(Sedeleg_bits   v) (( 8 :: int)::ii) (( 8 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " Sedeleg "


definition set_Sedeleg_UEnvCall  :: \<open>((regstate),(register_value),(Sedeleg))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Sedeleg_UEnvCall r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Sedeleg_bits := ((update_subrange_vec_dec(Sedeleg_bits   r) (( 8 :: int)::ii) (( 8 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Sedeleg))register_ref " 
  and  v  :: "(1)Word.word "


definition update_Sedeleg_UEnvCall  :: \<open> Sedeleg \<Rightarrow>(1)Word.word \<Rightarrow> Sedeleg \<close>  where 
     \<open> update_Sedeleg_UEnvCall v x = (
   ( v (| Sedeleg_bits := ((update_subrange_vec_dec(Sedeleg_bits   v) (( 8 :: int)::ii) (( 8 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Sedeleg " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val legalize_sedeleg : Sedeleg -> mword ty64 -> Sedeleg\<close>\<close>

definition legalize_sedeleg  :: \<open> Sedeleg \<Rightarrow>(64)Word.word \<Rightarrow> Sedeleg \<close>  where 
     \<open> legalize_sedeleg (s :: Sedeleg) (v :: xlenbits) = (
   Mk_Sedeleg ((EXTZ (( 64 :: int)::ii) ((subrange_vec_dec v (( 8 :: int)::ii) (( 0 :: int)::ii)  ::  9 Word.word))  ::  64 Word.word)))\<close> 
  for  s  :: " Sedeleg " 
  and  v  :: "(64)Word.word "


\<comment> \<open>\<open>val undefined_Sinterrupts : unit -> M Sinterrupts\<close>\<close>

definition undefined_Sinterrupts  :: \<open> unit \<Rightarrow>((register_value),(Sinterrupts),(exception))monad \<close>  where 
     \<open> undefined_Sinterrupts _ = (
   ((return (failwith (''undefined value of unsupported type''))) :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::
      64 Word.word) . 
   return ((| Sinterrupts_bits = w__0 |)))))\<close>


\<comment> \<open>\<open>val Mk_Sinterrupts : mword ty64 -> Sinterrupts\<close>\<close>

definition Mk_Sinterrupts  :: \<open>(64)Word.word \<Rightarrow> Sinterrupts \<close>  where 
     \<open> Mk_Sinterrupts v = ( (| Sinterrupts_bits = v |) )\<close> 
  for  v  :: "(64)Word.word "


definition get_Sinterrupts_bits  :: \<open> Sinterrupts \<Rightarrow>(64)Word.word \<close>  where 
     \<open> get_Sinterrupts_bits v = ( (subrange_vec_dec(Sinterrupts_bits   v) (( 63 :: int)::ii) (( 0 :: int)::ii)  ::  64 Word.word))\<close> 
  for  v  :: " Sinterrupts "


definition set_Sinterrupts_bits  :: \<open>((regstate),(register_value),(Sinterrupts))register_ref \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Sinterrupts_bits r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Sinterrupts_bits :=
         ((update_subrange_vec_dec(Sinterrupts_bits   r) (( 63 :: int)::ii) (( 0 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Sinterrupts))register_ref " 
  and  v  :: "(64)Word.word "


definition update_Sinterrupts_bits  :: \<open> Sinterrupts \<Rightarrow>(64)Word.word \<Rightarrow> Sinterrupts \<close>  where 
     \<open> update_Sinterrupts_bits v x = (
   ( v (|
     Sinterrupts_bits :=
       ((update_subrange_vec_dec(Sinterrupts_bits   v) (( 63 :: int)::ii) (( 0 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Sinterrupts " 
  and  x  :: "(64)Word.word "


definition get_Sinterrupts_SEI  :: \<open> Sinterrupts \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_Sinterrupts_SEI v = ( (subrange_vec_dec(Sinterrupts_bits   v) (( 9 :: int)::ii) (( 9 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " Sinterrupts "


definition set_Sinterrupts_SEI  :: \<open>((regstate),(register_value),(Sinterrupts))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Sinterrupts_SEI r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Sinterrupts_bits :=
         ((update_subrange_vec_dec(Sinterrupts_bits   r) (( 9 :: int)::ii) (( 9 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Sinterrupts))register_ref " 
  and  v  :: "(1)Word.word "


definition update_Sinterrupts_SEI  :: \<open> Sinterrupts \<Rightarrow>(1)Word.word \<Rightarrow> Sinterrupts \<close>  where 
     \<open> update_Sinterrupts_SEI v x = (
   ( v (|
     Sinterrupts_bits := ((update_subrange_vec_dec(Sinterrupts_bits   v) (( 9 :: int)::ii) (( 9 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Sinterrupts " 
  and  x  :: "(1)Word.word "


definition get_Sinterrupts_SSI  :: \<open> Sinterrupts \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_Sinterrupts_SSI v = ( (subrange_vec_dec(Sinterrupts_bits   v) (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " Sinterrupts "


definition set_Sinterrupts_SSI  :: \<open>((regstate),(register_value),(Sinterrupts))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Sinterrupts_SSI r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Sinterrupts_bits :=
         ((update_subrange_vec_dec(Sinterrupts_bits   r) (( 1 :: int)::ii) (( 1 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Sinterrupts))register_ref " 
  and  v  :: "(1)Word.word "


definition update_Sinterrupts_SSI  :: \<open> Sinterrupts \<Rightarrow>(1)Word.word \<Rightarrow> Sinterrupts \<close>  where 
     \<open> update_Sinterrupts_SSI v x = (
   ( v (|
     Sinterrupts_bits := ((update_subrange_vec_dec(Sinterrupts_bits   v) (( 1 :: int)::ii) (( 1 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Sinterrupts " 
  and  x  :: "(1)Word.word "


definition get_Sinterrupts_STI  :: \<open> Sinterrupts \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_Sinterrupts_STI v = ( (subrange_vec_dec(Sinterrupts_bits   v) (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " Sinterrupts "


definition set_Sinterrupts_STI  :: \<open>((regstate),(register_value),(Sinterrupts))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Sinterrupts_STI r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Sinterrupts_bits :=
         ((update_subrange_vec_dec(Sinterrupts_bits   r) (( 5 :: int)::ii) (( 5 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Sinterrupts))register_ref " 
  and  v  :: "(1)Word.word "


definition update_Sinterrupts_STI  :: \<open> Sinterrupts \<Rightarrow>(1)Word.word \<Rightarrow> Sinterrupts \<close>  where 
     \<open> update_Sinterrupts_STI v x = (
   ( v (|
     Sinterrupts_bits := ((update_subrange_vec_dec(Sinterrupts_bits   v) (( 5 :: int)::ii) (( 5 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Sinterrupts " 
  and  x  :: "(1)Word.word "


definition get_Sinterrupts_UEI  :: \<open> Sinterrupts \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_Sinterrupts_UEI v = ( (subrange_vec_dec(Sinterrupts_bits   v) (( 8 :: int)::ii) (( 8 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " Sinterrupts "


definition set_Sinterrupts_UEI  :: \<open>((regstate),(register_value),(Sinterrupts))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Sinterrupts_UEI r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Sinterrupts_bits :=
         ((update_subrange_vec_dec(Sinterrupts_bits   r) (( 8 :: int)::ii) (( 8 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Sinterrupts))register_ref " 
  and  v  :: "(1)Word.word "


definition update_Sinterrupts_UEI  :: \<open> Sinterrupts \<Rightarrow>(1)Word.word \<Rightarrow> Sinterrupts \<close>  where 
     \<open> update_Sinterrupts_UEI v x = (
   ( v (|
     Sinterrupts_bits := ((update_subrange_vec_dec(Sinterrupts_bits   v) (( 8 :: int)::ii) (( 8 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Sinterrupts " 
  and  x  :: "(1)Word.word "


definition get_Sinterrupts_USI  :: \<open> Sinterrupts \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_Sinterrupts_USI v = ( (subrange_vec_dec(Sinterrupts_bits   v) (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " Sinterrupts "


definition set_Sinterrupts_USI  :: \<open>((regstate),(register_value),(Sinterrupts))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Sinterrupts_USI r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Sinterrupts_bits :=
         ((update_subrange_vec_dec(Sinterrupts_bits   r) (( 0 :: int)::ii) (( 0 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Sinterrupts))register_ref " 
  and  v  :: "(1)Word.word "


definition update_Sinterrupts_USI  :: \<open> Sinterrupts \<Rightarrow>(1)Word.word \<Rightarrow> Sinterrupts \<close>  where 
     \<open> update_Sinterrupts_USI v x = (
   ( v (|
     Sinterrupts_bits := ((update_subrange_vec_dec(Sinterrupts_bits   v) (( 0 :: int)::ii) (( 0 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Sinterrupts " 
  and  x  :: "(1)Word.word "


definition get_Sinterrupts_UTI  :: \<open> Sinterrupts \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_Sinterrupts_UTI v = ( (subrange_vec_dec(Sinterrupts_bits   v) (( 4 :: int)::ii) (( 4 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " Sinterrupts "


definition set_Sinterrupts_UTI  :: \<open>((regstate),(register_value),(Sinterrupts))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Sinterrupts_UTI r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Sinterrupts_bits :=
         ((update_subrange_vec_dec(Sinterrupts_bits   r) (( 4 :: int)::ii) (( 4 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Sinterrupts))register_ref " 
  and  v  :: "(1)Word.word "


definition update_Sinterrupts_UTI  :: \<open> Sinterrupts \<Rightarrow>(1)Word.word \<Rightarrow> Sinterrupts \<close>  where 
     \<open> update_Sinterrupts_UTI v x = (
   ( v (|
     Sinterrupts_bits := ((update_subrange_vec_dec(Sinterrupts_bits   v) (( 4 :: int)::ii) (( 4 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Sinterrupts " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val lower_mip : Minterrupts -> Minterrupts -> Sinterrupts\<close>\<close>

definition lower_mip  :: \<open> Minterrupts \<Rightarrow> Minterrupts \<Rightarrow> Sinterrupts \<close>  where 
     \<open> lower_mip (m :: Minterrupts) (d :: Minterrupts) = (
   (let (s :: Sinterrupts) = (Mk_Sinterrupts ((EXTZ (( 64 :: int)::ii) ( 0b0 ::  1 Word.word)  ::  64 Word.word))) in
   (let s =
     (update_Sinterrupts_SEI s
       ((and_vec ((get_Minterrupts_SEI m  ::  1 Word.word)) ((get_Minterrupts_SEI d  ::  1 Word.word))
          ::  1 Word.word))) in
   (let s =
     (update_Sinterrupts_STI s
       ((and_vec ((get_Minterrupts_STI m  ::  1 Word.word)) ((get_Minterrupts_STI d  ::  1 Word.word))
          ::  1 Word.word))) in
   (let s =
     (update_Sinterrupts_SSI s
       ((and_vec ((get_Minterrupts_SSI m  ::  1 Word.word)) ((get_Minterrupts_SSI d  ::  1 Word.word))
          ::  1 Word.word))) in
   (let s =
     (update_Sinterrupts_UEI s
       ((and_vec ((get_Minterrupts_UEI m  ::  1 Word.word)) ((get_Minterrupts_UEI d  ::  1 Word.word))
          ::  1 Word.word))) in
   (let s =
     (update_Sinterrupts_UTI s
       ((and_vec ((get_Minterrupts_UTI m  ::  1 Word.word)) ((get_Minterrupts_UTI d  ::  1 Word.word))
          ::  1 Word.word))) in
   update_Sinterrupts_USI s
     ((and_vec ((get_Minterrupts_USI m  ::  1 Word.word)) ((get_Minterrupts_USI d  ::  1 Word.word))
        ::  1 Word.word)))))))))\<close> 
  for  m  :: " Minterrupts " 
  and  d  :: " Minterrupts "


\<comment> \<open>\<open>val lower_mie : Minterrupts -> Minterrupts -> Sinterrupts\<close>\<close>

definition lower_mie  :: \<open> Minterrupts \<Rightarrow> Minterrupts \<Rightarrow> Sinterrupts \<close>  where 
     \<open> lower_mie (m :: Minterrupts) (d :: Minterrupts) = (
   (let (s :: Sinterrupts) = (Mk_Sinterrupts ((EXTZ (( 64 :: int)::ii) ( 0b0 ::  1 Word.word)  ::  64 Word.word))) in
   (let s =
     (update_Sinterrupts_SEI s
       ((and_vec ((get_Minterrupts_SEI m  ::  1 Word.word)) ((get_Minterrupts_SEI d  ::  1 Word.word))
          ::  1 Word.word))) in
   (let s =
     (update_Sinterrupts_STI s
       ((and_vec ((get_Minterrupts_STI m  ::  1 Word.word)) ((get_Minterrupts_STI d  ::  1 Word.word))
          ::  1 Word.word))) in
   (let s =
     (update_Sinterrupts_SSI s
       ((and_vec ((get_Minterrupts_SSI m  ::  1 Word.word)) ((get_Minterrupts_SSI d  ::  1 Word.word))
          ::  1 Word.word))) in
   (let s =
     (update_Sinterrupts_UEI s
       ((and_vec ((get_Minterrupts_UEI m  ::  1 Word.word)) ((get_Minterrupts_UEI d  ::  1 Word.word))
          ::  1 Word.word))) in
   (let s =
     (update_Sinterrupts_UTI s
       ((and_vec ((get_Minterrupts_UTI m  ::  1 Word.word)) ((get_Minterrupts_UTI d  ::  1 Word.word))
          ::  1 Word.word))) in
   update_Sinterrupts_USI s
     ((and_vec ((get_Minterrupts_USI m  ::  1 Word.word)) ((get_Minterrupts_USI d  ::  1 Word.word))
        ::  1 Word.word)))))))))\<close> 
  for  m  :: " Minterrupts " 
  and  d  :: " Minterrupts "


\<comment> \<open>\<open>val lift_sip : Minterrupts -> Minterrupts -> Sinterrupts -> M Minterrupts\<close>\<close>

definition lift_sip  :: \<open> Minterrupts \<Rightarrow> Minterrupts \<Rightarrow> Sinterrupts \<Rightarrow>((register_value),(Minterrupts),(exception))monad \<close>  where 
     \<open> lift_sip (o1 :: Minterrupts) (d :: Minterrupts) (s :: Sinterrupts) = (
   (let (m :: Minterrupts) = o1 in
   (let m =
     (if (((((get_Minterrupts_SSI d  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))) then
       update_Minterrupts_SSI m ((get_Sinterrupts_SSI s  ::  1 Word.word))
     else m) in
   haveNExt ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   return (if w__0 then
             (let m =
               (if (((((get_Minterrupts_UEI d  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))) then
                 update_Minterrupts_UEI m ((get_Sinterrupts_UEI s  ::  1 Word.word))
               else m) in
             if (((((get_Minterrupts_USI d  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))) then
               update_Minterrupts_USI m ((get_Sinterrupts_USI s  ::  1 Word.word))
             else m)
           else m))))))\<close> 
  for  o1  :: " Minterrupts " 
  and  d  :: " Minterrupts " 
  and  s  :: " Sinterrupts "


\<comment> \<open>\<open>val legalize_sip : Minterrupts -> Minterrupts -> mword ty64 -> M Minterrupts\<close>\<close>

definition legalize_sip  :: \<open> Minterrupts \<Rightarrow> Minterrupts \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),(Minterrupts),(exception))monad \<close>  where 
     \<open> legalize_sip (m :: Minterrupts) (d :: Minterrupts) (v :: xlenbits) = (
   lift_sip m d ((Mk_Sinterrupts v)))\<close> 
  for  m  :: " Minterrupts " 
  and  d  :: " Minterrupts " 
  and  v  :: "(64)Word.word "


\<comment> \<open>\<open>val lift_sie : Minterrupts -> Minterrupts -> Sinterrupts -> M Minterrupts\<close>\<close>

definition lift_sie  :: \<open> Minterrupts \<Rightarrow> Minterrupts \<Rightarrow> Sinterrupts \<Rightarrow>((register_value),(Minterrupts),(exception))monad \<close>  where 
     \<open> lift_sie (o1 :: Minterrupts) (d :: Minterrupts) (s :: Sinterrupts) = (
   (let (m :: Minterrupts) = o1 in
   (let m =
     (if (((((get_Minterrupts_SEI d  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))) then
       update_Minterrupts_SEI m ((get_Sinterrupts_SEI s  ::  1 Word.word))
     else m) in
   (let m =
     (if (((((get_Minterrupts_STI d  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))) then
       update_Minterrupts_STI m ((get_Sinterrupts_STI s  ::  1 Word.word))
     else m) in
   (let m =
     (if (((((get_Minterrupts_SSI d  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))) then
       update_Minterrupts_SSI m ((get_Sinterrupts_SSI s  ::  1 Word.word))
     else m) in
   haveNExt ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   return (if w__0 then
             (let m =
               (if (((((get_Minterrupts_UEI d  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))) then
                 update_Minterrupts_UEI m ((get_Sinterrupts_UEI s  ::  1 Word.word))
               else m) in
             (let m =
               (if (((((get_Minterrupts_UTI d  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))) then
                 update_Minterrupts_UTI m ((get_Sinterrupts_UTI s  ::  1 Word.word))
               else m) in
             if (((((get_Minterrupts_USI d  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))) then
               update_Minterrupts_USI m ((get_Sinterrupts_USI s  ::  1 Word.word))
             else m))
           else m))))))))\<close> 
  for  o1  :: " Minterrupts " 
  and  d  :: " Minterrupts " 
  and  s  :: " Sinterrupts "


\<comment> \<open>\<open>val legalize_sie : Minterrupts -> Minterrupts -> mword ty64 -> M Minterrupts\<close>\<close>

definition legalize_sie  :: \<open> Minterrupts \<Rightarrow> Minterrupts \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),(Minterrupts),(exception))monad \<close>  where 
     \<open> legalize_sie (m :: Minterrupts) (d :: Minterrupts) (v :: xlenbits) = (
   lift_sie m d ((Mk_Sinterrupts v)))\<close> 
  for  m  :: " Minterrupts " 
  and  d  :: " Minterrupts " 
  and  v  :: "(64)Word.word "


\<comment> \<open>\<open>val undefined_Satp64 : unit -> M Satp64\<close>\<close>

definition undefined_Satp64  :: \<open> unit \<Rightarrow>((register_value),(Satp64),(exception))monad \<close>  where 
     \<open> undefined_Satp64 _ = (
   ((return (failwith (''undefined value of unsupported type''))) :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::
      64 Word.word) . 
   return ((| Satp64_bits = w__0 |)))))\<close>


\<comment> \<open>\<open>val Mk_Satp64 : mword ty64 -> Satp64\<close>\<close>

definition Mk_Satp64  :: \<open>(64)Word.word \<Rightarrow> Satp64 \<close>  where 
     \<open> Mk_Satp64 v = ( (| Satp64_bits = v |) )\<close> 
  for  v  :: "(64)Word.word "


definition get_Satp64_bits  :: \<open> Satp64 \<Rightarrow>(64)Word.word \<close>  where 
     \<open> get_Satp64_bits v = ( (subrange_vec_dec(Satp64_bits   v) (( 63 :: int)::ii) (( 0 :: int)::ii)  ::  64 Word.word))\<close> 
  for  v  :: " Satp64 "


definition set_Satp64_bits  :: \<open>((regstate),(register_value),(Satp64))register_ref \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Satp64_bits r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Satp64_bits := ((update_subrange_vec_dec(Satp64_bits   r) (( 63 :: int)::ii) (( 0 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Satp64))register_ref " 
  and  v  :: "(64)Word.word "


definition update_Satp64_bits  :: \<open> Satp64 \<Rightarrow>(64)Word.word \<Rightarrow> Satp64 \<close>  where 
     \<open> update_Satp64_bits v x = (
   ( v (| Satp64_bits := ((update_subrange_vec_dec(Satp64_bits   v) (( 63 :: int)::ii) (( 0 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Satp64 " 
  and  x  :: "(64)Word.word "


\<comment> \<open>\<open>val _get_Satp64_Asid : Satp64 -> mword ty16\<close>\<close>

definition get_Satp64_Asid  :: \<open> Satp64 \<Rightarrow>(16)Word.word \<close>  where 
     \<open> get_Satp64_Asid v = ( (subrange_vec_dec(Satp64_bits   v) (( 59 :: int)::ii) (( 44 :: int)::ii)  ::  16 Word.word))\<close> 
  for  v  :: " Satp64 "


\<comment> \<open>\<open>val _set_Satp64_Asid : register_ref regstate register_value Satp64 -> mword ty16 -> M unit\<close>\<close>

definition set_Satp64_Asid  :: \<open>((regstate),(register_value),(Satp64))register_ref \<Rightarrow>(16)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Satp64_Asid r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Satp64_bits := ((update_subrange_vec_dec(Satp64_bits   r) (( 59 :: int)::ii) (( 44 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Satp64))register_ref " 
  and  v  :: "(16)Word.word "


\<comment> \<open>\<open>val _update_Satp64_Asid : Satp64 -> mword ty16 -> Satp64\<close>\<close>

definition update_Satp64_Asid  :: \<open> Satp64 \<Rightarrow>(16)Word.word \<Rightarrow> Satp64 \<close>  where 
     \<open> update_Satp64_Asid v x = (
   ( v (| Satp64_bits := ((update_subrange_vec_dec(Satp64_bits   v) (( 59 :: int)::ii) (( 44 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Satp64 " 
  and  x  :: "(16)Word.word "


\<comment> \<open>\<open>val _update_Satp32_Asid : Satp32 -> mword ty9 -> Satp32\<close>\<close>

\<comment> \<open>\<open>val _get_Satp32_Asid : Satp32 -> mword ty9\<close>\<close>

\<comment> \<open>\<open>val _set_Satp32_Asid : register_ref regstate register_value Satp32 -> mword ty9 -> M unit\<close>\<close>

definition get_Satp64_Mode  :: \<open> Satp64 \<Rightarrow>(4)Word.word \<close>  where 
     \<open> get_Satp64_Mode v = ( (subrange_vec_dec(Satp64_bits   v) (( 63 :: int)::ii) (( 60 :: int)::ii)  ::  4 Word.word))\<close> 
  for  v  :: " Satp64 "


definition set_Satp64_Mode  :: \<open>((regstate),(register_value),(Satp64))register_ref \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Satp64_Mode r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Satp64_bits := ((update_subrange_vec_dec(Satp64_bits   r) (( 63 :: int)::ii) (( 60 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Satp64))register_ref " 
  and  v  :: "(4)Word.word "


definition update_Satp64_Mode  :: \<open> Satp64 \<Rightarrow>(4)Word.word \<Rightarrow> Satp64 \<close>  where 
     \<open> update_Satp64_Mode v x = (
   ( v (| Satp64_bits := ((update_subrange_vec_dec(Satp64_bits   v) (( 63 :: int)::ii) (( 60 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Satp64 " 
  and  x  :: "(4)Word.word "


\<comment> \<open>\<open>val _get_Satp64_PPN : Satp64 -> mword ty44\<close>\<close>

definition get_Satp64_PPN  :: \<open> Satp64 \<Rightarrow>(44)Word.word \<close>  where 
     \<open> get_Satp64_PPN v = ( (subrange_vec_dec(Satp64_bits   v) (( 43 :: int)::ii) (( 0 :: int)::ii)  ::  44 Word.word))\<close> 
  for  v  :: " Satp64 "


\<comment> \<open>\<open>val _set_Satp64_PPN : register_ref regstate register_value Satp64 -> mword ty44 -> M unit\<close>\<close>

definition set_Satp64_PPN  :: \<open>((regstate),(register_value),(Satp64))register_ref \<Rightarrow>(44)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Satp64_PPN r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Satp64_bits := ((update_subrange_vec_dec(Satp64_bits   r) (( 43 :: int)::ii) (( 0 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Satp64))register_ref " 
  and  v  :: "(44)Word.word "


\<comment> \<open>\<open>val _update_Satp64_PPN : Satp64 -> mword ty44 -> Satp64\<close>\<close>

definition update_Satp64_PPN  :: \<open> Satp64 \<Rightarrow>(44)Word.word \<Rightarrow> Satp64 \<close>  where 
     \<open> update_Satp64_PPN v x = (
   ( v (| Satp64_bits := ((update_subrange_vec_dec(Satp64_bits   v) (( 43 :: int)::ii) (( 0 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Satp64 " 
  and  x  :: "(44)Word.word "


\<comment> \<open>\<open>val _update_Satp32_PPN : Satp32 -> mword ty22 -> Satp32\<close>\<close>

\<comment> \<open>\<open>val _get_Satp32_PPN : Satp32 -> mword ty22\<close>\<close>

\<comment> \<open>\<open>val _set_Satp32_PPN : register_ref regstate register_value Satp32 -> mword ty22 -> M unit\<close>\<close>

\<comment> \<open>\<open>val legalize_satp64 : Architecture -> mword ty64 -> mword ty64 -> mword ty64\<close>\<close>

definition legalize_satp64  :: \<open> Architecture \<Rightarrow>(64)Word.word \<Rightarrow>(64)Word.word \<Rightarrow>(64)Word.word \<close>  where 
     \<open> legalize_satp64 (a :: Architecture) (o1 :: 64 bits) (v :: 64 bits) = (
   (let s = (Mk_Satp64 v) in
   (case  ((satp64Mode_of_bits a ((get_Satp64_Mode s  ::  4 Word.word)))) of
     None => o1
   | Some (Sv32) => o1
   | Some (_) => (get_Satp64_bits s  ::  64 Word.word)
   )))\<close> 
  for  a  :: " Architecture " 
  and  o1  :: "(64)Word.word " 
  and  v  :: "(64)Word.word "


\<comment> \<open>\<open>val undefined_Satp32 : unit -> M Satp32\<close>\<close>

definition undefined_Satp32  :: \<open> unit \<Rightarrow>((register_value),(Satp32),(exception))monad \<close>  where 
     \<open> undefined_Satp32 _ = (
   ((return (failwith (''undefined value of unsupported type''))) :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::
      32 Word.word) . 
   return ((| Satp32_bits = w__0 |)))))\<close>


\<comment> \<open>\<open>val Mk_Satp32 : mword ty32 -> Satp32\<close>\<close>

definition Mk_Satp32  :: \<open>(32)Word.word \<Rightarrow> Satp32 \<close>  where 
     \<open> Mk_Satp32 v = ( (| Satp32_bits = v |) )\<close> 
  for  v  :: "(32)Word.word "


definition get_Satp32_bits  :: \<open> Satp32 \<Rightarrow>(32)Word.word \<close>  where 
     \<open> get_Satp32_bits v = ( (subrange_vec_dec(Satp32_bits   v) (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))\<close> 
  for  v  :: " Satp32 "


definition set_Satp32_bits  :: \<open>((regstate),(register_value),(Satp32))register_ref \<Rightarrow>(32)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Satp32_bits r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Satp32_bits := ((update_subrange_vec_dec(Satp32_bits   r) (( 31 :: int)::ii) (( 0 :: int)::ii) v  ::  32 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Satp32))register_ref " 
  and  v  :: "(32)Word.word "


definition update_Satp32_bits  :: \<open> Satp32 \<Rightarrow>(32)Word.word \<Rightarrow> Satp32 \<close>  where 
     \<open> update_Satp32_bits v x = (
   ( v (| Satp32_bits := ((update_subrange_vec_dec(Satp32_bits   v) (( 31 :: int)::ii) (( 0 :: int)::ii) x  ::  32 Word.word)) |)))\<close> 
  for  v  :: " Satp32 " 
  and  x  :: "(32)Word.word "


definition get_Satp32_Asid  :: \<open> Satp32 \<Rightarrow>(9)Word.word \<close>  where 
     \<open> get_Satp32_Asid v = ( (subrange_vec_dec(Satp32_bits   v) (( 30 :: int)::ii) (( 22 :: int)::ii)  ::  9 Word.word))\<close> 
  for  v  :: " Satp32 "


definition set_Satp32_Asid  :: \<open>((regstate),(register_value),(Satp32))register_ref \<Rightarrow>(9)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Satp32_Asid r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Satp32_bits := ((update_subrange_vec_dec(Satp32_bits   r) (( 30 :: int)::ii) (( 22 :: int)::ii) v  ::  32 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Satp32))register_ref " 
  and  v  :: "(9)Word.word "


definition update_Satp32_Asid  :: \<open> Satp32 \<Rightarrow>(9)Word.word \<Rightarrow> Satp32 \<close>  where 
     \<open> update_Satp32_Asid v x = (
   ( v (| Satp32_bits := ((update_subrange_vec_dec(Satp32_bits   v) (( 30 :: int)::ii) (( 22 :: int)::ii) x  ::  32 Word.word)) |)))\<close> 
  for  v  :: " Satp32 " 
  and  x  :: "(9)Word.word "


definition get_Satp32_Mode  :: \<open> Satp32 \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_Satp32_Mode v = ( (subrange_vec_dec(Satp32_bits   v) (( 31 :: int)::ii) (( 31 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " Satp32 "


definition set_Satp32_Mode  :: \<open>((regstate),(register_value),(Satp32))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Satp32_Mode r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Satp32_bits := ((update_subrange_vec_dec(Satp32_bits   r) (( 31 :: int)::ii) (( 31 :: int)::ii) v  ::  32 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Satp32))register_ref " 
  and  v  :: "(1)Word.word "


definition update_Satp32_Mode  :: \<open> Satp32 \<Rightarrow>(1)Word.word \<Rightarrow> Satp32 \<close>  where 
     \<open> update_Satp32_Mode v x = (
   ( v (| Satp32_bits := ((update_subrange_vec_dec(Satp32_bits   v) (( 31 :: int)::ii) (( 31 :: int)::ii) x  ::  32 Word.word)) |)))\<close> 
  for  v  :: " Satp32 " 
  and  x  :: "(1)Word.word "


definition get_Satp32_PPN  :: \<open> Satp32 \<Rightarrow>(22)Word.word \<close>  where 
     \<open> get_Satp32_PPN v = ( (subrange_vec_dec(Satp32_bits   v) (( 21 :: int)::ii) (( 0 :: int)::ii)  ::  22 Word.word))\<close> 
  for  v  :: " Satp32 "


definition set_Satp32_PPN  :: \<open>((regstate),(register_value),(Satp32))register_ref \<Rightarrow>(22)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Satp32_PPN r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Satp32_bits := ((update_subrange_vec_dec(Satp32_bits   r) (( 21 :: int)::ii) (( 0 :: int)::ii) v  ::  32 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Satp32))register_ref " 
  and  v  :: "(22)Word.word "


definition update_Satp32_PPN  :: \<open> Satp32 \<Rightarrow>(22)Word.word \<Rightarrow> Satp32 \<close>  where 
     \<open> update_Satp32_PPN v x = (
   ( v (| Satp32_bits := ((update_subrange_vec_dec(Satp32_bits   v) (( 21 :: int)::ii) (( 0 :: int)::ii) x  ::  32 Word.word)) |)))\<close> 
  for  v  :: " Satp32 " 
  and  x  :: "(22)Word.word "


\<comment> \<open>\<open>val legalize_satp32 : Architecture -> mword ty32 -> mword ty32 -> mword ty32\<close>\<close>

definition legalize_satp32  :: \<open> Architecture \<Rightarrow>(32)Word.word \<Rightarrow>(32)Word.word \<Rightarrow>(32)Word.word \<close>  where 
     \<open> legalize_satp32 (a :: Architecture) (o1 :: 32 bits) (v :: 32 bits) = ( v )\<close> 
  for  a  :: " Architecture " 
  and  o1  :: "(32)Word.word " 
  and  v  :: "(32)Word.word "


\<comment> \<open>\<open>val PmpAddrMatchType_of_num : integer -> PmpAddrMatchType\<close>\<close>

definition PmpAddrMatchType_of_num  :: \<open> int \<Rightarrow> PmpAddrMatchType \<close>  where 
     \<open> PmpAddrMatchType_of_num arg1 = (
   (let l__82 = arg1 in
   if (((l__82 = (( 0 :: int)::ii)))) then OFF
   else if (((l__82 = (( 1 :: int)::ii)))) then TOR
   else if (((l__82 = (( 2 :: int)::ii)))) then NA4
   else NAPOT))\<close> 
  for  arg1  :: " int "


\<comment> \<open>\<open>val num_of_PmpAddrMatchType : PmpAddrMatchType -> integer\<close>\<close>

fun num_of_PmpAddrMatchType  :: \<open> PmpAddrMatchType \<Rightarrow> int \<close>  where 
     \<open> num_of_PmpAddrMatchType OFF = ( (( 0 :: int)::ii))\<close>
|\<open> num_of_PmpAddrMatchType TOR = ( (( 1 :: int)::ii))\<close>
|\<open> num_of_PmpAddrMatchType NA4 = ( (( 2 :: int)::ii))\<close>
|\<open> num_of_PmpAddrMatchType NAPOT = ( (( 3 :: int)::ii))\<close>


\<comment> \<open>\<open>val pmpAddrMatchType_of_bits : mword ty2 -> M PmpAddrMatchType\<close>\<close>

definition pmpAddrMatchType_of_bits  :: \<open>(2)Word.word \<Rightarrow>((register_value),(PmpAddrMatchType),(exception))monad \<close>  where 
     \<open> pmpAddrMatchType_of_bits bs = (
   (let b__0 = bs in
   if (((b__0 = ( 0b00 ::  2 Word.word)))) then return OFF
   else if (((b__0 = ( 0b01 ::  2 Word.word)))) then return TOR
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then return NA4
   else if (((b__0 = ( 0b11 ::  2 Word.word)))) then return NAPOT
   else assert_exp False (''Pattern match failure at model/riscv_pmp_regs.sail 7:2 - 12:3'') \<then> exit0 () ))\<close> 
  for  bs  :: "(2)Word.word "


\<comment> \<open>\<open>val pmpAddrMatchType_to_bits : PmpAddrMatchType -> mword ty2\<close>\<close>

fun pmpAddrMatchType_to_bits  :: \<open> PmpAddrMatchType \<Rightarrow>(2)Word.word \<close>  where 
     \<open> pmpAddrMatchType_to_bits OFF = ( ( 0b00 ::  2 Word.word))\<close>
|\<open> pmpAddrMatchType_to_bits TOR = ( ( 0b01 ::  2 Word.word))\<close>
|\<open> pmpAddrMatchType_to_bits NA4 = ( ( 0b10 ::  2 Word.word))\<close>
|\<open> pmpAddrMatchType_to_bits NAPOT = ( ( 0b11 ::  2 Word.word))\<close>


\<comment> \<open>\<open>val undefined_Pmpcfg_ent : unit -> M Pmpcfg_ent\<close>\<close>

definition undefined_Pmpcfg_ent  :: \<open> unit \<Rightarrow>((register_value),(Pmpcfg_ent),(exception))monad \<close>  where 
     \<open> undefined_Pmpcfg_ent _ = (
   ((return (failwith (''undefined value of unsupported type''))) :: ( 8 Word.word) M) \<bind> ((\<lambda> (w__0 ::
      8 Word.word) . 
   return ((| Pmpcfg_ent_bits = w__0 |)))))\<close>


\<comment> \<open>\<open>val Mk_Pmpcfg_ent : mword ty8 -> Pmpcfg_ent\<close>\<close>

definition Mk_Pmpcfg_ent  :: \<open>(8)Word.word \<Rightarrow> Pmpcfg_ent \<close>  where 
     \<open> Mk_Pmpcfg_ent v = ( (| Pmpcfg_ent_bits = v |) )\<close> 
  for  v  :: "(8)Word.word "


definition get_Pmpcfg_ent_bits  :: \<open> Pmpcfg_ent \<Rightarrow>(8)Word.word \<close>  where 
     \<open> get_Pmpcfg_ent_bits v = ( (subrange_vec_dec(Pmpcfg_ent_bits   v) (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))\<close> 
  for  v  :: " Pmpcfg_ent "


definition set_Pmpcfg_ent_bits  :: \<open>((regstate),(register_value),(Pmpcfg_ent))register_ref \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Pmpcfg_ent_bits r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Pmpcfg_ent_bits := ((update_subrange_vec_dec(Pmpcfg_ent_bits   r) (( 7 :: int)::ii) (( 0 :: int)::ii) v  ::  8 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Pmpcfg_ent))register_ref " 
  and  v  :: "(8)Word.word "


definition update_Pmpcfg_ent_bits  :: \<open> Pmpcfg_ent \<Rightarrow>(8)Word.word \<Rightarrow> Pmpcfg_ent \<close>  where 
     \<open> update_Pmpcfg_ent_bits v x = (
   ( v (|
     Pmpcfg_ent_bits := ((update_subrange_vec_dec(Pmpcfg_ent_bits   v) (( 7 :: int)::ii) (( 0 :: int)::ii) x  ::  8 Word.word)) |)))\<close> 
  for  v  :: " Pmpcfg_ent " 
  and  x  :: "(8)Word.word "


definition get_Pmpcfg_ent_A  :: \<open> Pmpcfg_ent \<Rightarrow>(2)Word.word \<close>  where 
     \<open> get_Pmpcfg_ent_A v = ( (subrange_vec_dec(Pmpcfg_ent_bits   v) (( 4 :: int)::ii) (( 3 :: int)::ii)  ::  2 Word.word))\<close> 
  for  v  :: " Pmpcfg_ent "


definition set_Pmpcfg_ent_A  :: \<open>((regstate),(register_value),(Pmpcfg_ent))register_ref \<Rightarrow>(2)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Pmpcfg_ent_A r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Pmpcfg_ent_bits := ((update_subrange_vec_dec(Pmpcfg_ent_bits   r) (( 4 :: int)::ii) (( 3 :: int)::ii) v  ::  8 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Pmpcfg_ent))register_ref " 
  and  v  :: "(2)Word.word "


definition update_Pmpcfg_ent_A  :: \<open> Pmpcfg_ent \<Rightarrow>(2)Word.word \<Rightarrow> Pmpcfg_ent \<close>  where 
     \<open> update_Pmpcfg_ent_A v x = (
   ( v (|
     Pmpcfg_ent_bits := ((update_subrange_vec_dec(Pmpcfg_ent_bits   v) (( 4 :: int)::ii) (( 3 :: int)::ii) x  ::  8 Word.word)) |)))\<close> 
  for  v  :: " Pmpcfg_ent " 
  and  x  :: "(2)Word.word "


definition get_Pmpcfg_ent_L  :: \<open> Pmpcfg_ent \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_Pmpcfg_ent_L v = ( (subrange_vec_dec(Pmpcfg_ent_bits   v) (( 7 :: int)::ii) (( 7 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " Pmpcfg_ent "


definition set_Pmpcfg_ent_L  :: \<open>((regstate),(register_value),(Pmpcfg_ent))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Pmpcfg_ent_L r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Pmpcfg_ent_bits := ((update_subrange_vec_dec(Pmpcfg_ent_bits   r) (( 7 :: int)::ii) (( 7 :: int)::ii) v  ::  8 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Pmpcfg_ent))register_ref " 
  and  v  :: "(1)Word.word "


definition update_Pmpcfg_ent_L  :: \<open> Pmpcfg_ent \<Rightarrow>(1)Word.word \<Rightarrow> Pmpcfg_ent \<close>  where 
     \<open> update_Pmpcfg_ent_L v x = (
   ( v (|
     Pmpcfg_ent_bits := ((update_subrange_vec_dec(Pmpcfg_ent_bits   v) (( 7 :: int)::ii) (( 7 :: int)::ii) x  ::  8 Word.word)) |)))\<close> 
  for  v  :: " Pmpcfg_ent " 
  and  x  :: "(1)Word.word "


definition get_Pmpcfg_ent_R  :: \<open> Pmpcfg_ent \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_Pmpcfg_ent_R v = ( (subrange_vec_dec(Pmpcfg_ent_bits   v) (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " Pmpcfg_ent "


definition set_Pmpcfg_ent_R  :: \<open>((regstate),(register_value),(Pmpcfg_ent))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Pmpcfg_ent_R r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Pmpcfg_ent_bits := ((update_subrange_vec_dec(Pmpcfg_ent_bits   r) (( 0 :: int)::ii) (( 0 :: int)::ii) v  ::  8 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Pmpcfg_ent))register_ref " 
  and  v  :: "(1)Word.word "


definition update_Pmpcfg_ent_R  :: \<open> Pmpcfg_ent \<Rightarrow>(1)Word.word \<Rightarrow> Pmpcfg_ent \<close>  where 
     \<open> update_Pmpcfg_ent_R v x = (
   ( v (|
     Pmpcfg_ent_bits := ((update_subrange_vec_dec(Pmpcfg_ent_bits   v) (( 0 :: int)::ii) (( 0 :: int)::ii) x  ::  8 Word.word)) |)))\<close> 
  for  v  :: " Pmpcfg_ent " 
  and  x  :: "(1)Word.word "


definition get_Pmpcfg_ent_W  :: \<open> Pmpcfg_ent \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_Pmpcfg_ent_W v = ( (subrange_vec_dec(Pmpcfg_ent_bits   v) (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " Pmpcfg_ent "


definition set_Pmpcfg_ent_W  :: \<open>((regstate),(register_value),(Pmpcfg_ent))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Pmpcfg_ent_W r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Pmpcfg_ent_bits := ((update_subrange_vec_dec(Pmpcfg_ent_bits   r) (( 1 :: int)::ii) (( 1 :: int)::ii) v  ::  8 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Pmpcfg_ent))register_ref " 
  and  v  :: "(1)Word.word "


definition update_Pmpcfg_ent_W  :: \<open> Pmpcfg_ent \<Rightarrow>(1)Word.word \<Rightarrow> Pmpcfg_ent \<close>  where 
     \<open> update_Pmpcfg_ent_W v x = (
   ( v (|
     Pmpcfg_ent_bits := ((update_subrange_vec_dec(Pmpcfg_ent_bits   v) (( 1 :: int)::ii) (( 1 :: int)::ii) x  ::  8 Word.word)) |)))\<close> 
  for  v  :: " Pmpcfg_ent " 
  and  x  :: "(1)Word.word "


definition get_Pmpcfg_ent_X  :: \<open> Pmpcfg_ent \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_Pmpcfg_ent_X v = ( (subrange_vec_dec(Pmpcfg_ent_bits   v) (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " Pmpcfg_ent "


definition set_Pmpcfg_ent_X  :: \<open>((regstate),(register_value),(Pmpcfg_ent))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Pmpcfg_ent_X r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Pmpcfg_ent_bits := ((update_subrange_vec_dec(Pmpcfg_ent_bits   r) (( 2 :: int)::ii) (( 2 :: int)::ii) v  ::  8 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Pmpcfg_ent))register_ref " 
  and  v  :: "(1)Word.word "


definition update_Pmpcfg_ent_X  :: \<open> Pmpcfg_ent \<Rightarrow>(1)Word.word \<Rightarrow> Pmpcfg_ent \<close>  where 
     \<open> update_Pmpcfg_ent_X v x = (
   ( v (|
     Pmpcfg_ent_bits := ((update_subrange_vec_dec(Pmpcfg_ent_bits   v) (( 2 :: int)::ii) (( 2 :: int)::ii) x  ::  8 Word.word)) |)))\<close> 
  for  v  :: " Pmpcfg_ent " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val pmpReadCfgReg : integer -> M (mword ty64)\<close>\<close>

definition pmpReadCfgReg  :: \<open> int \<Rightarrow>((register_value),((64)Word.word),(exception))monad \<close>  where 
     \<open> pmpReadCfgReg n = (
   (let l__80 = n in
   if (((l__80 = (( 0 :: int)::ii)))) then
     read_reg pmp7cfg_ref \<bind> ((\<lambda> (w__0 :: Pmpcfg_ent) . 
     read_reg pmp6cfg_ref \<bind> ((\<lambda> (w__1 :: Pmpcfg_ent) . 
     read_reg pmp5cfg_ref \<bind> ((\<lambda> (w__2 :: Pmpcfg_ent) . 
     read_reg pmp4cfg_ref \<bind> ((\<lambda> (w__3 :: Pmpcfg_ent) . 
     read_reg pmp3cfg_ref \<bind> ((\<lambda> (w__4 :: Pmpcfg_ent) . 
     read_reg pmp2cfg_ref \<bind> ((\<lambda> (w__5 :: Pmpcfg_ent) . 
     read_reg pmp1cfg_ref \<bind> ((\<lambda> (w__6 :: Pmpcfg_ent) . 
     read_reg pmp0cfg_ref \<bind> ((\<lambda> (w__7 :: Pmpcfg_ent) . 
     return ((concat_vec ((get_Pmpcfg_ent_bits w__0  ::  8 Word.word))
                ((concat_vec ((get_Pmpcfg_ent_bits w__1  ::  8 Word.word))
                    ((concat_vec ((get_Pmpcfg_ent_bits w__2  ::  8 Word.word))
                        ((concat_vec ((get_Pmpcfg_ent_bits w__3  ::  8 Word.word))
                            ((concat_vec ((get_Pmpcfg_ent_bits w__4  ::  8 Word.word))
                                ((concat_vec ((get_Pmpcfg_ent_bits w__5  ::  8 Word.word))
                                    ((concat_vec ((get_Pmpcfg_ent_bits w__6  ::  8 Word.word))
                                        ((get_Pmpcfg_ent_bits w__7  ::  8 Word.word))
                                       ::  16 Word.word))
                                   ::  24 Word.word))
                               ::  32 Word.word))
                           ::  40 Word.word))
                       ::  48 Word.word))
                   ::  56 Word.word))
               ::  64 Word.word))))))))))))))))))
   else if (((l__80 = (( 2 :: int)::ii)))) then
     read_reg pmp15cfg_ref \<bind> ((\<lambda> (w__8 :: Pmpcfg_ent) . 
     read_reg pmp14cfg_ref \<bind> ((\<lambda> (w__9 :: Pmpcfg_ent) . 
     read_reg pmp13cfg_ref \<bind> ((\<lambda> (w__10 :: Pmpcfg_ent) . 
     read_reg pmp12cfg_ref \<bind> ((\<lambda> (w__11 :: Pmpcfg_ent) . 
     read_reg pmp11cfg_ref \<bind> ((\<lambda> (w__12 :: Pmpcfg_ent) . 
     read_reg pmp10cfg_ref \<bind> ((\<lambda> (w__13 :: Pmpcfg_ent) . 
     read_reg pmp9cfg_ref \<bind> ((\<lambda> (w__14 :: Pmpcfg_ent) . 
     read_reg pmp8cfg_ref \<bind> ((\<lambda> (w__15 :: Pmpcfg_ent) . 
     return ((concat_vec ((get_Pmpcfg_ent_bits w__8  ::  8 Word.word))
                ((concat_vec ((get_Pmpcfg_ent_bits w__9  ::  8 Word.word))
                    ((concat_vec ((get_Pmpcfg_ent_bits w__10  ::  8 Word.word))
                        ((concat_vec ((get_Pmpcfg_ent_bits w__11  ::  8 Word.word))
                            ((concat_vec ((get_Pmpcfg_ent_bits w__12  ::  8 Word.word))
                                ((concat_vec ((get_Pmpcfg_ent_bits w__13  ::  8 Word.word))
                                    ((concat_vec ((get_Pmpcfg_ent_bits w__14  ::  8 Word.word))
                                        ((get_Pmpcfg_ent_bits w__15  ::  8 Word.word))
                                       ::  16 Word.word))
                                   ::  24 Word.word))
                               ::  32 Word.word))
                           ::  40 Word.word))
                       ::  48 Word.word))
                   ::  56 Word.word))
               ::  64 Word.word))))))))))))))))))
   else assert_exp False (''Pattern match failure at model/riscv_pmp_regs.sail 75:2 - 85:8'') \<then> exit0 () ))\<close> 
  for  n  :: " int "


\<comment> \<open>\<open>val pmpLocked : Pmpcfg_ent -> bool\<close>\<close>

definition pmpLocked  :: \<open> Pmpcfg_ent \<Rightarrow> bool \<close>  where 
     \<open> pmpLocked cfg = ( (((get_Pmpcfg_ent_L cfg  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))\<close> 
  for  cfg  :: " Pmpcfg_ent "


\<comment> \<open>\<open>val pmpTORLocked : Pmpcfg_ent -> M bool\<close>\<close>

definition pmpTORLocked  :: \<open> Pmpcfg_ent \<Rightarrow>((register_value),(bool),(exception))monad \<close>  where 
     \<open> pmpTORLocked cfg = (
   and_boolM (return (((((get_Pmpcfg_ent_L cfg  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))))
     (pmpAddrMatchType_of_bits ((get_Pmpcfg_ent_A cfg  ::  2 Word.word)) \<bind> ((\<lambda> (w__0 ::
        PmpAddrMatchType) . 
      return (((w__0 = TOR)))))))\<close> 
  for  cfg  :: " Pmpcfg_ent "


\<comment> \<open>\<open>val pmpWriteCfg : Pmpcfg_ent -> mword ty8 -> Pmpcfg_ent\<close>\<close>

definition pmpWriteCfg  :: \<open> Pmpcfg_ent \<Rightarrow>(8)Word.word \<Rightarrow> Pmpcfg_ent \<close>  where 
     \<open> pmpWriteCfg (cfg :: Pmpcfg_ent) (v :: 8 bits) = (
   if ((pmpLocked cfg)) then cfg
   else Mk_Pmpcfg_ent ((and_vec v ( 0x9F ::  8 Word.word)  ::  8 Word.word)))\<close> 
  for  cfg  :: " Pmpcfg_ent " 
  and  v  :: "(8)Word.word "


\<comment> \<open>\<open>val pmpWriteCfgReg : integer -> mword ty64 -> M unit\<close>\<close>

definition pmpWriteCfgReg  :: \<open> int \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> pmpWriteCfgReg n v = (
   (let l__78 = n in
   if (((l__78 = (( 0 :: int)::ii)))) then
     read_reg pmp0cfg_ref \<bind> ((\<lambda> (w__0 :: Pmpcfg_ent) . 
     (write_reg pmp0cfg_ref ((pmpWriteCfg w__0 ((subrange_vec_dec v (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word)))) \<then>
     read_reg pmp1cfg_ref) \<bind> ((\<lambda> (w__1 :: Pmpcfg_ent) . 
     (write_reg pmp1cfg_ref ((pmpWriteCfg w__1 ((subrange_vec_dec v (( 15 :: int)::ii) (( 8 :: int)::ii)  ::  8 Word.word)))) \<then>
     read_reg pmp2cfg_ref) \<bind> ((\<lambda> (w__2 :: Pmpcfg_ent) . 
     (write_reg pmp2cfg_ref ((pmpWriteCfg w__2 ((subrange_vec_dec v (( 23 :: int)::ii) (( 16 :: int)::ii)  ::  8 Word.word)))) \<then>
     read_reg pmp3cfg_ref) \<bind> ((\<lambda> (w__3 :: Pmpcfg_ent) . 
     (write_reg pmp3cfg_ref ((pmpWriteCfg w__3 ((subrange_vec_dec v (( 31 :: int)::ii) (( 24 :: int)::ii)  ::  8 Word.word)))) \<then>
     read_reg pmp4cfg_ref) \<bind> ((\<lambda> (w__4 :: Pmpcfg_ent) . 
     (write_reg pmp4cfg_ref ((pmpWriteCfg w__4 ((subrange_vec_dec v (( 39 :: int)::ii) (( 32 :: int)::ii)  ::  8 Word.word)))) \<then>
     read_reg pmp5cfg_ref) \<bind> ((\<lambda> (w__5 :: Pmpcfg_ent) . 
     (write_reg pmp5cfg_ref ((pmpWriteCfg w__5 ((subrange_vec_dec v (( 47 :: int)::ii) (( 40 :: int)::ii)  ::  8 Word.word)))) \<then>
     read_reg pmp6cfg_ref) \<bind> ((\<lambda> (w__6 :: Pmpcfg_ent) . 
     (write_reg pmp6cfg_ref ((pmpWriteCfg w__6 ((subrange_vec_dec v (( 55 :: int)::ii) (( 48 :: int)::ii)  ::  8 Word.word)))) \<then>
     read_reg pmp7cfg_ref) \<bind> ((\<lambda> (w__7 :: Pmpcfg_ent) . 
     write_reg pmp7cfg_ref ((pmpWriteCfg w__7 ((subrange_vec_dec v (( 63 :: int)::ii) (( 56 :: int)::ii)  ::  8 Word.word))))))))))))))))))))
   else if (((l__78 = (( 2 :: int)::ii)))) then
     read_reg pmp8cfg_ref \<bind> ((\<lambda> (w__8 :: Pmpcfg_ent) . 
     (write_reg pmp8cfg_ref ((pmpWriteCfg w__8 ((subrange_vec_dec v (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word)))) \<then>
     read_reg pmp9cfg_ref) \<bind> ((\<lambda> (w__9 :: Pmpcfg_ent) . 
     (write_reg pmp9cfg_ref ((pmpWriteCfg w__9 ((subrange_vec_dec v (( 15 :: int)::ii) (( 8 :: int)::ii)  ::  8 Word.word)))) \<then>
     read_reg pmp10cfg_ref) \<bind> ((\<lambda> (w__10 :: Pmpcfg_ent) . 
     (write_reg
       pmp10cfg_ref
       ((pmpWriteCfg w__10 ((subrange_vec_dec v (( 23 :: int)::ii) (( 16 :: int)::ii)  ::  8 Word.word)))) \<then>
     read_reg pmp11cfg_ref) \<bind> ((\<lambda> (w__11 :: Pmpcfg_ent) . 
     (write_reg
       pmp11cfg_ref
       ((pmpWriteCfg w__11 ((subrange_vec_dec v (( 31 :: int)::ii) (( 24 :: int)::ii)  ::  8 Word.word)))) \<then>
     read_reg pmp12cfg_ref) \<bind> ((\<lambda> (w__12 :: Pmpcfg_ent) . 
     (write_reg
       pmp12cfg_ref
       ((pmpWriteCfg w__12 ((subrange_vec_dec v (( 39 :: int)::ii) (( 32 :: int)::ii)  ::  8 Word.word)))) \<then>
     read_reg pmp13cfg_ref) \<bind> ((\<lambda> (w__13 :: Pmpcfg_ent) . 
     (write_reg
       pmp13cfg_ref
       ((pmpWriteCfg w__13 ((subrange_vec_dec v (( 47 :: int)::ii) (( 40 :: int)::ii)  ::  8 Word.word)))) \<then>
     read_reg pmp14cfg_ref) \<bind> ((\<lambda> (w__14 :: Pmpcfg_ent) . 
     (write_reg
       pmp14cfg_ref
       ((pmpWriteCfg w__14 ((subrange_vec_dec v (( 55 :: int)::ii) (( 48 :: int)::ii)  ::  8 Word.word)))) \<then>
     read_reg pmp15cfg_ref) \<bind> ((\<lambda> (w__15 :: Pmpcfg_ent) . 
     write_reg
       pmp15cfg_ref
       ((pmpWriteCfg w__15 ((subrange_vec_dec v (( 63 :: int)::ii) (( 56 :: int)::ii)  ::  8 Word.word))))))))))))))))))))
   else
     assert_exp False (''Pattern match failure at model/riscv_pmp_regs.sail 101:2 - 144:8'') \<then> exit0 () ))\<close> 
  for  n  :: " int " 
  and  v  :: "(64)Word.word "


\<comment> \<open>\<open>val pmpWriteAddr : bool -> bool -> mword ty64 -> mword ty64 -> mword ty64\<close>\<close>

definition pmpWriteAddr  :: \<open> bool \<Rightarrow> bool \<Rightarrow>(64)Word.word \<Rightarrow>(64)Word.word \<Rightarrow>(64)Word.word \<close>  where 
     \<open> pmpWriteAddr (locked :: bool) (tor_locked :: bool) (reg :: xlenbits) (v :: xlenbits) = (
   if (((locked \<or> tor_locked))) then reg
   else (EXTZ (( 64 :: int)::ii) ((subrange_vec_dec v (( 53 :: int)::ii) (( 0 :: int)::ii)  ::  54 Word.word))  ::  64 Word.word))\<close> 
  for  locked  :: " bool " 
  and  tor_locked  :: " bool " 
  and  reg  :: "(64)Word.word " 
  and  v  :: "(64)Word.word "


\<comment> \<open>\<open>val pmpAddrRange : Pmpcfg_ent -> mword ty64 -> mword ty64 -> M (maybe ((mword ty64 * mword ty64)))\<close>\<close>

definition pmpAddrRange  :: \<open> Pmpcfg_ent \<Rightarrow>(64)Word.word \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),(((64)Word.word*(64)Word.word)option),(exception))monad \<close>  where 
     \<open> pmpAddrRange (cfg :: Pmpcfg_ent) (pmpaddr :: xlenbits) (prev_pmpaddr :: xlenbits) = (
   pmpAddrMatchType_of_bits ((get_Pmpcfg_ent_A cfg  ::  2 Word.word)) \<bind> ((\<lambda> (w__0 :: PmpAddrMatchType) . 
   return ((case  w__0 of
     OFF => None
   | TOR => Some ((shiftl prev_pmpaddr (( 2 :: int)::ii)  ::  64 Word.word), (shiftl pmpaddr (( 2 :: int)::ii)  ::  64 Word.word))
   | NA4 =>
      (let lo = ((shiftl pmpaddr (( 2 :: int)::ii)  ::  64 Word.word)) in
      Some (lo, (add_vec_int lo (( 4 :: int)::ii)  ::  64 Word.word)))
   | NAPOT =>
      (let mask1 = ((xor_vec pmpaddr ((add_vec_int pmpaddr (( 1 :: int)::ii)  ::  64 Word.word))  ::  64 Word.word)) in
      (let lo = ((and_vec pmpaddr ((not_vec mask1  ::  64 Word.word))  ::  64 Word.word)) in
      (let len = ((add_vec_int mask1 (( 1 :: int)::ii)  ::  64 Word.word)) in
      Some ((shiftl lo (( 2 :: int)::ii)  ::  64 Word.word),
            (shiftl ((add_vec lo len  ::  64 Word.word)) (( 2 :: int)::ii)  ::  64 Word.word)))))
   )))))\<close> 
  for  cfg  :: " Pmpcfg_ent " 
  and  pmpaddr  :: "(64)Word.word " 
  and  prev_pmpaddr  :: "(64)Word.word "


\<comment> \<open>\<open>val pmpCheckRWX : Pmpcfg_ent -> AccessType unit -> bool\<close>\<close>

fun pmpCheckRWX  :: \<open> Pmpcfg_ent \<Rightarrow>(unit)AccessType \<Rightarrow> bool \<close>  where 
     \<open> pmpCheckRWX ent (Read (_)) = ( (((get_Pmpcfg_ent_R ent  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))\<close> 
  for  ent  :: " Pmpcfg_ent "
|\<open> pmpCheckRWX ent (Write (_)) = ( (((get_Pmpcfg_ent_W ent  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))\<close> 
  for  ent  :: " Pmpcfg_ent "
|\<open> pmpCheckRWX ent (ReadWrite (_)) = (
      ((((((get_Pmpcfg_ent_R ent  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))) \<and> (((((get_Pmpcfg_ent_W ent  ::  1 Word.word)) = ( 0b1 ::  1 Word.word))))))\<close> 
  for  ent  :: " Pmpcfg_ent "
|\<open> pmpCheckRWX ent (Execute (_)) = ( (((get_Pmpcfg_ent_X ent  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))\<close> 
  for  ent  :: " Pmpcfg_ent "


\<comment> \<open>\<open>val pmpCheckPerms : Pmpcfg_ent -> AccessType unit -> Privilege -> bool\<close>\<close>

fun pmpCheckPerms  :: \<open> Pmpcfg_ent \<Rightarrow>(unit)AccessType \<Rightarrow> Privilege \<Rightarrow> bool \<close>  where 
     \<open> pmpCheckPerms ent acc1 Machine = ( if ((pmpLocked ent)) then pmpCheckRWX ent acc1 else True )\<close> 
  for  ent  :: " Pmpcfg_ent " 
  and  acc1  :: "(unit)AccessType "
|\<open> pmpCheckPerms ent acc1 _ = ( pmpCheckRWX ent acc1 )\<close> 
  for  ent  :: " Pmpcfg_ent " 
  and  acc1  :: "(unit)AccessType "


\<comment> \<open>\<open>val pmpAddrMatch_of_num : integer -> pmpAddrMatch\<close>\<close>

definition pmpAddrMatch_of_num  :: \<open> int \<Rightarrow> pmpAddrMatch \<close>  where 
     \<open> pmpAddrMatch_of_num arg1 = (
   (let l__76 = arg1 in
   if (((l__76 = (( 0 :: int)::ii)))) then PMP_NoMatch
   else if (((l__76 = (( 1 :: int)::ii)))) then PMP_PartialMatch
   else PMP_Match))\<close> 
  for  arg1  :: " int "


\<comment> \<open>\<open>val num_of_pmpAddrMatch : pmpAddrMatch -> integer\<close>\<close>

fun num_of_pmpAddrMatch  :: \<open> pmpAddrMatch \<Rightarrow> int \<close>  where 
     \<open> num_of_pmpAddrMatch PMP_NoMatch = ( (( 0 :: int)::ii))\<close>
|\<open> num_of_pmpAddrMatch PMP_PartialMatch = ( (( 1 :: int)::ii))\<close>
|\<open> num_of_pmpAddrMatch PMP_Match = ( (( 2 :: int)::ii))\<close>


\<comment> \<open>\<open>val pmpMatchAddr : mword ty64 -> mword ty64 -> maybe ((mword ty64 * mword ty64)) -> pmpAddrMatch\<close>\<close>

fun pmpMatchAddr  :: \<open>(64)Word.word \<Rightarrow>(64)Word.word \<Rightarrow>(xlenbits*xlenbits)option \<Rightarrow> pmpAddrMatch \<close>  where 
     \<open> pmpMatchAddr (addr :: xlenbits) (width :: xlenbits) (None :: pmp_addr_range) = ( PMP_NoMatch )\<close> 
  for  addr  :: "(64)Word.word " 
  and  width  :: "(64)Word.word "
|\<open> pmpMatchAddr (addr :: xlenbits) (width :: xlenbits) ((Some ((lo, hi))) :: pmp_addr_range) = (
      if ((zopz0zI_u hi lo)) then PMP_NoMatch
      else if (((((zopz0zIzJ_u ((add_vec addr width  ::  64 Word.word)) lo)) \<or> ((zopz0zIzJ_u hi addr))))) then
        PMP_NoMatch
      else if (((((zopz0zIzJ_u lo addr)) \<and> ((zopz0zIzJ_u ((add_vec addr width  ::  64 Word.word)) hi))))) then
        PMP_Match
      else PMP_PartialMatch )\<close> 
  for  addr  :: "(64)Word.word " 
  and  width  :: "(64)Word.word " 
  and  hi  :: "(64)Word.word " 
  and  lo  :: "(64)Word.word "


\<comment> \<open>\<open>val pmpMatch_of_num : integer -> pmpMatch\<close>\<close>

definition pmpMatch_of_num  :: \<open> int \<Rightarrow> pmpMatch \<close>  where 
     \<open> pmpMatch_of_num arg1 = (
   (let l__74 = arg1 in
   if (((l__74 = (( 0 :: int)::ii)))) then PMP_Success
   else if (((l__74 = (( 1 :: int)::ii)))) then PMP_Continue
   else PMP_Fail))\<close> 
  for  arg1  :: " int "


\<comment> \<open>\<open>val num_of_pmpMatch : pmpMatch -> integer\<close>\<close>

fun num_of_pmpMatch  :: \<open> pmpMatch \<Rightarrow> int \<close>  where 
     \<open> num_of_pmpMatch PMP_Success = ( (( 0 :: int)::ii))\<close>
|\<open> num_of_pmpMatch PMP_Continue = ( (( 1 :: int)::ii))\<close>
|\<open> num_of_pmpMatch PMP_Fail = ( (( 2 :: int)::ii))\<close>


\<comment> \<open>\<open>val pmpMatchEntry : mword ty64 -> mword ty64 -> AccessType unit -> Privilege -> Pmpcfg_ent -> mword ty64 -> mword ty64 -> M pmpMatch\<close>\<close>

definition pmpMatchEntry  :: \<open>(64)Word.word \<Rightarrow>(64)Word.word \<Rightarrow>(ext_access_type)AccessType \<Rightarrow> Privilege \<Rightarrow> Pmpcfg_ent \<Rightarrow>(64)Word.word \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),(pmpMatch),(exception))monad \<close>  where 
     \<open> pmpMatchEntry (addr :: xlenbits) (width :: xlenbits) (acc1 :: ext_access_type AccessType) (priv ::
  Privilege) (ent :: Pmpcfg_ent) (pmpaddr :: xlenbits) (prev_pmpaddr :: xlenbits) = (
   (pmpAddrRange ent pmpaddr prev_pmpaddr  :: ( (( 64 Word.word *  64 Word.word))option) M) \<bind> ((\<lambda> rng . 
   return ((case  ((pmpMatchAddr addr width rng)) of
     PMP_NoMatch => PMP_Continue
   | PMP_PartialMatch => PMP_Fail
   | PMP_Match => if ((pmpCheckPerms ent acc1 priv)) then PMP_Success else PMP_Fail
   )))))\<close> 
  for  addr  :: "(64)Word.word " 
  and  width  :: "(64)Word.word " 
  and  acc1  :: "(ext_access_type)AccessType " 
  and  priv  :: " Privilege " 
  and  ent  :: " Pmpcfg_ent " 
  and  pmpaddr  :: "(64)Word.word " 
  and  prev_pmpaddr  :: "(64)Word.word "


\<comment> \<open>\<open>val pmpCheck : mword ty64 -> integer -> AccessType unit -> Privilege -> M (maybe ExceptionType)\<close>\<close>

definition pmpCheck  :: \<open>(64)Word.word \<Rightarrow> int \<Rightarrow>(ext_access_type)AccessType \<Rightarrow> Privilege \<Rightarrow>((register_value),((ExceptionType)option),(exception))monad \<close>  where 
     \<open> pmpCheck (addr :: xlenbits) (width :: int) (acc1 :: ext_access_type AccessType) (priv ::
  Privilege) = (
   (let (width :: xlenbits) = ((to_bits (( 64 :: int)::ii) width  ::  64 Word.word)) in
   read_reg pmp0cfg_ref \<bind> ((\<lambda> (w__0 :: Pmpcfg_ent) . 
   (read_reg pmpaddr0_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
   pmpMatchEntry addr width acc1 priv w__0 w__1 ((zeros_implicit (( 64 :: int)::ii)  ::  64 Word.word)) \<bind> ((\<lambda> (w__2 ::
     pmpMatch) . 
   (case  w__2 of
     PMP_Success => return True
   | PMP_Fail => return False
   | PMP_Continue =>
      read_reg pmp1cfg_ref \<bind> ((\<lambda> (w__3 :: Pmpcfg_ent) . 
      (read_reg pmpaddr1_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__4 ::  64 Word.word) . 
      (read_reg pmpaddr0_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__5 ::  64 Word.word) . 
      pmpMatchEntry addr width acc1 priv w__3 w__4 w__5 \<bind> ((\<lambda> (w__6 :: pmpMatch) . 
      (case  w__6 of
        PMP_Success => return True
      | PMP_Fail => return False
      | PMP_Continue =>
         read_reg pmp2cfg_ref \<bind> ((\<lambda> (w__7 :: Pmpcfg_ent) . 
         (read_reg pmpaddr2_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__8 ::  64 Word.word) . 
         (read_reg pmpaddr1_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__9 ::  64 Word.word) . 
         pmpMatchEntry addr width acc1 priv w__7 w__8 w__9 \<bind> ((\<lambda> (w__10 :: pmpMatch) . 
         (case  w__10 of
           PMP_Success => return True
         | PMP_Fail => return False
         | PMP_Continue =>
            read_reg pmp3cfg_ref \<bind> ((\<lambda> (w__11 :: Pmpcfg_ent) . 
            (read_reg pmpaddr3_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__12 ::  64 Word.word) . 
            (read_reg pmpaddr2_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__13 ::  64 Word.word) . 
            pmpMatchEntry addr width acc1 priv w__11 w__12 w__13 \<bind> ((\<lambda> (w__14 :: pmpMatch) . 
            (case  w__14 of
              PMP_Success => return True
            | PMP_Fail => return False
            | PMP_Continue =>
               read_reg pmp4cfg_ref \<bind> ((\<lambda> (w__15 :: Pmpcfg_ent) . 
               (read_reg pmpaddr4_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__16 ::  64 Word.word) . 
               (read_reg pmpaddr3_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__17 ::  64 Word.word) . 
               pmpMatchEntry addr width acc1 priv w__15 w__16 w__17 \<bind> ((\<lambda> (w__18 :: pmpMatch) . 
               (case  w__18 of
                 PMP_Success => return True
               | PMP_Fail => return False
               | PMP_Continue =>
                  read_reg pmp5cfg_ref \<bind> ((\<lambda> (w__19 :: Pmpcfg_ent) . 
                  (read_reg pmpaddr5_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__20 ::  64 Word.word) . 
                  (read_reg pmpaddr4_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__21 ::  64 Word.word) . 
                  pmpMatchEntry addr width acc1 priv w__19 w__20 w__21 \<bind> ((\<lambda> (w__22 :: pmpMatch) . 
                  (case  w__22 of
                    PMP_Success => return True
                  | PMP_Fail => return False
                  | PMP_Continue =>
                     read_reg pmp6cfg_ref \<bind> ((\<lambda> (w__23 :: Pmpcfg_ent) . 
                     (read_reg pmpaddr6_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__24 ::  64 Word.word) . 
                     (read_reg pmpaddr5_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__25 ::  64 Word.word) . 
                     pmpMatchEntry addr width acc1 priv w__23 w__24 w__25 \<bind> ((\<lambda> (w__26 :: pmpMatch) . 
                     (case  w__26 of
                       PMP_Success => return True
                     | PMP_Fail => return False
                     | PMP_Continue =>
                        read_reg pmp7cfg_ref \<bind> ((\<lambda> (w__27 :: Pmpcfg_ent) . 
                        (read_reg pmpaddr7_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__28 ::  64 Word.word) . 
                        (read_reg pmpaddr6_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__29 ::  64 Word.word) . 
                        pmpMatchEntry addr width acc1 priv w__27 w__28 w__29 \<bind> ((\<lambda> (w__30 ::
                          pmpMatch) . 
                        (case  w__30 of
                          PMP_Success => return True
                        | PMP_Fail => return False
                        | PMP_Continue =>
                           read_reg pmp8cfg_ref \<bind> ((\<lambda> (w__31 :: Pmpcfg_ent) . 
                           (read_reg pmpaddr8_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__32 ::  64 Word.word) . 
                           (read_reg pmpaddr7_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__33 ::  64 Word.word) . 
                           pmpMatchEntry addr width acc1 priv w__31 w__32 w__33 \<bind> ((\<lambda> (w__34 ::
                             pmpMatch) . 
                           (case  w__34 of
                             PMP_Success => return True
                           | PMP_Fail => return False
                           | PMP_Continue =>
                              read_reg pmp9cfg_ref \<bind> ((\<lambda> (w__35 :: Pmpcfg_ent) . 
                              (read_reg pmpaddr9_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__36 ::  64 Word.word) . 
                              (read_reg pmpaddr8_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__37 ::  64 Word.word) . 
                              pmpMatchEntry addr width acc1 priv w__35 w__36 w__37 \<bind> ((\<lambda> (w__38 ::
                                pmpMatch) . 
                              (case  w__38 of
                                PMP_Success => return True
                              | PMP_Fail => return False
                              | PMP_Continue =>
                                 read_reg pmp10cfg_ref \<bind> ((\<lambda> (w__39 :: Pmpcfg_ent) . 
                                 (read_reg pmpaddr10_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__40 ::
                                    64 Word.word) . 
                                 (read_reg pmpaddr9_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__41 ::
                                    64 Word.word) . 
                                 pmpMatchEntry addr width acc1 priv w__39 w__40 w__41 \<bind> ((\<lambda> (w__42 ::
                                   pmpMatch) . 
                                 (case  w__42 of
                                   PMP_Success => return True
                                 | PMP_Fail => return False
                                 | PMP_Continue =>
                                    read_reg pmp11cfg_ref \<bind> ((\<lambda> (w__43 :: Pmpcfg_ent) . 
                                    (read_reg pmpaddr11_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__44 ::
                                       64 Word.word) . 
                                    (read_reg pmpaddr10_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__45 ::
                                       64 Word.word) . 
                                    pmpMatchEntry addr width acc1 priv w__43 w__44 w__45 \<bind> ((\<lambda> (w__46 ::
                                      pmpMatch) . 
                                    (case  w__46 of
                                      PMP_Success => return True
                                    | PMP_Fail => return False
                                    | PMP_Continue =>
                                       read_reg pmp12cfg_ref \<bind> ((\<lambda> (w__47 :: Pmpcfg_ent) . 
                                       (read_reg pmpaddr12_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__48 ::
                                          64 Word.word) . 
                                       (read_reg pmpaddr11_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__49 ::
                                          64 Word.word) . 
                                       pmpMatchEntry addr width acc1 priv w__47 w__48 w__49 \<bind> ((\<lambda> (w__50 ::
                                         pmpMatch) . 
                                       (case  w__50 of
                                         PMP_Success => return True
                                       | PMP_Fail => return False
                                       | PMP_Continue =>
                                          read_reg pmp13cfg_ref \<bind> ((\<lambda> (w__51 :: Pmpcfg_ent) . 
                                          (read_reg pmpaddr13_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__52 ::
                                             64 Word.word) . 
                                          (read_reg pmpaddr12_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__53 ::
                                             64 Word.word) . 
                                          pmpMatchEntry addr width acc1 priv w__51 w__52 w__53 \<bind> ((\<lambda> (w__54 ::
                                            pmpMatch) . 
                                          (case  w__54 of
                                            PMP_Success => return True
                                          | PMP_Fail => return False
                                          | PMP_Continue =>
                                             read_reg pmp14cfg_ref \<bind> ((\<lambda> (w__55 :: Pmpcfg_ent) . 
                                             (read_reg pmpaddr14_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__56 ::
                                                64 Word.word) . 
                                             (read_reg pmpaddr13_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__57 ::
                                                64 Word.word) . 
                                             pmpMatchEntry addr width acc1 priv w__55 w__56 w__57 \<bind> ((\<lambda> (w__58 ::
                                               pmpMatch) . 
                                             (case  w__58 of
                                               PMP_Success => return True
                                             | PMP_Fail => return False
                                             | PMP_Continue =>
                                                read_reg pmp15cfg_ref \<bind> ((\<lambda> (w__59 :: Pmpcfg_ent) . 
                                                (read_reg pmpaddr15_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__60 ::
                                                   64 Word.word) . 
                                                (read_reg pmpaddr14_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__61 ::
                                                   64 Word.word) . 
                                                pmpMatchEntry addr width acc1 priv w__59 w__60 w__61 \<bind> ((\<lambda> (w__62 ::
                                                  pmpMatch) . 
                                                return ((case  w__62 of
                                                  PMP_Success => True
                                                | PMP_Fail => False
                                                | PMP_Continue =>
                                                   (case  priv of
                                                     Machine => True
                                                   | _ => False
                                                   )
                                                ))))))))))
                                             )))))))))
                                          )))))))))
                                       )))))))))
                                    )))))))))
                                 )))))))))
                              )))))))))
                           )))))))))
                        )))))))))
                     )))))))))
                  )))))))))
               )))))))))
            )))))))))
         )))))))))
      )))))))))
   ) \<bind> ((\<lambda> (check' :: bool) . 
   return (if check' then None
           else
             (case  acc1 of
               Read (_) => Some (E_Load_Access_Fault () )
             | Write (_) => Some (E_SAMO_Access_Fault () )
             | ReadWrite (_) => Some (E_SAMO_Access_Fault () )
             | Execute (_) => Some (E_Fetch_Access_Fault () )
             ))))))))))))\<close> 
  for  addr  :: "(64)Word.word " 
  and  width  :: " int " 
  and  acc1  :: "(ext_access_type)AccessType " 
  and  priv  :: " Privilege "


\<comment> \<open>\<open>val init_pmp : unit -> M unit\<close>\<close>

definition init_pmp  :: \<open> unit \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> init_pmp _ = (
   read_reg pmp0cfg_ref \<bind> ((\<lambda> (w__0 :: Pmpcfg_ent) . 
   (write_reg pmp0cfg_ref ((update_Pmpcfg_ent_A w__0 ((pmpAddrMatchType_to_bits OFF  ::  2 Word.word)))) \<then>
   read_reg pmp1cfg_ref) \<bind> ((\<lambda> (w__1 :: Pmpcfg_ent) . 
   (write_reg pmp1cfg_ref ((update_Pmpcfg_ent_A w__1 ((pmpAddrMatchType_to_bits OFF  ::  2 Word.word)))) \<then>
   read_reg pmp2cfg_ref) \<bind> ((\<lambda> (w__2 :: Pmpcfg_ent) . 
   (write_reg pmp2cfg_ref ((update_Pmpcfg_ent_A w__2 ((pmpAddrMatchType_to_bits OFF  ::  2 Word.word)))) \<then>
   read_reg pmp3cfg_ref) \<bind> ((\<lambda> (w__3 :: Pmpcfg_ent) . 
   (write_reg pmp3cfg_ref ((update_Pmpcfg_ent_A w__3 ((pmpAddrMatchType_to_bits OFF  ::  2 Word.word)))) \<then>
   read_reg pmp4cfg_ref) \<bind> ((\<lambda> (w__4 :: Pmpcfg_ent) . 
   (write_reg pmp4cfg_ref ((update_Pmpcfg_ent_A w__4 ((pmpAddrMatchType_to_bits OFF  ::  2 Word.word)))) \<then>
   read_reg pmp5cfg_ref) \<bind> ((\<lambda> (w__5 :: Pmpcfg_ent) . 
   (write_reg pmp5cfg_ref ((update_Pmpcfg_ent_A w__5 ((pmpAddrMatchType_to_bits OFF  ::  2 Word.word)))) \<then>
   read_reg pmp6cfg_ref) \<bind> ((\<lambda> (w__6 :: Pmpcfg_ent) . 
   (write_reg pmp6cfg_ref ((update_Pmpcfg_ent_A w__6 ((pmpAddrMatchType_to_bits OFF  ::  2 Word.word)))) \<then>
   read_reg pmp7cfg_ref) \<bind> ((\<lambda> (w__7 :: Pmpcfg_ent) . 
   (write_reg pmp7cfg_ref ((update_Pmpcfg_ent_A w__7 ((pmpAddrMatchType_to_bits OFF  ::  2 Word.word)))) \<then>
   read_reg pmp8cfg_ref) \<bind> ((\<lambda> (w__8 :: Pmpcfg_ent) . 
   (write_reg pmp8cfg_ref ((update_Pmpcfg_ent_A w__8 ((pmpAddrMatchType_to_bits OFF  ::  2 Word.word)))) \<then>
   read_reg pmp9cfg_ref) \<bind> ((\<lambda> (w__9 :: Pmpcfg_ent) . 
   (write_reg pmp9cfg_ref ((update_Pmpcfg_ent_A w__9 ((pmpAddrMatchType_to_bits OFF  ::  2 Word.word)))) \<then>
   read_reg pmp10cfg_ref) \<bind> ((\<lambda> (w__10 :: Pmpcfg_ent) . 
   (write_reg
     pmp10cfg_ref
     ((update_Pmpcfg_ent_A w__10 ((pmpAddrMatchType_to_bits OFF  ::  2 Word.word)))) \<then>
   read_reg pmp11cfg_ref) \<bind> ((\<lambda> (w__11 :: Pmpcfg_ent) . 
   (write_reg
     pmp11cfg_ref
     ((update_Pmpcfg_ent_A w__11 ((pmpAddrMatchType_to_bits OFF  ::  2 Word.word)))) \<then>
   read_reg pmp12cfg_ref) \<bind> ((\<lambda> (w__12 :: Pmpcfg_ent) . 
   (write_reg
     pmp12cfg_ref
     ((update_Pmpcfg_ent_A w__12 ((pmpAddrMatchType_to_bits OFF  ::  2 Word.word)))) \<then>
   read_reg pmp13cfg_ref) \<bind> ((\<lambda> (w__13 :: Pmpcfg_ent) . 
   (write_reg
     pmp13cfg_ref
     ((update_Pmpcfg_ent_A w__13 ((pmpAddrMatchType_to_bits OFF  ::  2 Word.word)))) \<then>
   read_reg pmp14cfg_ref) \<bind> ((\<lambda> (w__14 :: Pmpcfg_ent) . 
   (write_reg
     pmp14cfg_ref
     ((update_Pmpcfg_ent_A w__14 ((pmpAddrMatchType_to_bits OFF  ::  2 Word.word)))) \<then>
   read_reg pmp15cfg_ref) \<bind> ((\<lambda> (w__15 :: Pmpcfg_ent) . 
   write_reg
     pmp15cfg_ref
     ((update_Pmpcfg_ent_A w__15 ((pmpAddrMatchType_to_bits OFF  ::  2 Word.word)))))))))))))))))))))))))))))))))))))\<close>


\<comment> \<open>\<open>val ext_init_regs : unit -> M unit\<close>\<close>

definition ext_init_regs  :: \<open> unit \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> ext_init_regs _ = ( return ()  )\<close>


\<comment> \<open>\<open>
This function is called after above when running rvfi and allows the model
to be initialised differently (e.g. CHERI cap regs are initialised
to omnipotent instead of null).
\<close>\<close>
\<comment> \<open>\<open>val ext_rvfi_init : unit -> M unit\<close>\<close>

definition ext_rvfi_init  :: \<open> unit \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> ext_rvfi_init _ = (
   (read_reg x1_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) .  write_reg x1_ref w__0)))\<close>


\<comment> \<open>\<open>
THIS(csrno, priv, isWrite) allows an extension to block access to csrno,
at Privilege level priv. It should return true if the access is allowed.
\<close>\<close>
\<comment> \<open>\<open>val ext_check_CSR : mword ty12 -> Privilege -> bool -> bool\<close>\<close>

definition ext_check_CSR  :: \<open>(12)Word.word \<Rightarrow> Privilege \<Rightarrow> bool \<Rightarrow> bool \<close>  where 
     \<open> ext_check_CSR csrno p isWrite = ( True )\<close> 
  for  csrno  :: "(12)Word.word " 
  and  p  :: " Privilege " 
  and  isWrite  :: " bool "


\<comment> \<open>\<open>
THIS is called if ext_check_CSR returns false. It should
cause an appropriate RISCV exception.
\<close>\<close>
\<comment> \<open>\<open>val ext_check_CSR_fail : unit -> unit\<close>\<close>

definition ext_check_CSR_fail  :: \<open> unit \<Rightarrow> unit \<close>  where 
     \<open> ext_check_CSR_fail _ = ( ()  )\<close>


\<comment> \<open>\<open>
Validate a read from physical memory.
THIS(access_type, paddr, size, aquire, release, reserved, read_meta) should
return Some(exception) to abort the read or None to allow it to proceed. The
check is performed after PMP checks and does not apply to MMIO memory.
\<close>\<close>
\<comment> \<open>\<open>val ext_check_phys_mem_read : AccessType unit -> mword ty64 -> integer -> bool -> bool -> bool -> bool -> Ext_PhysAddr_Check\<close>\<close>

\<comment> \<open>\<open>
Validate a write to physical memory.
THIS(write_kind, paddr, size, data, metadata) should return Some(exception)
to abort the write or None to allow it to proceed. The check is performed 
after PMP checks and does not apply to MMIO memory.
\<close>\<close>
\<comment> \<open>\<open>val ext_check_phys_mem_write : forall 'int8_times_n. Size 'int8_times_n => write_kind -> mword ty64 -> integer -> mword 'int8_times_n -> unit -> Ext_PhysAddr_Check\<close>\<close>

\<comment> \<open>\<open>val ext_fetch_check_pc : mword ty64 -> mword ty64 -> Ext_FetchAddr_Check unit\<close>\<close>

definition ext_fetch_check_pc  :: \<open>(64)Word.word \<Rightarrow>(64)Word.word \<Rightarrow>(unit)Ext_FetchAddr_Check \<close>  where 
     \<open> ext_fetch_check_pc (start_pc :: xlenbits) (pc :: xlenbits) = ( Ext_FetchAddr_OK pc )\<close> 
  for  start_pc  :: "(64)Word.word " 
  and  pc  :: "(64)Word.word "


\<comment> \<open>\<open>val ext_handle_fetch_check_error : unit -> unit\<close>\<close>

definition ext_handle_fetch_check_error  :: \<open> unit \<Rightarrow> unit \<close>  where 
     \<open> ext_handle_fetch_check_error err = ( ()  )\<close> 
  for  err  :: " unit "


\<comment> \<open>\<open>val ext_control_check_addr : mword ty64 -> Ext_ControlAddr_Check unit\<close>\<close>

definition ext_control_check_addr  :: \<open>(64)Word.word \<Rightarrow>(unit)Ext_ControlAddr_Check \<close>  where 
     \<open> ext_control_check_addr pc = ( Ext_ControlAddr_OK pc )\<close> 
  for  pc  :: "(64)Word.word "


\<comment> \<open>\<open>val ext_control_check_pc : mword ty64 -> Ext_ControlAddr_Check unit\<close>\<close>

definition ext_control_check_pc  :: \<open>(64)Word.word \<Rightarrow>(unit)Ext_ControlAddr_Check \<close>  where 
     \<open> ext_control_check_pc pc = ( Ext_ControlAddr_OK pc )\<close> 
  for  pc  :: "(64)Word.word "


\<comment> \<open>\<open>val ext_handle_control_check_error : unit -> unit\<close>\<close>

definition ext_handle_control_check_error  :: \<open> unit \<Rightarrow> unit \<close>  where 
     \<open> ext_handle_control_check_error err = ( ()  )\<close> 
  for  err  :: " unit "


\<comment> \<open>\<open>val ext_data_get_addr : mword ty5 -> mword ty64 -> AccessType unit -> word_width -> M (Ext_DataAddr_Check unit)\<close>\<close>

definition ext_data_get_addr  :: \<open>(5)Word.word \<Rightarrow>(64)Word.word \<Rightarrow>(ext_access_type)AccessType \<Rightarrow> word_width \<Rightarrow>((register_value),((unit)Ext_DataAddr_Check),(exception))monad \<close>  where 
     \<open> ext_data_get_addr (base :: regidx) (offset :: xlenbits) (acc1 :: ext_access_type AccessType) (width ::
  word_width) = (
   (rX_bits base  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (let addr = ((add_vec w__0 offset  ::  64 Word.word)) in
   return (Ext_DataAddr_OK addr)))))\<close> 
  for  base  :: "(5)Word.word " 
  and  offset  :: "(64)Word.word " 
  and  acc1  :: "(ext_access_type)AccessType " 
  and  width  :: " word_width "


\<comment> \<open>\<open>val ext_handle_data_check_error : unit -> unit\<close>\<close>

definition ext_handle_data_check_error  :: \<open> unit \<Rightarrow> unit \<close>  where 
     \<open> ext_handle_data_check_error err = ( ()  )\<close> 
  for  err  :: " unit "


definition ext_check_phys_mem_read  :: \<open>(unit)AccessType \<Rightarrow>(64)Word.word \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow> Ext_PhysAddr_Check \<close>  where 
     \<open> ext_check_phys_mem_read access_type paddr size1 aquire release reserved read_meta = (
   Ext_PhysAddr_OK ()  )\<close> 
  for  access_type  :: "(unit)AccessType " 
  and  paddr  :: "(64)Word.word " 
  and  size1  :: " int " 
  and  aquire  :: " bool " 
  and  release  :: " bool " 
  and  reserved  :: " bool " 
  and  read_meta  :: " bool "


definition ext_check_phys_mem_write  :: \<open> write_kind \<Rightarrow>(64)Word.word \<Rightarrow> int \<Rightarrow>('int8_times_n::len)Word.word \<Rightarrow> unit \<Rightarrow> Ext_PhysAddr_Check \<close>  where 
     \<open> ext_check_phys_mem_write write_kind paddr size1 data metadata = ( Ext_PhysAddr_OK ()  )\<close> 
  for  write_kind  :: " write_kind " 
  and  paddr  :: "(64)Word.word " 
  and  size1  :: " int " 
  and  data  :: "('int8_times_n::len)Word.word " 
  and  metadata  :: " unit "


\<comment> \<open>\<open>val csr_name_map_forwards : mword ty12 -> string\<close>\<close>

\<comment> \<open>\<open>val csr_name_map_backwards : string -> M (mword ty12)\<close>\<close>

\<comment> \<open>\<open>val csr_name_map_forwards_matches : mword ty12 -> bool\<close>\<close>

\<comment> \<open>\<open>val csr_name_map_backwards_matches : string -> M bool\<close>\<close>

\<comment> \<open>\<open>val csr_name_map_matches_prefix : string -> maybe ((mword ty12 * ii))\<close>\<close>

\<comment> \<open>\<open>val ext_is_CSR_defined : mword ty12 -> Privilege -> M bool\<close>\<close>

\<comment> \<open>\<open>val ext_read_CSR : mword ty12 -> M (maybe (mword ty64))\<close>\<close>

\<comment> \<open>\<open>val ext_write_CSR : mword ty12 -> mword ty64 -> M (maybe (mword ty64))\<close>\<close>

\<comment> \<open>\<open>val undefined_Ustatus : unit -> M Ustatus\<close>\<close>

definition undefined_Ustatus  :: \<open> unit \<Rightarrow>((register_value),(Ustatus),(exception))monad \<close>  where 
     \<open> undefined_Ustatus _ = (
   ((return (failwith (''undefined value of unsupported type''))) :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::
      64 Word.word) . 
   return ((| Ustatus_bits = w__0 |)))))\<close>


\<comment> \<open>\<open>val Mk_Ustatus : mword ty64 -> Ustatus\<close>\<close>

definition Mk_Ustatus  :: \<open>(64)Word.word \<Rightarrow> Ustatus \<close>  where 
     \<open> Mk_Ustatus v = ( (| Ustatus_bits = v |) )\<close> 
  for  v  :: "(64)Word.word "


definition get_Ustatus_bits  :: \<open> Ustatus \<Rightarrow>(64)Word.word \<close>  where 
     \<open> get_Ustatus_bits v = ( (subrange_vec_dec(Ustatus_bits   v) (( 63 :: int)::ii) (( 0 :: int)::ii)  ::  64 Word.word))\<close> 
  for  v  :: " Ustatus "


definition set_Ustatus_bits  :: \<open>((regstate),(register_value),(Ustatus))register_ref \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Ustatus_bits r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Ustatus_bits := ((update_subrange_vec_dec(Ustatus_bits   r) (( 63 :: int)::ii) (( 0 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Ustatus))register_ref " 
  and  v  :: "(64)Word.word "


definition update_Ustatus_bits  :: \<open> Ustatus \<Rightarrow>(64)Word.word \<Rightarrow> Ustatus \<close>  where 
     \<open> update_Ustatus_bits v x = (
   ( v (|
     Ustatus_bits := ((update_subrange_vec_dec(Ustatus_bits   v) (( 63 :: int)::ii) (( 0 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Ustatus " 
  and  x  :: "(64)Word.word "


definition get_Ustatus_UIE  :: \<open> Ustatus \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_Ustatus_UIE v = ( (subrange_vec_dec(Ustatus_bits   v) (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " Ustatus "


definition set_Ustatus_UIE  :: \<open>((regstate),(register_value),(Ustatus))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Ustatus_UIE r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Ustatus_bits := ((update_subrange_vec_dec(Ustatus_bits   r) (( 0 :: int)::ii) (( 0 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Ustatus))register_ref " 
  and  v  :: "(1)Word.word "


definition update_Ustatus_UIE  :: \<open> Ustatus \<Rightarrow>(1)Word.word \<Rightarrow> Ustatus \<close>  where 
     \<open> update_Ustatus_UIE v x = (
   ( v (| Ustatus_bits := ((update_subrange_vec_dec(Ustatus_bits   v) (( 0 :: int)::ii) (( 0 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Ustatus " 
  and  x  :: "(1)Word.word "


definition get_Ustatus_UPIE  :: \<open> Ustatus \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_Ustatus_UPIE v = ( (subrange_vec_dec(Ustatus_bits   v) (( 4 :: int)::ii) (( 4 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " Ustatus "


definition set_Ustatus_UPIE  :: \<open>((regstate),(register_value),(Ustatus))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Ustatus_UPIE r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Ustatus_bits := ((update_subrange_vec_dec(Ustatus_bits   r) (( 4 :: int)::ii) (( 4 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Ustatus))register_ref " 
  and  v  :: "(1)Word.word "


definition update_Ustatus_UPIE  :: \<open> Ustatus \<Rightarrow>(1)Word.word \<Rightarrow> Ustatus \<close>  where 
     \<open> update_Ustatus_UPIE v x = (
   ( v (| Ustatus_bits := ((update_subrange_vec_dec(Ustatus_bits   v) (( 4 :: int)::ii) (( 4 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Ustatus " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val lower_sstatus : Sstatus -> Ustatus\<close>\<close>

definition lower_sstatus  :: \<open> Sstatus \<Rightarrow> Ustatus \<close>  where 
     \<open> lower_sstatus s = (
   (let u = (Mk_Ustatus ((EXTZ (( 64 :: int)::ii) ( 0b0 ::  1 Word.word)  ::  64 Word.word))) in
   (let u = (update_Ustatus_UPIE u ((get_Sstatus_UPIE s  ::  1 Word.word))) in
   update_Ustatus_UIE u ((get_Sstatus_UIE s  ::  1 Word.word)))))\<close> 
  for  s  :: " Sstatus "


\<comment> \<open>\<open>val lift_ustatus : Sstatus -> Ustatus -> Sstatus\<close>\<close>

definition lift_ustatus  :: \<open> Sstatus \<Rightarrow> Ustatus \<Rightarrow> Sstatus \<close>  where 
     \<open> lift_ustatus (s :: Sstatus) (u :: Ustatus) = (
   (let s = (update_Sstatus_UPIE s ((get_Ustatus_UPIE u  ::  1 Word.word))) in
   update_Sstatus_UIE s ((get_Ustatus_UIE u  ::  1 Word.word))))\<close> 
  for  s  :: " Sstatus " 
  and  u  :: " Ustatus "


\<comment> \<open>\<open>val legalize_ustatus : Mstatus -> mword ty64 -> M Mstatus\<close>\<close>

definition legalize_ustatus  :: \<open> Mstatus \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),(Mstatus),(exception))monad \<close>  where 
     \<open> legalize_ustatus (m :: Mstatus) (v :: xlenbits) = (
   (let u = (Mk_Ustatus v) in
   (let s = (lower_mstatus m) in
   (let s = (lift_ustatus s u) in
   lift_sstatus m s))))\<close> 
  for  m  :: " Mstatus " 
  and  v  :: "(64)Word.word "


\<comment> \<open>\<open>val undefined_Uinterrupts : unit -> M Uinterrupts\<close>\<close>

definition undefined_Uinterrupts  :: \<open> unit \<Rightarrow>((register_value),(Uinterrupts),(exception))monad \<close>  where 
     \<open> undefined_Uinterrupts _ = (
   ((return (failwith (''undefined value of unsupported type''))) :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::
      64 Word.word) . 
   return ((| Uinterrupts_bits = w__0 |)))))\<close>


\<comment> \<open>\<open>val Mk_Uinterrupts : mword ty64 -> Uinterrupts\<close>\<close>

definition Mk_Uinterrupts  :: \<open>(64)Word.word \<Rightarrow> Uinterrupts \<close>  where 
     \<open> Mk_Uinterrupts v = ( (| Uinterrupts_bits = v |) )\<close> 
  for  v  :: "(64)Word.word "


definition get_Uinterrupts_bits  :: \<open> Uinterrupts \<Rightarrow>(64)Word.word \<close>  where 
     \<open> get_Uinterrupts_bits v = ( (subrange_vec_dec(Uinterrupts_bits   v) (( 63 :: int)::ii) (( 0 :: int)::ii)  ::  64 Word.word))\<close> 
  for  v  :: " Uinterrupts "


definition set_Uinterrupts_bits  :: \<open>((regstate),(register_value),(Uinterrupts))register_ref \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Uinterrupts_bits r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Uinterrupts_bits :=
         ((update_subrange_vec_dec(Uinterrupts_bits   r) (( 63 :: int)::ii) (( 0 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Uinterrupts))register_ref " 
  and  v  :: "(64)Word.word "


definition update_Uinterrupts_bits  :: \<open> Uinterrupts \<Rightarrow>(64)Word.word \<Rightarrow> Uinterrupts \<close>  where 
     \<open> update_Uinterrupts_bits v x = (
   ( v (|
     Uinterrupts_bits :=
       ((update_subrange_vec_dec(Uinterrupts_bits   v) (( 63 :: int)::ii) (( 0 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Uinterrupts " 
  and  x  :: "(64)Word.word "


definition get_Uinterrupts_UEI  :: \<open> Uinterrupts \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_Uinterrupts_UEI v = ( (subrange_vec_dec(Uinterrupts_bits   v) (( 8 :: int)::ii) (( 8 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " Uinterrupts "


definition set_Uinterrupts_UEI  :: \<open>((regstate),(register_value),(Uinterrupts))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Uinterrupts_UEI r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Uinterrupts_bits :=
         ((update_subrange_vec_dec(Uinterrupts_bits   r) (( 8 :: int)::ii) (( 8 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Uinterrupts))register_ref " 
  and  v  :: "(1)Word.word "


definition update_Uinterrupts_UEI  :: \<open> Uinterrupts \<Rightarrow>(1)Word.word \<Rightarrow> Uinterrupts \<close>  where 
     \<open> update_Uinterrupts_UEI v x = (
   ( v (|
     Uinterrupts_bits := ((update_subrange_vec_dec(Uinterrupts_bits   v) (( 8 :: int)::ii) (( 8 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Uinterrupts " 
  and  x  :: "(1)Word.word "


definition get_Uinterrupts_USI  :: \<open> Uinterrupts \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_Uinterrupts_USI v = ( (subrange_vec_dec(Uinterrupts_bits   v) (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " Uinterrupts "


definition set_Uinterrupts_USI  :: \<open>((regstate),(register_value),(Uinterrupts))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Uinterrupts_USI r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Uinterrupts_bits :=
         ((update_subrange_vec_dec(Uinterrupts_bits   r) (( 0 :: int)::ii) (( 0 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Uinterrupts))register_ref " 
  and  v  :: "(1)Word.word "


definition update_Uinterrupts_USI  :: \<open> Uinterrupts \<Rightarrow>(1)Word.word \<Rightarrow> Uinterrupts \<close>  where 
     \<open> update_Uinterrupts_USI v x = (
   ( v (|
     Uinterrupts_bits := ((update_subrange_vec_dec(Uinterrupts_bits   v) (( 0 :: int)::ii) (( 0 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Uinterrupts " 
  and  x  :: "(1)Word.word "


definition get_Uinterrupts_UTI  :: \<open> Uinterrupts \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_Uinterrupts_UTI v = ( (subrange_vec_dec(Uinterrupts_bits   v) (( 4 :: int)::ii) (( 4 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " Uinterrupts "


definition set_Uinterrupts_UTI  :: \<open>((regstate),(register_value),(Uinterrupts))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Uinterrupts_UTI r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       Uinterrupts_bits :=
         ((update_subrange_vec_dec(Uinterrupts_bits   r) (( 4 :: int)::ii) (( 4 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Uinterrupts))register_ref " 
  and  v  :: "(1)Word.word "


definition update_Uinterrupts_UTI  :: \<open> Uinterrupts \<Rightarrow>(1)Word.word \<Rightarrow> Uinterrupts \<close>  where 
     \<open> update_Uinterrupts_UTI v x = (
   ( v (|
     Uinterrupts_bits := ((update_subrange_vec_dec(Uinterrupts_bits   v) (( 4 :: int)::ii) (( 4 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " Uinterrupts " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val lower_sip : Sinterrupts -> Sinterrupts -> Uinterrupts\<close>\<close>

definition lower_sip  :: \<open> Sinterrupts \<Rightarrow> Sinterrupts \<Rightarrow> Uinterrupts \<close>  where 
     \<open> lower_sip (s :: Sinterrupts) (d :: Sinterrupts) = (
   (let (u :: Uinterrupts) = (Mk_Uinterrupts ((EXTZ (( 64 :: int)::ii) ( 0b0 ::  1 Word.word)  ::  64 Word.word))) in
   (let u =
     (update_Uinterrupts_UEI u
       ((and_vec ((get_Sinterrupts_UEI s  ::  1 Word.word)) ((get_Sinterrupts_UEI d  ::  1 Word.word))
          ::  1 Word.word))) in
   (let u =
     (update_Uinterrupts_UTI u
       ((and_vec ((get_Sinterrupts_UTI s  ::  1 Word.word)) ((get_Sinterrupts_UTI d  ::  1 Word.word))
          ::  1 Word.word))) in
   update_Uinterrupts_USI u
     ((and_vec ((get_Sinterrupts_USI s  ::  1 Word.word)) ((get_Sinterrupts_USI d  ::  1 Word.word))
        ::  1 Word.word))))))\<close> 
  for  s  :: " Sinterrupts " 
  and  d  :: " Sinterrupts "


\<comment> \<open>\<open>val lower_sie : Sinterrupts -> Sinterrupts -> Uinterrupts\<close>\<close>

definition lower_sie  :: \<open> Sinterrupts \<Rightarrow> Sinterrupts \<Rightarrow> Uinterrupts \<close>  where 
     \<open> lower_sie (s :: Sinterrupts) (d :: Sinterrupts) = (
   (let (u :: Uinterrupts) = (Mk_Uinterrupts ((EXTZ (( 64 :: int)::ii) ( 0b0 ::  1 Word.word)  ::  64 Word.word))) in
   (let u =
     (update_Uinterrupts_UEI u
       ((and_vec ((get_Sinterrupts_UEI s  ::  1 Word.word)) ((get_Sinterrupts_UEI d  ::  1 Word.word))
          ::  1 Word.word))) in
   (let u =
     (update_Uinterrupts_UTI u
       ((and_vec ((get_Sinterrupts_UTI s  ::  1 Word.word)) ((get_Sinterrupts_UTI d  ::  1 Word.word))
          ::  1 Word.word))) in
   update_Uinterrupts_USI u
     ((and_vec ((get_Sinterrupts_USI s  ::  1 Word.word)) ((get_Sinterrupts_USI d  ::  1 Word.word))
        ::  1 Word.word))))))\<close> 
  for  s  :: " Sinterrupts " 
  and  d  :: " Sinterrupts "


\<comment> \<open>\<open>val lift_uip : Sinterrupts -> Sinterrupts -> Uinterrupts -> Sinterrupts\<close>\<close>

definition lift_uip  :: \<open> Sinterrupts \<Rightarrow> Sinterrupts \<Rightarrow> Uinterrupts \<Rightarrow> Sinterrupts \<close>  where 
     \<open> lift_uip (o1 :: Sinterrupts) (d :: Sinterrupts) (u :: Uinterrupts) = (
   (let (s :: Sinterrupts) = o1 in
   if (((((get_Sinterrupts_USI d  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))) then
     update_Sinterrupts_USI s ((get_Uinterrupts_USI u  ::  1 Word.word))
   else s))\<close> 
  for  o1  :: " Sinterrupts " 
  and  d  :: " Sinterrupts " 
  and  u  :: " Uinterrupts "


\<comment> \<open>\<open>val legalize_uip : Sinterrupts -> Sinterrupts -> mword ty64 -> Sinterrupts\<close>\<close>

definition legalize_uip  :: \<open> Sinterrupts \<Rightarrow> Sinterrupts \<Rightarrow>(64)Word.word \<Rightarrow> Sinterrupts \<close>  where 
     \<open> legalize_uip (s :: Sinterrupts) (d :: Sinterrupts) (v :: xlenbits) = (
   lift_uip s d ((Mk_Uinterrupts v)))\<close> 
  for  s  :: " Sinterrupts " 
  and  d  :: " Sinterrupts " 
  and  v  :: "(64)Word.word "


\<comment> \<open>\<open>val lift_uie : Sinterrupts -> Sinterrupts -> Uinterrupts -> Sinterrupts\<close>\<close>

definition lift_uie  :: \<open> Sinterrupts \<Rightarrow> Sinterrupts \<Rightarrow> Uinterrupts \<Rightarrow> Sinterrupts \<close>  where 
     \<open> lift_uie (o1 :: Sinterrupts) (d :: Sinterrupts) (u :: Uinterrupts) = (
   (let (s :: Sinterrupts) = o1 in
   (let s =
     (if (((((get_Sinterrupts_UEI d  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))) then
       update_Sinterrupts_UEI s ((get_Uinterrupts_UEI u  ::  1 Word.word))
     else s) in
   (let s =
     (if (((((get_Sinterrupts_UTI d  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))) then
       update_Sinterrupts_UTI s ((get_Uinterrupts_UTI u  ::  1 Word.word))
     else s) in
   if (((((get_Sinterrupts_USI d  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))) then
     update_Sinterrupts_USI s ((get_Uinterrupts_USI u  ::  1 Word.word))
   else s))))\<close> 
  for  o1  :: " Sinterrupts " 
  and  d  :: " Sinterrupts " 
  and  u  :: " Uinterrupts "


\<comment> \<open>\<open>val legalize_uie : Sinterrupts -> Sinterrupts -> mword ty64 -> Sinterrupts\<close>\<close>

definition legalize_uie  :: \<open> Sinterrupts \<Rightarrow> Sinterrupts \<Rightarrow>(64)Word.word \<Rightarrow> Sinterrupts \<close>  where 
     \<open> legalize_uie (s :: Sinterrupts) (d :: Sinterrupts) (v :: xlenbits) = (
   lift_uie s d ((Mk_Uinterrupts v)))\<close> 
  for  s  :: " Sinterrupts " 
  and  d  :: " Sinterrupts " 
  and  v  :: "(64)Word.word "


\<comment> \<open>\<open>val ext_check_xret_priv : Privilege -> bool\<close>\<close>

definition ext_check_xret_priv  :: \<open> Privilege \<Rightarrow> bool \<close>  where 
     \<open> ext_check_xret_priv p = ( True )\<close> 
  for  p  :: " Privilege "


\<comment> \<open>\<open>val ext_fail_xret_priv : unit -> unit\<close>\<close>

definition ext_fail_xret_priv  :: \<open> unit \<Rightarrow> unit \<close>  where 
     \<open> ext_fail_xret_priv _ = ( ()  )\<close>


\<comment> \<open>\<open>val handle_trap_extension : Privilege -> mword ty64 -> maybe unit -> unit\<close>\<close>

definition handle_trap_extension  :: \<open> Privilege \<Rightarrow>(64)Word.word \<Rightarrow>(unit)option \<Rightarrow> unit \<close>  where 
     \<open> handle_trap_extension (p :: Privilege) (pc :: xlenbits) (u ::  unit option) = ( ()  )\<close> 
  for  p  :: " Privilege " 
  and  pc  :: "(64)Word.word " 
  and  u  :: "(unit)option "


\<comment> \<open>\<open>val prepare_trap_vector : Privilege -> Mcause -> M (mword ty64)\<close>\<close>

definition prepare_trap_vector  :: \<open> Privilege \<Rightarrow> Mcause \<Rightarrow>((register_value),((64)Word.word),(exception))monad \<close>  where 
     \<open> prepare_trap_vector (p :: Privilege) (cause :: Mcause) = (
   (case  p of
     Machine => read_reg mtvec_ref
   | Supervisor => read_reg stvec_ref
   | User => read_reg utvec_ref
   ) \<bind> ((\<lambda> (tvec :: Mtvec) . 
   (case  ((tvec_addr tvec cause  ::  ( 64 Word.word)option)) of
     Some (epc) => return epc
   | None => (internal_error (''Invalid tvec mode'')  :: ( 64 Word.word) M)
   ))))\<close> 
  for  p  :: " Privilege " 
  and  cause  :: " Mcause "


\<comment> \<open>\<open>val get_xret_target : Privilege -> M (mword ty64)\<close>\<close>

fun get_xret_target  :: \<open> Privilege \<Rightarrow>((register_value),((64)Word.word),(exception))monad \<close>  where 
     \<open> get_xret_target Machine = ( (read_reg mepc_ref  :: ( 64 Word.word) M))\<close>
|\<open> get_xret_target Supervisor = ( (read_reg sepc_ref  :: ( 64 Word.word) M))\<close>
|\<open> get_xret_target User = ( (read_reg uepc_ref  :: ( 64 Word.word) M))\<close>


\<comment> \<open>\<open>val set_xret_target : Privilege -> mword ty64 -> M (mword ty64)\<close>\<close>

definition set_xret_target  :: \<open> Privilege \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),((64)Word.word),(exception))monad \<close>  where 
     \<open> set_xret_target p value1 = (
   (legalize_xepc value1  :: ( 64 Word.word) M) \<bind> ((\<lambda> target . 
   (case  p of
     Machine => write_reg mepc_ref target
   | Supervisor => write_reg sepc_ref target
   | User => write_reg uepc_ref target
   ) \<then>
   return target)))\<close> 
  for  p  :: " Privilege " 
  and  value1  :: "(64)Word.word "


\<comment> \<open>\<open>val prepare_xret_target : Privilege -> M (mword ty64)\<close>\<close>

definition prepare_xret_target  :: \<open> Privilege \<Rightarrow>((register_value),((64)Word.word),(exception))monad \<close>  where 
     \<open> prepare_xret_target p = ( (get_xret_target p  :: ( 64 Word.word) M))\<close> 
  for  p  :: " Privilege "


\<comment> \<open>\<open>val get_mtvec : unit -> M (mword ty64)\<close>\<close>

definition get_mtvec  :: \<open> unit \<Rightarrow>((register_value),((64)Word.word),(exception))monad \<close>  where 
     \<open> get_mtvec _ = (
   read_reg mtvec_ref \<bind> ((\<lambda> (w__0 :: Mtvec) .  return ((get_Mtvec_bits w__0  ::  64 Word.word)))))\<close>


\<comment> \<open>\<open>val get_stvec : unit -> M (mword ty64)\<close>\<close>

definition get_stvec  :: \<open> unit \<Rightarrow>((register_value),((64)Word.word),(exception))monad \<close>  where 
     \<open> get_stvec _ = (
   read_reg stvec_ref \<bind> ((\<lambda> (w__0 :: Mtvec) .  return ((get_Mtvec_bits w__0  ::  64 Word.word)))))\<close>


\<comment> \<open>\<open>val get_utvec : unit -> M (mword ty64)\<close>\<close>

definition get_utvec  :: \<open> unit \<Rightarrow>((register_value),((64)Word.word),(exception))monad \<close>  where 
     \<open> get_utvec _ = (
   read_reg utvec_ref \<bind> ((\<lambda> (w__0 :: Mtvec) .  return ((get_Mtvec_bits w__0  ::  64 Word.word)))))\<close>


\<comment> \<open>\<open>val set_mtvec : mword ty64 -> M (mword ty64)\<close>\<close>

definition set_mtvec  :: \<open>(64)Word.word \<Rightarrow>((register_value),((64)Word.word),(exception))monad \<close>  where 
     \<open> set_mtvec value1 = (
   read_reg mtvec_ref \<bind> ((\<lambda> (w__0 :: Mtvec) . 
   (write_reg mtvec_ref ((legalize_tvec w__0 value1)) \<then>
   read_reg mtvec_ref) \<bind> ((\<lambda> (w__1 :: Mtvec) .  return ((get_Mtvec_bits w__1  ::  64 Word.word)))))))\<close> 
  for  value1  :: "(64)Word.word "


\<comment> \<open>\<open>val set_stvec : mword ty64 -> M (mword ty64)\<close>\<close>

definition set_stvec  :: \<open>(64)Word.word \<Rightarrow>((register_value),((64)Word.word),(exception))monad \<close>  where 
     \<open> set_stvec value1 = (
   read_reg stvec_ref \<bind> ((\<lambda> (w__0 :: Mtvec) . 
   (write_reg stvec_ref ((legalize_tvec w__0 value1)) \<then>
   read_reg stvec_ref) \<bind> ((\<lambda> (w__1 :: Mtvec) .  return ((get_Mtvec_bits w__1  ::  64 Word.word)))))))\<close> 
  for  value1  :: "(64)Word.word "


\<comment> \<open>\<open>val set_utvec : mword ty64 -> M (mword ty64)\<close>\<close>

definition set_utvec  :: \<open>(64)Word.word \<Rightarrow>((register_value),((64)Word.word),(exception))monad \<close>  where 
     \<open> set_utvec value1 = (
   read_reg utvec_ref \<bind> ((\<lambda> (w__0 :: Mtvec) . 
   (write_reg utvec_ref ((legalize_tvec w__0 value1)) \<then>
   read_reg utvec_ref) \<bind> ((\<lambda> (w__1 :: Mtvec) .  return ((get_Mtvec_bits w__1  ::  64 Word.word)))))))\<close> 
  for  value1  :: "(64)Word.word "


\<comment> \<open>\<open>val update_softfloat_fflags : mword ty5 -> M unit\<close>\<close>

definition update_softfloat_fflags  :: \<open>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> update_softfloat_fflags flags = (
   write_reg float_fflags_ref ((zero_extend flags (( 64 :: int)::ii)  ::  64 Word.word)))\<close> 
  for  flags  :: "(5)Word.word "


\<comment> \<open>\<open>val riscv_f16Add : mword ty3 -> mword ty16 -> mword ty16 -> M (mword ty5 * mword ty16)\<close>\<close>

definition riscv_f16Add  :: \<open>(3)Word.word \<Rightarrow>(16)Word.word \<Rightarrow>(16)Word.word \<Rightarrow>((register_value),((5)Word.word*(16)Word.word),(exception))monad \<close>  where 
     \<open> riscv_f16Add rm v1 v2 = (
   (let (_ :: unit) = (softfloat_f16_add rm v1 v2) in
   (read_reg float_fflags_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (read_reg float_result_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
   return ((subrange_vec_dec w__0 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word),
           (subrange_vec_dec w__1 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))))))))\<close> 
  for  rm  :: "(3)Word.word " 
  and  v1  :: "(16)Word.word " 
  and  v2  :: "(16)Word.word "


\<comment> \<open>\<open>val riscv_f16Sub : mword ty3 -> mword ty16 -> mword ty16 -> M (mword ty5 * mword ty16)\<close>\<close>

definition riscv_f16Sub  :: \<open>(3)Word.word \<Rightarrow>(16)Word.word \<Rightarrow>(16)Word.word \<Rightarrow>((register_value),((5)Word.word*(16)Word.word),(exception))monad \<close>  where 
     \<open> riscv_f16Sub rm v1 v2 = (
   (let (_ :: unit) = (softfloat_f16_sub rm v1 v2) in
   (read_reg float_fflags_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (read_reg float_result_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
   return ((subrange_vec_dec w__0 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word),
           (subrange_vec_dec w__1 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))))))))\<close> 
  for  rm  :: "(3)Word.word " 
  and  v1  :: "(16)Word.word " 
  and  v2  :: "(16)Word.word "


\<comment> \<open>\<open>val riscv_f16Mul : mword ty3 -> mword ty16 -> mword ty16 -> M (mword ty5 * mword ty16)\<close>\<close>

definition riscv_f16Mul  :: \<open>(3)Word.word \<Rightarrow>(16)Word.word \<Rightarrow>(16)Word.word \<Rightarrow>((register_value),((5)Word.word*(16)Word.word),(exception))monad \<close>  where 
     \<open> riscv_f16Mul rm v1 v2 = (
   (let (_ :: unit) = (softfloat_f16_mul rm v1 v2) in
   (read_reg float_fflags_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (read_reg float_result_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
   return ((subrange_vec_dec w__0 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word),
           (subrange_vec_dec w__1 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))))))))\<close> 
  for  rm  :: "(3)Word.word " 
  and  v1  :: "(16)Word.word " 
  and  v2  :: "(16)Word.word "


\<comment> \<open>\<open>val riscv_f16Div : mword ty3 -> mword ty16 -> mword ty16 -> M (mword ty5 * mword ty16)\<close>\<close>

definition riscv_f16Div  :: \<open>(3)Word.word \<Rightarrow>(16)Word.word \<Rightarrow>(16)Word.word \<Rightarrow>((register_value),((5)Word.word*(16)Word.word),(exception))monad \<close>  where 
     \<open> riscv_f16Div rm v1 v2 = (
   (let (_ :: unit) = (softfloat_f16_div rm v1 v2) in
   (read_reg float_fflags_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (read_reg float_result_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
   return ((subrange_vec_dec w__0 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word),
           (subrange_vec_dec w__1 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))))))))\<close> 
  for  rm  :: "(3)Word.word " 
  and  v1  :: "(16)Word.word " 
  and  v2  :: "(16)Word.word "


\<comment> \<open>\<open>val riscv_f32Add : mword ty3 -> mword ty32 -> mword ty32 -> M (mword ty5 * mword ty32)\<close>\<close>

definition riscv_f32Add  :: \<open>(3)Word.word \<Rightarrow>(32)Word.word \<Rightarrow>(32)Word.word \<Rightarrow>((register_value),((5)Word.word*(32)Word.word),(exception))monad \<close>  where 
     \<open> riscv_f32Add rm v1 v2 = (
   (let (_ :: unit) = (softfloat_f32_add rm v1 v2) in
   (read_reg float_fflags_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (read_reg float_result_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
   return ((subrange_vec_dec w__0 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word),
           (subrange_vec_dec w__1 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))))))))\<close> 
  for  rm  :: "(3)Word.word " 
  and  v1  :: "(32)Word.word " 
  and  v2  :: "(32)Word.word "


\<comment> \<open>\<open>val riscv_f32Sub : mword ty3 -> mword ty32 -> mword ty32 -> M (mword ty5 * mword ty32)\<close>\<close>

definition riscv_f32Sub  :: \<open>(3)Word.word \<Rightarrow>(32)Word.word \<Rightarrow>(32)Word.word \<Rightarrow>((register_value),((5)Word.word*(32)Word.word),(exception))monad \<close>  where 
     \<open> riscv_f32Sub rm v1 v2 = (
   (let (_ :: unit) = (softfloat_f32_sub rm v1 v2) in
   (read_reg float_fflags_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (read_reg float_result_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
   return ((subrange_vec_dec w__0 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word),
           (subrange_vec_dec w__1 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))))))))\<close> 
  for  rm  :: "(3)Word.word " 
  and  v1  :: "(32)Word.word " 
  and  v2  :: "(32)Word.word "


\<comment> \<open>\<open>val riscv_f32Mul : mword ty3 -> mword ty32 -> mword ty32 -> M (mword ty5 * mword ty32)\<close>\<close>

definition riscv_f32Mul  :: \<open>(3)Word.word \<Rightarrow>(32)Word.word \<Rightarrow>(32)Word.word \<Rightarrow>((register_value),((5)Word.word*(32)Word.word),(exception))monad \<close>  where 
     \<open> riscv_f32Mul rm v1 v2 = (
   (let (_ :: unit) = (softfloat_f32_mul rm v1 v2) in
   (read_reg float_fflags_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (read_reg float_result_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
   return ((subrange_vec_dec w__0 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word),
           (subrange_vec_dec w__1 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))))))))\<close> 
  for  rm  :: "(3)Word.word " 
  and  v1  :: "(32)Word.word " 
  and  v2  :: "(32)Word.word "


\<comment> \<open>\<open>val riscv_f32Div : mword ty3 -> mword ty32 -> mword ty32 -> M (mword ty5 * mword ty32)\<close>\<close>

definition riscv_f32Div  :: \<open>(3)Word.word \<Rightarrow>(32)Word.word \<Rightarrow>(32)Word.word \<Rightarrow>((register_value),((5)Word.word*(32)Word.word),(exception))monad \<close>  where 
     \<open> riscv_f32Div rm v1 v2 = (
   (let (_ :: unit) = (softfloat_f32_div rm v1 v2) in
   (read_reg float_fflags_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (read_reg float_result_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
   return ((subrange_vec_dec w__0 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word),
           (subrange_vec_dec w__1 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))))))))\<close> 
  for  rm  :: "(3)Word.word " 
  and  v1  :: "(32)Word.word " 
  and  v2  :: "(32)Word.word "


\<comment> \<open>\<open>val riscv_f64Add : mword ty3 -> mword ty64 -> mword ty64 -> M (mword ty5 * mword ty64)\<close>\<close>

definition riscv_f64Add  :: \<open>(3)Word.word \<Rightarrow>(64)Word.word \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),((5)Word.word*(64)Word.word),(exception))monad \<close>  where 
     \<open> riscv_f64Add rm v1 v2 = (
   (let (_ :: unit) = (softfloat_f64_add rm v1 v2) in
   (read_reg float_fflags_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (read_reg float_result_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
   return ((subrange_vec_dec w__0 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word), w__1)))))))\<close> 
  for  rm  :: "(3)Word.word " 
  and  v1  :: "(64)Word.word " 
  and  v2  :: "(64)Word.word "


\<comment> \<open>\<open>val riscv_f64Sub : mword ty3 -> mword ty64 -> mword ty64 -> M (mword ty5 * mword ty64)\<close>\<close>

definition riscv_f64Sub  :: \<open>(3)Word.word \<Rightarrow>(64)Word.word \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),((5)Word.word*(64)Word.word),(exception))monad \<close>  where 
     \<open> riscv_f64Sub rm v1 v2 = (
   (let (_ :: unit) = (softfloat_f64_sub rm v1 v2) in
   (read_reg float_fflags_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (read_reg float_result_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
   return ((subrange_vec_dec w__0 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word), w__1)))))))\<close> 
  for  rm  :: "(3)Word.word " 
  and  v1  :: "(64)Word.word " 
  and  v2  :: "(64)Word.word "


\<comment> \<open>\<open>val riscv_f64Mul : mword ty3 -> mword ty64 -> mword ty64 -> M (mword ty5 * mword ty64)\<close>\<close>

definition riscv_f64Mul  :: \<open>(3)Word.word \<Rightarrow>(64)Word.word \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),((5)Word.word*(64)Word.word),(exception))monad \<close>  where 
     \<open> riscv_f64Mul rm v1 v2 = (
   (let (_ :: unit) = (softfloat_f64_mul rm v1 v2) in
   (read_reg float_fflags_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (read_reg float_result_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
   return ((subrange_vec_dec w__0 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word), w__1)))))))\<close> 
  for  rm  :: "(3)Word.word " 
  and  v1  :: "(64)Word.word " 
  and  v2  :: "(64)Word.word "


\<comment> \<open>\<open>val riscv_f64Div : mword ty3 -> mword ty64 -> mword ty64 -> M (mword ty5 * mword ty64)\<close>\<close>

definition riscv_f64Div  :: \<open>(3)Word.word \<Rightarrow>(64)Word.word \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),((5)Word.word*(64)Word.word),(exception))monad \<close>  where 
     \<open> riscv_f64Div rm v1 v2 = (
   (let (_ :: unit) = (softfloat_f64_div rm v1 v2) in
   (read_reg float_fflags_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (read_reg float_result_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
   return ((subrange_vec_dec w__0 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word), w__1)))))))\<close> 
  for  rm  :: "(3)Word.word " 
  and  v1  :: "(64)Word.word " 
  and  v2  :: "(64)Word.word "


\<comment> \<open>\<open>val riscv_f16MulAdd : mword ty3 -> mword ty16 -> mword ty16 -> mword ty16 -> M (mword ty5 * mword ty16)\<close>\<close>

definition riscv_f16MulAdd  :: \<open>(3)Word.word \<Rightarrow>(16)Word.word \<Rightarrow>(16)Word.word \<Rightarrow>(16)Word.word \<Rightarrow>((register_value),((5)Word.word*(16)Word.word),(exception))monad \<close>  where 
     \<open> riscv_f16MulAdd rm v1 v2 v3 = (
   (let (_ :: unit) = (softfloat_f16_muladd rm v1 v2 v3) in
   (read_reg float_fflags_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (read_reg float_result_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
   return ((subrange_vec_dec w__0 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word),
           (subrange_vec_dec w__1 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))))))))\<close> 
  for  rm  :: "(3)Word.word " 
  and  v1  :: "(16)Word.word " 
  and  v2  :: "(16)Word.word " 
  and  v3  :: "(16)Word.word "


\<comment> \<open>\<open>val riscv_f32MulAdd : mword ty3 -> mword ty32 -> mword ty32 -> mword ty32 -> M (mword ty5 * mword ty32)\<close>\<close>

definition riscv_f32MulAdd  :: \<open>(3)Word.word \<Rightarrow>(32)Word.word \<Rightarrow>(32)Word.word \<Rightarrow>(32)Word.word \<Rightarrow>((register_value),((5)Word.word*(32)Word.word),(exception))monad \<close>  where 
     \<open> riscv_f32MulAdd rm v1 v2 v3 = (
   (let (_ :: unit) = (softfloat_f32_muladd rm v1 v2 v3) in
   (read_reg float_fflags_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (read_reg float_result_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
   return ((subrange_vec_dec w__0 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word),
           (subrange_vec_dec w__1 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))))))))\<close> 
  for  rm  :: "(3)Word.word " 
  and  v1  :: "(32)Word.word " 
  and  v2  :: "(32)Word.word " 
  and  v3  :: "(32)Word.word "


\<comment> \<open>\<open>val riscv_f64MulAdd : mword ty3 -> mword ty64 -> mword ty64 -> mword ty64 -> M (mword ty5 * mword ty64)\<close>\<close>

definition riscv_f64MulAdd  :: \<open>(3)Word.word \<Rightarrow>(64)Word.word \<Rightarrow>(64)Word.word \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),((5)Word.word*(64)Word.word),(exception))monad \<close>  where 
     \<open> riscv_f64MulAdd rm v1 v2 v3 = (
   (let (_ :: unit) = (softfloat_f64_muladd rm v1 v2 v3) in
   (read_reg float_fflags_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (read_reg float_result_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
   return ((subrange_vec_dec w__0 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word), w__1)))))))\<close> 
  for  rm  :: "(3)Word.word " 
  and  v1  :: "(64)Word.word " 
  and  v2  :: "(64)Word.word " 
  and  v3  :: "(64)Word.word "


\<comment> \<open>\<open>val riscv_f16Sqrt : mword ty3 -> mword ty16 -> M (mword ty5 * mword ty16)\<close>\<close>

definition riscv_f16Sqrt  :: \<open>(3)Word.word \<Rightarrow>(16)Word.word \<Rightarrow>((register_value),((5)Word.word*(16)Word.word),(exception))monad \<close>  where 
     \<open> riscv_f16Sqrt rm v = (
   (let (_ :: unit) = (softfloat_f16_sqrt rm v) in
   (read_reg float_fflags_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (read_reg float_result_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
   return ((subrange_vec_dec w__0 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word),
           (subrange_vec_dec w__1 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))))))))\<close> 
  for  rm  :: "(3)Word.word " 
  and  v  :: "(16)Word.word "


\<comment> \<open>\<open>val riscv_f32Sqrt : mword ty3 -> mword ty32 -> M (mword ty5 * mword ty32)\<close>\<close>

definition riscv_f32Sqrt  :: \<open>(3)Word.word \<Rightarrow>(32)Word.word \<Rightarrow>((register_value),((5)Word.word*(32)Word.word),(exception))monad \<close>  where 
     \<open> riscv_f32Sqrt rm v = (
   (let (_ :: unit) = (softfloat_f32_sqrt rm v) in
   (read_reg float_fflags_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (read_reg float_result_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
   return ((subrange_vec_dec w__0 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word),
           (subrange_vec_dec w__1 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))))))))\<close> 
  for  rm  :: "(3)Word.word " 
  and  v  :: "(32)Word.word "


\<comment> \<open>\<open>val riscv_f64Sqrt : mword ty3 -> mword ty64 -> M (mword ty5 * mword ty64)\<close>\<close>

definition riscv_f64Sqrt  :: \<open>(3)Word.word \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),((5)Word.word*(64)Word.word),(exception))monad \<close>  where 
     \<open> riscv_f64Sqrt rm v = (
   (let (_ :: unit) = (softfloat_f64_sqrt rm v) in
   (read_reg float_fflags_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (read_reg float_result_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
   return ((subrange_vec_dec w__0 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word), w__1)))))))\<close> 
  for  rm  :: "(3)Word.word " 
  and  v  :: "(64)Word.word "


\<comment> \<open>\<open>val riscv_f16ToI32 : mword ty3 -> mword ty16 -> M (mword ty5 * mword ty32)\<close>\<close>

definition riscv_f16ToI32  :: \<open>(3)Word.word \<Rightarrow>(16)Word.word \<Rightarrow>((register_value),((5)Word.word*(32)Word.word),(exception))monad \<close>  where 
     \<open> riscv_f16ToI32 rm v = (
   (let (_ :: unit) = (softfloat_f16_to_i32 rm v) in
   (read_reg float_fflags_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (read_reg float_result_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
   return ((subrange_vec_dec w__0 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word),
           (subrange_vec_dec w__1 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))))))))\<close> 
  for  rm  :: "(3)Word.word " 
  and  v  :: "(16)Word.word "


\<comment> \<open>\<open>val riscv_f16ToUi32 : mword ty3 -> mword ty16 -> M (mword ty5 * mword ty32)\<close>\<close>

definition riscv_f16ToUi32  :: \<open>(3)Word.word \<Rightarrow>(16)Word.word \<Rightarrow>((register_value),((5)Word.word*(32)Word.word),(exception))monad \<close>  where 
     \<open> riscv_f16ToUi32 rm v = (
   (let (_ :: unit) = (softfloat_f16_to_ui32 rm v) in
   (read_reg float_fflags_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (read_reg float_result_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
   return ((subrange_vec_dec w__0 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word),
           (subrange_vec_dec w__1 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))))))))\<close> 
  for  rm  :: "(3)Word.word " 
  and  v  :: "(16)Word.word "


\<comment> \<open>\<open>val riscv_i32ToF16 : mword ty3 -> mword ty32 -> M (mword ty5 * mword ty16)\<close>\<close>

definition riscv_i32ToF16  :: \<open>(3)Word.word \<Rightarrow>(32)Word.word \<Rightarrow>((register_value),((5)Word.word*(16)Word.word),(exception))monad \<close>  where 
     \<open> riscv_i32ToF16 rm v = (
   (let (_ :: unit) = (softfloat_i32_to_f16 rm v) in
   (read_reg float_fflags_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (read_reg float_result_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
   return ((subrange_vec_dec w__0 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word),
           (subrange_vec_dec w__1 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))))))))\<close> 
  for  rm  :: "(3)Word.word " 
  and  v  :: "(32)Word.word "


\<comment> \<open>\<open>val riscv_ui32ToF16 : mword ty3 -> mword ty32 -> M (mword ty5 * mword ty16)\<close>\<close>

definition riscv_ui32ToF16  :: \<open>(3)Word.word \<Rightarrow>(32)Word.word \<Rightarrow>((register_value),((5)Word.word*(16)Word.word),(exception))monad \<close>  where 
     \<open> riscv_ui32ToF16 rm v = (
   (let (_ :: unit) = (softfloat_ui32_to_f16 rm v) in
   (read_reg float_fflags_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (read_reg float_result_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
   return ((subrange_vec_dec w__0 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word),
           (subrange_vec_dec w__1 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))))))))\<close> 
  for  rm  :: "(3)Word.word " 
  and  v  :: "(32)Word.word "


\<comment> \<open>\<open>val riscv_f16ToI64 : mword ty3 -> mword ty16 -> M (mword ty5 * mword ty64)\<close>\<close>

definition riscv_f16ToI64  :: \<open>(3)Word.word \<Rightarrow>(16)Word.word \<Rightarrow>((register_value),((5)Word.word*(64)Word.word),(exception))monad \<close>  where 
     \<open> riscv_f16ToI64 rm v = (
   (let (_ :: unit) = (softfloat_f16_to_i64 rm v) in
   (read_reg float_fflags_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (read_reg float_result_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
   return ((subrange_vec_dec w__0 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word), w__1)))))))\<close> 
  for  rm  :: "(3)Word.word " 
  and  v  :: "(16)Word.word "


\<comment> \<open>\<open>val riscv_f16ToUi64 : mword ty3 -> mword ty16 -> M (mword ty5 * mword ty64)\<close>\<close>

definition riscv_f16ToUi64  :: \<open>(3)Word.word \<Rightarrow>(16)Word.word \<Rightarrow>((register_value),((5)Word.word*(64)Word.word),(exception))monad \<close>  where 
     \<open> riscv_f16ToUi64 rm v = (
   (let (_ :: unit) = (softfloat_f16_to_ui64 rm v) in
   (read_reg float_fflags_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (read_reg float_result_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
   return ((subrange_vec_dec w__0 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word), w__1)))))))\<close> 
  for  rm  :: "(3)Word.word " 
  and  v  :: "(16)Word.word "


\<comment> \<open>\<open>val riscv_i64ToF16 : mword ty3 -> mword ty64 -> M (mword ty5 * mword ty16)\<close>\<close>

definition riscv_i64ToF16  :: \<open>(3)Word.word \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),((5)Word.word*(16)Word.word),(exception))monad \<close>  where 
     \<open> riscv_i64ToF16 rm v = (
   (let (_ :: unit) = (softfloat_i64_to_f16 rm v) in
   (read_reg float_fflags_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (read_reg float_result_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
   return ((subrange_vec_dec w__0 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word),
           (subrange_vec_dec w__1 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))))))))\<close> 
  for  rm  :: "(3)Word.word " 
  and  v  :: "(64)Word.word "


\<comment> \<open>\<open>val riscv_ui64ToF16 : mword ty3 -> mword ty64 -> M (mword ty5 * mword ty16)\<close>\<close>

definition riscv_ui64ToF16  :: \<open>(3)Word.word \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),((5)Word.word*(16)Word.word),(exception))monad \<close>  where 
     \<open> riscv_ui64ToF16 rm v = (
   (let (_ :: unit) = (softfloat_ui64_to_f16 rm v) in
   (read_reg float_fflags_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (read_reg float_result_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
   return ((subrange_vec_dec w__0 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word),
           (subrange_vec_dec w__1 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))))))))\<close> 
  for  rm  :: "(3)Word.word " 
  and  v  :: "(64)Word.word "


\<comment> \<open>\<open>val riscv_f32ToI32 : mword ty3 -> mword ty32 -> M (mword ty5 * mword ty32)\<close>\<close>

definition riscv_f32ToI32  :: \<open>(3)Word.word \<Rightarrow>(32)Word.word \<Rightarrow>((register_value),((5)Word.word*(32)Word.word),(exception))monad \<close>  where 
     \<open> riscv_f32ToI32 rm v = (
   (let (_ :: unit) = (softfloat_f32_to_i32 rm v) in
   (read_reg float_fflags_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (read_reg float_result_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
   return ((subrange_vec_dec w__0 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word),
           (subrange_vec_dec w__1 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))))))))\<close> 
  for  rm  :: "(3)Word.word " 
  and  v  :: "(32)Word.word "


\<comment> \<open>\<open>val riscv_f32ToUi32 : mword ty3 -> mword ty32 -> M (mword ty5 * mword ty32)\<close>\<close>

definition riscv_f32ToUi32  :: \<open>(3)Word.word \<Rightarrow>(32)Word.word \<Rightarrow>((register_value),((5)Word.word*(32)Word.word),(exception))monad \<close>  where 
     \<open> riscv_f32ToUi32 rm v = (
   (let (_ :: unit) = (softfloat_f32_to_ui32 rm v) in
   (read_reg float_fflags_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (read_reg float_result_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
   return ((subrange_vec_dec w__0 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word),
           (subrange_vec_dec w__1 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))))))))\<close> 
  for  rm  :: "(3)Word.word " 
  and  v  :: "(32)Word.word "


\<comment> \<open>\<open>val riscv_i32ToF32 : mword ty3 -> mword ty32 -> M (mword ty5 * mword ty32)\<close>\<close>

definition riscv_i32ToF32  :: \<open>(3)Word.word \<Rightarrow>(32)Word.word \<Rightarrow>((register_value),((5)Word.word*(32)Word.word),(exception))monad \<close>  where 
     \<open> riscv_i32ToF32 rm v = (
   (let (_ :: unit) = (softfloat_i32_to_f32 rm v) in
   (read_reg float_fflags_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (read_reg float_result_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
   return ((subrange_vec_dec w__0 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word),
           (subrange_vec_dec w__1 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))))))))\<close> 
  for  rm  :: "(3)Word.word " 
  and  v  :: "(32)Word.word "


\<comment> \<open>\<open>val riscv_ui32ToF32 : mword ty3 -> mword ty32 -> M (mword ty5 * mword ty32)\<close>\<close>

definition riscv_ui32ToF32  :: \<open>(3)Word.word \<Rightarrow>(32)Word.word \<Rightarrow>((register_value),((5)Word.word*(32)Word.word),(exception))monad \<close>  where 
     \<open> riscv_ui32ToF32 rm v = (
   (let (_ :: unit) = (softfloat_ui32_to_f32 rm v) in
   (read_reg float_fflags_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (read_reg float_result_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
   return ((subrange_vec_dec w__0 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word),
           (subrange_vec_dec w__1 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))))))))\<close> 
  for  rm  :: "(3)Word.word " 
  and  v  :: "(32)Word.word "


\<comment> \<open>\<open>val riscv_f32ToI64 : mword ty3 -> mword ty32 -> M (mword ty5 * mword ty64)\<close>\<close>

definition riscv_f32ToI64  :: \<open>(3)Word.word \<Rightarrow>(32)Word.word \<Rightarrow>((register_value),((5)Word.word*(64)Word.word),(exception))monad \<close>  where 
     \<open> riscv_f32ToI64 rm v = (
   (let (_ :: unit) = (softfloat_f32_to_i64 rm v) in
   (read_reg float_fflags_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (read_reg float_result_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
   return ((subrange_vec_dec w__0 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word), w__1)))))))\<close> 
  for  rm  :: "(3)Word.word " 
  and  v  :: "(32)Word.word "


\<comment> \<open>\<open>val riscv_f32ToUi64 : mword ty3 -> mword ty32 -> M (mword ty5 * mword ty64)\<close>\<close>

definition riscv_f32ToUi64  :: \<open>(3)Word.word \<Rightarrow>(32)Word.word \<Rightarrow>((register_value),((5)Word.word*(64)Word.word),(exception))monad \<close>  where 
     \<open> riscv_f32ToUi64 rm v = (
   (let (_ :: unit) = (softfloat_f32_to_ui64 rm v) in
   (read_reg float_fflags_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (read_reg float_result_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
   return ((subrange_vec_dec w__0 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word), w__1)))))))\<close> 
  for  rm  :: "(3)Word.word " 
  and  v  :: "(32)Word.word "


\<comment> \<open>\<open>val riscv_i64ToF32 : mword ty3 -> mword ty64 -> M (mword ty5 * mword ty32)\<close>\<close>

definition riscv_i64ToF32  :: \<open>(3)Word.word \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),((5)Word.word*(32)Word.word),(exception))monad \<close>  where 
     \<open> riscv_i64ToF32 rm v = (
   (let (_ :: unit) = (softfloat_i64_to_f32 rm v) in
   (read_reg float_fflags_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (read_reg float_result_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
   return ((subrange_vec_dec w__0 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word),
           (subrange_vec_dec w__1 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))))))))\<close> 
  for  rm  :: "(3)Word.word " 
  and  v  :: "(64)Word.word "


\<comment> \<open>\<open>val riscv_ui64ToF32 : mword ty3 -> mword ty64 -> M (mword ty5 * mword ty32)\<close>\<close>

definition riscv_ui64ToF32  :: \<open>(3)Word.word \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),((5)Word.word*(32)Word.word),(exception))monad \<close>  where 
     \<open> riscv_ui64ToF32 rm v = (
   (let (_ :: unit) = (softfloat_ui64_to_f32 rm v) in
   (read_reg float_fflags_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (read_reg float_result_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
   return ((subrange_vec_dec w__0 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word),
           (subrange_vec_dec w__1 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))))))))\<close> 
  for  rm  :: "(3)Word.word " 
  and  v  :: "(64)Word.word "


\<comment> \<open>\<open>val riscv_f64ToI32 : mword ty3 -> mword ty64 -> M (mword ty5 * mword ty32)\<close>\<close>

definition riscv_f64ToI32  :: \<open>(3)Word.word \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),((5)Word.word*(32)Word.word),(exception))monad \<close>  where 
     \<open> riscv_f64ToI32 rm v = (
   (let (_ :: unit) = (softfloat_f64_to_i32 rm v) in
   (read_reg float_fflags_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (read_reg float_result_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
   return ((subrange_vec_dec w__0 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word),
           (subrange_vec_dec w__1 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))))))))\<close> 
  for  rm  :: "(3)Word.word " 
  and  v  :: "(64)Word.word "


\<comment> \<open>\<open>val riscv_f64ToUi32 : mword ty3 -> mword ty64 -> M (mword ty5 * mword ty32)\<close>\<close>

definition riscv_f64ToUi32  :: \<open>(3)Word.word \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),((5)Word.word*(32)Word.word),(exception))monad \<close>  where 
     \<open> riscv_f64ToUi32 rm v = (
   (let (_ :: unit) = (softfloat_f64_to_ui32 rm v) in
   (read_reg float_fflags_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (read_reg float_result_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
   return ((subrange_vec_dec w__0 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word),
           (subrange_vec_dec w__1 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))))))))\<close> 
  for  rm  :: "(3)Word.word " 
  and  v  :: "(64)Word.word "


\<comment> \<open>\<open>val riscv_i32ToF64 : mword ty3 -> mword ty32 -> M (mword ty5 * mword ty64)\<close>\<close>

definition riscv_i32ToF64  :: \<open>(3)Word.word \<Rightarrow>(32)Word.word \<Rightarrow>((register_value),((5)Word.word*(64)Word.word),(exception))monad \<close>  where 
     \<open> riscv_i32ToF64 rm v = (
   (let (_ :: unit) = (softfloat_i32_to_f64 rm v) in
   (read_reg float_fflags_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (read_reg float_result_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
   return ((subrange_vec_dec w__0 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word), w__1)))))))\<close> 
  for  rm  :: "(3)Word.word " 
  and  v  :: "(32)Word.word "


\<comment> \<open>\<open>val riscv_ui32ToF64 : mword ty3 -> mword ty32 -> M (mword ty5 * mword ty64)\<close>\<close>

definition riscv_ui32ToF64  :: \<open>(3)Word.word \<Rightarrow>(32)Word.word \<Rightarrow>((register_value),((5)Word.word*(64)Word.word),(exception))monad \<close>  where 
     \<open> riscv_ui32ToF64 rm v = (
   (let (_ :: unit) = (softfloat_ui32_to_f64 rm v) in
   (read_reg float_fflags_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (read_reg float_result_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
   return ((subrange_vec_dec w__0 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word), w__1)))))))\<close> 
  for  rm  :: "(3)Word.word " 
  and  v  :: "(32)Word.word "


\<comment> \<open>\<open>val riscv_f64ToI64 : mword ty3 -> mword ty64 -> M (mword ty5 * mword ty64)\<close>\<close>

definition riscv_f64ToI64  :: \<open>(3)Word.word \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),((5)Word.word*(64)Word.word),(exception))monad \<close>  where 
     \<open> riscv_f64ToI64 rm v = (
   (let (_ :: unit) = (softfloat_f64_to_i64 rm v) in
   (read_reg float_fflags_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (read_reg float_result_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
   return ((subrange_vec_dec w__0 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word), w__1)))))))\<close> 
  for  rm  :: "(3)Word.word " 
  and  v  :: "(64)Word.word "


\<comment> \<open>\<open>val riscv_f64ToUi64 : mword ty3 -> mword ty64 -> M (mword ty5 * mword ty64)\<close>\<close>

definition riscv_f64ToUi64  :: \<open>(3)Word.word \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),((5)Word.word*(64)Word.word),(exception))monad \<close>  where 
     \<open> riscv_f64ToUi64 rm v = (
   (let (_ :: unit) = (softfloat_f64_to_ui64 rm v) in
   (read_reg float_fflags_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (read_reg float_result_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
   return ((subrange_vec_dec w__0 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word), w__1)))))))\<close> 
  for  rm  :: "(3)Word.word " 
  and  v  :: "(64)Word.word "


\<comment> \<open>\<open>val riscv_i64ToF64 : mword ty3 -> mword ty64 -> M (mword ty5 * mword ty64)\<close>\<close>

definition riscv_i64ToF64  :: \<open>(3)Word.word \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),((5)Word.word*(64)Word.word),(exception))monad \<close>  where 
     \<open> riscv_i64ToF64 rm v = (
   (let (_ :: unit) = (softfloat_i64_to_f64 rm v) in
   (read_reg float_fflags_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (read_reg float_result_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
   return ((subrange_vec_dec w__0 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word), w__1)))))))\<close> 
  for  rm  :: "(3)Word.word " 
  and  v  :: "(64)Word.word "


\<comment> \<open>\<open>val riscv_ui64ToF64 : mword ty3 -> mword ty64 -> M (mword ty5 * mword ty64)\<close>\<close>

definition riscv_ui64ToF64  :: \<open>(3)Word.word \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),((5)Word.word*(64)Word.word),(exception))monad \<close>  where 
     \<open> riscv_ui64ToF64 rm v = (
   (let (_ :: unit) = (softfloat_ui64_to_f64 rm v) in
   (read_reg float_fflags_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (read_reg float_result_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
   return ((subrange_vec_dec w__0 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word), w__1)))))))\<close> 
  for  rm  :: "(3)Word.word " 
  and  v  :: "(64)Word.word "


\<comment> \<open>\<open>val riscv_f16ToF32 : mword ty3 -> mword ty16 -> M (mword ty5 * mword ty32)\<close>\<close>

definition riscv_f16ToF32  :: \<open>(3)Word.word \<Rightarrow>(16)Word.word \<Rightarrow>((register_value),((5)Word.word*(32)Word.word),(exception))monad \<close>  where 
     \<open> riscv_f16ToF32 rm v = (
   (let (_ :: unit) = (softfloat_f16_to_f32 rm v) in
   (read_reg float_fflags_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (read_reg float_result_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
   return ((subrange_vec_dec w__0 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word),
           (subrange_vec_dec w__1 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))))))))\<close> 
  for  rm  :: "(3)Word.word " 
  and  v  :: "(16)Word.word "


\<comment> \<open>\<open>val riscv_f16ToF64 : mword ty3 -> mword ty16 -> M (mword ty5 * mword ty64)\<close>\<close>

definition riscv_f16ToF64  :: \<open>(3)Word.word \<Rightarrow>(16)Word.word \<Rightarrow>((register_value),((5)Word.word*(64)Word.word),(exception))monad \<close>  where 
     \<open> riscv_f16ToF64 rm v = (
   (let (_ :: unit) = (softfloat_f16_to_f64 rm v) in
   (read_reg float_fflags_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (read_reg float_result_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
   return ((subrange_vec_dec w__0 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word), w__1)))))))\<close> 
  for  rm  :: "(3)Word.word " 
  and  v  :: "(16)Word.word "


\<comment> \<open>\<open>val riscv_f32ToF64 : mword ty3 -> mword ty32 -> M (mword ty5 * mword ty64)\<close>\<close>

definition riscv_f32ToF64  :: \<open>(3)Word.word \<Rightarrow>(32)Word.word \<Rightarrow>((register_value),((5)Word.word*(64)Word.word),(exception))monad \<close>  where 
     \<open> riscv_f32ToF64 rm v = (
   (let (_ :: unit) = (softfloat_f32_to_f64 rm v) in
   (read_reg float_fflags_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (read_reg float_result_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
   return ((subrange_vec_dec w__0 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word), w__1)))))))\<close> 
  for  rm  :: "(3)Word.word " 
  and  v  :: "(32)Word.word "


\<comment> \<open>\<open>val riscv_f32ToF16 : mword ty3 -> mword ty32 -> M (mword ty5 * mword ty16)\<close>\<close>

definition riscv_f32ToF16  :: \<open>(3)Word.word \<Rightarrow>(32)Word.word \<Rightarrow>((register_value),((5)Word.word*(16)Word.word),(exception))monad \<close>  where 
     \<open> riscv_f32ToF16 rm v = (
   (let (_ :: unit) = (softfloat_f32_to_f16 rm v) in
   (read_reg float_fflags_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (read_reg float_result_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
   return ((subrange_vec_dec w__0 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word),
           (subrange_vec_dec w__1 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))))))))\<close> 
  for  rm  :: "(3)Word.word " 
  and  v  :: "(32)Word.word "


\<comment> \<open>\<open>val riscv_f64ToF16 : mword ty3 -> mword ty64 -> M (mword ty5 * mword ty16)\<close>\<close>

definition riscv_f64ToF16  :: \<open>(3)Word.word \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),((5)Word.word*(16)Word.word),(exception))monad \<close>  where 
     \<open> riscv_f64ToF16 rm v = (
   (let (_ :: unit) = (softfloat_f64_to_f16 rm v) in
   (read_reg float_fflags_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (read_reg float_result_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
   return ((subrange_vec_dec w__0 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word),
           (subrange_vec_dec w__1 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))))))))\<close> 
  for  rm  :: "(3)Word.word " 
  and  v  :: "(64)Word.word "


\<comment> \<open>\<open>val riscv_f64ToF32 : mword ty3 -> mword ty64 -> M (mword ty5 * mword ty32)\<close>\<close>

definition riscv_f64ToF32  :: \<open>(3)Word.word \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),((5)Word.word*(32)Word.word),(exception))monad \<close>  where 
     \<open> riscv_f64ToF32 rm v = (
   (let (_ :: unit) = (softfloat_f64_to_f32 rm v) in
   (read_reg float_fflags_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (read_reg float_result_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
   return ((subrange_vec_dec w__0 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word),
           (subrange_vec_dec w__1 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))))))))\<close> 
  for  rm  :: "(3)Word.word " 
  and  v  :: "(64)Word.word "


\<comment> \<open>\<open>val riscv_f16Lt : mword ty16 -> mword ty16 -> M (mword ty5 * mword ty16)\<close>\<close>

definition riscv_f16Lt  :: \<open>(16)Word.word \<Rightarrow>(16)Word.word \<Rightarrow>((register_value),((5)Word.word*(16)Word.word),(exception))monad \<close>  where 
     \<open> riscv_f16Lt v1 v2 = (
   (let (_ :: unit) = (softfloat_f16_lt v1 v2) in
   (read_reg float_fflags_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (read_reg float_result_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
   return ((subrange_vec_dec w__0 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word),
           (subrange_vec_dec w__1 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))))))))\<close> 
  for  v1  :: "(16)Word.word " 
  and  v2  :: "(16)Word.word "


\<comment> \<open>\<open>val riscv_f16Le : mword ty16 -> mword ty16 -> M (mword ty5 * mword ty16)\<close>\<close>

definition riscv_f16Le  :: \<open>(16)Word.word \<Rightarrow>(16)Word.word \<Rightarrow>((register_value),((5)Word.word*(16)Word.word),(exception))monad \<close>  where 
     \<open> riscv_f16Le v1 v2 = (
   (let (_ :: unit) = (softfloat_f16_le v1 v2) in
   (read_reg float_fflags_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (read_reg float_result_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
   return ((subrange_vec_dec w__0 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word),
           (subrange_vec_dec w__1 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))))))))\<close> 
  for  v1  :: "(16)Word.word " 
  and  v2  :: "(16)Word.word "


\<comment> \<open>\<open>val riscv_f16Eq : mword ty16 -> mword ty16 -> M (mword ty5 * mword ty16)\<close>\<close>

definition riscv_f16Eq  :: \<open>(16)Word.word \<Rightarrow>(16)Word.word \<Rightarrow>((register_value),((5)Word.word*(16)Word.word),(exception))monad \<close>  where 
     \<open> riscv_f16Eq v1 v2 = (
   (let (_ :: unit) = (softfloat_f16_eq v1 v2) in
   (read_reg float_fflags_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (read_reg float_result_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
   return ((subrange_vec_dec w__0 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word),
           (subrange_vec_dec w__1 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))))))))\<close> 
  for  v1  :: "(16)Word.word " 
  and  v2  :: "(16)Word.word "


\<comment> \<open>\<open>val riscv_f32Lt : mword ty32 -> mword ty32 -> M (mword ty5 * mword ty32)\<close>\<close>

definition riscv_f32Lt  :: \<open>(32)Word.word \<Rightarrow>(32)Word.word \<Rightarrow>((register_value),((5)Word.word*(32)Word.word),(exception))monad \<close>  where 
     \<open> riscv_f32Lt v1 v2 = (
   (let (_ :: unit) = (softfloat_f32_lt v1 v2) in
   (read_reg float_fflags_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (read_reg float_result_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
   return ((subrange_vec_dec w__0 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word),
           (subrange_vec_dec w__1 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))))))))\<close> 
  for  v1  :: "(32)Word.word " 
  and  v2  :: "(32)Word.word "


\<comment> \<open>\<open>val riscv_f32Le : mword ty32 -> mword ty32 -> M (mword ty5 * mword ty32)\<close>\<close>

definition riscv_f32Le  :: \<open>(32)Word.word \<Rightarrow>(32)Word.word \<Rightarrow>((register_value),((5)Word.word*(32)Word.word),(exception))monad \<close>  where 
     \<open> riscv_f32Le v1 v2 = (
   (let (_ :: unit) = (softfloat_f32_le v1 v2) in
   (read_reg float_fflags_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (read_reg float_result_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
   return ((subrange_vec_dec w__0 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word),
           (subrange_vec_dec w__1 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))))))))\<close> 
  for  v1  :: "(32)Word.word " 
  and  v2  :: "(32)Word.word "


\<comment> \<open>\<open>val riscv_f32Eq : mword ty32 -> mword ty32 -> M (mword ty5 * mword ty32)\<close>\<close>

definition riscv_f32Eq  :: \<open>(32)Word.word \<Rightarrow>(32)Word.word \<Rightarrow>((register_value),((5)Word.word*(32)Word.word),(exception))monad \<close>  where 
     \<open> riscv_f32Eq v1 v2 = (
   (let (_ :: unit) = (softfloat_f32_eq v1 v2) in
   (read_reg float_fflags_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (read_reg float_result_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
   return ((subrange_vec_dec w__0 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word),
           (subrange_vec_dec w__1 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))))))))\<close> 
  for  v1  :: "(32)Word.word " 
  and  v2  :: "(32)Word.word "


\<comment> \<open>\<open>val riscv_f64Lt : mword ty64 -> mword ty64 -> M (mword ty5 * mword ty64)\<close>\<close>

definition riscv_f64Lt  :: \<open>(64)Word.word \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),((5)Word.word*(64)Word.word),(exception))monad \<close>  where 
     \<open> riscv_f64Lt v1 v2 = (
   (let (_ :: unit) = (softfloat_f64_lt v1 v2) in
   (read_reg float_fflags_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (read_reg float_result_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
   return ((subrange_vec_dec w__0 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word), w__1)))))))\<close> 
  for  v1  :: "(64)Word.word " 
  and  v2  :: "(64)Word.word "


\<comment> \<open>\<open>val riscv_f64Le : mword ty64 -> mword ty64 -> M (mword ty5 * mword ty64)\<close>\<close>

definition riscv_f64Le  :: \<open>(64)Word.word \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),((5)Word.word*(64)Word.word),(exception))monad \<close>  where 
     \<open> riscv_f64Le v1 v2 = (
   (let (_ :: unit) = (softfloat_f64_le v1 v2) in
   (read_reg float_fflags_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (read_reg float_result_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
   return ((subrange_vec_dec w__0 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word), w__1)))))))\<close> 
  for  v1  :: "(64)Word.word " 
  and  v2  :: "(64)Word.word "


\<comment> \<open>\<open>val riscv_f64Eq : mword ty64 -> mword ty64 -> M (mword ty5 * mword ty64)\<close>\<close>

definition riscv_f64Eq  :: \<open>(64)Word.word \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),((5)Word.word*(64)Word.word),(exception))monad \<close>  where 
     \<open> riscv_f64Eq v1 v2 = (
   (let (_ :: unit) = (softfloat_f64_eq v1 v2) in
   (read_reg float_fflags_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (read_reg float_result_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
   return ((subrange_vec_dec w__0 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word), w__1)))))))\<close> 
  for  v1  :: "(64)Word.word " 
  and  v2  :: "(64)Word.word "


\<comment> \<open>\<open>val dirty_fd_context : unit -> M unit\<close>\<close>

definition dirty_fd_context  :: \<open> unit \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> dirty_fd_context _ = (
   set_Mstatus_FS mstatus_ref ((extStatus_to_bits Dirty  ::  2 Word.word)) \<then>
   set_Mstatus_SD mstatus_ref ( 0b1 ::  1 Word.word))\<close>


\<comment> \<open>\<open>val rF : integer -> M (mword ty64)\<close>\<close>

definition rF  :: \<open> int \<Rightarrow>((register_value),((64)Word.word),(exception))monad \<close>  where 
     \<open> rF r = (
   (let l__42 = r in
   (if (((l__42 = (( 0 :: int)::ii)))) then (read_reg f0_ref  :: ( 64 Word.word) M)
    else if (((l__42 = (( 1 :: int)::ii)))) then (read_reg f1_ref  :: ( 64 Word.word) M)
    else if (((l__42 = (( 2 :: int)::ii)))) then (read_reg f2_ref  :: ( 64 Word.word) M)
    else if (((l__42 = (( 3 :: int)::ii)))) then (read_reg f3_ref  :: ( 64 Word.word) M)
    else if (((l__42 = (( 4 :: int)::ii)))) then (read_reg f4_ref  :: ( 64 Word.word) M)
    else if (((l__42 = (( 5 :: int)::ii)))) then (read_reg f5_ref  :: ( 64 Word.word) M)
    else if (((l__42 = (( 6 :: int)::ii)))) then (read_reg f6_ref  :: ( 64 Word.word) M)
    else if (((l__42 = (( 7 :: int)::ii)))) then (read_reg f7_ref  :: ( 64 Word.word) M)
    else if (((l__42 = (( 8 :: int)::ii)))) then (read_reg f8_ref  :: ( 64 Word.word) M)
    else if (((l__42 = (( 9 :: int)::ii)))) then (read_reg f9_ref  :: ( 64 Word.word) M)
    else if (((l__42 = (( 10 :: int)::ii)))) then (read_reg f10_ref  :: ( 64 Word.word) M)
    else if (((l__42 = (( 11 :: int)::ii)))) then (read_reg f11_ref  :: ( 64 Word.word) M)
    else if (((l__42 = (( 12 :: int)::ii)))) then (read_reg f12_ref  :: ( 64 Word.word) M)
    else if (((l__42 = (( 13 :: int)::ii)))) then (read_reg f13_ref  :: ( 64 Word.word) M)
    else if (((l__42 = (( 14 :: int)::ii)))) then (read_reg f14_ref  :: ( 64 Word.word) M)
    else if (((l__42 = (( 15 :: int)::ii)))) then (read_reg f15_ref  :: ( 64 Word.word) M)
    else if (((l__42 = (( 16 :: int)::ii)))) then (read_reg f16_ref  :: ( 64 Word.word) M)
    else if (((l__42 = (( 17 :: int)::ii)))) then (read_reg f17_ref  :: ( 64 Word.word) M)
    else if (((l__42 = (( 18 :: int)::ii)))) then (read_reg f18_ref  :: ( 64 Word.word) M)
    else if (((l__42 = (( 19 :: int)::ii)))) then (read_reg f19_ref  :: ( 64 Word.word) M)
    else if (((l__42 = (( 20 :: int)::ii)))) then (read_reg f20_ref  :: ( 64 Word.word) M)
    else if (((l__42 = (( 21 :: int)::ii)))) then (read_reg f21_ref  :: ( 64 Word.word) M)
    else if (((l__42 = (( 22 :: int)::ii)))) then (read_reg f22_ref  :: ( 64 Word.word) M)
    else if (((l__42 = (( 23 :: int)::ii)))) then (read_reg f23_ref  :: ( 64 Word.word) M)
    else if (((l__42 = (( 24 :: int)::ii)))) then (read_reg f24_ref  :: ( 64 Word.word) M)
    else if (((l__42 = (( 25 :: int)::ii)))) then (read_reg f25_ref  :: ( 64 Word.word) M)
    else if (((l__42 = (( 26 :: int)::ii)))) then (read_reg f26_ref  :: ( 64 Word.word) M)
    else if (((l__42 = (( 27 :: int)::ii)))) then (read_reg f27_ref  :: ( 64 Word.word) M)
    else if (((l__42 = (( 28 :: int)::ii)))) then (read_reg f28_ref  :: ( 64 Word.word) M)
    else if (((l__42 = (( 29 :: int)::ii)))) then (read_reg f29_ref  :: ( 64 Word.word) M)
    else if (((l__42 = (( 30 :: int)::ii)))) then (read_reg f30_ref  :: ( 64 Word.word) M)
    else if (((l__42 = (( 31 :: int)::ii)))) then (read_reg f31_ref  :: ( 64 Word.word) M)
    else assert_exp False (''invalid floating point register number'') \<then> exit0 () ) \<bind> ((\<lambda> (v :: fregtype) . 
   return ((fregval_from_freg v  ::  64 Word.word))))))\<close> 
  for  r  :: " int "


\<comment> \<open>\<open>val wF : integer -> mword ty64 -> M unit\<close>\<close>

definition wF  :: \<open> int \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> wF r in_v = (
   (let v = ((fregval_into_freg in_v  ::  64 Word.word)) in
   (let l__10 = r in
   ((if (((l__10 = (( 0 :: int)::ii)))) then write_reg f0_ref v
    else if (((l__10 = (( 1 :: int)::ii)))) then write_reg f1_ref v
    else if (((l__10 = (( 2 :: int)::ii)))) then write_reg f2_ref v
    else if (((l__10 = (( 3 :: int)::ii)))) then write_reg f3_ref v
    else if (((l__10 = (( 4 :: int)::ii)))) then write_reg f4_ref v
    else if (((l__10 = (( 5 :: int)::ii)))) then write_reg f5_ref v
    else if (((l__10 = (( 6 :: int)::ii)))) then write_reg f6_ref v
    else if (((l__10 = (( 7 :: int)::ii)))) then write_reg f7_ref v
    else if (((l__10 = (( 8 :: int)::ii)))) then write_reg f8_ref v
    else if (((l__10 = (( 9 :: int)::ii)))) then write_reg f9_ref v
    else if (((l__10 = (( 10 :: int)::ii)))) then write_reg f10_ref v
    else if (((l__10 = (( 11 :: int)::ii)))) then write_reg f11_ref v
    else if (((l__10 = (( 12 :: int)::ii)))) then write_reg f12_ref v
    else if (((l__10 = (( 13 :: int)::ii)))) then write_reg f13_ref v
    else if (((l__10 = (( 14 :: int)::ii)))) then write_reg f14_ref v
    else if (((l__10 = (( 15 :: int)::ii)))) then write_reg f15_ref v
    else if (((l__10 = (( 16 :: int)::ii)))) then write_reg f16_ref v
    else if (((l__10 = (( 17 :: int)::ii)))) then write_reg f17_ref v
    else if (((l__10 = (( 18 :: int)::ii)))) then write_reg f18_ref v
    else if (((l__10 = (( 19 :: int)::ii)))) then write_reg f19_ref v
    else if (((l__10 = (( 20 :: int)::ii)))) then write_reg f20_ref v
    else if (((l__10 = (( 21 :: int)::ii)))) then write_reg f21_ref v
    else if (((l__10 = (( 22 :: int)::ii)))) then write_reg f22_ref v
    else if (((l__10 = (( 23 :: int)::ii)))) then write_reg f23_ref v
    else if (((l__10 = (( 24 :: int)::ii)))) then write_reg f24_ref v
    else if (((l__10 = (( 25 :: int)::ii)))) then write_reg f25_ref v
    else if (((l__10 = (( 26 :: int)::ii)))) then write_reg f26_ref v
    else if (((l__10 = (( 27 :: int)::ii)))) then write_reg f27_ref v
    else if (((l__10 = (( 28 :: int)::ii)))) then write_reg f28_ref v
    else if (((l__10 = (( 29 :: int)::ii)))) then write_reg f29_ref v
    else if (((l__10 = (( 30 :: int)::ii)))) then write_reg f30_ref v
    else if (((l__10 = (( 31 :: int)::ii)))) then write_reg f31_ref v
    else assert_exp False (''invalid floating point register number'') \<then> exit0 () ) \<then>
   dirty_fd_context () ) \<then>
   return (if ((get_config_print_reg () )) then
             print_dbg
               (((@) (''f'')
                   (((@) ((stringFromInteger r)) (((@) ('' <- '') ((FRegStr v))))))))
           else () ))))\<close> 
  for  r  :: " int " 
  and  in_v  :: "(64)Word.word "


\<comment> \<open>\<open>val rF_bits : mword ty5 -> M (mword ty64)\<close>\<close>

definition rF_bits  :: \<open>(5)Word.word \<Rightarrow>((register_value),((64)Word.word),(exception))monad \<close>  where 
     \<open> rF_bits i = ( (rF ((Word.uint i))  :: ( 64 Word.word) M))\<close> 
  for  i  :: "(5)Word.word "


\<comment> \<open>\<open>val wF_bits : mword ty5 -> mword ty64 -> M unit\<close>\<close>

definition wF_bits  :: \<open>(5)Word.word \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> wF_bits (i :: 5 bits) (data :: flenbits) = ( wF ((Word.uint i)) data )\<close> 
  for  i  :: "(5)Word.word " 
  and  data  :: "(64)Word.word "


\<comment> \<open>\<open>val freg_name_abi_forwards : mword ty5 -> M string\<close>\<close>

\<comment> \<open>\<open>val freg_name_abi_backwards : string -> M (mword ty5)\<close>\<close>

\<comment> \<open>\<open>val freg_name_abi_forwards_matches : mword ty5 -> bool\<close>\<close>

\<comment> \<open>\<open>val freg_name_abi_backwards_matches : string -> bool\<close>\<close>

\<comment> \<open>\<open>val freg_name_abi_matches_prefix : string -> maybe ((mword ty5 * ii))\<close>\<close>

definition freg_name_abi_forwards  :: \<open>(5)Word.word \<Rightarrow>((register_value),(string),(exception))monad \<close>  where 
     \<open> freg_name_abi_forwards arg1 = (
   (let b__0 = arg1 in
   if (((b__0 = ( 0b00000 ::  5 Word.word)))) then return (''ft0'')
   else if (((b__0 = ( 0b00001 ::  5 Word.word)))) then return (''ft1'')
   else if (((b__0 = ( 0b00010 ::  5 Word.word)))) then return (''ft2'')
   else if (((b__0 = ( 0b00011 ::  5 Word.word)))) then return (''ft3'')
   else if (((b__0 = ( 0b00100 ::  5 Word.word)))) then return (''ft4'')
   else if (((b__0 = ( 0b00101 ::  5 Word.word)))) then return (''ft5'')
   else if (((b__0 = ( 0b00110 ::  5 Word.word)))) then return (''ft6'')
   else if (((b__0 = ( 0b00111 ::  5 Word.word)))) then return (''ft7'')
   else if (((b__0 = ( 0b01000 ::  5 Word.word)))) then return (''fs0'')
   else if (((b__0 = ( 0b01001 ::  5 Word.word)))) then return (''fs1'')
   else if (((b__0 = ( 0b01010 ::  5 Word.word)))) then return (''fa0'')
   else if (((b__0 = ( 0b01011 ::  5 Word.word)))) then return (''fa1'')
   else if (((b__0 = ( 0b01100 ::  5 Word.word)))) then return (''fa2'')
   else if (((b__0 = ( 0b01101 ::  5 Word.word)))) then return (''fa3'')
   else if (((b__0 = ( 0b01110 ::  5 Word.word)))) then return (''fa4'')
   else if (((b__0 = ( 0b01111 ::  5 Word.word)))) then return (''fa5'')
   else if (((b__0 = ( 0b10000 ::  5 Word.word)))) then return (''fa6'')
   else if (((b__0 = ( 0b10001 ::  5 Word.word)))) then return (''fa7'')
   else if (((b__0 = ( 0b10010 ::  5 Word.word)))) then return (''fs2'')
   else if (((b__0 = ( 0b10011 ::  5 Word.word)))) then return (''fs3'')
   else if (((b__0 = ( 0b10100 ::  5 Word.word)))) then return (''fs4'')
   else if (((b__0 = ( 0b10101 ::  5 Word.word)))) then return (''fs5'')
   else if (((b__0 = ( 0b10110 ::  5 Word.word)))) then return (''fs6'')
   else if (((b__0 = ( 0b10111 ::  5 Word.word)))) then return (''fs7'')
   else if (((b__0 = ( 0b11000 ::  5 Word.word)))) then return (''fs8'')
   else if (((b__0 = ( 0b11001 ::  5 Word.word)))) then return (''fs9'')
   else if (((b__0 = ( 0b11010 ::  5 Word.word)))) then return (''fs10'')
   else if (((b__0 = ( 0b11011 ::  5 Word.word)))) then return (''fs11'')
   else if (((b__0 = ( 0b11100 ::  5 Word.word)))) then return (''ft8'')
   else if (((b__0 = ( 0b11101 ::  5 Word.word)))) then return (''ft9'')
   else if (((b__0 = ( 0b11110 ::  5 Word.word)))) then return (''ft10'')
   else if (((b__0 = ( 0b11111 ::  5 Word.word)))) then return (''ft11'')
   else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))\<close> 
  for  arg1  :: "(5)Word.word "


definition freg_name_abi_backwards  :: \<open> string \<Rightarrow>((register_value),((5)Word.word),(exception))monad \<close>  where 
     \<open> freg_name_abi_backwards arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''ft0'')))) then return ( 0b00000 ::  5 Word.word)
   else if (((p00 = (''ft1'')))) then return ( 0b00001 ::  5 Word.word)
   else if (((p00 = (''ft2'')))) then return ( 0b00010 ::  5 Word.word)
   else if (((p00 = (''ft3'')))) then return ( 0b00011 ::  5 Word.word)
   else if (((p00 = (''ft4'')))) then return ( 0b00100 ::  5 Word.word)
   else if (((p00 = (''ft5'')))) then return ( 0b00101 ::  5 Word.word)
   else if (((p00 = (''ft6'')))) then return ( 0b00110 ::  5 Word.word)
   else if (((p00 = (''ft7'')))) then return ( 0b00111 ::  5 Word.word)
   else if (((p00 = (''fs0'')))) then return ( 0b01000 ::  5 Word.word)
   else if (((p00 = (''fs1'')))) then return ( 0b01001 ::  5 Word.word)
   else if (((p00 = (''fa0'')))) then return ( 0b01010 ::  5 Word.word)
   else if (((p00 = (''fa1'')))) then return ( 0b01011 ::  5 Word.word)
   else if (((p00 = (''fa2'')))) then return ( 0b01100 ::  5 Word.word)
   else if (((p00 = (''fa3'')))) then return ( 0b01101 ::  5 Word.word)
   else if (((p00 = (''fa4'')))) then return ( 0b01110 ::  5 Word.word)
   else if (((p00 = (''fa5'')))) then return ( 0b01111 ::  5 Word.word)
   else if (((p00 = (''fa6'')))) then return ( 0b10000 ::  5 Word.word)
   else if (((p00 = (''fa7'')))) then return ( 0b10001 ::  5 Word.word)
   else if (((p00 = (''fs2'')))) then return ( 0b10010 ::  5 Word.word)
   else if (((p00 = (''fs3'')))) then return ( 0b10011 ::  5 Word.word)
   else if (((p00 = (''fs4'')))) then return ( 0b10100 ::  5 Word.word)
   else if (((p00 = (''fs5'')))) then return ( 0b10101 ::  5 Word.word)
   else if (((p00 = (''fs6'')))) then return ( 0b10110 ::  5 Word.word)
   else if (((p00 = (''fs7'')))) then return ( 0b10111 ::  5 Word.word)
   else if (((p00 = (''fs8'')))) then return ( 0b11000 ::  5 Word.word)
   else if (((p00 = (''fs9'')))) then return ( 0b11001 ::  5 Word.word)
   else if (((p00 = (''fs10'')))) then return ( 0b11010 ::  5 Word.word)
   else if (((p00 = (''fs11'')))) then return ( 0b11011 ::  5 Word.word)
   else if (((p00 = (''ft8'')))) then return ( 0b11100 ::  5 Word.word)
   else if (((p00 = (''ft9'')))) then return ( 0b11101 ::  5 Word.word)
   else if (((p00 = (''ft10'')))) then return ( 0b11110 ::  5 Word.word)
   else if (((p00 = (''ft11'')))) then return ( 0b11111 ::  5 Word.word)
   else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))\<close> 
  for  arg1  :: " string "


definition freg_name_abi_forwards_matches  :: \<open>(5)Word.word \<Rightarrow> bool \<close>  where 
     \<open> freg_name_abi_forwards_matches arg1 = (
   (let b__0 = arg1 in
   if (((b__0 = ( 0b00000 ::  5 Word.word)))) then True
   else if (((b__0 = ( 0b00001 ::  5 Word.word)))) then True
   else if (((b__0 = ( 0b00010 ::  5 Word.word)))) then True
   else if (((b__0 = ( 0b00011 ::  5 Word.word)))) then True
   else if (((b__0 = ( 0b00100 ::  5 Word.word)))) then True
   else if (((b__0 = ( 0b00101 ::  5 Word.word)))) then True
   else if (((b__0 = ( 0b00110 ::  5 Word.word)))) then True
   else if (((b__0 = ( 0b00111 ::  5 Word.word)))) then True
   else if (((b__0 = ( 0b01000 ::  5 Word.word)))) then True
   else if (((b__0 = ( 0b01001 ::  5 Word.word)))) then True
   else if (((b__0 = ( 0b01010 ::  5 Word.word)))) then True
   else if (((b__0 = ( 0b01011 ::  5 Word.word)))) then True
   else if (((b__0 = ( 0b01100 ::  5 Word.word)))) then True
   else if (((b__0 = ( 0b01101 ::  5 Word.word)))) then True
   else if (((b__0 = ( 0b01110 ::  5 Word.word)))) then True
   else if (((b__0 = ( 0b01111 ::  5 Word.word)))) then True
   else if (((b__0 = ( 0b10000 ::  5 Word.word)))) then True
   else if (((b__0 = ( 0b10001 ::  5 Word.word)))) then True
   else if (((b__0 = ( 0b10010 ::  5 Word.word)))) then True
   else if (((b__0 = ( 0b10011 ::  5 Word.word)))) then True
   else if (((b__0 = ( 0b10100 ::  5 Word.word)))) then True
   else if (((b__0 = ( 0b10101 ::  5 Word.word)))) then True
   else if (((b__0 = ( 0b10110 ::  5 Word.word)))) then True
   else if (((b__0 = ( 0b10111 ::  5 Word.word)))) then True
   else if (((b__0 = ( 0b11000 ::  5 Word.word)))) then True
   else if (((b__0 = ( 0b11001 ::  5 Word.word)))) then True
   else if (((b__0 = ( 0b11010 ::  5 Word.word)))) then True
   else if (((b__0 = ( 0b11011 ::  5 Word.word)))) then True
   else if (((b__0 = ( 0b11100 ::  5 Word.word)))) then True
   else if (((b__0 = ( 0b11101 ::  5 Word.word)))) then True
   else if (((b__0 = ( 0b11110 ::  5 Word.word)))) then True
   else if (((b__0 = ( 0b11111 ::  5 Word.word)))) then True
   else False))\<close> 
  for  arg1  :: "(5)Word.word "


definition freg_name_abi_backwards_matches  :: \<open> string \<Rightarrow> bool \<close>  where 
     \<open> freg_name_abi_backwards_matches arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''ft0'')))) then True
   else if (((p00 = (''ft1'')))) then True
   else if (((p00 = (''ft2'')))) then True
   else if (((p00 = (''ft3'')))) then True
   else if (((p00 = (''ft4'')))) then True
   else if (((p00 = (''ft5'')))) then True
   else if (((p00 = (''ft6'')))) then True
   else if (((p00 = (''ft7'')))) then True
   else if (((p00 = (''fs0'')))) then True
   else if (((p00 = (''fs1'')))) then True
   else if (((p00 = (''fa0'')))) then True
   else if (((p00 = (''fa1'')))) then True
   else if (((p00 = (''fa2'')))) then True
   else if (((p00 = (''fa3'')))) then True
   else if (((p00 = (''fa4'')))) then True
   else if (((p00 = (''fa5'')))) then True
   else if (((p00 = (''fa6'')))) then True
   else if (((p00 = (''fa7'')))) then True
   else if (((p00 = (''fs2'')))) then True
   else if (((p00 = (''fs3'')))) then True
   else if (((p00 = (''fs4'')))) then True
   else if (((p00 = (''fs5'')))) then True
   else if (((p00 = (''fs6'')))) then True
   else if (((p00 = (''fs7'')))) then True
   else if (((p00 = (''fs8'')))) then True
   else if (((p00 = (''fs9'')))) then True
   else if (((p00 = (''fs10'')))) then True
   else if (((p00 = (''fs11'')))) then True
   else if (((p00 = (''ft8'')))) then True
   else if (((p00 = (''ft9'')))) then True
   else if (((p00 = (''ft10'')))) then True
   else if (((p00 = (''ft11'')))) then True
   else False))\<close> 
  for  arg1  :: " string "


\<comment> \<open>\<open>val _s324_ : string -> maybe string\<close>\<close>

definition s324  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s324 s3251 = (
   (let s3260 = s3251 in
   if ((string_startswith s3260 (''ft11''))) then  
  (case  ((string_drop s3260 ((string_length (''ft11''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s3251  :: " string "


\<comment> \<open>\<open>val _s320_ : string -> maybe string\<close>\<close>

definition s320  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s320 s3210 = (
   (let s3220 = s3210 in
   if ((string_startswith s3220 (''ft10''))) then  
  (case  ((string_drop s3220 ((string_length (''ft10''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s3210  :: " string "


\<comment> \<open>\<open>val _s316_ : string -> maybe string\<close>\<close>

definition s316  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s316 s3170 = (
   (let s3180 = s3170 in
   if ((string_startswith s3180 (''ft9''))) then  
  (case  ((string_drop s3180 ((string_length (''ft9''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s3170  :: " string "


\<comment> \<open>\<open>val _s312_ : string -> maybe string\<close>\<close>

definition s312  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s312 s3130 = (
   (let s3140 = s3130 in
   if ((string_startswith s3140 (''ft8''))) then  
  (case  ((string_drop s3140 ((string_length (''ft8''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s3130  :: " string "


\<comment> \<open>\<open>val _s308_ : string -> maybe string\<close>\<close>

definition s308  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s308 s3090 = (
   (let s3100 = s3090 in
   if ((string_startswith s3100 (''fs11''))) then  
  (case  ((string_drop s3100 ((string_length (''fs11''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s3090  :: " string "


\<comment> \<open>\<open>val _s304_ : string -> maybe string\<close>\<close>

definition s304  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s304 s3050 = (
   (let s3060 = s3050 in
   if ((string_startswith s3060 (''fs10''))) then  
  (case  ((string_drop s3060 ((string_length (''fs10''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s3050  :: " string "


\<comment> \<open>\<open>val _s300_ : string -> maybe string\<close>\<close>

definition s300  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s300 s3010 = (
   (let s3020 = s3010 in
   if ((string_startswith s3020 (''fs9''))) then  
  (case  ((string_drop s3020 ((string_length (''fs9''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s3010  :: " string "


\<comment> \<open>\<open>val _s296_ : string -> maybe string\<close>\<close>

definition s296  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s296 s2970 = (
   (let s2980 = s2970 in
   if ((string_startswith s2980 (''fs8''))) then  
  (case  ((string_drop s2980 ((string_length (''fs8''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s2970  :: " string "


\<comment> \<open>\<open>val _s292_ : string -> maybe string\<close>\<close>

definition s292  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s292 s2930 = (
   (let s2940 = s2930 in
   if ((string_startswith s2940 (''fs7''))) then  
  (case  ((string_drop s2940 ((string_length (''fs7''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s2930  :: " string "


\<comment> \<open>\<open>val _s288_ : string -> maybe string\<close>\<close>

definition s288  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s288 s2890 = (
   (let s2900 = s2890 in
   if ((string_startswith s2900 (''fs6''))) then  
  (case  ((string_drop s2900 ((string_length (''fs6''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s2890  :: " string "


\<comment> \<open>\<open>val _s284_ : string -> maybe string\<close>\<close>

definition s284  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s284 s2850 = (
   (let s2860 = s2850 in
   if ((string_startswith s2860 (''fs5''))) then  
  (case  ((string_drop s2860 ((string_length (''fs5''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s2850  :: " string "


\<comment> \<open>\<open>val _s280_ : string -> maybe string\<close>\<close>

definition s280  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s280 s2810 = (
   (let s2821 = s2810 in
   if ((string_startswith s2821 (''fs4''))) then  
  (case  ((string_drop s2821 ((string_length (''fs4''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s2810  :: " string "


\<comment> \<open>\<open>val _s276_ : string -> maybe string\<close>\<close>

definition s276  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s276 s2770 = (
   (let s2780 = s2770 in
   if ((string_startswith s2780 (''fs3''))) then  
  (case  ((string_drop s2780 ((string_length (''fs3''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s2770  :: " string "


\<comment> \<open>\<open>val _s272_ : string -> maybe string\<close>\<close>

definition s272  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s272 s2730 = (
   (let s2740 = s2730 in
   if ((string_startswith s2740 (''fs2''))) then  
  (case  ((string_drop s2740 ((string_length (''fs2''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s2730  :: " string "


\<comment> \<open>\<open>val _s268_ : string -> maybe string\<close>\<close>

definition s268  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s268 s2690 = (
   (let s2700 = s2690 in
   if ((string_startswith s2700 (''fa7''))) then  
  (case  ((string_drop s2700 ((string_length (''fa7''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s2690  :: " string "


\<comment> \<open>\<open>val _s264_ : string -> maybe string\<close>\<close>

definition s264  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s264 s2650 = (
   (let s2660 = s2650 in
   if ((string_startswith s2660 (''fa6''))) then  
  (case  ((string_drop s2660 ((string_length (''fa6''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s2650  :: " string "


\<comment> \<open>\<open>val _s260_ : string -> maybe string\<close>\<close>

definition s260  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s260 s2610 = (
   (let s2620 = s2610 in
   if ((string_startswith s2620 (''fa5''))) then  
  (case  ((string_drop s2620 ((string_length (''fa5''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s2610  :: " string "


\<comment> \<open>\<open>val _s256_ : string -> maybe string\<close>\<close>

definition s256  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s256 s2570 = (
   (let s2580 = s2570 in
   if ((string_startswith s2580 (''fa4''))) then  
  (case  ((string_drop s2580 ((string_length (''fa4''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s2570  :: " string "


\<comment> \<open>\<open>val _s252_ : string -> maybe string\<close>\<close>

definition s252  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s252 s2530 = (
   (let s2540 = s2530 in
   if ((string_startswith s2540 (''fa3''))) then  
  (case  ((string_drop s2540 ((string_length (''fa3''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s2530  :: " string "


\<comment> \<open>\<open>val _s248_ : string -> maybe string\<close>\<close>

definition s248  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s248 s2490 = (
   (let s2500 = s2490 in
   if ((string_startswith s2500 (''fa2''))) then  
  (case  ((string_drop s2500 ((string_length (''fa2''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s2490  :: " string "


\<comment> \<open>\<open>val _s244_ : string -> maybe string\<close>\<close>

definition s244  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s244 s2450 = (
   (let s2460 = s2450 in
   if ((string_startswith s2460 (''fa1''))) then  
  (case  ((string_drop s2460 ((string_length (''fa1''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s2450  :: " string "


\<comment> \<open>\<open>val _s240_ : string -> maybe string\<close>\<close>

definition s240  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s240 s2410 = (
   (let s2420 = s2410 in
   if ((string_startswith s2420 (''fa0''))) then  
  (case  ((string_drop s2420 ((string_length (''fa0''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s2410  :: " string "


\<comment> \<open>\<open>val _s236_ : string -> maybe string\<close>\<close>

definition s236  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s236 s2370 = (
   (let s2380 = s2370 in
   if ((string_startswith s2380 (''fs1''))) then  
  (case  ((string_drop s2380 ((string_length (''fs1''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s2370  :: " string "


\<comment> \<open>\<open>val _s232_ : string -> maybe string\<close>\<close>

definition s232  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s232 s2330 = (
   (let s2340 = s2330 in
   if ((string_startswith s2340 (''fs0''))) then  
  (case  ((string_drop s2340 ((string_length (''fs0''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s2330  :: " string "


\<comment> \<open>\<open>val _s228_ : string -> maybe string\<close>\<close>

definition s228  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s228 s2290 = (
   (let s2300 = s2290 in
   if ((string_startswith s2300 (''ft7''))) then  
  (case  ((string_drop s2300 ((string_length (''ft7''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s2290  :: " string "


\<comment> \<open>\<open>val _s224_ : string -> maybe string\<close>\<close>

definition s224  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s224 s2250 = (
   (let s2260 = s2250 in
   if ((string_startswith s2260 (''ft6''))) then  
  (case  ((string_drop s2260 ((string_length (''ft6''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s2250  :: " string "


\<comment> \<open>\<open>val _s220_ : string -> maybe string\<close>\<close>

definition s220  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s220 s2211 = (
   (let s2220 = s2211 in
   if ((string_startswith s2220 (''ft5''))) then  
  (case  ((string_drop s2220 ((string_length (''ft5''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s2211  :: " string "


\<comment> \<open>\<open>val _s216_ : string -> maybe string\<close>\<close>

definition s216  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s216 s2170 = (
   (let s2180 = s2170 in
   if ((string_startswith s2180 (''ft4''))) then  
  (case  ((string_drop s2180 ((string_length (''ft4''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s2170  :: " string "


\<comment> \<open>\<open>val _s212_ : string -> maybe string\<close>\<close>

definition s212  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s212 s2130 = (
   (let s2140 = s2130 in
   if ((string_startswith s2140 (''ft3''))) then  
  (case  ((string_drop s2140 ((string_length (''ft3''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s2130  :: " string "


\<comment> \<open>\<open>val _s208_ : string -> maybe string\<close>\<close>

definition s208  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s208 s2090 = (
   (let s2100 = s2090 in
   if ((string_startswith s2100 (''ft2''))) then  
  (case  ((string_drop s2100 ((string_length (''ft2''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s2090  :: " string "


\<comment> \<open>\<open>val _s204_ : string -> maybe string\<close>\<close>

definition s204  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s204 s2051 = (
   (let s2060 = s2051 in
   if ((string_startswith s2060 (''ft1''))) then  
  (case  ((string_drop s2060 ((string_length (''ft1''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s2051  :: " string "


\<comment> \<open>\<open>val _s200_ : string -> maybe string\<close>\<close>

definition s200  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s200 s2011 = (
   (let s2020 = s2011 in
   if ((string_startswith s2020 (''ft0''))) then  
  (case  ((string_drop s2020 ((string_length (''ft0''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s2011  :: " string "


definition freg_name_abi_matches_prefix  :: \<open> string \<Rightarrow>((5)Word.word*int)option \<close>  where 
     \<open> freg_name_abi_matches_prefix arg1 = (
   (let s2030 = arg1 in
   if ((case  ((s200 s2030)) of   Some (s1) => True | _ => False )) then  
  (case  s200 s2030 of
      (Some (s1)) =>
  Some
    (( 0b00000 :: 5 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s204 s2030)) of   Some (s1) => True | _ => False )) then  
  (case  s204 s2030 of
      (Some (s1)) =>
  Some
    (( 0b00001 :: 5 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s208 s2030)) of   Some (s1) => True | _ => False )) then  
  (case  s208 s2030 of
      (Some (s1)) =>
  Some
    (( 0b00010 :: 5 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s212 s2030)) of   Some (s1) => True | _ => False )) then  
  (case  s212 s2030 of
      (Some (s1)) =>
  Some
    (( 0b00011 :: 5 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s216 s2030)) of   Some (s1) => True | _ => False )) then  
  (case  s216 s2030 of
      (Some (s1)) =>
  Some
    (( 0b00100 :: 5 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s220 s2030)) of   Some (s1) => True | _ => False )) then  
  (case  s220 s2030 of
      (Some (s1)) =>
  Some
    (( 0b00101 :: 5 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s224 s2030)) of   Some (s1) => True | _ => False )) then  
  (case  s224 s2030 of
      (Some (s1)) =>
  Some
    (( 0b00110 :: 5 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s228 s2030)) of   Some (s1) => True | _ => False )) then  
  (case  s228 s2030 of
      (Some (s1)) =>
  Some
    (( 0b00111 :: 5 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s232 s2030)) of   Some (s1) => True | _ => False )) then  
  (case  s232 s2030 of
      (Some (s1)) =>
  Some
    (( 0b01000 :: 5 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s236 s2030)) of   Some (s1) => True | _ => False )) then  
  (case  s236 s2030 of
      (Some (s1)) =>
  Some
    (( 0b01001 :: 5 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s240 s2030)) of   Some (s1) => True | _ => False )) then  
  (case  s240 s2030 of
      (Some (s1)) =>
  Some
    (( 0b01010 :: 5 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s244 s2030)) of   Some (s1) => True | _ => False )) then  
  (case  s244 s2030 of
      (Some (s1)) =>
  Some
    (( 0b01011 :: 5 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s248 s2030)) of   Some (s1) => True | _ => False )) then  
  (case  s248 s2030 of
      (Some (s1)) =>
  Some
    (( 0b01100 :: 5 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s252 s2030)) of   Some (s1) => True | _ => False )) then  
  (case  s252 s2030 of
      (Some (s1)) =>
  Some
    (( 0b01101 :: 5 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s256 s2030)) of   Some (s1) => True | _ => False )) then  
  (case  s256 s2030 of
      (Some (s1)) =>
  Some
    (( 0b01110 :: 5 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s260 s2030)) of   Some (s1) => True | _ => False )) then  
  (case  s260 s2030 of
      (Some (s1)) =>
  Some
    (( 0b01111 :: 5 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s264 s2030)) of   Some (s1) => True | _ => False )) then  
  (case  s264 s2030 of
      (Some (s1)) =>
  Some
    (( 0b10000 :: 5 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s268 s2030)) of   Some (s1) => True | _ => False )) then  
  (case  s268 s2030 of
      (Some (s1)) =>
  Some
    (( 0b10001 :: 5 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s272 s2030)) of   Some (s1) => True | _ => False )) then  
  (case  s272 s2030 of
      (Some (s1)) =>
  Some
    (( 0b10010 :: 5 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s276 s2030)) of   Some (s1) => True | _ => False )) then  
  (case  s276 s2030 of
      (Some (s1)) =>
  Some
    (( 0b10011 :: 5 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s280 s2030)) of   Some (s1) => True | _ => False )) then  
  (case  s280 s2030 of
      (Some (s1)) =>
  Some
    (( 0b10100 :: 5 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s284 s2030)) of   Some (s1) => True | _ => False )) then  
  (case  s284 s2030 of
      (Some (s1)) =>
  Some
    (( 0b10101 :: 5 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s288 s2030)) of   Some (s1) => True | _ => False )) then  
  (case  s288 s2030 of
      (Some (s1)) =>
  Some
    (( 0b10110 :: 5 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s292 s2030)) of   Some (s1) => True | _ => False )) then  
  (case  s292 s2030 of
      (Some (s1)) =>
  Some
    (( 0b10111 :: 5 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s296 s2030)) of   Some (s1) => True | _ => False )) then  
  (case  s296 s2030 of
      (Some (s1)) =>
  Some
    (( 0b11000 :: 5 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s300 s2030)) of   Some (s1) => True | _ => False )) then  
  (case  s300 s2030 of
      (Some (s1)) =>
  Some
    (( 0b11001 :: 5 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s304 s2030)) of   Some (s1) => True | _ => False )) then  
  (case  s304 s2030 of
      (Some (s1)) =>
  Some
    (( 0b11010 :: 5 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s308 s2030)) of   Some (s1) => True | _ => False )) then  
  (case  s308 s2030 of
      (Some (s1)) =>
  Some
    (( 0b11011 :: 5 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s312 s2030)) of   Some (s1) => True | _ => False )) then  
  (case  s312 s2030 of
      (Some (s1)) =>
  Some
    (( 0b11100 :: 5 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s316 s2030)) of   Some (s1) => True | _ => False )) then  
  (case  s316 s2030 of
      (Some (s1)) =>
  Some
    (( 0b11101 :: 5 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s320 s2030)) of   Some (s1) => True | _ => False )) then  
  (case  s320 s2030 of
      (Some (s1)) =>
  Some
    (( 0b11110 :: 5 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s324 s2030)) of   Some (s1) => True | _ => False )) then  
  (case  s324 s2030 of
      (Some (s1)) =>
  Some
    (( 0b11111 :: 5 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else None))\<close> 
  for  arg1  :: " string "


\<comment> \<open>\<open>val freg_name_forwards : mword ty5 -> M string\<close>\<close>

\<comment> \<open>\<open>val freg_name_backwards : string -> M (mword ty5)\<close>\<close>

\<comment> \<open>\<open>val freg_name_forwards_matches : mword ty5 -> bool\<close>\<close>

\<comment> \<open>\<open>val freg_name_backwards_matches : string -> bool\<close>\<close>

\<comment> \<open>\<open>val freg_name_matches_prefix : string -> maybe ((mword ty5 * ii))\<close>\<close>

definition freg_name_forwards  :: \<open>(5)Word.word \<Rightarrow>((register_value),(string),(exception))monad \<close>  where 
     \<open> freg_name_forwards arg1 = (
   (let b__0 = arg1 in
   if (((b__0 = ( 0b00000 ::  5 Word.word)))) then return (''ft0'')
   else if (((b__0 = ( 0b00001 ::  5 Word.word)))) then return (''ft1'')
   else if (((b__0 = ( 0b00010 ::  5 Word.word)))) then return (''ft2'')
   else if (((b__0 = ( 0b00011 ::  5 Word.word)))) then return (''ft3'')
   else if (((b__0 = ( 0b00100 ::  5 Word.word)))) then return (''ft4'')
   else if (((b__0 = ( 0b00101 ::  5 Word.word)))) then return (''ft5'')
   else if (((b__0 = ( 0b00110 ::  5 Word.word)))) then return (''ft6'')
   else if (((b__0 = ( 0b00111 ::  5 Word.word)))) then return (''ft7'')
   else if (((b__0 = ( 0b01000 ::  5 Word.word)))) then return (''fs0'')
   else if (((b__0 = ( 0b01001 ::  5 Word.word)))) then return (''fs1'')
   else if (((b__0 = ( 0b01010 ::  5 Word.word)))) then return (''fa0'')
   else if (((b__0 = ( 0b01011 ::  5 Word.word)))) then return (''fa1'')
   else if (((b__0 = ( 0b01100 ::  5 Word.word)))) then return (''fa2'')
   else if (((b__0 = ( 0b01101 ::  5 Word.word)))) then return (''fa3'')
   else if (((b__0 = ( 0b01110 ::  5 Word.word)))) then return (''fa4'')
   else if (((b__0 = ( 0b01111 ::  5 Word.word)))) then return (''fa5'')
   else if (((b__0 = ( 0b10000 ::  5 Word.word)))) then return (''fa6'')
   else if (((b__0 = ( 0b10001 ::  5 Word.word)))) then return (''fa7'')
   else if (((b__0 = ( 0b10010 ::  5 Word.word)))) then return (''fs2'')
   else if (((b__0 = ( 0b10011 ::  5 Word.word)))) then return (''fs3'')
   else if (((b__0 = ( 0b10100 ::  5 Word.word)))) then return (''fs4'')
   else if (((b__0 = ( 0b10101 ::  5 Word.word)))) then return (''fs5'')
   else if (((b__0 = ( 0b10110 ::  5 Word.word)))) then return (''fs6'')
   else if (((b__0 = ( 0b10111 ::  5 Word.word)))) then return (''fs7'')
   else if (((b__0 = ( 0b11000 ::  5 Word.word)))) then return (''fs8'')
   else if (((b__0 = ( 0b11001 ::  5 Word.word)))) then return (''fs9'')
   else if (((b__0 = ( 0b11010 ::  5 Word.word)))) then return (''fs10'')
   else if (((b__0 = ( 0b11011 ::  5 Word.word)))) then return (''fs11'')
   else if (((b__0 = ( 0b11100 ::  5 Word.word)))) then return (''ft8'')
   else if (((b__0 = ( 0b11101 ::  5 Word.word)))) then return (''ft9'')
   else if (((b__0 = ( 0b11110 ::  5 Word.word)))) then return (''ft10'')
   else if (((b__0 = ( 0b11111 ::  5 Word.word)))) then return (''ft11'')
   else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))\<close> 
  for  arg1  :: "(5)Word.word "


definition freg_name_backwards  :: \<open> string \<Rightarrow>((register_value),((5)Word.word),(exception))monad \<close>  where 
     \<open> freg_name_backwards arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''ft0'')))) then return ( 0b00000 ::  5 Word.word)
   else if (((p00 = (''ft1'')))) then return ( 0b00001 ::  5 Word.word)
   else if (((p00 = (''ft2'')))) then return ( 0b00010 ::  5 Word.word)
   else if (((p00 = (''ft3'')))) then return ( 0b00011 ::  5 Word.word)
   else if (((p00 = (''ft4'')))) then return ( 0b00100 ::  5 Word.word)
   else if (((p00 = (''ft5'')))) then return ( 0b00101 ::  5 Word.word)
   else if (((p00 = (''ft6'')))) then return ( 0b00110 ::  5 Word.word)
   else if (((p00 = (''ft7'')))) then return ( 0b00111 ::  5 Word.word)
   else if (((p00 = (''fs0'')))) then return ( 0b01000 ::  5 Word.word)
   else if (((p00 = (''fs1'')))) then return ( 0b01001 ::  5 Word.word)
   else if (((p00 = (''fa0'')))) then return ( 0b01010 ::  5 Word.word)
   else if (((p00 = (''fa1'')))) then return ( 0b01011 ::  5 Word.word)
   else if (((p00 = (''fa2'')))) then return ( 0b01100 ::  5 Word.word)
   else if (((p00 = (''fa3'')))) then return ( 0b01101 ::  5 Word.word)
   else if (((p00 = (''fa4'')))) then return ( 0b01110 ::  5 Word.word)
   else if (((p00 = (''fa5'')))) then return ( 0b01111 ::  5 Word.word)
   else if (((p00 = (''fa6'')))) then return ( 0b10000 ::  5 Word.word)
   else if (((p00 = (''fa7'')))) then return ( 0b10001 ::  5 Word.word)
   else if (((p00 = (''fs2'')))) then return ( 0b10010 ::  5 Word.word)
   else if (((p00 = (''fs3'')))) then return ( 0b10011 ::  5 Word.word)
   else if (((p00 = (''fs4'')))) then return ( 0b10100 ::  5 Word.word)
   else if (((p00 = (''fs5'')))) then return ( 0b10101 ::  5 Word.word)
   else if (((p00 = (''fs6'')))) then return ( 0b10110 ::  5 Word.word)
   else if (((p00 = (''fs7'')))) then return ( 0b10111 ::  5 Word.word)
   else if (((p00 = (''fs8'')))) then return ( 0b11000 ::  5 Word.word)
   else if (((p00 = (''fs9'')))) then return ( 0b11001 ::  5 Word.word)
   else if (((p00 = (''fs10'')))) then return ( 0b11010 ::  5 Word.word)
   else if (((p00 = (''fs11'')))) then return ( 0b11011 ::  5 Word.word)
   else if (((p00 = (''ft8'')))) then return ( 0b11100 ::  5 Word.word)
   else if (((p00 = (''ft9'')))) then return ( 0b11101 ::  5 Word.word)
   else if (((p00 = (''ft10'')))) then return ( 0b11110 ::  5 Word.word)
   else if (((p00 = (''ft11'')))) then return ( 0b11111 ::  5 Word.word)
   else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))\<close> 
  for  arg1  :: " string "


definition freg_name_forwards_matches  :: \<open>(5)Word.word \<Rightarrow> bool \<close>  where 
     \<open> freg_name_forwards_matches arg1 = (
   (let b__0 = arg1 in
   if (((b__0 = ( 0b00000 ::  5 Word.word)))) then True
   else if (((b__0 = ( 0b00001 ::  5 Word.word)))) then True
   else if (((b__0 = ( 0b00010 ::  5 Word.word)))) then True
   else if (((b__0 = ( 0b00011 ::  5 Word.word)))) then True
   else if (((b__0 = ( 0b00100 ::  5 Word.word)))) then True
   else if (((b__0 = ( 0b00101 ::  5 Word.word)))) then True
   else if (((b__0 = ( 0b00110 ::  5 Word.word)))) then True
   else if (((b__0 = ( 0b00111 ::  5 Word.word)))) then True
   else if (((b__0 = ( 0b01000 ::  5 Word.word)))) then True
   else if (((b__0 = ( 0b01001 ::  5 Word.word)))) then True
   else if (((b__0 = ( 0b01010 ::  5 Word.word)))) then True
   else if (((b__0 = ( 0b01011 ::  5 Word.word)))) then True
   else if (((b__0 = ( 0b01100 ::  5 Word.word)))) then True
   else if (((b__0 = ( 0b01101 ::  5 Word.word)))) then True
   else if (((b__0 = ( 0b01110 ::  5 Word.word)))) then True
   else if (((b__0 = ( 0b01111 ::  5 Word.word)))) then True
   else if (((b__0 = ( 0b10000 ::  5 Word.word)))) then True
   else if (((b__0 = ( 0b10001 ::  5 Word.word)))) then True
   else if (((b__0 = ( 0b10010 ::  5 Word.word)))) then True
   else if (((b__0 = ( 0b10011 ::  5 Word.word)))) then True
   else if (((b__0 = ( 0b10100 ::  5 Word.word)))) then True
   else if (((b__0 = ( 0b10101 ::  5 Word.word)))) then True
   else if (((b__0 = ( 0b10110 ::  5 Word.word)))) then True
   else if (((b__0 = ( 0b10111 ::  5 Word.word)))) then True
   else if (((b__0 = ( 0b11000 ::  5 Word.word)))) then True
   else if (((b__0 = ( 0b11001 ::  5 Word.word)))) then True
   else if (((b__0 = ( 0b11010 ::  5 Word.word)))) then True
   else if (((b__0 = ( 0b11011 ::  5 Word.word)))) then True
   else if (((b__0 = ( 0b11100 ::  5 Word.word)))) then True
   else if (((b__0 = ( 0b11101 ::  5 Word.word)))) then True
   else if (((b__0 = ( 0b11110 ::  5 Word.word)))) then True
   else if (((b__0 = ( 0b11111 ::  5 Word.word)))) then True
   else False))\<close> 
  for  arg1  :: "(5)Word.word "


definition freg_name_backwards_matches  :: \<open> string \<Rightarrow> bool \<close>  where 
     \<open> freg_name_backwards_matches arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''ft0'')))) then True
   else if (((p00 = (''ft1'')))) then True
   else if (((p00 = (''ft2'')))) then True
   else if (((p00 = (''ft3'')))) then True
   else if (((p00 = (''ft4'')))) then True
   else if (((p00 = (''ft5'')))) then True
   else if (((p00 = (''ft6'')))) then True
   else if (((p00 = (''ft7'')))) then True
   else if (((p00 = (''fs0'')))) then True
   else if (((p00 = (''fs1'')))) then True
   else if (((p00 = (''fa0'')))) then True
   else if (((p00 = (''fa1'')))) then True
   else if (((p00 = (''fa2'')))) then True
   else if (((p00 = (''fa3'')))) then True
   else if (((p00 = (''fa4'')))) then True
   else if (((p00 = (''fa5'')))) then True
   else if (((p00 = (''fa6'')))) then True
   else if (((p00 = (''fa7'')))) then True
   else if (((p00 = (''fs2'')))) then True
   else if (((p00 = (''fs3'')))) then True
   else if (((p00 = (''fs4'')))) then True
   else if (((p00 = (''fs5'')))) then True
   else if (((p00 = (''fs6'')))) then True
   else if (((p00 = (''fs7'')))) then True
   else if (((p00 = (''fs8'')))) then True
   else if (((p00 = (''fs9'')))) then True
   else if (((p00 = (''fs10'')))) then True
   else if (((p00 = (''fs11'')))) then True
   else if (((p00 = (''ft8'')))) then True
   else if (((p00 = (''ft9'')))) then True
   else if (((p00 = (''ft10'')))) then True
   else if (((p00 = (''ft11'')))) then True
   else False))\<close> 
  for  arg1  :: " string "


\<comment> \<open>\<open>val _s452_ : string -> maybe string\<close>\<close>

definition s452  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s452 s4530 = (
   (let s4540 = s4530 in
   if ((string_startswith s4540 (''ft11''))) then  
  (case  ((string_drop s4540 ((string_length (''ft11''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s4530  :: " string "


\<comment> \<open>\<open>val _s448_ : string -> maybe string\<close>\<close>

definition s448  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s448 s4490 = (
   (let s4500 = s4490 in
   if ((string_startswith s4500 (''ft10''))) then  
  (case  ((string_drop s4500 ((string_length (''ft10''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s4490  :: " string "


\<comment> \<open>\<open>val _s444_ : string -> maybe string\<close>\<close>

definition s444  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s444 s4450 = (
   (let s4460 = s4450 in
   if ((string_startswith s4460 (''ft9''))) then  
  (case  ((string_drop s4460 ((string_length (''ft9''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s4450  :: " string "


\<comment> \<open>\<open>val _s440_ : string -> maybe string\<close>\<close>

definition s440  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s440 s4410 = (
   (let s4420 = s4410 in
   if ((string_startswith s4420 (''ft8''))) then  
  (case  ((string_drop s4420 ((string_length (''ft8''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s4410  :: " string "


\<comment> \<open>\<open>val _s436_ : string -> maybe string\<close>\<close>

definition s436  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s436 s4370 = (
   (let s4380 = s4370 in
   if ((string_startswith s4380 (''fs11''))) then  
  (case  ((string_drop s4380 ((string_length (''fs11''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s4370  :: " string "


\<comment> \<open>\<open>val _s432_ : string -> maybe string\<close>\<close>

definition s432  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s432 s4330 = (
   (let s4340 = s4330 in
   if ((string_startswith s4340 (''fs10''))) then  
  (case  ((string_drop s4340 ((string_length (''fs10''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s4330  :: " string "


\<comment> \<open>\<open>val _s428_ : string -> maybe string\<close>\<close>

definition s428  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s428 s4290 = (
   (let s4300 = s4290 in
   if ((string_startswith s4300 (''fs9''))) then  
  (case  ((string_drop s4300 ((string_length (''fs9''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s4290  :: " string "


\<comment> \<open>\<open>val _s424_ : string -> maybe string\<close>\<close>

definition s424  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s424 s4250 = (
   (let s4260 = s4250 in
   if ((string_startswith s4260 (''fs8''))) then  
  (case  ((string_drop s4260 ((string_length (''fs8''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s4250  :: " string "


\<comment> \<open>\<open>val _s420_ : string -> maybe string\<close>\<close>

definition s420  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s420 s4210 = (
   (let s4220 = s4210 in
   if ((string_startswith s4220 (''fs7''))) then  
  (case  ((string_drop s4220 ((string_length (''fs7''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s4210  :: " string "


\<comment> \<open>\<open>val _s416_ : string -> maybe string\<close>\<close>

definition s416  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s416 s4171 = (
   (let s4180 = s4171 in
   if ((string_startswith s4180 (''fs6''))) then  
  (case  ((string_drop s4180 ((string_length (''fs6''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s4171  :: " string "


\<comment> \<open>\<open>val _s412_ : string -> maybe string\<close>\<close>

definition s412  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s412 s4130 = (
   (let s4141 = s4130 in
   if ((string_startswith s4141 (''fs5''))) then  
  (case  ((string_drop s4141 ((string_length (''fs5''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s4130  :: " string "


\<comment> \<open>\<open>val _s408_ : string -> maybe string\<close>\<close>

definition s408  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s408 s4090 = (
   (let s4100 = s4090 in
   if ((string_startswith s4100 (''fs4''))) then  
  (case  ((string_drop s4100 ((string_length (''fs4''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s4090  :: " string "


\<comment> \<open>\<open>val _s404_ : string -> maybe string\<close>\<close>

definition s404  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s404 s4050 = (
   (let s4061 = s4050 in
   if ((string_startswith s4061 (''fs3''))) then  
  (case  ((string_drop s4061 ((string_length (''fs3''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s4050  :: " string "


\<comment> \<open>\<open>val _s400_ : string -> maybe string\<close>\<close>

definition s400  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s400 s4010 = (
   (let s4020 = s4010 in
   if ((string_startswith s4020 (''fs2''))) then  
  (case  ((string_drop s4020 ((string_length (''fs2''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s4010  :: " string "


\<comment> \<open>\<open>val _s396_ : string -> maybe string\<close>\<close>

definition s396  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s396 s3971 = (
   (let s3980 = s3971 in
   if ((string_startswith s3980 (''fa7''))) then  
  (case  ((string_drop s3980 ((string_length (''fa7''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s3971  :: " string "


\<comment> \<open>\<open>val _s392_ : string -> maybe string\<close>\<close>

definition s392  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s392 s3930 = (
   (let s3940 = s3930 in
   if ((string_startswith s3940 (''fa6''))) then  
  (case  ((string_drop s3940 ((string_length (''fa6''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s3930  :: " string "


\<comment> \<open>\<open>val _s388_ : string -> maybe string\<close>\<close>

definition s388  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s388 s3890 = (
   (let s3900 = s3890 in
   if ((string_startswith s3900 (''fa5''))) then  
  (case  ((string_drop s3900 ((string_length (''fa5''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s3890  :: " string "


\<comment> \<open>\<open>val _s384_ : string -> maybe string\<close>\<close>

definition s384  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s384 s3850 = (
   (let s3860 = s3850 in
   if ((string_startswith s3860 (''fa4''))) then  
  (case  ((string_drop s3860 ((string_length (''fa4''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s3850  :: " string "


\<comment> \<open>\<open>val _s380_ : string -> maybe string\<close>\<close>

definition s380  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s380 s3810 = (
   (let s3820 = s3810 in
   if ((string_startswith s3820 (''fa3''))) then  
  (case  ((string_drop s3820 ((string_length (''fa3''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s3810  :: " string "


\<comment> \<open>\<open>val _s376_ : string -> maybe string\<close>\<close>

definition s376  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s376 s3770 = (
   (let s3780 = s3770 in
   if ((string_startswith s3780 (''fa2''))) then  
  (case  ((string_drop s3780 ((string_length (''fa2''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s3770  :: " string "


\<comment> \<open>\<open>val _s372_ : string -> maybe string\<close>\<close>

definition s372  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s372 s3730 = (
   (let s3740 = s3730 in
   if ((string_startswith s3740 (''fa1''))) then  
  (case  ((string_drop s3740 ((string_length (''fa1''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s3730  :: " string "


\<comment> \<open>\<open>val _s368_ : string -> maybe string\<close>\<close>

definition s368  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s368 s3690 = (
   (let s3700 = s3690 in
   if ((string_startswith s3700 (''fa0''))) then  
  (case  ((string_drop s3700 ((string_length (''fa0''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s3690  :: " string "


\<comment> \<open>\<open>val _s364_ : string -> maybe string\<close>\<close>

definition s364  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s364 s3650 = (
   (let s3660 = s3650 in
   if ((string_startswith s3660 (''fs1''))) then  
  (case  ((string_drop s3660 ((string_length (''fs1''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s3650  :: " string "


\<comment> \<open>\<open>val _s360_ : string -> maybe string\<close>\<close>

definition s360  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s360 s3610 = (
   (let s3620 = s3610 in
   if ((string_startswith s3620 (''fs0''))) then  
  (case  ((string_drop s3620 ((string_length (''fs0''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s3610  :: " string "


\<comment> \<open>\<open>val _s356_ : string -> maybe string\<close>\<close>

definition s356  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s356 s3570 = (
   (let s3580 = s3570 in
   if ((string_startswith s3580 (''ft7''))) then  
  (case  ((string_drop s3580 ((string_length (''ft7''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s3570  :: " string "


\<comment> \<open>\<open>val _s352_ : string -> maybe string\<close>\<close>

definition s352  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s352 s3530 = (
   (let s3540 = s3530 in
   if ((string_startswith s3540 (''ft6''))) then  
  (case  ((string_drop s3540 ((string_length (''ft6''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s3530  :: " string "


\<comment> \<open>\<open>val _s348_ : string -> maybe string\<close>\<close>

definition s348  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s348 s3490 = (
   (let s3500 = s3490 in
   if ((string_startswith s3500 (''ft5''))) then  
  (case  ((string_drop s3500 ((string_length (''ft5''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s3490  :: " string "


\<comment> \<open>\<open>val _s344_ : string -> maybe string\<close>\<close>

definition s344  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s344 s3450 = (
   (let s3460 = s3450 in
   if ((string_startswith s3460 (''ft4''))) then  
  (case  ((string_drop s3460 ((string_length (''ft4''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s3450  :: " string "


\<comment> \<open>\<open>val _s340_ : string -> maybe string\<close>\<close>

definition s340  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s340 s3410 = (
   (let s3421 = s3410 in
   if ((string_startswith s3421 (''ft3''))) then  
  (case  ((string_drop s3421 ((string_length (''ft3''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s3410  :: " string "


\<comment> \<open>\<open>val _s336_ : string -> maybe string\<close>\<close>

definition s336  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s336 s3370 = (
   (let s3380 = s3370 in
   if ((string_startswith s3380 (''ft2''))) then  
  (case  ((string_drop s3380 ((string_length (''ft2''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s3370  :: " string "


\<comment> \<open>\<open>val _s332_ : string -> maybe string\<close>\<close>

definition s332  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s332 s3330 = (
   (let s3340 = s3330 in
   if ((string_startswith s3340 (''ft1''))) then  
  (case  ((string_drop s3340 ((string_length (''ft1''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s3330  :: " string "


\<comment> \<open>\<open>val _s328_ : string -> maybe string\<close>\<close>

definition s328  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s328 s3290 = (
   (let s3300 = s3290 in
   if ((string_startswith s3300 (''ft0''))) then  
  (case  ((string_drop s3300 ((string_length (''ft0''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s3290  :: " string "


definition freg_name_matches_prefix  :: \<open> string \<Rightarrow>((5)Word.word*int)option \<close>  where 
     \<open> freg_name_matches_prefix arg1 = (
   (let s3310 = arg1 in
   if ((case  ((s328 s3310)) of   Some (s1) => True | _ => False )) then  
  (case  s328 s3310 of
      (Some (s1)) =>
  Some
    (( 0b00000 :: 5 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s332 s3310)) of   Some (s1) => True | _ => False )) then  
  (case  s332 s3310 of
      (Some (s1)) =>
  Some
    (( 0b00001 :: 5 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s336 s3310)) of   Some (s1) => True | _ => False )) then  
  (case  s336 s3310 of
      (Some (s1)) =>
  Some
    (( 0b00010 :: 5 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s340 s3310)) of   Some (s1) => True | _ => False )) then  
  (case  s340 s3310 of
      (Some (s1)) =>
  Some
    (( 0b00011 :: 5 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s344 s3310)) of   Some (s1) => True | _ => False )) then  
  (case  s344 s3310 of
      (Some (s1)) =>
  Some
    (( 0b00100 :: 5 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s348 s3310)) of   Some (s1) => True | _ => False )) then  
  (case  s348 s3310 of
      (Some (s1)) =>
  Some
    (( 0b00101 :: 5 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s352 s3310)) of   Some (s1) => True | _ => False )) then  
  (case  s352 s3310 of
      (Some (s1)) =>
  Some
    (( 0b00110 :: 5 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s356 s3310)) of   Some (s1) => True | _ => False )) then  
  (case  s356 s3310 of
      (Some (s1)) =>
  Some
    (( 0b00111 :: 5 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s360 s3310)) of   Some (s1) => True | _ => False )) then  
  (case  s360 s3310 of
      (Some (s1)) =>
  Some
    (( 0b01000 :: 5 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s364 s3310)) of   Some (s1) => True | _ => False )) then  
  (case  s364 s3310 of
      (Some (s1)) =>
  Some
    (( 0b01001 :: 5 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s368 s3310)) of   Some (s1) => True | _ => False )) then  
  (case  s368 s3310 of
      (Some (s1)) =>
  Some
    (( 0b01010 :: 5 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s372 s3310)) of   Some (s1) => True | _ => False )) then  
  (case  s372 s3310 of
      (Some (s1)) =>
  Some
    (( 0b01011 :: 5 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s376 s3310)) of   Some (s1) => True | _ => False )) then  
  (case  s376 s3310 of
      (Some (s1)) =>
  Some
    (( 0b01100 :: 5 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s380 s3310)) of   Some (s1) => True | _ => False )) then  
  (case  s380 s3310 of
      (Some (s1)) =>
  Some
    (( 0b01101 :: 5 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s384 s3310)) of   Some (s1) => True | _ => False )) then  
  (case  s384 s3310 of
      (Some (s1)) =>
  Some
    (( 0b01110 :: 5 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s388 s3310)) of   Some (s1) => True | _ => False )) then  
  (case  s388 s3310 of
      (Some (s1)) =>
  Some
    (( 0b01111 :: 5 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s392 s3310)) of   Some (s1) => True | _ => False )) then  
  (case  s392 s3310 of
      (Some (s1)) =>
  Some
    (( 0b10000 :: 5 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s396 s3310)) of   Some (s1) => True | _ => False )) then  
  (case  s396 s3310 of
      (Some (s1)) =>
  Some
    (( 0b10001 :: 5 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s400 s3310)) of   Some (s1) => True | _ => False )) then  
  (case  s400 s3310 of
      (Some (s1)) =>
  Some
    (( 0b10010 :: 5 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s404 s3310)) of   Some (s1) => True | _ => False )) then  
  (case  s404 s3310 of
      (Some (s1)) =>
  Some
    (( 0b10011 :: 5 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s408 s3310)) of   Some (s1) => True | _ => False )) then  
  (case  s408 s3310 of
      (Some (s1)) =>
  Some
    (( 0b10100 :: 5 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s412 s3310)) of   Some (s1) => True | _ => False )) then  
  (case  s412 s3310 of
      (Some (s1)) =>
  Some
    (( 0b10101 :: 5 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s416 s3310)) of   Some (s1) => True | _ => False )) then  
  (case  s416 s3310 of
      (Some (s1)) =>
  Some
    (( 0b10110 :: 5 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s420 s3310)) of   Some (s1) => True | _ => False )) then  
  (case  s420 s3310 of
      (Some (s1)) =>
  Some
    (( 0b10111 :: 5 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s424 s3310)) of   Some (s1) => True | _ => False )) then  
  (case  s424 s3310 of
      (Some (s1)) =>
  Some
    (( 0b11000 :: 5 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s428 s3310)) of   Some (s1) => True | _ => False )) then  
  (case  s428 s3310 of
      (Some (s1)) =>
  Some
    (( 0b11001 :: 5 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s432 s3310)) of   Some (s1) => True | _ => False )) then  
  (case  s432 s3310 of
      (Some (s1)) =>
  Some
    (( 0b11010 :: 5 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s436 s3310)) of   Some (s1) => True | _ => False )) then  
  (case  s436 s3310 of
      (Some (s1)) =>
  Some
    (( 0b11011 :: 5 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s440 s3310)) of   Some (s1) => True | _ => False )) then  
  (case  s440 s3310 of
      (Some (s1)) =>
  Some
    (( 0b11100 :: 5 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s444 s3310)) of   Some (s1) => True | _ => False )) then  
  (case  s444 s3310 of
      (Some (s1)) =>
  Some
    (( 0b11101 :: 5 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s448 s3310)) of   Some (s1) => True | _ => False )) then  
  (case  s448 s3310 of
      (Some (s1)) =>
  Some
    (( 0b11110 :: 5 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s452 s3310)) of   Some (s1) => True | _ => False )) then  
  (case  s452 s3310 of
      (Some (s1)) =>
  Some
    (( 0b11111 :: 5 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else None))\<close> 
  for  arg1  :: " string "


\<comment> \<open>\<open>val init_fdext_regs : unit -> M unit\<close>\<close>

definition init_fdext_regs  :: \<open> unit \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> init_fdext_regs _ = (
   ((((((((((((((((((((((((((((((write_reg f0_ref zero_freg \<then>
   write_reg f1_ref zero_freg) \<then>
   write_reg f2_ref zero_freg) \<then>
   write_reg f3_ref zero_freg) \<then>
   write_reg f4_ref zero_freg) \<then>
   write_reg f5_ref zero_freg) \<then>
   write_reg f6_ref zero_freg) \<then>
   write_reg f7_ref zero_freg) \<then>
   write_reg f8_ref zero_freg) \<then>
   write_reg f9_ref zero_freg) \<then>
   write_reg f10_ref zero_freg) \<then>
   write_reg f11_ref zero_freg) \<then>
   write_reg f12_ref zero_freg) \<then>
   write_reg f13_ref zero_freg) \<then>
   write_reg f14_ref zero_freg) \<then>
   write_reg f15_ref zero_freg) \<then>
   write_reg f16_ref zero_freg) \<then>
   write_reg f17_ref zero_freg) \<then>
   write_reg f18_ref zero_freg) \<then>
   write_reg f19_ref zero_freg) \<then>
   write_reg f20_ref zero_freg) \<then>
   write_reg f21_ref zero_freg) \<then>
   write_reg f22_ref zero_freg) \<then>
   write_reg f23_ref zero_freg) \<then>
   write_reg f24_ref zero_freg) \<then>
   write_reg f25_ref zero_freg) \<then>
   write_reg f26_ref zero_freg) \<then>
   write_reg f27_ref zero_freg) \<then>
   write_reg f28_ref zero_freg) \<then>
   write_reg f29_ref zero_freg) \<then> write_reg f30_ref zero_freg) \<then> write_reg f31_ref zero_freg )\<close>


\<comment> \<open>\<open>val undefined_Fcsr : unit -> M Fcsr\<close>\<close>

definition undefined_Fcsr  :: \<open> unit \<Rightarrow>((register_value),(Fcsr),(exception))monad \<close>  where 
     \<open> undefined_Fcsr _ = (
   ((return (failwith (''undefined value of unsupported type''))) :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::
      32 Word.word) . 
   return ((| Fcsr_bits = w__0 |)))))\<close>


\<comment> \<open>\<open>val Mk_Fcsr : mword ty32 -> Fcsr\<close>\<close>

definition Mk_Fcsr  :: \<open>(32)Word.word \<Rightarrow> Fcsr \<close>  where 
     \<open> Mk_Fcsr v = ( (| Fcsr_bits = v |) )\<close> 
  for  v  :: "(32)Word.word "


definition get_Fcsr_bits  :: \<open> Fcsr \<Rightarrow>(32)Word.word \<close>  where 
     \<open> get_Fcsr_bits v = ( (subrange_vec_dec(Fcsr_bits   v) (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))\<close> 
  for  v  :: " Fcsr "


definition set_Fcsr_bits  :: \<open>((regstate),(register_value),(Fcsr))register_ref \<Rightarrow>(32)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Fcsr_bits r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (| Fcsr_bits := ((update_subrange_vec_dec(Fcsr_bits   r) (( 31 :: int)::ii) (( 0 :: int)::ii) v  ::  32 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Fcsr))register_ref " 
  and  v  :: "(32)Word.word "


definition update_Fcsr_bits  :: \<open> Fcsr \<Rightarrow>(32)Word.word \<Rightarrow> Fcsr \<close>  where 
     \<open> update_Fcsr_bits v x = (
   ( v (| Fcsr_bits := ((update_subrange_vec_dec(Fcsr_bits   v) (( 31 :: int)::ii) (( 0 :: int)::ii) x  ::  32 Word.word)) |)))\<close> 
  for  v  :: " Fcsr " 
  and  x  :: "(32)Word.word "


\<comment> \<open>\<open>val _get_Fcsr_FFLAGS : Fcsr -> mword ty5\<close>\<close>

definition get_Fcsr_FFLAGS  :: \<open> Fcsr \<Rightarrow>(5)Word.word \<close>  where 
     \<open> get_Fcsr_FFLAGS v = ( (subrange_vec_dec(Fcsr_bits   v) (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word))\<close> 
  for  v  :: " Fcsr "


\<comment> \<open>\<open>val _set_Fcsr_FFLAGS : register_ref regstate register_value Fcsr -> mword ty5 -> M unit\<close>\<close>

definition set_Fcsr_FFLAGS  :: \<open>((regstate),(register_value),(Fcsr))register_ref \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Fcsr_FFLAGS r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (| Fcsr_bits := ((update_subrange_vec_dec(Fcsr_bits   r) (( 4 :: int)::ii) (( 0 :: int)::ii) v  ::  32 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Fcsr))register_ref " 
  and  v  :: "(5)Word.word "


\<comment> \<open>\<open>val _update_Fcsr_FFLAGS : Fcsr -> mword ty5 -> Fcsr\<close>\<close>

definition update_Fcsr_FFLAGS  :: \<open> Fcsr \<Rightarrow>(5)Word.word \<Rightarrow> Fcsr \<close>  where 
     \<open> update_Fcsr_FFLAGS v x = (
   ( v (| Fcsr_bits := ((update_subrange_vec_dec(Fcsr_bits   v) (( 4 :: int)::ii) (( 0 :: int)::ii) x  ::  32 Word.word)) |)))\<close> 
  for  v  :: " Fcsr " 
  and  x  :: "(5)Word.word "


\<comment> \<open>\<open>val _get_Fcsr_FRM : Fcsr -> mword ty3\<close>\<close>

definition get_Fcsr_FRM  :: \<open> Fcsr \<Rightarrow>(3)Word.word \<close>  where 
     \<open> get_Fcsr_FRM v = ( (subrange_vec_dec(Fcsr_bits   v) (( 7 :: int)::ii) (( 5 :: int)::ii)  ::  3 Word.word))\<close> 
  for  v  :: " Fcsr "


\<comment> \<open>\<open>val _set_Fcsr_FRM : register_ref regstate register_value Fcsr -> mword ty3 -> M unit\<close>\<close>

definition set_Fcsr_FRM  :: \<open>((regstate),(register_value),(Fcsr))register_ref \<Rightarrow>(3)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_Fcsr_FRM r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (| Fcsr_bits := ((update_subrange_vec_dec(Fcsr_bits   r) (( 7 :: int)::ii) (( 5 :: int)::ii) v  ::  32 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(Fcsr))register_ref " 
  and  v  :: "(3)Word.word "


\<comment> \<open>\<open>val _update_Fcsr_FRM : Fcsr -> mword ty3 -> Fcsr\<close>\<close>

definition update_Fcsr_FRM  :: \<open> Fcsr \<Rightarrow>(3)Word.word \<Rightarrow> Fcsr \<close>  where 
     \<open> update_Fcsr_FRM v x = (
   ( v (| Fcsr_bits := ((update_subrange_vec_dec(Fcsr_bits   v) (( 7 :: int)::ii) (( 5 :: int)::ii) x  ::  32 Word.word)) |)))\<close> 
  for  v  :: " Fcsr " 
  and  x  :: "(3)Word.word "


\<comment> \<open>\<open>val ext_write_fcsr : mword ty3 -> mword ty5 -> M unit\<close>\<close>

definition ext_write_fcsr  :: \<open>(3)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> ext_write_fcsr frm fflags = (
   ((set_Fcsr_FRM fcsr_ref frm \<then>
   set_Fcsr_FFLAGS fcsr_ref fflags) \<then> update_softfloat_fflags fflags) \<then> dirty_fd_context ()  )\<close> 
  for  frm  :: "(3)Word.word " 
  and  fflags  :: "(5)Word.word "


\<comment> \<open>\<open>val write_fflags : mword ty5 -> M unit\<close>\<close>

definition write_fflags  :: \<open>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> write_fflags fflags = (
   read_reg fcsr_ref \<bind> ((\<lambda> (w__0 :: Fcsr) . 
   (if (((((get_Fcsr_FFLAGS w__0  ::  5 Word.word)) \<noteq> fflags))) then dirty_fd_context () 
    else return () ) \<then>
   set_Fcsr_FFLAGS fcsr_ref fflags)))\<close> 
  for  fflags  :: "(5)Word.word "


\<comment> \<open>\<open>val accrue_fflags : mword ty5 -> M unit\<close>\<close>

definition accrue_fflags  :: \<open>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> accrue_fflags flags = (
   read_reg fcsr_ref \<bind> ((\<lambda> (w__0 :: Fcsr) . 
   (let f = ((or_vec ((get_Fcsr_FFLAGS w__0  ::  5 Word.word)) flags  ::  5 Word.word)) in
   read_reg fcsr_ref \<bind> ((\<lambda> (w__1 :: Fcsr) . 
   if (((((get_Fcsr_FFLAGS w__1  ::  5 Word.word)) \<noteq> f))) then
     (set_Fcsr_FFLAGS fcsr_ref f \<then> update_softfloat_fflags f) \<then> dirty_fd_context () 
   else return () ))))))\<close> 
  for  flags  :: "(5)Word.word "


definition csr_name_map_forwards  :: \<open>(12)Word.word \<Rightarrow> string \<close>  where 
     \<open> csr_name_map_forwards arg1 = (
   (let b__0 = arg1 in
   if (((b__0 = ( 0x000 ::  12 Word.word)))) then (''ustatus'')
   else if (((b__0 = ( 0x004 ::  12 Word.word)))) then (''uie'')
   else if (((b__0 = ( 0x005 ::  12 Word.word)))) then (''utvec'')
   else if (((b__0 = ( 0x040 ::  12 Word.word)))) then (''uscratch'')
   else if (((b__0 = ( 0x041 ::  12 Word.word)))) then (''uepc'')
   else if (((b__0 = ( 0x042 ::  12 Word.word)))) then (''ucause'')
   else if (((b__0 = ( 0x043 ::  12 Word.word)))) then (''utval'')
   else if (((b__0 = ( 0x044 ::  12 Word.word)))) then (''uip'')
   else if (((b__0 = ( 0x001 ::  12 Word.word)))) then (''fflags'')
   else if (((b__0 = ( 0x002 ::  12 Word.word)))) then (''frm'')
   else if (((b__0 = ( 0x003 ::  12 Word.word)))) then (''fcsr'')
   else if (((b__0 = ( 0xC00 ::  12 Word.word)))) then (''cycle'')
   else if (((b__0 = ( 0xC01 ::  12 Word.word)))) then (''time'')
   else if (((b__0 = ( 0xC02 ::  12 Word.word)))) then (''instret'')
   else if (((b__0 = ( 0xC80 ::  12 Word.word)))) then (''cycleh'')
   else if (((b__0 = ( 0xC81 ::  12 Word.word)))) then (''timeh'')
   else if (((b__0 = ( 0xC82 ::  12 Word.word)))) then (''instreth'')
   else if (((b__0 = ( 0x100 ::  12 Word.word)))) then (''sstatus'')
   else if (((b__0 = ( 0x102 ::  12 Word.word)))) then (''sedeleg'')
   else if (((b__0 = ( 0x103 ::  12 Word.word)))) then (''sideleg'')
   else if (((b__0 = ( 0x104 ::  12 Word.word)))) then (''sie'')
   else if (((b__0 = ( 0x105 ::  12 Word.word)))) then (''stvec'')
   else if (((b__0 = ( 0x106 ::  12 Word.word)))) then (''scounteren'')
   else if (((b__0 = ( 0x140 ::  12 Word.word)))) then (''sscratch'')
   else if (((b__0 = ( 0x141 ::  12 Word.word)))) then (''sepc'')
   else if (((b__0 = ( 0x142 ::  12 Word.word)))) then (''scause'')
   else if (((b__0 = ( 0x143 ::  12 Word.word)))) then (''stval'')
   else if (((b__0 = ( 0x144 ::  12 Word.word)))) then (''sip'')
   else if (((b__0 = ( 0x180 ::  12 Word.word)))) then (''satp'')
   else if (((b__0 = ( 0xF11 ::  12 Word.word)))) then (''mvendorid'')
   else if (((b__0 = ( 0xF12 ::  12 Word.word)))) then (''marchid'')
   else if (((b__0 = ( 0xF13 ::  12 Word.word)))) then (''mimpid'')
   else if (((b__0 = ( 0xF14 ::  12 Word.word)))) then (''mhartid'')
   else if (((b__0 = ( 0x300 ::  12 Word.word)))) then (''mstatus'')
   else if (((b__0 = ( 0x301 ::  12 Word.word)))) then (''misa'')
   else if (((b__0 = ( 0x302 ::  12 Word.word)))) then (''medeleg'')
   else if (((b__0 = ( 0x303 ::  12 Word.word)))) then (''mideleg'')
   else if (((b__0 = ( 0x304 ::  12 Word.word)))) then (''mie'')
   else if (((b__0 = ( 0x305 ::  12 Word.word)))) then (''mtvec'')
   else if (((b__0 = ( 0x306 ::  12 Word.word)))) then (''mcounteren'')
   else if (((b__0 = ( 0x320 ::  12 Word.word)))) then (''mcountinhibit'')
   else if (((b__0 = ( 0x340 ::  12 Word.word)))) then (''mscratch'')
   else if (((b__0 = ( 0x341 ::  12 Word.word)))) then (''mepc'')
   else if (((b__0 = ( 0x342 ::  12 Word.word)))) then (''mcause'')
   else if (((b__0 = ( 0x343 ::  12 Word.word)))) then (''mtval'')
   else if (((b__0 = ( 0x344 ::  12 Word.word)))) then (''mip'')
   else if (((b__0 = ( 0x3A0 ::  12 Word.word)))) then (''pmpcfg0'')
   else if (((b__0 = ( 0x3A1 ::  12 Word.word)))) then (''pmpcfg1'')
   else if (((b__0 = ( 0x3A2 ::  12 Word.word)))) then (''pmpcfg2'')
   else if (((b__0 = ( 0x3A3 ::  12 Word.word)))) then (''pmpcfg3'')
   else if (((b__0 = ( 0x3B0 ::  12 Word.word)))) then (''pmpaddr0'')
   else if (((b__0 = ( 0x3B1 ::  12 Word.word)))) then (''pmpaddr1'')
   else if (((b__0 = ( 0x3B2 ::  12 Word.word)))) then (''pmpaddr2'')
   else if (((b__0 = ( 0x3B3 ::  12 Word.word)))) then (''pmpaddr3'')
   else if (((b__0 = ( 0x3B4 ::  12 Word.word)))) then (''pmpaddr4'')
   else if (((b__0 = ( 0x3B5 ::  12 Word.word)))) then (''pmpaddr5'')
   else if (((b__0 = ( 0x3B6 ::  12 Word.word)))) then (''pmpaddr6'')
   else if (((b__0 = ( 0x3B7 ::  12 Word.word)))) then (''pmpaddr7'')
   else if (((b__0 = ( 0x3B8 ::  12 Word.word)))) then (''pmpaddr8'')
   else if (((b__0 = ( 0x3B9 ::  12 Word.word)))) then (''pmpaddr9'')
   else if (((b__0 = ( 0x3BA ::  12 Word.word)))) then (''pmpaddr10'')
   else if (((b__0 = ( 0x3BB ::  12 Word.word)))) then (''pmpaddr11'')
   else if (((b__0 = ( 0x3BC ::  12 Word.word)))) then (''pmpaddr12'')
   else if (((b__0 = ( 0x3BD ::  12 Word.word)))) then (''pmpaddr13'')
   else if (((b__0 = ( 0x3BE ::  12 Word.word)))) then (''pmpaddr14'')
   else if (((b__0 = ( 0x3BF ::  12 Word.word)))) then (''pmpaddr15'')
   else if (((b__0 = ( 0xB00 ::  12 Word.word)))) then (''mcycle'')
   else if (((b__0 = ( 0xB02 ::  12 Word.word)))) then (''minstret'')
   else if (((b__0 = ( 0xB80 ::  12 Word.word)))) then (''mcycleh'')
   else if (((b__0 = ( 0xB82 ::  12 Word.word)))) then (''minstreth'')
   else if (((b__0 = ( 0x7A0 ::  12 Word.word)))) then (''tselect'')
   else if (((b__0 = ( 0x7A1 ::  12 Word.word)))) then (''tdata1'')
   else if (((b__0 = ( 0x7A2 ::  12 Word.word)))) then (''tdata2'')
   else if (((b__0 = ( 0x7A3 ::  12 Word.word)))) then (''tdata3'')
   else decimal_string_of_bits b__0))\<close> 
  for  arg1  :: "(12)Word.word "


definition csr_name_map_backwards  :: \<open> string \<Rightarrow>((register_value),((12)Word.word),(exception))monad \<close>  where 
     \<open> csr_name_map_backwards arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''ustatus'')))) then return ( 0x000 ::  12 Word.word)
   else if (((p00 = (''uie'')))) then return ( 0x004 ::  12 Word.word)
   else if (((p00 = (''utvec'')))) then return ( 0x005 ::  12 Word.word)
   else if (((p00 = (''uscratch'')))) then return ( 0x040 ::  12 Word.word)
   else if (((p00 = (''uepc'')))) then return ( 0x041 ::  12 Word.word)
   else if (((p00 = (''ucause'')))) then return ( 0x042 ::  12 Word.word)
   else if (((p00 = (''utval'')))) then return ( 0x043 ::  12 Word.word)
   else if (((p00 = (''uip'')))) then return ( 0x044 ::  12 Word.word)
   else if (((p00 = (''fflags'')))) then return ( 0x001 ::  12 Word.word)
   else if (((p00 = (''frm'')))) then return ( 0x002 ::  12 Word.word)
   else if (((p00 = (''fcsr'')))) then return ( 0x003 ::  12 Word.word)
   else if (((p00 = (''cycle'')))) then return ( 0xC00 ::  12 Word.word)
   else if (((p00 = (''time'')))) then return ( 0xC01 ::  12 Word.word)
   else if (((p00 = (''instret'')))) then return ( 0xC02 ::  12 Word.word)
   else if (((p00 = (''cycleh'')))) then return ( 0xC80 ::  12 Word.word)
   else if (((p00 = (''timeh'')))) then return ( 0xC81 ::  12 Word.word)
   else if (((p00 = (''instreth'')))) then return ( 0xC82 ::  12 Word.word)
   else if (((p00 = (''sstatus'')))) then return ( 0x100 ::  12 Word.word)
   else if (((p00 = (''sedeleg'')))) then return ( 0x102 ::  12 Word.word)
   else if (((p00 = (''sideleg'')))) then return ( 0x103 ::  12 Word.word)
   else if (((p00 = (''sie'')))) then return ( 0x104 ::  12 Word.word)
   else if (((p00 = (''stvec'')))) then return ( 0x105 ::  12 Word.word)
   else if (((p00 = (''scounteren'')))) then return ( 0x106 ::  12 Word.word)
   else if (((p00 = (''sscratch'')))) then return ( 0x140 ::  12 Word.word)
   else if (((p00 = (''sepc'')))) then return ( 0x141 ::  12 Word.word)
   else if (((p00 = (''scause'')))) then return ( 0x142 ::  12 Word.word)
   else if (((p00 = (''stval'')))) then return ( 0x143 ::  12 Word.word)
   else if (((p00 = (''sip'')))) then return ( 0x144 ::  12 Word.word)
   else if (((p00 = (''satp'')))) then return ( 0x180 ::  12 Word.word)
   else if (((p00 = (''mvendorid'')))) then return ( 0xF11 ::  12 Word.word)
   else if (((p00 = (''marchid'')))) then return ( 0xF12 ::  12 Word.word)
   else if (((p00 = (''mimpid'')))) then return ( 0xF13 ::  12 Word.word)
   else if (((p00 = (''mhartid'')))) then return ( 0xF14 ::  12 Word.word)
   else if (((p00 = (''mstatus'')))) then return ( 0x300 ::  12 Word.word)
   else if (((p00 = (''misa'')))) then return ( 0x301 ::  12 Word.word)
   else if (((p00 = (''medeleg'')))) then return ( 0x302 ::  12 Word.word)
   else if (((p00 = (''mideleg'')))) then return ( 0x303 ::  12 Word.word)
   else if (((p00 = (''mie'')))) then return ( 0x304 ::  12 Word.word)
   else if (((p00 = (''mtvec'')))) then return ( 0x305 ::  12 Word.word)
   else if (((p00 = (''mcounteren'')))) then return ( 0x306 ::  12 Word.word)
   else if (((p00 = (''mcountinhibit'')))) then return ( 0x320 ::  12 Word.word)
   else if (((p00 = (''mscratch'')))) then return ( 0x340 ::  12 Word.word)
   else if (((p00 = (''mepc'')))) then return ( 0x341 ::  12 Word.word)
   else if (((p00 = (''mcause'')))) then return ( 0x342 ::  12 Word.word)
   else if (((p00 = (''mtval'')))) then return ( 0x343 ::  12 Word.word)
   else if (((p00 = (''mip'')))) then return ( 0x344 ::  12 Word.word)
   else if (((p00 = (''pmpcfg0'')))) then return ( 0x3A0 ::  12 Word.word)
   else if (((p00 = (''pmpcfg1'')))) then return ( 0x3A1 ::  12 Word.word)
   else if (((p00 = (''pmpcfg2'')))) then return ( 0x3A2 ::  12 Word.word)
   else if (((p00 = (''pmpcfg3'')))) then return ( 0x3A3 ::  12 Word.word)
   else if (((p00 = (''pmpaddr0'')))) then return ( 0x3B0 ::  12 Word.word)
   else if (((p00 = (''pmpaddr1'')))) then return ( 0x3B1 ::  12 Word.word)
   else if (((p00 = (''pmpaddr2'')))) then return ( 0x3B2 ::  12 Word.word)
   else if (((p00 = (''pmpaddr3'')))) then return ( 0x3B3 ::  12 Word.word)
   else if (((p00 = (''pmpaddr4'')))) then return ( 0x3B4 ::  12 Word.word)
   else if (((p00 = (''pmpaddr5'')))) then return ( 0x3B5 ::  12 Word.word)
   else if (((p00 = (''pmpaddr6'')))) then return ( 0x3B6 ::  12 Word.word)
   else if (((p00 = (''pmpaddr7'')))) then return ( 0x3B7 ::  12 Word.word)
   else if (((p00 = (''pmpaddr8'')))) then return ( 0x3B8 ::  12 Word.word)
   else if (((p00 = (''pmpaddr9'')))) then return ( 0x3B9 ::  12 Word.word)
   else if (((p00 = (''pmpaddr10'')))) then return ( 0x3BA ::  12 Word.word)
   else if (((p00 = (''pmpaddr11'')))) then return ( 0x3BB ::  12 Word.word)
   else if (((p00 = (''pmpaddr12'')))) then return ( 0x3BC ::  12 Word.word)
   else if (((p00 = (''pmpaddr13'')))) then return ( 0x3BD ::  12 Word.word)
   else if (((p00 = (''pmpaddr14'')))) then return ( 0x3BE ::  12 Word.word)
   else if (((p00 = (''pmpaddr15'')))) then return ( 0x3BF ::  12 Word.word)
   else if (((p00 = (''mcycle'')))) then return ( 0xB00 ::  12 Word.word)
   else if (((p00 = (''minstret'')))) then return ( 0xB02 ::  12 Word.word)
   else if (((p00 = (''mcycleh'')))) then return ( 0xB80 ::  12 Word.word)
   else if (((p00 = (''minstreth'')))) then return ( 0xB82 ::  12 Word.word)
   else if (((p00 = (''tselect'')))) then return ( 0x7A0 ::  12 Word.word)
   else if (((p00 = (''tdata1'')))) then return ( 0x7A1 ::  12 Word.word)
   else if (((p00 = (''tdata2'')))) then return ( 0x7A2 ::  12 Word.word)
   else if (((p00 = (''tdata3'')))) then return ( 0x7A3 ::  12 Word.word)
   else if ((hex_bits_12_backwards_matches p00)) then (hex_bits_12_backwards p00  :: ( 12 Word.word) M)
   else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))\<close> 
  for  arg1  :: " string "


definition csr_name_map_forwards_matches  :: \<open>(12)Word.word \<Rightarrow> bool \<close>  where 
     \<open> csr_name_map_forwards_matches arg1 = (
   (let b__0 = arg1 in
   if (((b__0 = ( 0x000 ::  12 Word.word)))) then True
   else if (((b__0 = ( 0x004 ::  12 Word.word)))) then True
   else if (((b__0 = ( 0x005 ::  12 Word.word)))) then True
   else if (((b__0 = ( 0x040 ::  12 Word.word)))) then True
   else if (((b__0 = ( 0x041 ::  12 Word.word)))) then True
   else if (((b__0 = ( 0x042 ::  12 Word.word)))) then True
   else if (((b__0 = ( 0x043 ::  12 Word.word)))) then True
   else if (((b__0 = ( 0x044 ::  12 Word.word)))) then True
   else if (((b__0 = ( 0x001 ::  12 Word.word)))) then True
   else if (((b__0 = ( 0x002 ::  12 Word.word)))) then True
   else if (((b__0 = ( 0x003 ::  12 Word.word)))) then True
   else if (((b__0 = ( 0xC00 ::  12 Word.word)))) then True
   else if (((b__0 = ( 0xC01 ::  12 Word.word)))) then True
   else if (((b__0 = ( 0xC02 ::  12 Word.word)))) then True
   else if (((b__0 = ( 0xC80 ::  12 Word.word)))) then True
   else if (((b__0 = ( 0xC81 ::  12 Word.word)))) then True
   else if (((b__0 = ( 0xC82 ::  12 Word.word)))) then True
   else if (((b__0 = ( 0x100 ::  12 Word.word)))) then True
   else if (((b__0 = ( 0x102 ::  12 Word.word)))) then True
   else if (((b__0 = ( 0x103 ::  12 Word.word)))) then True
   else if (((b__0 = ( 0x104 ::  12 Word.word)))) then True
   else if (((b__0 = ( 0x105 ::  12 Word.word)))) then True
   else if (((b__0 = ( 0x106 ::  12 Word.word)))) then True
   else if (((b__0 = ( 0x140 ::  12 Word.word)))) then True
   else if (((b__0 = ( 0x141 ::  12 Word.word)))) then True
   else if (((b__0 = ( 0x142 ::  12 Word.word)))) then True
   else if (((b__0 = ( 0x143 ::  12 Word.word)))) then True
   else if (((b__0 = ( 0x144 ::  12 Word.word)))) then True
   else if (((b__0 = ( 0x180 ::  12 Word.word)))) then True
   else if (((b__0 = ( 0xF11 ::  12 Word.word)))) then True
   else if (((b__0 = ( 0xF12 ::  12 Word.word)))) then True
   else if (((b__0 = ( 0xF13 ::  12 Word.word)))) then True
   else if (((b__0 = ( 0xF14 ::  12 Word.word)))) then True
   else if (((b__0 = ( 0x300 ::  12 Word.word)))) then True
   else if (((b__0 = ( 0x301 ::  12 Word.word)))) then True
   else if (((b__0 = ( 0x302 ::  12 Word.word)))) then True
   else if (((b__0 = ( 0x303 ::  12 Word.word)))) then True
   else if (((b__0 = ( 0x304 ::  12 Word.word)))) then True
   else if (((b__0 = ( 0x305 ::  12 Word.word)))) then True
   else if (((b__0 = ( 0x306 ::  12 Word.word)))) then True
   else if (((b__0 = ( 0x320 ::  12 Word.word)))) then True
   else if (((b__0 = ( 0x340 ::  12 Word.word)))) then True
   else if (((b__0 = ( 0x341 ::  12 Word.word)))) then True
   else if (((b__0 = ( 0x342 ::  12 Word.word)))) then True
   else if (((b__0 = ( 0x343 ::  12 Word.word)))) then True
   else if (((b__0 = ( 0x344 ::  12 Word.word)))) then True
   else if (((b__0 = ( 0x3A0 ::  12 Word.word)))) then True
   else if (((b__0 = ( 0x3A1 ::  12 Word.word)))) then True
   else if (((b__0 = ( 0x3A2 ::  12 Word.word)))) then True
   else if (((b__0 = ( 0x3A3 ::  12 Word.word)))) then True
   else if (((b__0 = ( 0x3B0 ::  12 Word.word)))) then True
   else if (((b__0 = ( 0x3B1 ::  12 Word.word)))) then True
   else if (((b__0 = ( 0x3B2 ::  12 Word.word)))) then True
   else if (((b__0 = ( 0x3B3 ::  12 Word.word)))) then True
   else if (((b__0 = ( 0x3B4 ::  12 Word.word)))) then True
   else if (((b__0 = ( 0x3B5 ::  12 Word.word)))) then True
   else if (((b__0 = ( 0x3B6 ::  12 Word.word)))) then True
   else if (((b__0 = ( 0x3B7 ::  12 Word.word)))) then True
   else if (((b__0 = ( 0x3B8 ::  12 Word.word)))) then True
   else if (((b__0 = ( 0x3B9 ::  12 Word.word)))) then True
   else if (((b__0 = ( 0x3BA ::  12 Word.word)))) then True
   else if (((b__0 = ( 0x3BB ::  12 Word.word)))) then True
   else if (((b__0 = ( 0x3BC ::  12 Word.word)))) then True
   else if (((b__0 = ( 0x3BD ::  12 Word.word)))) then True
   else if (((b__0 = ( 0x3BE ::  12 Word.word)))) then True
   else if (((b__0 = ( 0x3BF ::  12 Word.word)))) then True
   else if (((b__0 = ( 0xB00 ::  12 Word.word)))) then True
   else if (((b__0 = ( 0xB02 ::  12 Word.word)))) then True
   else if (((b__0 = ( 0xB80 ::  12 Word.word)))) then True
   else if (((b__0 = ( 0xB82 ::  12 Word.word)))) then True
   else if (((b__0 = ( 0x7A0 ::  12 Word.word)))) then True
   else if (((b__0 = ( 0x7A1 ::  12 Word.word)))) then True
   else if (((b__0 = ( 0x7A2 ::  12 Word.word)))) then True
   else if (((b__0 = ( 0x7A3 ::  12 Word.word)))) then True
   else True))\<close> 
  for  arg1  :: "(12)Word.word "


definition csr_name_map_backwards_matches  :: \<open> string \<Rightarrow>((register_value),(bool),(exception))monad \<close>  where 
     \<open> csr_name_map_backwards_matches arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''ustatus'')))) then return True
   else if (((p00 = (''uie'')))) then return True
   else if (((p00 = (''utvec'')))) then return True
   else if (((p00 = (''uscratch'')))) then return True
   else if (((p00 = (''uepc'')))) then return True
   else if (((p00 = (''ucause'')))) then return True
   else if (((p00 = (''utval'')))) then return True
   else if (((p00 = (''uip'')))) then return True
   else if (((p00 = (''fflags'')))) then return True
   else if (((p00 = (''frm'')))) then return True
   else if (((p00 = (''fcsr'')))) then return True
   else if (((p00 = (''cycle'')))) then return True
   else if (((p00 = (''time'')))) then return True
   else if (((p00 = (''instret'')))) then return True
   else if (((p00 = (''cycleh'')))) then return True
   else if (((p00 = (''timeh'')))) then return True
   else if (((p00 = (''instreth'')))) then return True
   else if (((p00 = (''sstatus'')))) then return True
   else if (((p00 = (''sedeleg'')))) then return True
   else if (((p00 = (''sideleg'')))) then return True
   else if (((p00 = (''sie'')))) then return True
   else if (((p00 = (''stvec'')))) then return True
   else if (((p00 = (''scounteren'')))) then return True
   else if (((p00 = (''sscratch'')))) then return True
   else if (((p00 = (''sepc'')))) then return True
   else if (((p00 = (''scause'')))) then return True
   else if (((p00 = (''stval'')))) then return True
   else if (((p00 = (''sip'')))) then return True
   else if (((p00 = (''satp'')))) then return True
   else if (((p00 = (''mvendorid'')))) then return True
   else if (((p00 = (''marchid'')))) then return True
   else if (((p00 = (''mimpid'')))) then return True
   else if (((p00 = (''mhartid'')))) then return True
   else if (((p00 = (''mstatus'')))) then return True
   else if (((p00 = (''misa'')))) then return True
   else if (((p00 = (''medeleg'')))) then return True
   else if (((p00 = (''mideleg'')))) then return True
   else if (((p00 = (''mie'')))) then return True
   else if (((p00 = (''mtvec'')))) then return True
   else if (((p00 = (''mcounteren'')))) then return True
   else if (((p00 = (''mcountinhibit'')))) then return True
   else if (((p00 = (''mscratch'')))) then return True
   else if (((p00 = (''mepc'')))) then return True
   else if (((p00 = (''mcause'')))) then return True
   else if (((p00 = (''mtval'')))) then return True
   else if (((p00 = (''mip'')))) then return True
   else if (((p00 = (''pmpcfg0'')))) then return True
   else if (((p00 = (''pmpcfg1'')))) then return True
   else if (((p00 = (''pmpcfg2'')))) then return True
   else if (((p00 = (''pmpcfg3'')))) then return True
   else if (((p00 = (''pmpaddr0'')))) then return True
   else if (((p00 = (''pmpaddr1'')))) then return True
   else if (((p00 = (''pmpaddr2'')))) then return True
   else if (((p00 = (''pmpaddr3'')))) then return True
   else if (((p00 = (''pmpaddr4'')))) then return True
   else if (((p00 = (''pmpaddr5'')))) then return True
   else if (((p00 = (''pmpaddr6'')))) then return True
   else if (((p00 = (''pmpaddr7'')))) then return True
   else if (((p00 = (''pmpaddr8'')))) then return True
   else if (((p00 = (''pmpaddr9'')))) then return True
   else if (((p00 = (''pmpaddr10'')))) then return True
   else if (((p00 = (''pmpaddr11'')))) then return True
   else if (((p00 = (''pmpaddr12'')))) then return True
   else if (((p00 = (''pmpaddr13'')))) then return True
   else if (((p00 = (''pmpaddr14'')))) then return True
   else if (((p00 = (''pmpaddr15'')))) then return True
   else if (((p00 = (''mcycle'')))) then return True
   else if (((p00 = (''minstret'')))) then return True
   else if (((p00 = (''mcycleh'')))) then return True
   else if (((p00 = (''minstreth'')))) then return True
   else if (((p00 = (''tselect'')))) then return True
   else if (((p00 = (''tdata1'')))) then return True
   else if (((p00 = (''tdata2'')))) then return True
   else if (((p00 = (''tdata3'')))) then return True
   else if ((hex_bits_12_backwards_matches p00)) then
     (hex_bits_12_backwards p00  :: ( 12 Word.word) M) \<bind> ((\<lambda> reg .  return True))
   else return False))\<close> 
  for  arg1  :: " string "


\<comment> \<open>\<open>val _s752_ : string -> maybe ((mword ty12 * string))\<close>\<close>

definition s752  :: \<open> string \<Rightarrow>((12)Word.word*string)option \<close>  where 
     \<open> s752 s7540 = (
      (case  ((hex_bits_12_matches_prefix0 s7540  ::  (( 12 Word.word * ii))option)) of
        Some ((reg, s7550)) => 
  (case  ((string_drop s7540 s7550)) of   s1 => Some (reg, s1) )
      | _ => None
      ))\<close> 
  for  s7540  :: " string "


\<comment> \<open>\<open>val _s748_ : string -> maybe string\<close>\<close>

definition s748  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s748 s7490 = (
   (let s7500 = s7490 in
   if ((string_startswith s7500 (''tdata3''))) then  
  (case  ((string_drop s7500 ((string_length (''tdata3''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s7490  :: " string "


\<comment> \<open>\<open>val _s744_ : string -> maybe string\<close>\<close>

definition s744  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s744 s7450 = (
   (let s7460 = s7450 in
   if ((string_startswith s7460 (''tdata2''))) then  
  (case  ((string_drop s7460 ((string_length (''tdata2''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s7450  :: " string "


\<comment> \<open>\<open>val _s740_ : string -> maybe string\<close>\<close>

definition s740  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s740 s7410 = (
   (let s7420 = s7410 in
   if ((string_startswith s7420 (''tdata1''))) then  
  (case  ((string_drop s7420 ((string_length (''tdata1''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s7410  :: " string "


\<comment> \<open>\<open>val _s736_ : string -> maybe string\<close>\<close>

definition s736  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s736 s7370 = (
   (let s7380 = s7370 in
   if ((string_startswith s7380 (''tselect''))) then  
  (case  ((string_drop s7380 ((string_length (''tselect''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s7370  :: " string "


\<comment> \<open>\<open>val _s732_ : string -> maybe string\<close>\<close>

definition s732  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s732 s7330 = (
   (let s7340 = s7330 in
   if ((string_startswith s7340 (''minstreth''))) then  
  (case  ((string_drop s7340 ((string_length (''minstreth''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s7330  :: " string "


\<comment> \<open>\<open>val _s728_ : string -> maybe string\<close>\<close>

definition s728  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s728 s7290 = (
   (let s7300 = s7290 in
   if ((string_startswith s7300 (''mcycleh''))) then  
  (case  ((string_drop s7300 ((string_length (''mcycleh''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s7290  :: " string "


\<comment> \<open>\<open>val _s724_ : string -> maybe string\<close>\<close>

definition s724  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s724 s7250 = (
   (let s7260 = s7250 in
   if ((string_startswith s7260 (''minstret''))) then  
  (case  ((string_drop s7260 ((string_length (''minstret''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s7250  :: " string "


\<comment> \<open>\<open>val _s720_ : string -> maybe string\<close>\<close>

definition s720  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s720 s7210 = (
   (let s7220 = s7210 in
   if ((string_startswith s7220 (''mcycle''))) then  
  (case  ((string_drop s7220 ((string_length (''mcycle''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s7210  :: " string "


\<comment> \<open>\<open>val _s716_ : string -> maybe string\<close>\<close>

definition s716  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s716 s7170 = (
   (let s7180 = s7170 in
   if ((string_startswith s7180 (''pmpaddr15''))) then  
  (case  ((string_drop s7180 ((string_length (''pmpaddr15''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s7170  :: " string "


\<comment> \<open>\<open>val _s712_ : string -> maybe string\<close>\<close>

definition s712  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s712 s7130 = (
   (let s7140 = s7130 in
   if ((string_startswith s7140 (''pmpaddr14''))) then  
  (case  ((string_drop s7140 ((string_length (''pmpaddr14''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s7130  :: " string "


\<comment> \<open>\<open>val _s708_ : string -> maybe string\<close>\<close>

definition s708  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s708 s7090 = (
   (let s7100 = s7090 in
   if ((string_startswith s7100 (''pmpaddr13''))) then  
  (case  ((string_drop s7100 ((string_length (''pmpaddr13''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s7090  :: " string "


\<comment> \<open>\<open>val _s704_ : string -> maybe string\<close>\<close>

definition s704  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s704 s7050 = (
   (let s7060 = s7050 in
   if ((string_startswith s7060 (''pmpaddr12''))) then  
  (case  ((string_drop s7060 ((string_length (''pmpaddr12''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s7050  :: " string "


\<comment> \<open>\<open>val _s700_ : string -> maybe string\<close>\<close>

definition s700  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s700 s7010 = (
   (let s7020 = s7010 in
   if ((string_startswith s7020 (''pmpaddr11''))) then  
  (case  ((string_drop s7020 ((string_length (''pmpaddr11''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s7010  :: " string "


\<comment> \<open>\<open>val _s696_ : string -> maybe string\<close>\<close>

definition s696  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s696 s6970 = (
   (let s6980 = s6970 in
   if ((string_startswith s6980 (''pmpaddr10''))) then  
  (case  ((string_drop s6980 ((string_length (''pmpaddr10''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s6970  :: " string "


\<comment> \<open>\<open>val _s692_ : string -> maybe string\<close>\<close>

definition s692  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s692 s6930 = (
   (let s6940 = s6930 in
   if ((string_startswith s6940 (''pmpaddr9''))) then  
  (case  ((string_drop s6940 ((string_length (''pmpaddr9''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s6930  :: " string "


\<comment> \<open>\<open>val _s688_ : string -> maybe string\<close>\<close>

definition s688  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s688 s6890 = (
   (let s6901 = s6890 in
   if ((string_startswith s6901 (''pmpaddr8''))) then  
  (case  ((string_drop s6901 ((string_length (''pmpaddr8''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s6890  :: " string "


\<comment> \<open>\<open>val _s684_ : string -> maybe string\<close>\<close>

definition s684  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s684 s6850 = (
   (let s6860 = s6850 in
   if ((string_startswith s6860 (''pmpaddr7''))) then  
  (case  ((string_drop s6860 ((string_length (''pmpaddr7''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s6850  :: " string "


\<comment> \<open>\<open>val _s680_ : string -> maybe string\<close>\<close>

definition s680  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s680 s6810 = (
   (let s6820 = s6810 in
   if ((string_startswith s6820 (''pmpaddr6''))) then  
  (case  ((string_drop s6820 ((string_length (''pmpaddr6''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s6810  :: " string "


\<comment> \<open>\<open>val _s676_ : string -> maybe string\<close>\<close>

definition s676  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s676 s6770 = (
   (let s6780 = s6770 in
   if ((string_startswith s6780 (''pmpaddr5''))) then  
  (case  ((string_drop s6780 ((string_length (''pmpaddr5''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s6770  :: " string "


\<comment> \<open>\<open>val _s672_ : string -> maybe string\<close>\<close>

definition s672  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s672 s6731 = (
   (let s6740 = s6731 in
   if ((string_startswith s6740 (''pmpaddr4''))) then  
  (case  ((string_drop s6740 ((string_length (''pmpaddr4''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s6731  :: " string "


\<comment> \<open>\<open>val _s668_ : string -> maybe string\<close>\<close>

definition s668  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s668 s6690 = (
   (let s6700 = s6690 in
   if ((string_startswith s6700 (''pmpaddr3''))) then  
  (case  ((string_drop s6700 ((string_length (''pmpaddr3''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s6690  :: " string "


\<comment> \<open>\<open>val _s664_ : string -> maybe string\<close>\<close>

definition s664  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s664 s6650 = (
   (let s6660 = s6650 in
   if ((string_startswith s6660 (''pmpaddr2''))) then  
  (case  ((string_drop s6660 ((string_length (''pmpaddr2''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s6650  :: " string "


\<comment> \<open>\<open>val _s660_ : string -> maybe string\<close>\<close>

definition s660  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s660 s6610 = (
   (let s6620 = s6610 in
   if ((string_startswith s6620 (''pmpaddr1''))) then  
  (case  ((string_drop s6620 ((string_length (''pmpaddr1''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s6610  :: " string "


\<comment> \<open>\<open>val _s656_ : string -> maybe string\<close>\<close>

definition s656  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s656 s6570 = (
   (let s6580 = s6570 in
   if ((string_startswith s6580 (''pmpaddr0''))) then  
  (case  ((string_drop s6580 ((string_length (''pmpaddr0''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s6570  :: " string "


\<comment> \<open>\<open>val _s652_ : string -> maybe string\<close>\<close>

definition s652  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s652 s6531 = (
   (let s6540 = s6531 in
   if ((string_startswith s6540 (''pmpcfg3''))) then  
  (case  ((string_drop s6540 ((string_length (''pmpcfg3''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s6531  :: " string "


\<comment> \<open>\<open>val _s648_ : string -> maybe string\<close>\<close>

definition s648  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s648 s6490 = (
   (let s6500 = s6490 in
   if ((string_startswith s6500 (''pmpcfg2''))) then  
  (case  ((string_drop s6500 ((string_length (''pmpcfg2''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s6490  :: " string "


\<comment> \<open>\<open>val _s644_ : string -> maybe string\<close>\<close>

definition s644  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s644 s6450 = (
   (let s6460 = s6450 in
   if ((string_startswith s6460 (''pmpcfg1''))) then  
  (case  ((string_drop s6460 ((string_length (''pmpcfg1''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s6450  :: " string "


\<comment> \<open>\<open>val _s640_ : string -> maybe string\<close>\<close>

definition s640  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s640 s6410 = (
   (let s6420 = s6410 in
   if ((string_startswith s6420 (''pmpcfg0''))) then  
  (case  ((string_drop s6420 ((string_length (''pmpcfg0''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s6410  :: " string "


\<comment> \<open>\<open>val _s636_ : string -> maybe string\<close>\<close>

definition s636  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s636 s6370 = (
   (let s6380 = s6370 in
   if ((string_startswith s6380 (''mip''))) then  
  (case  ((string_drop s6380 ((string_length (''mip''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s6370  :: " string "


\<comment> \<open>\<open>val _s632_ : string -> maybe string\<close>\<close>

definition s632  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s632 s6330 = (
   (let s6340 = s6330 in
   if ((string_startswith s6340 (''mtval''))) then  
  (case  ((string_drop s6340 ((string_length (''mtval''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s6330  :: " string "


\<comment> \<open>\<open>val _s628_ : string -> maybe string\<close>\<close>

definition s628  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s628 s6290 = (
   (let s6301 = s6290 in
   if ((string_startswith s6301 (''mcause''))) then  
  (case  ((string_drop s6301 ((string_length (''mcause''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s6290  :: " string "


\<comment> \<open>\<open>val _s624_ : string -> maybe string\<close>\<close>

definition s624  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s624 s6250 = (
   (let s6260 = s6250 in
   if ((string_startswith s6260 (''mepc''))) then  
  (case  ((string_drop s6260 ((string_length (''mepc''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s6250  :: " string "


\<comment> \<open>\<open>val _s620_ : string -> maybe string\<close>\<close>

definition s620  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s620 s6210 = (
   (let s6220 = s6210 in
   if ((string_startswith s6220 (''mscratch''))) then  
  (case  ((string_drop s6220 ((string_length (''mscratch''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s6210  :: " string "


\<comment> \<open>\<open>val _s616_ : string -> maybe string\<close>\<close>

definition s616  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s616 s6170 = (
   (let s6180 = s6170 in
   if ((string_startswith s6180 (''mcountinhibit''))) then  
  (case  ((string_drop s6180 ((string_length (''mcountinhibit''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s6170  :: " string "


\<comment> \<open>\<open>val _s612_ : string -> maybe string\<close>\<close>

definition s612  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s612 s6130 = (
   (let s6140 = s6130 in
   if ((string_startswith s6140 (''mcounteren''))) then  
  (case  ((string_drop s6140 ((string_length (''mcounteren''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s6130  :: " string "


\<comment> \<open>\<open>val _s608_ : string -> maybe string\<close>\<close>

definition s608  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s608 s6090 = (
   (let s6100 = s6090 in
   if ((string_startswith s6100 (''mtvec''))) then  
  (case  ((string_drop s6100 ((string_length (''mtvec''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s6090  :: " string "


\<comment> \<open>\<open>val _s604_ : string -> maybe string\<close>\<close>

definition s604  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s604 s6050 = (
   (let s6060 = s6050 in
   if ((string_startswith s6060 (''mie''))) then  
  (case  ((string_drop s6060 ((string_length (''mie''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s6050  :: " string "


\<comment> \<open>\<open>val _s600_ : string -> maybe string\<close>\<close>

definition s600  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s600 s6010 = (
   (let s6020 = s6010 in
   if ((string_startswith s6020 (''mideleg''))) then  
  (case  ((string_drop s6020 ((string_length (''mideleg''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s6010  :: " string "


\<comment> \<open>\<open>val _s596_ : string -> maybe string\<close>\<close>

definition s596  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s596 s5970 = (
   (let s5980 = s5970 in
   if ((string_startswith s5980 (''medeleg''))) then  
  (case  ((string_drop s5980 ((string_length (''medeleg''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s5970  :: " string "


\<comment> \<open>\<open>val _s592_ : string -> maybe string\<close>\<close>

definition s592  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s592 s5930 = (
   (let s5940 = s5930 in
   if ((string_startswith s5940 (''misa''))) then  
  (case  ((string_drop s5940 ((string_length (''misa''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s5930  :: " string "


\<comment> \<open>\<open>val _s588_ : string -> maybe string\<close>\<close>

definition s588  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s588 s5890 = (
   (let s5900 = s5890 in
   if ((string_startswith s5900 (''mstatus''))) then  
  (case  ((string_drop s5900 ((string_length (''mstatus''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s5890  :: " string "


\<comment> \<open>\<open>val _s584_ : string -> maybe string\<close>\<close>

definition s584  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s584 s5850 = (
   (let s5861 = s5850 in
   if ((string_startswith s5861 (''mhartid''))) then  
  (case  ((string_drop s5861 ((string_length (''mhartid''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s5850  :: " string "


\<comment> \<open>\<open>val _s580_ : string -> maybe string\<close>\<close>

definition s580  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s580 s5810 = (
   (let s5821 = s5810 in
   if ((string_startswith s5821 (''mimpid''))) then  
  (case  ((string_drop s5821 ((string_length (''mimpid''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s5810  :: " string "


\<comment> \<open>\<open>val _s576_ : string -> maybe string\<close>\<close>

definition s576  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s576 s5770 = (
   (let s5780 = s5770 in
   if ((string_startswith s5780 (''marchid''))) then  
  (case  ((string_drop s5780 ((string_length (''marchid''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s5770  :: " string "


\<comment> \<open>\<open>val _s572_ : string -> maybe string\<close>\<close>

definition s572  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s572 s5730 = (
   (let s5741 = s5730 in
   if ((string_startswith s5741 (''mvendorid''))) then  
  (case  ((string_drop s5741 ((string_length (''mvendorid''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s5730  :: " string "


\<comment> \<open>\<open>val _s568_ : string -> maybe string\<close>\<close>

definition s568  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s568 s5690 = (
   (let s5700 = s5690 in
   if ((string_startswith s5700 (''satp''))) then  
  (case  ((string_drop s5700 ((string_length (''satp''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s5690  :: " string "


\<comment> \<open>\<open>val _s564_ : string -> maybe string\<close>\<close>

definition s564  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s564 s5650 = (
   (let s5660 = s5650 in
   if ((string_startswith s5660 (''sip''))) then  
  (case  ((string_drop s5660 ((string_length (''sip''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s5650  :: " string "


\<comment> \<open>\<open>val _s560_ : string -> maybe string\<close>\<close>

definition s560  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s560 s5610 = (
   (let s5620 = s5610 in
   if ((string_startswith s5620 (''stval''))) then  
  (case  ((string_drop s5620 ((string_length (''stval''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s5610  :: " string "


\<comment> \<open>\<open>val _s556_ : string -> maybe string\<close>\<close>

definition s556  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s556 s5570 = (
   (let s5581 = s5570 in
   if ((string_startswith s5581 (''scause''))) then  
  (case  ((string_drop s5581 ((string_length (''scause''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s5570  :: " string "


\<comment> \<open>\<open>val _s552_ : string -> maybe string\<close>\<close>

definition s552  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s552 s5530 = (
   (let s5540 = s5530 in
   if ((string_startswith s5540 (''sepc''))) then  
  (case  ((string_drop s5540 ((string_length (''sepc''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s5530  :: " string "


\<comment> \<open>\<open>val _s548_ : string -> maybe string\<close>\<close>

definition s548  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s548 s5490 = (
   (let s5501 = s5490 in
   if ((string_startswith s5501 (''sscratch''))) then  
  (case  ((string_drop s5501 ((string_length (''sscratch''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s5490  :: " string "


\<comment> \<open>\<open>val _s544_ : string -> maybe string\<close>\<close>

definition s544  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s544 s5450 = (
   (let s5460 = s5450 in
   if ((string_startswith s5460 (''scounteren''))) then  
  (case  ((string_drop s5460 ((string_length (''scounteren''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s5450  :: " string "


\<comment> \<open>\<open>val _s540_ : string -> maybe string\<close>\<close>

definition s540  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s540 s5411 = (
   (let s5420 = s5411 in
   if ((string_startswith s5420 (''stvec''))) then  
  (case  ((string_drop s5420 ((string_length (''stvec''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s5411  :: " string "


\<comment> \<open>\<open>val _s536_ : string -> maybe string\<close>\<close>

definition s536  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s536 s5370 = (
   (let s5380 = s5370 in
   if ((string_startswith s5380 (''sie''))) then  
  (case  ((string_drop s5380 ((string_length (''sie''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s5370  :: " string "


\<comment> \<open>\<open>val _s532_ : string -> maybe string\<close>\<close>

definition s532  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s532 s5330 = (
   (let s5341 = s5330 in
   if ((string_startswith s5341 (''sideleg''))) then  
  (case  ((string_drop s5341 ((string_length (''sideleg''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s5330  :: " string "


\<comment> \<open>\<open>val _s528_ : string -> maybe string\<close>\<close>

definition s528  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s528 s5290 = (
   (let s5300 = s5290 in
   if ((string_startswith s5300 (''sedeleg''))) then  
  (case  ((string_drop s5300 ((string_length (''sedeleg''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s5290  :: " string "


\<comment> \<open>\<open>val _s524_ : string -> maybe string\<close>\<close>

definition s524  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s524 s5250 = (
   (let s5260 = s5250 in
   if ((string_startswith s5260 (''sstatus''))) then  
  (case  ((string_drop s5260 ((string_length (''sstatus''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s5250  :: " string "


\<comment> \<open>\<open>val _s520_ : string -> maybe string\<close>\<close>

definition s520  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s520 s5210 = (
   (let s5220 = s5210 in
   if ((string_startswith s5220 (''instreth''))) then  
  (case  ((string_drop s5220 ((string_length (''instreth''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s5210  :: " string "


\<comment> \<open>\<open>val _s516_ : string -> maybe string\<close>\<close>

definition s516  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s516 s5170 = (
   (let s5180 = s5170 in
   if ((string_startswith s5180 (''timeh''))) then  
  (case  ((string_drop s5180 ((string_length (''timeh''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s5170  :: " string "


\<comment> \<open>\<open>val _s512_ : string -> maybe string\<close>\<close>

definition s512  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s512 s5130 = (
   (let s5141 = s5130 in
   if ((string_startswith s5141 (''cycleh''))) then  
  (case  ((string_drop s5141 ((string_length (''cycleh''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s5130  :: " string "


\<comment> \<open>\<open>val _s508_ : string -> maybe string\<close>\<close>

definition s508  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s508 s5090 = (
   (let s5100 = s5090 in
   if ((string_startswith s5100 (''instret''))) then  
  (case  ((string_drop s5100 ((string_length (''instret''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s5090  :: " string "


\<comment> \<open>\<open>val _s504_ : string -> maybe string\<close>\<close>

definition s504  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s504 s5050 = (
   (let s5060 = s5050 in
   if ((string_startswith s5060 (''time''))) then  
  (case  ((string_drop s5060 ((string_length (''time''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s5050  :: " string "


\<comment> \<open>\<open>val _s500_ : string -> maybe string\<close>\<close>

definition s500  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s500 s5010 = (
   (let s5020 = s5010 in
   if ((string_startswith s5020 (''cycle''))) then  
  (case  ((string_drop s5020 ((string_length (''cycle''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s5010  :: " string "


\<comment> \<open>\<open>val _s496_ : string -> maybe string\<close>\<close>

definition s496  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s496 s4970 = (
   (let s4980 = s4970 in
   if ((string_startswith s4980 (''fcsr''))) then  
  (case  ((string_drop s4980 ((string_length (''fcsr''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s4970  :: " string "


\<comment> \<open>\<open>val _s492_ : string -> maybe string\<close>\<close>

definition s492  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s492 s4930 = (
   (let s4940 = s4930 in
   if ((string_startswith s4940 (''frm''))) then  
  (case  ((string_drop s4940 ((string_length (''frm''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s4930  :: " string "


\<comment> \<open>\<open>val _s488_ : string -> maybe string\<close>\<close>

definition s488  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s488 s4890 = (
   (let s4900 = s4890 in
   if ((string_startswith s4900 (''fflags''))) then  
  (case  ((string_drop s4900 ((string_length (''fflags''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s4890  :: " string "


\<comment> \<open>\<open>val _s484_ : string -> maybe string\<close>\<close>

definition s484  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s484 s4850 = (
   (let s4860 = s4850 in
   if ((string_startswith s4860 (''uip''))) then  
  (case  ((string_drop s4860 ((string_length (''uip''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s4850  :: " string "


\<comment> \<open>\<open>val _s480_ : string -> maybe string\<close>\<close>

definition s480  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s480 s4810 = (
   (let s4820 = s4810 in
   if ((string_startswith s4820 (''utval''))) then  
  (case  ((string_drop s4820 ((string_length (''utval''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s4810  :: " string "


\<comment> \<open>\<open>val _s476_ : string -> maybe string\<close>\<close>

definition s476  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s476 s4770 = (
   (let s4780 = s4770 in
   if ((string_startswith s4780 (''ucause''))) then  
  (case  ((string_drop s4780 ((string_length (''ucause''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s4770  :: " string "


\<comment> \<open>\<open>val _s472_ : string -> maybe string\<close>\<close>

definition s472  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s472 s4730 = (
   (let s4741 = s4730 in
   if ((string_startswith s4741 (''uepc''))) then  
  (case  ((string_drop s4741 ((string_length (''uepc''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s4730  :: " string "


\<comment> \<open>\<open>val _s468_ : string -> maybe string\<close>\<close>

definition s468  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s468 s4690 = (
   (let s4700 = s4690 in
   if ((string_startswith s4700 (''uscratch''))) then  
  (case  ((string_drop s4700 ((string_length (''uscratch''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s4690  :: " string "


\<comment> \<open>\<open>val _s464_ : string -> maybe string\<close>\<close>

definition s464  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s464 s4650 = (
   (let s4661 = s4650 in
   if ((string_startswith s4661 (''utvec''))) then  
  (case  ((string_drop s4661 ((string_length (''utvec''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s4650  :: " string "


\<comment> \<open>\<open>val _s460_ : string -> maybe string\<close>\<close>

definition s460  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s460 s4610 = (
   (let s4620 = s4610 in
   if ((string_startswith s4620 (''uie''))) then  
  (case  ((string_drop s4620 ((string_length (''uie''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s4610  :: " string "


\<comment> \<open>\<open>val _s456_ : string -> maybe string\<close>\<close>

definition s456  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s456 s4570 = (
   (let s4580 = s4570 in
   if ((string_startswith s4580 (''ustatus''))) then  
  (case  ((string_drop s4580 ((string_length (''ustatus''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s4570  :: " string "


definition csr_name_map_matches_prefix  :: \<open> string \<Rightarrow>((12)Word.word*int)option \<close>  where 
     \<open> csr_name_map_matches_prefix arg1 = (
   (let s4590 = arg1 in
   if ((case  ((s456 s4590)) of   Some (s1) => True | _ => False )) then  
  (case  s456 s4590 of
      (Some (s1)) =>
  Some
    (( 0x000 :: 12 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s460 s4590)) of   Some (s1) => True | _ => False )) then  
  (case  s460 s4590 of
      (Some (s1)) =>
  Some
    (( 0x004 :: 12 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s464 s4590)) of   Some (s1) => True | _ => False )) then  
  (case  s464 s4590 of
      (Some (s1)) =>
  Some
    (( 0x005 :: 12 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s468 s4590)) of   Some (s1) => True | _ => False )) then  
  (case  s468 s4590 of
      (Some (s1)) =>
  Some
    (( 0x040 :: 12 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s472 s4590)) of   Some (s1) => True | _ => False )) then  
  (case  s472 s4590 of
      (Some (s1)) =>
  Some
    (( 0x041 :: 12 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s476 s4590)) of   Some (s1) => True | _ => False )) then  
  (case  s476 s4590 of
      (Some (s1)) =>
  Some
    (( 0x042 :: 12 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s480 s4590)) of   Some (s1) => True | _ => False )) then  
  (case  s480 s4590 of
      (Some (s1)) =>
  Some
    (( 0x043 :: 12 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s484 s4590)) of   Some (s1) => True | _ => False )) then  
  (case  s484 s4590 of
      (Some (s1)) =>
  Some
    (( 0x044 :: 12 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s488 s4590)) of   Some (s1) => True | _ => False )) then  
  (case  s488 s4590 of
      (Some (s1)) =>
  Some
    (( 0x001 :: 12 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s492 s4590)) of   Some (s1) => True | _ => False )) then  
  (case  s492 s4590 of
      (Some (s1)) =>
  Some
    (( 0x002 :: 12 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s496 s4590)) of   Some (s1) => True | _ => False )) then  
  (case  s496 s4590 of
      (Some (s1)) =>
  Some
    (( 0x003 :: 12 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s500 s4590)) of   Some (s1) => True | _ => False )) then  
  (case  s500 s4590 of
      (Some (s1)) =>
  Some
    (( 0xC00 :: 12 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s504 s4590)) of   Some (s1) => True | _ => False )) then  
  (case  s504 s4590 of
      (Some (s1)) =>
  Some
    (( 0xC01 :: 12 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s508 s4590)) of   Some (s1) => True | _ => False )) then  
  (case  s508 s4590 of
      (Some (s1)) =>
  Some
    (( 0xC02 :: 12 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s512 s4590)) of   Some (s1) => True | _ => False )) then  
  (case  s512 s4590 of
      (Some (s1)) =>
  Some
    (( 0xC80 :: 12 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s516 s4590)) of   Some (s1) => True | _ => False )) then  
  (case  s516 s4590 of
      (Some (s1)) =>
  Some
    (( 0xC81 :: 12 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s520 s4590)) of   Some (s1) => True | _ => False )) then  
  (case  s520 s4590 of
      (Some (s1)) =>
  Some
    (( 0xC82 :: 12 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s524 s4590)) of   Some (s1) => True | _ => False )) then  
  (case  s524 s4590 of
      (Some (s1)) =>
  Some
    (( 0x100 :: 12 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s528 s4590)) of   Some (s1) => True | _ => False )) then  
  (case  s528 s4590 of
      (Some (s1)) =>
  Some
    (( 0x102 :: 12 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s532 s4590)) of   Some (s1) => True | _ => False )) then  
  (case  s532 s4590 of
      (Some (s1)) =>
  Some
    (( 0x103 :: 12 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s536 s4590)) of   Some (s1) => True | _ => False )) then  
  (case  s536 s4590 of
      (Some (s1)) =>
  Some
    (( 0x104 :: 12 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s540 s4590)) of   Some (s1) => True | _ => False )) then  
  (case  s540 s4590 of
      (Some (s1)) =>
  Some
    (( 0x105 :: 12 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s544 s4590)) of   Some (s1) => True | _ => False )) then  
  (case  s544 s4590 of
      (Some (s1)) =>
  Some
    (( 0x106 :: 12 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s548 s4590)) of   Some (s1) => True | _ => False )) then  
  (case  s548 s4590 of
      (Some (s1)) =>
  Some
    (( 0x140 :: 12 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s552 s4590)) of   Some (s1) => True | _ => False )) then  
  (case  s552 s4590 of
      (Some (s1)) =>
  Some
    (( 0x141 :: 12 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s556 s4590)) of   Some (s1) => True | _ => False )) then  
  (case  s556 s4590 of
      (Some (s1)) =>
  Some
    (( 0x142 :: 12 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s560 s4590)) of   Some (s1) => True | _ => False )) then  
  (case  s560 s4590 of
      (Some (s1)) =>
  Some
    (( 0x143 :: 12 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s564 s4590)) of   Some (s1) => True | _ => False )) then  
  (case  s564 s4590 of
      (Some (s1)) =>
  Some
    (( 0x144 :: 12 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s568 s4590)) of   Some (s1) => True | _ => False )) then  
  (case  s568 s4590 of
      (Some (s1)) =>
  Some
    (( 0x180 :: 12 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s572 s4590)) of   Some (s1) => True | _ => False )) then  
  (case  s572 s4590 of
      (Some (s1)) =>
  Some
    (( 0xF11 :: 12 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s576 s4590)) of   Some (s1) => True | _ => False )) then  
  (case  s576 s4590 of
      (Some (s1)) =>
  Some
    (( 0xF12 :: 12 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s580 s4590)) of   Some (s1) => True | _ => False )) then  
  (case  s580 s4590 of
      (Some (s1)) =>
  Some
    (( 0xF13 :: 12 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s584 s4590)) of   Some (s1) => True | _ => False )) then  
  (case  s584 s4590 of
      (Some (s1)) =>
  Some
    (( 0xF14 :: 12 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s588 s4590)) of   Some (s1) => True | _ => False )) then  
  (case  s588 s4590 of
      (Some (s1)) =>
  Some
    (( 0x300 :: 12 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s592 s4590)) of   Some (s1) => True | _ => False )) then  
  (case  s592 s4590 of
      (Some (s1)) =>
  Some
    (( 0x301 :: 12 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s596 s4590)) of   Some (s1) => True | _ => False )) then  
  (case  s596 s4590 of
      (Some (s1)) =>
  Some
    (( 0x302 :: 12 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s600 s4590)) of   Some (s1) => True | _ => False )) then  
  (case  s600 s4590 of
      (Some (s1)) =>
  Some
    (( 0x303 :: 12 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s604 s4590)) of   Some (s1) => True | _ => False )) then  
  (case  s604 s4590 of
      (Some (s1)) =>
  Some
    (( 0x304 :: 12 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s608 s4590)) of   Some (s1) => True | _ => False )) then  
  (case  s608 s4590 of
      (Some (s1)) =>
  Some
    (( 0x305 :: 12 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s612 s4590)) of   Some (s1) => True | _ => False )) then  
  (case  s612 s4590 of
      (Some (s1)) =>
  Some
    (( 0x306 :: 12 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s616 s4590)) of   Some (s1) => True | _ => False )) then  
  (case  s616 s4590 of
      (Some (s1)) =>
  Some
    (( 0x320 :: 12 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s620 s4590)) of   Some (s1) => True | _ => False )) then  
  (case  s620 s4590 of
      (Some (s1)) =>
  Some
    (( 0x340 :: 12 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s624 s4590)) of   Some (s1) => True | _ => False )) then  
  (case  s624 s4590 of
      (Some (s1)) =>
  Some
    (( 0x341 :: 12 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s628 s4590)) of   Some (s1) => True | _ => False )) then  
  (case  s628 s4590 of
      (Some (s1)) =>
  Some
    (( 0x342 :: 12 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s632 s4590)) of   Some (s1) => True | _ => False )) then  
  (case  s632 s4590 of
      (Some (s1)) =>
  Some
    (( 0x343 :: 12 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s636 s4590)) of   Some (s1) => True | _ => False )) then  
  (case  s636 s4590 of
      (Some (s1)) =>
  Some
    (( 0x344 :: 12 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s640 s4590)) of   Some (s1) => True | _ => False )) then  
  (case  s640 s4590 of
      (Some (s1)) =>
  Some
    (( 0x3A0 :: 12 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s644 s4590)) of   Some (s1) => True | _ => False )) then  
  (case  s644 s4590 of
      (Some (s1)) =>
  Some
    (( 0x3A1 :: 12 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s648 s4590)) of   Some (s1) => True | _ => False )) then  
  (case  s648 s4590 of
      (Some (s1)) =>
  Some
    (( 0x3A2 :: 12 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s652 s4590)) of   Some (s1) => True | _ => False )) then  
  (case  s652 s4590 of
      (Some (s1)) =>
  Some
    (( 0x3A3 :: 12 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s656 s4590)) of   Some (s1) => True | _ => False )) then  
  (case  s656 s4590 of
      (Some (s1)) =>
  Some
    (( 0x3B0 :: 12 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s660 s4590)) of   Some (s1) => True | _ => False )) then  
  (case  s660 s4590 of
      (Some (s1)) =>
  Some
    (( 0x3B1 :: 12 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s664 s4590)) of   Some (s1) => True | _ => False )) then  
  (case  s664 s4590 of
      (Some (s1)) =>
  Some
    (( 0x3B2 :: 12 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s668 s4590)) of   Some (s1) => True | _ => False )) then  
  (case  s668 s4590 of
      (Some (s1)) =>
  Some
    (( 0x3B3 :: 12 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s672 s4590)) of   Some (s1) => True | _ => False )) then  
  (case  s672 s4590 of
      (Some (s1)) =>
  Some
    (( 0x3B4 :: 12 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s676 s4590)) of   Some (s1) => True | _ => False )) then  
  (case  s676 s4590 of
      (Some (s1)) =>
  Some
    (( 0x3B5 :: 12 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s680 s4590)) of   Some (s1) => True | _ => False )) then  
  (case  s680 s4590 of
      (Some (s1)) =>
  Some
    (( 0x3B6 :: 12 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s684 s4590)) of   Some (s1) => True | _ => False )) then  
  (case  s684 s4590 of
      (Some (s1)) =>
  Some
    (( 0x3B7 :: 12 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s688 s4590)) of   Some (s1) => True | _ => False )) then  
  (case  s688 s4590 of
      (Some (s1)) =>
  Some
    (( 0x3B8 :: 12 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s692 s4590)) of   Some (s1) => True | _ => False )) then  
  (case  s692 s4590 of
      (Some (s1)) =>
  Some
    (( 0x3B9 :: 12 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s696 s4590)) of   Some (s1) => True | _ => False )) then  
  (case  s696 s4590 of
      (Some (s1)) =>
  Some
    (( 0x3BA :: 12 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s700 s4590)) of   Some (s1) => True | _ => False )) then  
  (case  s700 s4590 of
      (Some (s1)) =>
  Some
    (( 0x3BB :: 12 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s704 s4590)) of   Some (s1) => True | _ => False )) then  
  (case  s704 s4590 of
      (Some (s1)) =>
  Some
    (( 0x3BC :: 12 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s708 s4590)) of   Some (s1) => True | _ => False )) then  
  (case  s708 s4590 of
      (Some (s1)) =>
  Some
    (( 0x3BD :: 12 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s712 s4590)) of   Some (s1) => True | _ => False )) then  
  (case  s712 s4590 of
      (Some (s1)) =>
  Some
    (( 0x3BE :: 12 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s716 s4590)) of   Some (s1) => True | _ => False )) then  
  (case  s716 s4590 of
      (Some (s1)) =>
  Some
    (( 0x3BF :: 12 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s720 s4590)) of   Some (s1) => True | _ => False )) then  
  (case  s720 s4590 of
      (Some (s1)) =>
  Some
    (( 0xB00 :: 12 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s724 s4590)) of   Some (s1) => True | _ => False )) then  
  (case  s724 s4590 of
      (Some (s1)) =>
  Some
    (( 0xB02 :: 12 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s728 s4590)) of   Some (s1) => True | _ => False )) then  
  (case  s728 s4590 of
      (Some (s1)) =>
  Some
    (( 0xB80 :: 12 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s732 s4590)) of   Some (s1) => True | _ => False )) then  
  (case  s732 s4590 of
      (Some (s1)) =>
  Some
    (( 0xB82 :: 12 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s736 s4590)) of   Some (s1) => True | _ => False )) then  
  (case  s736 s4590 of
      (Some (s1)) =>
  Some
    (( 0x7A0 :: 12 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s740 s4590)) of   Some (s1) => True | _ => False )) then  
  (case  s740 s4590 of
      (Some (s1)) =>
  Some
    (( 0x7A1 :: 12 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s744 s4590)) of   Some (s1) => True | _ => False )) then  
  (case  s744 s4590 of
      (Some (s1)) =>
  Some
    (( 0x7A2 :: 12 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s748 s4590)) of   Some (s1) => True | _ => False )) then  
  (case  s748 s4590 of
      (Some (s1)) =>
  Some
    (( 0x7A3 :: 12 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s752 s4590  ::  (( 12 Word.word * string))option)) of
       Some ((reg, s1)) => True
     | _ => False
     )) then  (case  (s752 s4590 :: (( 12 Word.word * string)) option) of
     (Some ((reg, s1))) =>
 Some (reg, ((string_length arg1)) - ((string_length s1)))
 )
   else None))\<close> 
  for  arg1  :: " string "


definition csr_name  :: \<open>(12)Word.word \<Rightarrow> string \<close>  where 
     \<open> csr_name csr = ( csr_name_map_forwards csr )\<close> 
  for  csr  :: "(12)Word.word "


definition ext_is_CSR_defined  :: \<open>(12)Word.word \<Rightarrow> Privilege \<Rightarrow>((register_value),(bool),(exception))monad \<close>  where 
     \<open> ext_is_CSR_defined b__0 g__337 = (
   if (((b__0 = ( 0x000 ::  12 Word.word)))) then and_boolM ((haveUsrMode () )) ((haveNExt () ))
   else if (((b__0 = ( 0x004 ::  12 Word.word)))) then and_boolM ((haveUsrMode () )) ((haveNExt () ))
   else if (((b__0 = ( 0x005 ::  12 Word.word)))) then and_boolM ((haveUsrMode () )) ((haveNExt () ))
   else if (((b__0 = ( 0x040 ::  12 Word.word)))) then and_boolM ((haveUsrMode () )) ((haveNExt () ))
   else if (((b__0 = ( 0x041 ::  12 Word.word)))) then and_boolM ((haveUsrMode () )) ((haveNExt () ))
   else if (((b__0 = ( 0x042 ::  12 Word.word)))) then and_boolM ((haveUsrMode () )) ((haveNExt () ))
   else if (((b__0 = ( 0x043 ::  12 Word.word)))) then and_boolM ((haveUsrMode () )) ((haveNExt () ))
   else if (((b__0 = ( 0x044 ::  12 Word.word)))) then and_boolM ((haveUsrMode () )) ((haveNExt () ))
   else if (((b__0 = ( 0x001 ::  12 Word.word)))) then or_boolM ((haveFExt () )) ((haveDExt () ))
   else if (((b__0 = ( 0x002 ::  12 Word.word)))) then or_boolM ((haveFExt () )) ((haveDExt () ))
   else if (((b__0 = ( 0x003 ::  12 Word.word)))) then or_boolM ((haveFExt () )) ((haveDExt () ))
   else return False )\<close> 
  for  b__0  :: "(12)Word.word " 
  and  g__337  :: " Privilege "


definition ext_read_CSR  :: \<open>(12)Word.word \<Rightarrow>((register_value),(((64)Word.word)option),(exception))monad \<close>  where 
     \<open> ext_read_CSR b__0 = (
   if (((b__0 = ( 0x000 ::  12 Word.word)))) then
     read_reg mstatus_ref \<bind> ((\<lambda> (w__0 :: Mstatus) . 
     return (Some ((get_Ustatus_bits ((lower_sstatus ((lower_mstatus w__0))))  ::  64 Word.word)))))
   else if (((b__0 = ( 0x004 ::  12 Word.word)))) then
     read_reg mie_ref \<bind> ((\<lambda> (w__1 :: Minterrupts) . 
     read_reg mideleg_ref \<bind> ((\<lambda> (w__2 :: Minterrupts) . 
     read_reg sideleg_ref \<bind> ((\<lambda> (w__3 :: Sinterrupts) . 
     return (Some ((get_Uinterrupts_bits ((lower_sie ((lower_mie w__1 w__2)) w__3))  ::  64 Word.word)))))))))
   else if (((b__0 = ( 0x005 ::  12 Word.word)))) then
     (get_utvec ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__4 ::  64 Word.word) .  return (Some w__4)))
   else if (((b__0 = ( 0x040 ::  12 Word.word)))) then
     (read_reg uscratch_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__5 ::  64 Word.word) .  return (Some w__5)))
   else if (((b__0 = ( 0x041 ::  12 Word.word)))) then
     (get_xret_target User  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__6 ::  64 Word.word) . 
     (pc_alignment_mask ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__7 ::  64 Word.word) . 
     return (Some ((and_vec w__6 w__7  ::  64 Word.word)))))))
   else if (((b__0 = ( 0x042 ::  12 Word.word)))) then
     read_reg ucause_ref \<bind> ((\<lambda> (w__8 :: Mcause) . 
     return (Some ((get_Mcause_bits w__8  ::  64 Word.word)))))
   else if (((b__0 = ( 0x043 ::  12 Word.word)))) then
     (read_reg utval_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__9 ::  64 Word.word) .  return (Some w__9)))
   else if (((b__0 = ( 0x044 ::  12 Word.word)))) then
     read_reg mip_ref \<bind> ((\<lambda> (w__10 :: Minterrupts) . 
     read_reg mideleg_ref \<bind> ((\<lambda> (w__11 :: Minterrupts) . 
     read_reg sideleg_ref \<bind> ((\<lambda> (w__12 :: Sinterrupts) . 
     return (Some ((get_Uinterrupts_bits ((lower_sip ((lower_mip w__10 w__11)) w__12))
                     ::  64 Word.word)))))))))
   else if (((b__0 = ( 0x001 ::  12 Word.word)))) then
     read_reg fcsr_ref \<bind> ((\<lambda> (w__13 :: Fcsr) . 
     return (Some ((EXTZ (( 64 :: int)::ii) ((get_Fcsr_FFLAGS w__13  ::  5 Word.word))  ::  64 Word.word)))))
   else if (((b__0 = ( 0x002 ::  12 Word.word)))) then
     read_reg fcsr_ref \<bind> ((\<lambda> (w__14 :: Fcsr) . 
     return (Some ((EXTZ (( 64 :: int)::ii) ((get_Fcsr_FRM w__14  ::  3 Word.word))  ::  64 Word.word)))))
   else if (((b__0 = ( 0x003 ::  12 Word.word)))) then
     read_reg fcsr_ref \<bind> ((\<lambda> (w__15 :: Fcsr) . 
     return (Some ((EXTZ (( 64 :: int)::ii) ((get_Fcsr_bits w__15  ::  32 Word.word))  ::  64 Word.word)))))
   else return None )\<close> 
  for  b__0  :: "(12)Word.word "


definition ext_write_CSR  :: \<open>(12)Word.word \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),(((64)Word.word)option),(exception))monad \<close>  where 
     \<open> ext_write_CSR b__0 value1 = (
   if (((b__0 = ( 0x000 ::  12 Word.word)))) then
     read_reg mstatus_ref \<bind> ((\<lambda> (w__0 :: Mstatus) . 
     legalize_ustatus w__0 value1 \<bind> ((\<lambda> (w__1 :: Mstatus) . 
     (write_reg mstatus_ref w__1 \<then>
     read_reg mstatus_ref) \<bind> ((\<lambda> (w__2 :: Mstatus) . 
     return (Some ((get_Mstatus_bits w__2  ::  64 Word.word)))))))))
   else if (((b__0 = ( 0x004 ::  12 Word.word)))) then
     read_reg mie_ref \<bind> ((\<lambda> (w__3 :: Minterrupts) . 
     read_reg mideleg_ref \<bind> ((\<lambda> (w__4 :: Minterrupts) . 
     read_reg sideleg_ref \<bind> ((\<lambda> (w__5 :: Sinterrupts) . 
     (let sie = (legalize_uie ((lower_mie w__3 w__4)) w__5 value1) in
     read_reg mie_ref \<bind> ((\<lambda> (w__6 :: Minterrupts) . 
     read_reg mideleg_ref \<bind> ((\<lambda> (w__7 :: Minterrupts) . 
     lift_sie w__6 w__7 sie \<bind> ((\<lambda> (w__8 :: Minterrupts) . 
     (write_reg mie_ref w__8 \<then>
     read_reg mie_ref) \<bind> ((\<lambda> (w__9 :: Minterrupts) . 
     return (Some ((get_Minterrupts_bits w__9  ::  64 Word.word))))))))))))))))))
   else if (((b__0 = ( 0x005 ::  12 Word.word)))) then
     (set_utvec value1  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__10 ::  64 Word.word) .  return (Some w__10)))
   else if (((b__0 = ( 0x040 ::  12 Word.word)))) then
     (write_reg uscratch_ref value1 \<then>
     (read_reg uscratch_ref  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__11 ::  64 Word.word) .  return (Some w__11)))
   else if (((b__0 = ( 0x041 ::  12 Word.word)))) then
     (set_xret_target User value1  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__12 ::  64 Word.word) . 
     return (Some w__12)))
   else if (((b__0 = ( 0x042 ::  12 Word.word)))) then
     (set_Mcause_bits ucause_ref value1 \<then>
     read_reg ucause_ref) \<bind> ((\<lambda> (w__13 :: Mcause) . 
     return (Some ((get_Mcause_bits w__13  ::  64 Word.word)))))
   else if (((b__0 = ( 0x043 ::  12 Word.word)))) then
     (write_reg utval_ref value1 \<then>
     (read_reg utval_ref  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__14 ::  64 Word.word) .  return (Some w__14)))
   else if (((b__0 = ( 0x044 ::  12 Word.word)))) then
     read_reg mip_ref \<bind> ((\<lambda> (w__15 :: Minterrupts) . 
     read_reg mideleg_ref \<bind> ((\<lambda> (w__16 :: Minterrupts) . 
     read_reg sideleg_ref \<bind> ((\<lambda> (w__17 :: Sinterrupts) . 
     (let sip = (legalize_uip ((lower_mip w__15 w__16)) w__17 value1) in
     read_reg mip_ref \<bind> ((\<lambda> (w__18 :: Minterrupts) . 
     read_reg mideleg_ref \<bind> ((\<lambda> (w__19 :: Minterrupts) . 
     lift_sip w__18 w__19 sip \<bind> ((\<lambda> (w__20 :: Minterrupts) . 
     (write_reg mip_ref w__20 \<then>
     read_reg mip_ref) \<bind> ((\<lambda> (w__21 :: Minterrupts) . 
     return (Some ((get_Minterrupts_bits w__21  ::  64 Word.word))))))))))))))))))
   else if (((b__0 = ( 0x001 ::  12 Word.word)))) then
     read_reg fcsr_ref \<bind> ((\<lambda> (w__22 :: Fcsr) . 
     (ext_write_fcsr ((get_Fcsr_FRM w__22  ::  3 Word.word))
       ((subrange_vec_dec value1 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) \<then>
     read_reg fcsr_ref) \<bind> ((\<lambda> (w__23 :: Fcsr) . 
     return (Some ((EXTZ (( 64 :: int)::ii) ((get_Fcsr_FFLAGS w__23  ::  5 Word.word))  ::  64 Word.word)))))))
   else if (((b__0 = ( 0x002 ::  12 Word.word)))) then
     read_reg fcsr_ref \<bind> ((\<lambda> (w__24 :: Fcsr) . 
     (ext_write_fcsr ((subrange_vec_dec value1 (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word))
       ((get_Fcsr_FFLAGS w__24  ::  5 Word.word)) \<then>
     read_reg fcsr_ref) \<bind> ((\<lambda> (w__25 :: Fcsr) . 
     return (Some ((EXTZ (( 64 :: int)::ii) ((get_Fcsr_FRM w__25  ::  3 Word.word))  ::  64 Word.word)))))))
   else if (((b__0 = ( 0x003 ::  12 Word.word)))) then
     (ext_write_fcsr ((subrange_vec_dec value1 (( 7 :: int)::ii) (( 5 :: int)::ii)  ::  3 Word.word))
       ((subrange_vec_dec value1 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) \<then>
     read_reg fcsr_ref) \<bind> ((\<lambda> (w__26 :: Fcsr) . 
     return (Some ((EXTZ (( 64 :: int)::ii) ((get_Fcsr_bits w__26  ::  32 Word.word))  ::  64 Word.word)))))
   else return None )\<close> 
  for  b__0  :: "(12)Word.word " 
  and  value1  :: "(64)Word.word "


\<comment> \<open>\<open>val csrAccess : mword ty12 -> mword ty2\<close>\<close>

definition csrAccess  :: \<open>(12)Word.word \<Rightarrow>(2)Word.word \<close>  where 
     \<open> csrAccess csr = ( (subrange_vec_dec csr (( 11 :: int)::ii) (( 10 :: int)::ii)  ::  2 Word.word))\<close> 
  for  csr  :: "(12)Word.word "


\<comment> \<open>\<open>val csrPriv : mword ty12 -> mword ty2\<close>\<close>

definition csrPriv  :: \<open>(12)Word.word \<Rightarrow>(2)Word.word \<close>  where 
     \<open> csrPriv csr = ( (subrange_vec_dec csr (( 9 :: int)::ii) (( 8 :: int)::ii)  ::  2 Word.word))\<close> 
  for  csr  :: "(12)Word.word "


\<comment> \<open>\<open>val is_CSR_defined : mword ty12 -> Privilege -> M bool\<close>\<close>

definition is_CSR_defined  :: \<open>(12)Word.word \<Rightarrow> Privilege \<Rightarrow>((register_value),(bool),(exception))monad \<close>  where 
     \<open> is_CSR_defined (csr :: csreg) (p :: Privilege) = (
   (let b__0 = csr in
   if (((b__0 = ( 0xF11 ::  12 Word.word)))) then return (((p = Machine)))
   else if (((b__0 = ( 0xF12 ::  12 Word.word)))) then return (((p = Machine)))
   else if (((b__0 = ( 0xF13 ::  12 Word.word)))) then return (((p = Machine)))
   else if (((b__0 = ( 0xF14 ::  12 Word.word)))) then return (((p = Machine)))
   else if (((b__0 = ( 0x300 ::  12 Word.word)))) then return (((p = Machine)))
   else if (((b__0 = ( 0x301 ::  12 Word.word)))) then return (((p = Machine)))
   else if (((b__0 = ( 0x302 ::  12 Word.word)))) then
     and_boolM (return (((p = Machine)))) (or_boolM ((haveSupMode () )) ((haveNExt () )))
   else if (((b__0 = ( 0x303 ::  12 Word.word)))) then
     and_boolM (return (((p = Machine)))) (or_boolM ((haveSupMode () )) ((haveNExt () )))
   else if (((b__0 = ( 0x304 ::  12 Word.word)))) then return (((p = Machine)))
   else if (((b__0 = ( 0x305 ::  12 Word.word)))) then return (((p = Machine)))
   else if (((b__0 = ( 0x306 ::  12 Word.word)))) then
     and_boolM (return (((p = Machine)))) ((haveUsrMode () ))
   else if (((b__0 = ( 0x310 ::  12 Word.word)))) then
     return ((((((p = Machine))) \<and> ((((( 64 :: int)::ii) = (( 32 :: int)::ii)))))))
   else if (((b__0 = ( 0x320 ::  12 Word.word)))) then return (((p = Machine)))
   else if (((b__0 = ( 0x340 ::  12 Word.word)))) then return (((p = Machine)))
   else if (((b__0 = ( 0x341 ::  12 Word.word)))) then return (((p = Machine)))
   else if (((b__0 = ( 0x342 ::  12 Word.word)))) then return (((p = Machine)))
   else if (((b__0 = ( 0x343 ::  12 Word.word)))) then return (((p = Machine)))
   else if (((b__0 = ( 0x344 ::  12 Word.word)))) then return (((p = Machine)))
   else if (((b__0 = ( 0x3A0 ::  12 Word.word)))) then return (((p = Machine)))
   else if (((b__0 = ( 0x3A1 ::  12 Word.word)))) then
     return ((((((p = Machine))) \<and> ((((( 64 :: int)::ii) = (( 32 :: int)::ii)))))))
   else if (((b__0 = ( 0x3A2 ::  12 Word.word)))) then return (((p = Machine)))
   else if (((b__0 = ( 0x3A3 ::  12 Word.word)))) then
     return ((((((p = Machine))) \<and> ((((( 64 :: int)::ii) = (( 32 :: int)::ii)))))))
   else if (((b__0 = ( 0x3B0 ::  12 Word.word)))) then return (((p = Machine)))
   else if (((b__0 = ( 0x3B1 ::  12 Word.word)))) then return (((p = Machine)))
   else if (((b__0 = ( 0x3B2 ::  12 Word.word)))) then return (((p = Machine)))
   else if (((b__0 = ( 0x3B3 ::  12 Word.word)))) then return (((p = Machine)))
   else if (((b__0 = ( 0x3B4 ::  12 Word.word)))) then return (((p = Machine)))
   else if (((b__0 = ( 0x3B5 ::  12 Word.word)))) then return (((p = Machine)))
   else if (((b__0 = ( 0x3B6 ::  12 Word.word)))) then return (((p = Machine)))
   else if (((b__0 = ( 0x3B7 ::  12 Word.word)))) then return (((p = Machine)))
   else if (((b__0 = ( 0x3B8 ::  12 Word.word)))) then return (((p = Machine)))
   else if (((b__0 = ( 0x3B9 ::  12 Word.word)))) then return (((p = Machine)))
   else if (((b__0 = ( 0x3BA ::  12 Word.word)))) then return (((p = Machine)))
   else if (((b__0 = ( 0x3BB ::  12 Word.word)))) then return (((p = Machine)))
   else if (((b__0 = ( 0x3BC ::  12 Word.word)))) then return (((p = Machine)))
   else if (((b__0 = ( 0x3BD ::  12 Word.word)))) then return (((p = Machine)))
   else if (((b__0 = ( 0x3BE ::  12 Word.word)))) then return (((p = Machine)))
   else if (((b__0 = ( 0x3BF ::  12 Word.word)))) then return (((p = Machine)))
   else if (((b__0 = ( 0xB00 ::  12 Word.word)))) then return (((p = Machine)))
   else if (((b__0 = ( 0xB02 ::  12 Word.word)))) then return (((p = Machine)))
   else if (((b__0 = ( 0xB80 ::  12 Word.word)))) then
     return ((((((p = Machine))) \<and> ((((( 64 :: int)::ii) = (( 32 :: int)::ii)))))))
   else if (((b__0 = ( 0xB82 ::  12 Word.word)))) then
     return ((((((p = Machine))) \<and> ((((( 64 :: int)::ii) = (( 32 :: int)::ii)))))))
   else if (((b__0 = ( 0x7A0 ::  12 Word.word)))) then return (((p = Machine)))
   else if (((b__0 = ( 0x100 ::  12 Word.word)))) then
     and_boolM ((haveSupMode () )) (return ((((((p = Machine))) \<or> (((p = Supervisor)))))))
   else if (((b__0 = ( 0x102 ::  12 Word.word)))) then
     and_boolM ((haveSupMode () ))
       (and_boolM ((haveNExt () )) (return ((((((p = Machine))) \<or> (((p = Supervisor))))))))
   else if (((b__0 = ( 0x103 ::  12 Word.word)))) then
     and_boolM ((haveSupMode () ))
       (and_boolM ((haveNExt () )) (return ((((((p = Machine))) \<or> (((p = Supervisor))))))))
   else if (((b__0 = ( 0x104 ::  12 Word.word)))) then
     and_boolM ((haveSupMode () )) (return ((((((p = Machine))) \<or> (((p = Supervisor)))))))
   else if (((b__0 = ( 0x105 ::  12 Word.word)))) then
     and_boolM ((haveSupMode () )) (return ((((((p = Machine))) \<or> (((p = Supervisor)))))))
   else if (((b__0 = ( 0x106 ::  12 Word.word)))) then
     and_boolM ((haveSupMode () )) (return ((((((p = Machine))) \<or> (((p = Supervisor)))))))
   else if (((b__0 = ( 0x140 ::  12 Word.word)))) then
     and_boolM ((haveSupMode () )) (return ((((((p = Machine))) \<or> (((p = Supervisor)))))))
   else if (((b__0 = ( 0x141 ::  12 Word.word)))) then
     and_boolM ((haveSupMode () )) (return ((((((p = Machine))) \<or> (((p = Supervisor)))))))
   else if (((b__0 = ( 0x142 ::  12 Word.word)))) then
     and_boolM ((haveSupMode () )) (return ((((((p = Machine))) \<or> (((p = Supervisor)))))))
   else if (((b__0 = ( 0x143 ::  12 Word.word)))) then
     and_boolM ((haveSupMode () )) (return ((((((p = Machine))) \<or> (((p = Supervisor)))))))
   else if (((b__0 = ( 0x144 ::  12 Word.word)))) then
     and_boolM ((haveSupMode () )) (return ((((((p = Machine))) \<or> (((p = Supervisor)))))))
   else if (((b__0 = ( 0x180 ::  12 Word.word)))) then
     and_boolM ((haveSupMode () )) (return ((((((p = Machine))) \<or> (((p = Supervisor)))))))
   else if (((b__0 = ( 0xC00 ::  12 Word.word)))) then haveUsrMode () 
   else if (((b__0 = ( 0xC01 ::  12 Word.word)))) then haveUsrMode () 
   else if (((b__0 = ( 0xC02 ::  12 Word.word)))) then haveUsrMode () 
   else if (((b__0 = ( 0xC80 ::  12 Word.word)))) then
     and_boolM ((haveUsrMode () )) (return ((((( 64 :: int)::ii) = (( 32 :: int)::ii)))))
   else if (((b__0 = ( 0xC81 ::  12 Word.word)))) then
     and_boolM ((haveUsrMode () )) (return ((((( 64 :: int)::ii) = (( 32 :: int)::ii)))))
   else if (((b__0 = ( 0xC82 ::  12 Word.word)))) then
     and_boolM ((haveUsrMode () )) (return ((((( 64 :: int)::ii) = (( 32 :: int)::ii)))))
   else ext_is_CSR_defined csr p))\<close> 
  for  csr  :: "(12)Word.word " 
  and  p  :: " Privilege "


\<comment> \<open>\<open>val check_CSR_access : mword ty2 -> mword ty2 -> Privilege -> bool -> bool\<close>\<close>

definition check_CSR_access  :: \<open>(2)Word.word \<Rightarrow>(2)Word.word \<Rightarrow> Privilege \<Rightarrow> bool \<Rightarrow> bool \<close>  where 
     \<open> check_CSR_access csrrw csrpr p isWrite = (
   (((\<not> ((((((isWrite = True))) \<and> (((csrrw = ( 0b11 ::  2 Word.word))))))))) \<and> ((zopz0zKzJ_u ((privLevel_to_bits p  ::  2 Word.word)) csrpr))))\<close> 
  for  csrrw  :: "(2)Word.word " 
  and  csrpr  :: "(2)Word.word " 
  and  p  :: " Privilege " 
  and  isWrite  :: " bool "


\<comment> \<open>\<open>val check_TVM_SATP : mword ty12 -> Privilege -> M bool\<close>\<close>

definition check_TVM_SATP  :: \<open>(12)Word.word \<Rightarrow> Privilege \<Rightarrow>((register_value),(bool),(exception))monad \<close>  where 
     \<open> check_TVM_SATP (csr :: csreg) (p :: Privilege) = (
   and_boolM (return (((csr = ( 0x180 ::  12 Word.word)))))
     (and_boolM (return (((p = Supervisor))))
        (read_reg mstatus_ref \<bind> ((\<lambda> (w__0 :: Mstatus) . 
         return (((((get_Mstatus_TVM w__0  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))))))) \<bind> ((\<lambda> (w__2 ::
     bool) . 
   return ((\<not> w__2)))))\<close> 
  for  csr  :: "(12)Word.word " 
  and  p  :: " Privilege "


\<comment> \<open>\<open>val check_Counteren : mword ty12 -> Privilege -> M bool\<close>\<close>

definition check_Counteren  :: \<open>(12)Word.word \<Rightarrow> Privilege \<Rightarrow>((register_value),(bool),(exception))monad \<close>  where 
     \<open> check_Counteren (csr :: csreg) (p :: Privilege) = (
   (case  (csr, p) of
     (b__0, Supervisor) =>
      if (((b__0 = ( 0xC00 ::  12 Word.word)))) then
        read_reg mcounteren_ref \<bind> ((\<lambda> (w__0 :: Counteren) . 
        return (((((get_Counteren_CY w__0  ::  1 Word.word)) = ( 0b1 ::  1 Word.word))))))
      else if (((b__0 = ( 0xC01 ::  12 Word.word)))) then
        read_reg mcounteren_ref \<bind> ((\<lambda> (w__1 :: Counteren) . 
        return (((((get_Counteren_TM w__1  ::  1 Word.word)) = ( 0b1 ::  1 Word.word))))))
      else if (((b__0 = ( 0xC02 ::  12 Word.word)))) then
        read_reg mcounteren_ref \<bind> ((\<lambda> (w__2 :: Counteren) . 
        return (((((get_Counteren_IR w__2  ::  1 Word.word)) = ( 0b1 ::  1 Word.word))))))
      else
        return ((case  (b__0, Supervisor) of
          (_, _) =>
           if (((((zopz0zIzJ_u ( 0xC03 ::  12 Word.word) csr)) \<and> ((zopz0zIzJ_u csr ( 0xC1F ::  12 Word.word)))))) then
             False
           else True
        ))
   | (b__3, User) =>
      if (((b__3 = ( 0xC00 ::  12 Word.word)))) then
        and_boolM
          (read_reg mcounteren_ref \<bind> ((\<lambda> (w__6 :: Counteren) . 
           return (((((get_Counteren_CY w__6  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))))))
          (or_boolM (haveSupMode ()  \<bind> ((\<lambda> (w__7 :: bool) .  return ((\<not> w__7)))))
             (read_reg scounteren_ref \<bind> ((\<lambda> (w__8 :: Counteren) . 
              return (((((get_Counteren_CY w__8  ::  1 Word.word)) = ( 0b1 ::  1 Word.word))))))))
      else if (((b__3 = ( 0xC01 ::  12 Word.word)))) then
        and_boolM
          (read_reg mcounteren_ref \<bind> ((\<lambda> (w__11 :: Counteren) . 
           return (((((get_Counteren_TM w__11  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))))))
          (or_boolM (haveSupMode ()  \<bind> ((\<lambda> (w__12 :: bool) .  return ((\<not> w__12)))))
             (read_reg scounteren_ref \<bind> ((\<lambda> (w__13 :: Counteren) . 
              return (((((get_Counteren_TM w__13  ::  1 Word.word)) = ( 0b1 ::  1 Word.word))))))))
      else if (((b__3 = ( 0xC02 ::  12 Word.word)))) then
        and_boolM
          (read_reg mcounteren_ref \<bind> ((\<lambda> (w__16 :: Counteren) . 
           return (((((get_Counteren_IR w__16  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))))))
          (or_boolM (haveSupMode ()  \<bind> ((\<lambda> (w__17 :: bool) .  return ((\<not> w__17)))))
             (read_reg scounteren_ref \<bind> ((\<lambda> (w__18 :: Counteren) . 
              return (((((get_Counteren_IR w__18  ::  1 Word.word)) = ( 0b1 ::  1 Word.word))))))))
      else
        return ((case  (b__3, User) of
          (_, _) =>
           if (((((zopz0zIzJ_u ( 0xC03 ::  12 Word.word) csr)) \<and> ((zopz0zIzJ_u csr ( 0xC1F ::  12 Word.word)))))) then
             False
           else True
        ))
   | (_, _) =>
      return (if (((((zopz0zIzJ_u ( 0xC03 ::  12 Word.word) csr)) \<and> ((zopz0zIzJ_u csr ( 0xC1F ::  12 Word.word)))))) then
                False
              else True)
   ))\<close> 
  for  csr  :: "(12)Word.word " 
  and  p  :: " Privilege "


\<comment> \<open>\<open>val check_CSR : mword ty12 -> Privilege -> bool -> M bool\<close>\<close>

definition check_CSR  :: \<open>(12)Word.word \<Rightarrow> Privilege \<Rightarrow> bool \<Rightarrow>((register_value),(bool),(exception))monad \<close>  where 
     \<open> check_CSR (csr :: csreg) (p :: Privilege) (isWrite :: bool) = (
   and_boolM ((is_CSR_defined csr p))
     (and_boolM
        (return ((check_CSR_access ((csrAccess csr  ::  2 Word.word)) ((csrPriv csr  ::  2 Word.word)) p
                    isWrite))) (and_boolM ((check_TVM_SATP csr p)) ((check_Counteren csr p)))))\<close> 
  for  csr  :: "(12)Word.word " 
  and  p  :: " Privilege " 
  and  isWrite  :: " bool "


\<comment> \<open>\<open>val exception_delegatee : ExceptionType -> Privilege -> M Privilege\<close>\<close>

definition exception_delegatee  :: \<open> ExceptionType \<Rightarrow> Privilege \<Rightarrow>((register_value),(Privilege),(exception))monad \<close>  where 
     \<open> exception_delegatee (e :: ExceptionType) (p :: Privilege) = (
   (let idx = (num_of_ExceptionType e) in
   read_reg medeleg_ref \<bind> ((\<lambda> (w__0 :: Medeleg) . 
   (let super = (bit_to_bool ((access_vec_dec ((get_Medeleg_bits w__0  ::  64 Word.word)) idx))) in
   haveSupMode ()  \<bind> ((\<lambda> (w__1 :: bool) . 
   (if w__1 then
      and_boolM (return super)
        (and_boolM ((haveNExt () ))
           (read_reg sedeleg_ref \<bind> ((\<lambda> (w__3 :: Sedeleg) . 
            return ((bit_to_bool ((access_vec_dec ((get_Sedeleg_bits w__3  ::  64 Word.word)) idx))))))))
    else and_boolM (return super) ((haveNExt () ))) \<bind> ((\<lambda> user . 
   and_boolM ((haveUsrMode () )) (return user) \<bind> ((\<lambda> w__9 . 
   (if w__9 then return User
    else
      and_boolM ((haveSupMode () )) (return super) \<bind> ((\<lambda> w__11 . 
      return (if w__11 then Supervisor
              else Machine)))) \<bind> ((\<lambda> deleg . 
   return (if ((zopz0zI_u ((privLevel_to_bits deleg  ::  2 Word.word))
                  ((privLevel_to_bits p  ::  2 Word.word)))) then
             p
           else deleg))))))))))))))\<close> 
  for  e  :: " ExceptionType " 
  and  p  :: " Privilege "


\<comment> \<open>\<open>val findPendingInterrupt : mword ty64 -> maybe InterruptType\<close>\<close>

definition findPendingInterrupt  :: \<open>(64)Word.word \<Rightarrow>(InterruptType)option \<close>  where 
     \<open> findPendingInterrupt ip = (
   (let ip = (Mk_Minterrupts ip) in
   if (((((get_Minterrupts_MEI ip  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))) then Some I_M_External
   else if (((((get_Minterrupts_MSI ip  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))) then
     Some I_M_Software
   else if (((((get_Minterrupts_MTI ip  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))) then Some I_M_Timer
   else if (((((get_Minterrupts_SEI ip  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))) then
     Some I_S_External
   else if (((((get_Minterrupts_SSI ip  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))) then
     Some I_S_Software
   else if (((((get_Minterrupts_STI ip  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))) then Some I_S_Timer
   else if (((((get_Minterrupts_UEI ip  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))) then
     Some I_U_External
   else if (((((get_Minterrupts_USI ip  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))) then
     Some I_U_Software
   else if (((((get_Minterrupts_UTI ip  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))) then Some I_U_Timer
   else None))\<close> 
  for  ip  :: "(64)Word.word "


\<comment> \<open>\<open>val processPending : Minterrupts -> Minterrupts -> mword ty64 -> bool -> interrupt_set\<close>\<close>

definition processPending  :: \<open> Minterrupts \<Rightarrow> Minterrupts \<Rightarrow>(64)Word.word \<Rightarrow> bool \<Rightarrow> interrupt_set \<close>  where 
     \<open> processPending (xip :: Minterrupts) (xie :: Minterrupts) (xideleg :: xlenbits) (priv_enabled :: bool) = (
   (let effective_pend =
     ((and_vec ((get_Minterrupts_bits xip  ::  64 Word.word))
        ((and_vec ((get_Minterrupts_bits xie  ::  64 Word.word)) ((not_vec xideleg  ::  64 Word.word))
           ::  64 Word.word))
       ::  64 Word.word)) in
   (let effective_delg = ((and_vec ((get_Minterrupts_bits xip  ::  64 Word.word)) xideleg  ::  64 Word.word)) in
   if (((priv_enabled \<and> (((effective_pend \<noteq> ((EXTZ (( 64 :: int)::ii) ( 0b0 ::  1 Word.word)  ::  64 Word.word)))))))) then
     Ints_Pending effective_pend
   else if (((effective_delg \<noteq> ((EXTZ (( 64 :: int)::ii) ( 0b0 ::  1 Word.word)  ::  64 Word.word))))) then
     Ints_Delegated effective_delg
   else Ints_Empty () )))\<close> 
  for  xip  :: " Minterrupts " 
  and  xie  :: " Minterrupts " 
  and  xideleg  :: "(64)Word.word " 
  and  priv_enabled  :: " bool "


\<comment> \<open>\<open>val getPendingSet : Privilege -> M (maybe ((mword ty64 * Privilege)))\<close>\<close>

definition getPendingSet  :: \<open> Privilege \<Rightarrow>((register_value),(((64)Word.word*Privilege)option),(exception))monad \<close>  where 
     \<open> getPendingSet priv = (
   haveUsrMode ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   (assert_exp w__0 (''no user mode: M/U or M/S/U system required'') \<then>
   read_reg mip_ref) \<bind> ((\<lambda> (w__1 :: Minterrupts) . 
   read_reg mie_ref \<bind> ((\<lambda> (w__2 :: Minterrupts) . 
   (let effective_pending =
     ((and_vec ((get_Minterrupts_bits w__1  ::  64 Word.word))
        ((get_Minterrupts_bits w__2  ::  64 Word.word))
       ::  64 Word.word)) in
   if (((effective_pending = ((EXTZ (( 64 :: int)::ii) ( 0b0 ::  1 Word.word)  ::  64 Word.word))))) then
     return None
   else
     or_boolM (return (((priv \<noteq> Machine))))
       (and_boolM (return (((priv = Machine))))
          (read_reg mstatus_ref \<bind> ((\<lambda> (w__3 :: Mstatus) . 
           return (((((get_Mstatus_MIE w__3  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))))))) \<bind> ((\<lambda> mIE . 
     and_boolM ((haveSupMode () ))
       (or_boolM (return (((priv = User))))
          (and_boolM (return (((priv = Supervisor))))
             (read_reg mstatus_ref \<bind> ((\<lambda> (w__6 :: Mstatus) . 
              return (((((get_Mstatus_SIE w__6  ::  1 Word.word)) = ( 0b1 ::  1 Word.word))))))))) \<bind> ((\<lambda> sIE . 
     and_boolM ((haveNExt () ))
       (and_boolM (return (((priv = User))))
          (read_reg mstatus_ref \<bind> ((\<lambda> (w__10 :: Mstatus) . 
           return (((((get_Mstatus_UIE w__10  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))))))) \<bind> ((\<lambda> uIE . 
     read_reg mip_ref \<bind> ((\<lambda> (w__12 :: Minterrupts) . 
     read_reg mie_ref \<bind> ((\<lambda> (w__13 :: Minterrupts) . 
     read_reg mideleg_ref \<bind> ((\<lambda> (w__14 :: Minterrupts) . 
     (case  ((processPending w__12 w__13 ((get_Minterrupts_bits w__14  ::  64 Word.word)) mIE)) of
       Ints_Empty (_) => return None
     | Ints_Pending (p) =>
        (let r = (p, Machine) in
        return (Some r))
     | Ints_Delegated (d) =>
        haveSupMode ()  \<bind> ((\<lambda> (w__15 :: bool) . 
        if ((\<not> w__15)) then
          return (if uIE then
                    (let r = (d, User) in
                    Some r)
                  else None)
        else
          read_reg mie_ref \<bind> ((\<lambda> (w__16 :: Minterrupts) . 
          read_reg sideleg_ref \<bind> ((\<lambda> (w__17 :: Sinterrupts) . 
          return ((case  ((processPending ((Mk_Minterrupts d)) w__16
                            ((get_Sinterrupts_bits w__17  ::  64 Word.word)) sIE)) of
            Ints_Empty (_) => None
          | Ints_Pending (p) =>
             (let r = (p, Supervisor) in
             Some r)
          | Ints_Delegated (d) =>
             if uIE then
               (let r = (d, User) in
               Some r)
             else None
          ))))))))
     )))))))))))))))))))))\<close> 
  for  priv  :: " Privilege "


\<comment> \<open>\<open>val dispatchInterrupt : Privilege -> M (maybe ((InterruptType * Privilege)))\<close>\<close>

definition dispatchInterrupt  :: \<open> Privilege \<Rightarrow>((register_value),((InterruptType*Privilege)option),(exception))monad \<close>  where 
     \<open> dispatchInterrupt priv = (
   or_boolM (haveUsrMode ()  \<bind> ((\<lambda> (w__0 :: bool) .  return ((\<not> w__0)))))
     (and_boolM (haveSupMode ()  \<bind> ((\<lambda> (w__1 :: bool) .  return ((\<not> w__1)))))
        (haveNExt ()  \<bind> ((\<lambda> (w__2 :: bool) .  return ((\<not> w__2)))))) \<bind> ((\<lambda> (w__4 :: bool) . 
   if w__4 then
     (assert_exp (((priv = Machine))) (''invalid current privilege'') \<then>
     read_reg mip_ref) \<bind> ((\<lambda> (w__5 :: Minterrupts) . 
     read_reg mie_ref \<bind> ((\<lambda> (w__6 :: Minterrupts) . 
     (let enabled_pending =
       ((and_vec ((get_Minterrupts_bits w__5  ::  64 Word.word))
          ((get_Minterrupts_bits w__6  ::  64 Word.word))
         ::  64 Word.word)) in
     return ((case  ((findPendingInterrupt enabled_pending)) of
       Some (i) =>
        (let r = (i, Machine) in
        Some r)
     | None => None
     )))))))
   else
     (getPendingSet priv  :: ( (( 64 Word.word * Privilege))option) M) \<bind> ((\<lambda> (w__7 ::
        (( 64 Word.word * Privilege))option) . 
     return ((case  w__7 of
       None => None
     | Some ((ip, p)) =>
        (case  ((findPendingInterrupt ip)) of
          None => None
        | Some (i) =>
           (let r = (i, p) in
           Some r)
        )
     )))))))\<close> 
  for  priv  :: " Privilege "


\<comment> \<open>\<open>val tval : maybe (mword ty64) -> mword ty64\<close>\<close>

fun tval  :: \<open>((64)Word.word)option \<Rightarrow>(64)Word.word \<close>  where 
     \<open> tval (Some (e)) = ( e )\<close> 
  for  e  :: "(64)Word.word "
|\<open> tval None = ( (EXTZ (( 64 :: int)::ii) ( 0b0 ::  1 Word.word)  ::  64 Word.word))\<close>


\<comment> \<open>\<open>val rvfi_trap : unit -> unit\<close>\<close>

definition rvfi_trap  :: \<open> unit \<Rightarrow> unit \<close>  where 
     \<open> rvfi_trap _ = ( ()  )\<close>


\<comment> \<open>\<open>val trap_handler : Privilege -> bool -> mword ty8 -> mword ty64 -> maybe (mword ty64) -> maybe unit -> M (mword ty64)\<close>\<close>

definition trap_handler  :: \<open> Privilege \<Rightarrow> bool \<Rightarrow>(8)Word.word \<Rightarrow>(64)Word.word \<Rightarrow>(xlenbits)option \<Rightarrow>(ext_exception)option \<Rightarrow>((register_value),((64)Word.word),(exception))monad \<close>  where 
     \<open> trap_handler (del_priv :: Privilege) (intr :: bool) (c :: exc_code) (pc :: xlenbits) (info ::
   xlenbits option) (ext ::  ext_exception option) = (
   (let (_ :: unit) = (rvfi_trap () ) in
   (let (_ :: unit) =
     (if ((get_config_print_platform () )) then
       print_dbg
         (((@) (''handling '')
             (((@) (if intr then (''int#'') else (''exc#''))
                 (((@) ((string_of_bits c))
                     (((@) ('' at priv '')
                         (((@) ((privLevel_to_str del_priv))
                             (((@) ('' with tval '')
                                 ((string_of_bits ((tval info  ::  64 Word.word))))))))))))))))
     else () ) in
   (let (_ :: unit) = (cancel_reservation () ) in
   (case  del_priv of
     Machine =>
      ((set_Mcause_IsInterrupt mcause_ref ((bool_to_bits intr  ::  1 Word.word)) \<then>
      set_Mcause_Cause mcause_ref ((EXTZ (( 63 :: int)::ii) c  ::  63 Word.word))) \<then>
      read_reg mstatus_ref) \<bind> ((\<lambda> (w__0 :: Mstatus) . 
      ((set_Mstatus_MPIE mstatus_ref ((get_Mstatus_MIE w__0  ::  1 Word.word)) \<then>
      set_Mstatus_MIE mstatus_ref ( 0b0 ::  1 Word.word)) \<then>
      read_reg cur_privilege_ref) \<bind> ((\<lambda> (w__1 :: Privilege) . 
      (((set_Mstatus_MPP mstatus_ref ((privLevel_to_bits w__1  ::  2 Word.word)) \<then>
      write_reg mtval_ref ((tval info  ::  64 Word.word))) \<then>
      write_reg mepc_ref pc) \<then>
      write_reg cur_privilege_ref del_priv) \<then>
      ((let (_ :: unit) = (handle_trap_extension del_priv pc ext) in
      ((if ((get_config_print_reg () )) then
         read_reg mstatus_ref \<bind> ((\<lambda> (w__2 :: Mstatus) . 
         return ((print_dbg
                    (((@) (''CSR mstatus <- '')
                        ((string_of_bits ((get_Mstatus_bits w__2  ::  64 Word.word))))))))))
       else return () ) \<then>
      read_reg mcause_ref) \<bind> ((\<lambda> (w__3 :: Mcause) . 
      (prepare_trap_vector del_priv w__3  :: ( 64 Word.word) M)))))))))
   | Supervisor =>
      haveSupMode ()  \<bind> ((\<lambda> (w__5 :: bool) . 
      (((assert_exp w__5 (''no supervisor mode present for delegation'') \<then>
      set_Mcause_IsInterrupt scause_ref ((bool_to_bits intr  ::  1 Word.word))) \<then>
      set_Mcause_Cause scause_ref ((EXTZ (( 63 :: int)::ii) c  ::  63 Word.word))) \<then>
      read_reg mstatus_ref) \<bind> ((\<lambda> (w__6 :: Mstatus) . 
      ((set_Mstatus_SPIE mstatus_ref ((get_Mstatus_SIE w__6  ::  1 Word.word)) \<then>
      set_Mstatus_SIE mstatus_ref ( 0b0 ::  1 Word.word)) \<then>
      read_reg cur_privilege_ref) \<bind> ((\<lambda> (w__7 :: Privilege) . 
      (case  w__7 of
        User => return ( 0b0 ::  1 Word.word)
      | Supervisor => return ( 0b1 ::  1 Word.word)
      | Machine => (internal_error (''invalid privilege for s-mode trap'')  :: ( 1 Word.word) M)
      ) \<bind> ((\<lambda> (w__9 ::  1 Word.word) . 
      (((set_Mstatus_SPP mstatus_ref w__9 \<then>
      write_reg stval_ref ((tval info  ::  64 Word.word))) \<then>
      write_reg sepc_ref pc) \<then>
      write_reg cur_privilege_ref del_priv) \<then>
      ((let (_ :: unit) = (handle_trap_extension del_priv pc ext) in
      ((if ((get_config_print_reg () )) then
         read_reg mstatus_ref \<bind> ((\<lambda> (w__10 :: Mstatus) . 
         return ((print_dbg
                    (((@) (''CSR mstatus <- '')
                        ((string_of_bits ((get_Mstatus_bits w__10  ::  64 Word.word))))))))))
       else return () ) \<then>
      read_reg scause_ref) \<bind> ((\<lambda> (w__11 :: Mcause) . 
      (prepare_trap_vector del_priv w__11  :: ( 64 Word.word) M)))))))))))))
   | User =>
      haveUsrMode ()  \<bind> ((\<lambda> (w__13 :: bool) . 
      (((assert_exp w__13 (''no user mode present for delegation'') \<then>
      set_Mcause_IsInterrupt ucause_ref ((bool_to_bits intr  ::  1 Word.word))) \<then>
      set_Mcause_Cause ucause_ref ((EXTZ (( 63 :: int)::ii) c  ::  63 Word.word))) \<then>
      read_reg mstatus_ref) \<bind> ((\<lambda> (w__14 :: Mstatus) . 
      ((((set_Mstatus_UPIE mstatus_ref ((get_Mstatus_UIE w__14  ::  1 Word.word)) \<then>
      set_Mstatus_UIE mstatus_ref ( 0b0 ::  1 Word.word)) \<then>
      write_reg utval_ref ((tval info  ::  64 Word.word))) \<then>
      write_reg uepc_ref pc) \<then>
      write_reg cur_privilege_ref del_priv) \<then>
      ((let (_ :: unit) = (handle_trap_extension del_priv pc ext) in
      ((if ((get_config_print_reg () )) then
         read_reg mstatus_ref \<bind> ((\<lambda> (w__15 :: Mstatus) . 
         return ((print_dbg
                    (((@) (''CSR mstatus <- '')
                        ((string_of_bits ((get_Mstatus_bits w__15  ::  64 Word.word))))))))))
       else return () ) \<then>
      read_reg ucause_ref) \<bind> ((\<lambda> (w__16 :: Mcause) . 
      (prepare_trap_vector del_priv w__16  :: ( 64 Word.word) M)))))))))
   )))))\<close> 
  for  del_priv  :: " Privilege " 
  and  intr  :: " bool " 
  and  c  :: "(8)Word.word " 
  and  pc  :: "(64)Word.word " 
  and  info  :: "(xlenbits)option " 
  and  ext  :: "(ext_exception)option "


\<comment> \<open>\<open>val exception_handler : Privilege -> ctl_result -> mword ty64 -> M (mword ty64)\<close>\<close>

definition exception_handler  :: \<open> Privilege \<Rightarrow> ctl_result \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),((64)Word.word),(exception))monad \<close>  where 
     \<open> exception_handler (cur_priv :: Privilege) (ctl :: ctl_result) (pc :: xlenbits) = (
   (case  (cur_priv, ctl) of
     (_, CTL_TRAP (e)) =>
      exception_delegatee(sync_exception_trap   e) cur_priv \<bind> ((\<lambda> del_priv . 
      (let (_ :: unit) =
        (if ((get_config_print_platform () )) then
          print_dbg
            (((@) (''trapping from '')
                (((@) ((privLevel_to_str cur_priv))
                    (((@) ('' to '')
                        (((@) ((privLevel_to_str del_priv))
                            (((@) ('' to handle '')
                                ((exceptionType_to_str(sync_exception_trap   e)))))))))))))
        else () ) in
      (trap_handler del_priv False ((exceptionType_to_bits(sync_exception_trap   e)  ::  8 Word.word)) pc(sync_exception_excinfo  
         e)(sync_exception_ext_exception   e)
        :: ( 64 Word.word) M))))
   | (_, CTL_MRET (_)) =>
      read_reg cur_privilege_ref \<bind> ((\<lambda> prev_priv . 
      read_reg mstatus_ref \<bind> ((\<lambda> (w__1 :: Mstatus) . 
      ((set_Mstatus_MIE mstatus_ref ((get_Mstatus_MPIE w__1  ::  1 Word.word)) \<then>
      set_Mstatus_MPIE mstatus_ref ( 0b1 ::  1 Word.word)) \<then>
      read_reg mstatus_ref) \<bind> ((\<lambda> (w__2 :: Mstatus) . 
      privLevel_of_bits ((get_Mstatus_MPP w__2  ::  2 Word.word)) \<bind> ((\<lambda> (w__3 :: Privilege) . 
      (write_reg cur_privilege_ref w__3 \<then>
      haveUsrMode () ) \<bind> ((\<lambda> (w__4 :: bool) . 
      (set_Mstatus_MPP mstatus_ref
        ((privLevel_to_bits (if w__4 then User else Machine)  ::  2 Word.word)) \<then>
      read_reg cur_privilege_ref) \<bind> ((\<lambda> (w__5 :: Privilege) . 
      (((if (((w__5 \<noteq> Machine))) then set_Mstatus_MPRV mstatus_ref ( 0b0 ::  1 Word.word)
       else return () ) \<then>
      (if ((get_config_print_reg () )) then
         read_reg mstatus_ref \<bind> ((\<lambda> (w__6 :: Mstatus) . 
         return ((print_dbg
                    (((@) (''CSR mstatus <- '')
                        ((string_of_bits ((get_Mstatus_bits w__6  ::  64 Word.word))))))))))
       else return () )) \<then>
      (if ((get_config_print_platform () )) then
         read_reg cur_privilege_ref \<bind> ((\<lambda> (w__7 :: Privilege) . 
         return ((print_dbg
                    (((@) (''ret-ing from '')
                        (((@) ((privLevel_to_str prev_priv))
                            (((@) ('' to '') ((privLevel_to_str w__7))))))))))))
       else return () )) \<then>
      ((let (_ :: unit) = (cancel_reservation () ) in
      (prepare_xret_target Machine  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__8 ::  64 Word.word) . 
      (pc_alignment_mask ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__9 ::  64 Word.word) . 
      return ((and_vec w__8 w__9  ::  64 Word.word))))))))))))))))))))
   | (_, CTL_SRET (_)) =>
      read_reg cur_privilege_ref \<bind> ((\<lambda> prev_priv . 
      read_reg mstatus_ref \<bind> ((\<lambda> (w__10 :: Mstatus) . 
      ((set_Mstatus_SIE mstatus_ref ((get_Mstatus_SPIE w__10  ::  1 Word.word)) \<then>
      set_Mstatus_SPIE mstatus_ref ( 0b1 ::  1 Word.word)) \<then>
      read_reg mstatus_ref) \<bind> ((\<lambda> (w__11 :: Mstatus) . 
      ((write_reg
        cur_privilege_ref
        (if (((((get_Mstatus_SPP w__11  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))) then Supervisor
         else User) \<then>
      set_Mstatus_SPP mstatus_ref ( 0b0 ::  1 Word.word)) \<then>
      read_reg cur_privilege_ref) \<bind> ((\<lambda> (w__12 :: Privilege) . 
      (((if (((w__12 \<noteq> Machine))) then set_Mstatus_MPRV mstatus_ref ( 0b0 ::  1 Word.word)
       else return () ) \<then>
      (if ((get_config_print_reg () )) then
         read_reg mstatus_ref \<bind> ((\<lambda> (w__13 :: Mstatus) . 
         return ((print_dbg
                    (((@) (''CSR mstatus <- '')
                        ((string_of_bits ((get_Mstatus_bits w__13  ::  64 Word.word))))))))))
       else return () )) \<then>
      (if ((get_config_print_platform () )) then
         read_reg cur_privilege_ref \<bind> ((\<lambda> (w__14 :: Privilege) . 
         return ((print_dbg
                    (((@) (''ret-ing from '')
                        (((@) ((privLevel_to_str prev_priv))
                            (((@) ('' to '') ((privLevel_to_str w__14))))))))))))
       else return () )) \<then>
      ((let (_ :: unit) = (cancel_reservation () ) in
      (prepare_xret_target Supervisor  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__15 ::  64 Word.word) . 
      (pc_alignment_mask ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__16 ::  64 Word.word) . 
      return ((and_vec w__15 w__16  ::  64 Word.word))))))))))))))))
   | (_, CTL_URET (_)) =>
      read_reg cur_privilege_ref \<bind> ((\<lambda> prev_priv . 
      read_reg mstatus_ref \<bind> ((\<lambda> (w__17 :: Mstatus) . 
      ((((set_Mstatus_UIE mstatus_ref ((get_Mstatus_UPIE w__17  ::  1 Word.word)) \<then>
      set_Mstatus_UPIE mstatus_ref ( 0b1 ::  1 Word.word)) \<then>
      write_reg cur_privilege_ref User) \<then>
      (if ((get_config_print_reg () )) then
         read_reg mstatus_ref \<bind> ((\<lambda> (w__18 :: Mstatus) . 
         return ((print_dbg
                    (((@) (''CSR mstatus <- '')
                        ((string_of_bits ((get_Mstatus_bits w__18  ::  64 Word.word))))))))))
       else return () )) \<then>
      (if ((get_config_print_platform () )) then
         read_reg cur_privilege_ref \<bind> ((\<lambda> (w__19 :: Privilege) . 
         return ((print_dbg
                    (((@) (''ret-ing from '')
                        (((@) ((privLevel_to_str prev_priv))
                            (((@) ('' to '') ((privLevel_to_str w__19))))))))))))
       else return () )) \<then>
      ((let (_ :: unit) = (cancel_reservation () ) in
      (prepare_xret_target User  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__20 ::  64 Word.word) . 
      (pc_alignment_mask ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__21 ::  64 Word.word) . 
      return ((and_vec w__20 w__21  ::  64 Word.word))))))))))))
   ))\<close> 
  for  cur_priv  :: " Privilege " 
  and  ctl  :: " ctl_result " 
  and  pc  :: "(64)Word.word "


\<comment> \<open>\<open>val handle_mem_exception : mword ty64 -> ExceptionType -> M unit\<close>\<close>

definition handle_mem_exception  :: \<open>(64)Word.word \<Rightarrow> ExceptionType \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> handle_mem_exception (addr :: xlenbits) (e :: ExceptionType) = (
   (let (t :: sync_exception) =
     ((| sync_exception_trap = e, 
        sync_exception_excinfo = (Some addr), 
        sync_exception_ext_exception = None |)) in
   read_reg cur_privilege_ref \<bind> ((\<lambda> (w__0 :: Privilege) . 
   (read_reg PC_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
   (exception_handler w__0 (CTL_TRAP t) w__1  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
   set_next_pc w__2))))))))\<close> 
  for  addr  :: "(64)Word.word " 
  and  e  :: " ExceptionType "


\<comment> \<open>\<open>val handle_exception : ExceptionType -> M unit\<close>\<close>

definition handle_exception  :: \<open> ExceptionType \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> handle_exception e = (
   (let (t :: sync_exception) =
     ((| sync_exception_trap = e, 
        sync_exception_excinfo = None, 
        sync_exception_ext_exception = None |)) in
   read_reg cur_privilege_ref \<bind> ((\<lambda> (w__0 :: Privilege) . 
   (read_reg PC_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
   (exception_handler w__0 (CTL_TRAP t) w__1  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
   set_next_pc w__2))))))))\<close> 
  for  e  :: " ExceptionType "


\<comment> \<open>\<open>val handle_interrupt : InterruptType -> Privilege -> M unit\<close>\<close>

definition handle_interrupt  :: \<open> InterruptType \<Rightarrow> Privilege \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> handle_interrupt (i :: InterruptType) (del_priv :: Privilege) = (
   (read_reg PC_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (trap_handler del_priv True ((interruptType_to_bits i  ::  8 Word.word)) w__0 None None
     :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
   set_next_pc w__1)))))\<close> 
  for  i  :: " InterruptType " 
  and  del_priv  :: " Privilege "


\<comment> \<open>\<open>val init_sys : unit -> M unit\<close>\<close>

definition init_sys  :: \<open> unit \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> init_sys _ = (
   (((((((((((write_reg cur_privilege_ref Machine \<then>
   write_reg mhartid_ref ((EXTZ (( 64 :: int)::ii) ( 0b0 ::  1 Word.word)  ::  64 Word.word))) \<then>
   set_Misa_MXL misa_ref ((arch_to_bits RV64  ::  2 Word.word))) \<then>
   set_Misa_A misa_ref ( 0b1 ::  1 Word.word)) \<then>
   set_Misa_C misa_ref ((bool_to_bits ((sys_enable_rvc () ))  ::  1 Word.word))) \<then>
   set_Misa_I misa_ref ( 0b1 ::  1 Word.word)) \<then>
   set_Misa_M misa_ref ( 0b1 ::  1 Word.word)) \<then>
   set_Misa_U misa_ref ( 0b1 ::  1 Word.word)) \<then>
   set_Misa_S misa_ref ( 0b1 ::  1 Word.word)) \<then>
   set_Misa_F misa_ref ((bool_to_bits ((sys_enable_fdext () ))  ::  1 Word.word))) \<then>
   set_Misa_D misa_ref ((bool_to_bits ((sys_enable_fdext () ))  ::  1 Word.word))) \<then>
   read_reg mstatus_ref) \<bind> ((\<lambda> (w__0 :: Mstatus) . 
   read_reg misa_ref \<bind> ((\<lambda> (w__1 :: Misa) . 
   (write_reg mstatus_ref ((set_mstatus_SXL w__0 ((get_Misa_MXL w__1  ::  2 Word.word)))) \<then>
   read_reg mstatus_ref) \<bind> ((\<lambda> (w__2 :: Mstatus) . 
   read_reg misa_ref \<bind> ((\<lambda> (w__3 :: Misa) . 
   ((write_reg mstatus_ref ((set_mstatus_UXL w__2 ((get_Misa_MXL w__3  ::  2 Word.word)))) \<then>
   set_Mstatus_SD mstatus_ref ( 0b0 ::  1 Word.word)) \<then>
   read_reg mstatus_ref) \<bind> ((\<lambda> (w__4 :: Mstatus) . 
   ((((((((((((((((write_reg
     mstatus_ref
     ((Mk_Mstatus
         ((update_subrange_vec_dec ((get_Mstatus_bits w__4  ::  64 Word.word)) (( 37 :: int)::ii) (( 36 :: int)::ii)
             ( 0b00 ::  2 Word.word)
            ::  64 Word.word)))) \<then>
   set_Mstatush_bits mstatush_ref ((EXTZ (( 32 :: int)::ii) ( 0b0 ::  1 Word.word)  ::  32 Word.word))) \<then>
   set_Minterrupts_bits mip_ref ((EXTZ (( 64 :: int)::ii) ( 0b0 ::  1 Word.word)  ::  64 Word.word))) \<then>
   set_Minterrupts_bits mie_ref ((EXTZ (( 64 :: int)::ii) ( 0b0 ::  1 Word.word)  ::  64 Word.word))) \<then>
   set_Minterrupts_bits mideleg_ref ((EXTZ (( 64 :: int)::ii) ( 0b0 ::  1 Word.word)  ::  64 Word.word))) \<then>
   set_Medeleg_bits medeleg_ref ((EXTZ (( 64 :: int)::ii) ( 0b0 ::  1 Word.word)  ::  64 Word.word))) \<then>
   set_Mtvec_bits mtvec_ref ((EXTZ (( 64 :: int)::ii) ( 0b0 ::  1 Word.word)  ::  64 Word.word))) \<then>
   set_Mcause_bits mcause_ref ((EXTZ (( 64 :: int)::ii) ( 0b0 ::  1 Word.word)  ::  64 Word.word))) \<then>
   write_reg mepc_ref ((EXTZ (( 64 :: int)::ii) ( 0b0 ::  1 Word.word)  ::  64 Word.word))) \<then>
   write_reg mtval_ref ((EXTZ (( 64 :: int)::ii) ( 0b0 ::  1 Word.word)  ::  64 Word.word))) \<then>
   write_reg mscratch_ref ((EXTZ (( 64 :: int)::ii) ( 0b0 ::  1 Word.word)  ::  64 Word.word))) \<then>
   write_reg mcycle_ref ((EXTZ (( 64 :: int)::ii) ( 0b0 ::  1 Word.word)  ::  64 Word.word))) \<then>
   write_reg mtime_ref ((EXTZ (( 64 :: int)::ii) ( 0b0 ::  1 Word.word)  ::  64 Word.word))) \<then>
   set_Counteren_bits mcounteren_ref ((EXTZ (( 32 :: int)::ii) ( 0b0 ::  1 Word.word)  ::  32 Word.word))) \<then>
   write_reg minstret_ref ((EXTZ (( 64 :: int)::ii) ( 0b0 ::  1 Word.word)  ::  64 Word.word))) \<then>
   write_reg minstret_written_ref False) \<then>
   init_pmp () ) \<then>
   (if ((get_config_print_reg () )) then
     read_reg mstatus_ref \<bind> ((\<lambda> (w__5 :: Mstatus) . 
     return ((print_dbg
                (((@) (''CSR mstatus <- '')
                    (((@) ((string_of_bits ((get_Mstatus_bits w__5  ::  64 Word.word))))
                        (((@) ('' (input: '')
                            (((@)
                                ((string_of_bits ((EXTZ (( 64 :: int)::ii) ( 0b0 ::  1 Word.word)  ::  64 Word.word))))
                                ('')'')))))))))))))
   else return () ))))))))))))\<close>


\<comment> \<open>\<open>val MemoryOpResult_add_meta : forall 't. MemoryOpResult 't -> unit -> MemoryOpResult (('t * unit))\<close>\<close>

fun MemoryOpResult_add_meta  :: \<open> 't MemoryOpResult \<Rightarrow> unit \<Rightarrow>('t*unit)MemoryOpResult \<close>  where 
     \<open> MemoryOpResult_add_meta (MemValue (v)) m = ( MemValue (v, m))\<close> 
  for  v  :: " 't " 
  and  m  :: " unit "
|\<open> MemoryOpResult_add_meta (MemException (e)) m = ( MemException e )\<close> 
  for  e  :: " ExceptionType " 
  and  m  :: " unit "


\<comment> \<open>\<open>val MemoryOpResult_drop_meta : forall 't. MemoryOpResult (('t * unit)) -> MemoryOpResult 't\<close>\<close>

fun MemoryOpResult_drop_meta  :: \<open>('t*unit)MemoryOpResult \<Rightarrow> 't MemoryOpResult \<close>  where 
     \<open> MemoryOpResult_drop_meta (MemValue ((v, m))) = ( MemValue v )\<close> 
  for  m  :: " unit " 
  and  v  :: " 't "
|\<open> MemoryOpResult_drop_meta (MemException (e)) = ( MemException e )\<close> 
  for  e  :: " ExceptionType "


\<comment> \<open>\<open>val elf_tohost : unit -> ii\<close>\<close>

\<comment> \<open>\<open>val elf_entry : unit -> ii\<close>\<close>



\<comment> \<open>\<open>val phys_mem_segments : unit -> list ((mword ty64 * mword ty64))\<close>\<close>

definition phys_mem_segments  :: \<open> unit \<Rightarrow>((64)Word.word*(64)Word.word)list \<close>  where 
     \<open> phys_mem_segments _ = (
   ((plat_rom_base ()   ::  64 Word.word), (plat_rom_size ()   ::  64 Word.word)) #
     (((plat_ram_base ()   ::  64 Word.word), (plat_ram_size ()   ::  64 Word.word)) # []))\<close>


\<comment> \<open>\<open>val within_phys_mem : mword ty64 -> integer -> bool\<close>\<close>

definition within_phys_mem  :: \<open>(64)Word.word \<Rightarrow> int \<Rightarrow> bool \<close>  where 
     \<open> within_phys_mem (addr :: xlenbits) (width :: int) = (
   (let addr_int = (Word.uint addr) in
   (let ram_base_int = (Word.uint ((plat_ram_base ()   ::  64 Word.word))) in
   (let rom_base_int = (Word.uint ((plat_rom_base ()   ::  64 Word.word))) in
   (let ram_size_int = (Word.uint ((plat_ram_size ()   ::  64 Word.word))) in
   (let rom_size_int = (Word.uint ((plat_rom_size ()   ::  64 Word.word))) in
   if (((((ram_base_int \<le> addr_int)) \<and> ((((addr_int + ((id0 width)))) \<le> ((ram_base_int + ram_size_int)))))))
   then
     True
   else if (((((rom_base_int \<le> addr_int)) \<and> ((((addr_int + ((id0 width)))) \<le>
                   ((rom_base_int + rom_size_int))))))) then
     True
   else
     (let (_ :: unit) =
       (print_dbg
         (((@) (''within_phys_mem: '')
             (((@) ((string_of_bits addr)) ('' not within phys-mem:'')))))) in
     (let (_ :: unit) =
       (print_dbg
         (((@) (''  plat_rom_base: '') ((string_of_bits ((plat_rom_base ()   ::  64 Word.word))))))) in
     (let (_ :: unit) =
       (print_dbg
         (((@) (''  plat_rom_size: '') ((string_of_bits ((plat_rom_size ()   ::  64 Word.word))))))) in
     (let (_ :: unit) =
       (print_dbg
         (((@) (''  plat_ram_base: '') ((string_of_bits ((plat_ram_base ()   ::  64 Word.word))))))) in
     (let (_ :: unit) =
       (print_dbg
         (((@) (''  plat_ram_size: '') ((string_of_bits ((plat_ram_size ()   ::  64 Word.word))))))) in
     False)))))))))))\<close> 
  for  addr  :: "(64)Word.word " 
  and  width  :: " int "


\<comment> \<open>\<open>val within_clint : mword ty64 -> integer -> bool\<close>\<close>

definition within_clint  :: \<open>(64)Word.word \<Rightarrow> int \<Rightarrow> bool \<close>  where 
     \<open> within_clint (addr :: xlenbits) (width :: int) = (
   (let addr_int = (Word.uint addr) in
   (let clint_base_int = (Word.uint ((plat_clint_base ()   ::  64 Word.word))) in
   (let clint_size_int = (Word.uint ((plat_clint_size ()   ::  64 Word.word))) in
   (((clint_base_int \<le> addr_int)) \<and> ((((addr_int + ((id0 width)))) \<le> ((clint_base_int + clint_size_int)))))))))\<close> 
  for  addr  :: "(64)Word.word " 
  and  width  :: " int "


\<comment> \<open>\<open>val within_htif_writable : mword ty64 -> integer -> bool\<close>\<close>

definition within_htif_writable  :: \<open>(64)Word.word \<Rightarrow> int \<Rightarrow> bool \<close>  where 
     \<open> within_htif_writable (addr :: xlenbits) (width :: int) = (
   ((((((plat_htif_tohost ()   ::  64 Word.word)) = addr))) \<or> ((((((((add_vec_int ((plat_htif_tohost ()   ::  64 Word.word)) (( 4 :: int)::ii)  ::  64 Word.word)) = addr))) \<and> (((width = (( 4 :: int)::ii)))))))))\<close> 
  for  addr  :: "(64)Word.word " 
  and  width  :: " int "


\<comment> \<open>\<open>val within_htif_readable : mword ty64 -> integer -> bool\<close>\<close>

definition within_htif_readable  :: \<open>(64)Word.word \<Rightarrow> int \<Rightarrow> bool \<close>  where 
     \<open> within_htif_readable (addr :: xlenbits) (width :: int) = (
   ((((((plat_htif_tohost ()   ::  64 Word.word)) = addr))) \<or> ((((((((add_vec_int ((plat_htif_tohost ()   ::  64 Word.word)) (( 4 :: int)::ii)  ::  64 Word.word)) = addr))) \<and> (((width = (( 4 :: int)::ii)))))))))\<close> 
  for  addr  :: "(64)Word.word " 
  and  width  :: " int "


definition MSIP_BASE  :: \<open>(64)Word.word \<close>  where 
     \<open> MSIP_BASE = ( ( 0x0000000000000000 ::  64 Word.word))\<close>


definition MTIMECMP_BASE  :: \<open>(64)Word.word \<close>  where 
     \<open> MTIMECMP_BASE = ( ( 0x0000000000004000 ::  64 Word.word))\<close>


definition MTIMECMP_BASE_HI  :: \<open>(64)Word.word \<close>  where 
     \<open> MTIMECMP_BASE_HI = ( ( 0x0000000000004004 ::  64 Word.word))\<close>


definition MTIME_BASE  :: \<open>(64)Word.word \<close>  where 
     \<open> MTIME_BASE = ( ( 0x000000000000BFF8 ::  64 Word.word))\<close>


definition MTIME_BASE_HI  :: \<open>(64)Word.word \<close>  where 
     \<open> MTIME_BASE_HI = ( ( 0x000000000000BFFC ::  64 Word.word))\<close>


\<comment> \<open>\<open>val clint_load : forall 'int8_times_n. Size 'int8_times_n => AccessType unit -> mword ty64 -> integer -> M (MemoryOpResult (mword 'int8_times_n))\<close>\<close>

definition clint_load  :: \<open>(unit)AccessType \<Rightarrow>(64)Word.word \<Rightarrow> int \<Rightarrow>((register_value),((('int8_times_n::len)Word.word)MemoryOpResult),(exception))monad \<close>  where 
     \<open> clint_load t addr width = (
   (let addr = ((sub_vec addr ((plat_clint_base ()   ::  64 Word.word))  ::  64 Word.word)) in
   if ((((((addr = MSIP_BASE))) \<and> ((((((((id0 width)) = (( 8 :: int)::ii)))) \<or> (((((id0 width)) = (( 4 :: int)::ii)))))))))) then
     ((if ((get_config_print_platform () )) then
        read_reg mip_ref \<bind> ((\<lambda> (w__0 :: Minterrupts) . 
        return ((print_dbg
                   (((@) (''clint['')
                       (((@) ((string_of_bits addr))
                           (((@) (''] -> '')
                               ((string_of_bits ((get_Minterrupts_MSI w__0  ::  1 Word.word))))))))))))))
      else return () ) \<then>
     read_reg mip_ref) \<bind> ((\<lambda> (w__1 :: Minterrupts) . 
     return (MemValue ((zero_extend ((get_Minterrupts_MSI w__1  ::  1 Word.word))
                          (((( 8 :: int)::ii) * ((id0 width))))
                         :: ( 'int8_times_n::len)Word.word)))))
   else if ((((((addr = MTIMECMP_BASE))) \<and> (((((id0 width)) = (( 4 :: int)::ii))))))) then
     ((if ((get_config_print_platform () )) then
        (read_reg mtimecmp_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
        return ((print_dbg
                   (((@) (''clint<4>['')
                       (((@) ((string_of_bits addr))
                           (((@) (''] -> '')
                               ((string_of_bits
                                   ((subrange_vec_dec w__2 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))))))))))))))
      else return () ) \<then>
     (read_reg mtimecmp_ref  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__3 ::  64 Word.word) . 
     return (MemValue ((Word.ucast
                          ((zero_extend ((subrange_vec_dec w__3 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
                              (( 32 :: int)::ii)
                             ::  32 Word.word))
                         :: ( 'int8_times_n::len)Word.word)))))
   else if ((((((addr = MTIMECMP_BASE))) \<and> (((((id0 width)) = (( 8 :: int)::ii))))))) then
     ((if ((get_config_print_platform () )) then
        (read_reg mtimecmp_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__4 ::  64 Word.word) . 
        return ((print_dbg
                   (((@) (''clint<8>['')
                       (((@) ((string_of_bits addr))
                           (((@) (''] -> '') ((string_of_bits w__4))))))))))))
      else return () ) \<then>
     (read_reg mtimecmp_ref  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__5 ::  64 Word.word) . 
     return (MemValue ((Word.ucast ((zero_extend w__5 (( 64 :: int)::ii)  ::  64 Word.word))  :: ( 'int8_times_n::len)Word.word)))))
   else if ((((((addr = MTIMECMP_BASE_HI))) \<and> (((((id0 width)) = (( 4 :: int)::ii))))))) then
     ((if ((get_config_print_platform () )) then
        (read_reg mtimecmp_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__6 ::  64 Word.word) . 
        return ((print_dbg
                   (((@) (''clint-hi<4>['')
                       (((@) ((string_of_bits addr))
                           (((@) (''] -> '')
                               ((string_of_bits
                                   ((subrange_vec_dec w__6 (( 63 :: int)::ii) (( 32 :: int)::ii)  ::  32 Word.word))))))))))))))
      else return () ) \<then>
     (read_reg mtimecmp_ref  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__7 ::  64 Word.word) . 
     return (MemValue ((Word.ucast
                          ((zero_extend ((subrange_vec_dec w__7 (( 63 :: int)::ii) (( 32 :: int)::ii)  ::  32 Word.word))
                              (( 32 :: int)::ii)
                             ::  32 Word.word))
                         :: ( 'int8_times_n::len)Word.word)))))
   else if ((((((addr = MTIME_BASE))) \<and> (((((id0 width)) = (( 4 :: int)::ii))))))) then
     ((if ((get_config_print_platform () )) then
        (read_reg mtime_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__8 ::  64 Word.word) . 
        return ((print_dbg
                   (((@) (''clint['')
                       (((@) ((string_of_bits addr))
                           (((@) (''] -> '') ((string_of_bits w__8))))))))))))
      else return () ) \<then>
     (read_reg mtime_ref  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__9 ::  64 Word.word) . 
     return (MemValue ((Word.ucast
                          ((zero_extend ((subrange_vec_dec w__9 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
                              (( 32 :: int)::ii)
                             ::  32 Word.word))
                         :: ( 'int8_times_n::len)Word.word)))))
   else if ((((((addr = MTIME_BASE))) \<and> (((((id0 width)) = (( 8 :: int)::ii))))))) then
     ((if ((get_config_print_platform () )) then
        (read_reg mtime_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__10 ::  64 Word.word) . 
        return ((print_dbg
                   (((@) (''clint['')
                       (((@) ((string_of_bits addr))
                           (((@) (''] -> '') ((string_of_bits w__10))))))))))))
      else return () ) \<then>
     (read_reg mtime_ref  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__11 ::  64 Word.word) . 
     return (MemValue ((Word.ucast ((zero_extend w__11 (( 64 :: int)::ii)  ::  64 Word.word))
                         :: ( 'int8_times_n::len)Word.word)))))
   else if ((((((addr = MTIME_BASE_HI))) \<and> (((((id0 width)) = (( 4 :: int)::ii))))))) then
     ((if ((get_config_print_platform () )) then
        (read_reg mtime_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__12 ::  64 Word.word) . 
        return ((print_dbg
                   (((@) (''clint['')
                       (((@) ((string_of_bits addr))
                           (((@) (''] -> '') ((string_of_bits w__12))))))))))))
      else return () ) \<then>
     (read_reg mtime_ref  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__13 ::  64 Word.word) . 
     return (MemValue ((Word.ucast
                          ((zero_extend ((subrange_vec_dec w__13 (( 63 :: int)::ii) (( 32 :: int)::ii)  ::  32 Word.word))
                              (( 32 :: int)::ii)
                             ::  32 Word.word))
                         :: ( 'int8_times_n::len)Word.word)))))
   else
     (let (_ :: unit) =
       (if ((get_config_print_platform () )) then
         print_dbg
           (((@) (''clint['') (((@) ((string_of_bits addr)) (''] -> <not-mapped>'')))))
       else () ) in
     return ((case  t of
       Execute (_) => MemException (E_Fetch_Access_Fault () )
     | Read (Data1) => MemException (E_Load_Access_Fault () )
     | _ => MemException (E_SAMO_Access_Fault () )
     )))))\<close> 
  for  t  :: "(unit)AccessType " 
  and  addr  :: "(64)Word.word " 
  and  width  :: " int "


\<comment> \<open>\<open>val clint_dispatch : unit -> M unit\<close>\<close>

definition clint_dispatch  :: \<open> unit \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> clint_dispatch _ = (
   (((if ((get_config_print_platform () )) then
      (read_reg mtime_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
      return ((print_dbg (((@) (''clint::tick mtime <- '') ((string_of_bits w__0))))))))
    else return () ) \<then>
   set_Minterrupts_MTI mip_ref ( 0b0 ::  1 Word.word)) \<then>
   (read_reg mtimecmp_ref  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
   (read_reg mtime_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
   if ((zopz0zIzJ_u w__1 w__2)) then
     (if ((get_config_print_platform () )) then
        (read_reg mtime_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__3 ::  64 Word.word) . 
        return ((print_dbg (((@) ('' clint timer pending at mtime '') ((string_of_bits w__3))))))))
      else return () ) \<then>
     set_Minterrupts_MTI mip_ref ( 0b1 ::  1 Word.word)
   else return () )))))\<close>


\<comment> \<open>\<open>val clint_store : forall 'int8_times_n. Size 'int8_times_n => mword ty64 -> integer -> mword 'int8_times_n -> M (MemoryOpResult bool)\<close>\<close>

definition clint_store  :: \<open>(64)Word.word \<Rightarrow> int \<Rightarrow>('int8_times_n::len)Word.word \<Rightarrow>((register_value),((bool)MemoryOpResult),(exception))monad \<close>  where 
     \<open> clint_store addr width data = (
   (let addr = ((sub_vec addr ((plat_clint_base ()   ::  64 Word.word))  ::  64 Word.word)) in
   if ((((((addr = MSIP_BASE))) \<and> ((((((((id0 width)) = (( 8 :: int)::ii)))) \<or> (((((id0 width)) = (( 4 :: int)::ii)))))))))) then
     (let (_ :: unit) =
       (if ((get_config_print_platform () )) then
         print_dbg
           (((@) (''clint['')
               (((@) ((string_of_bits addr))
                   (((@) (''] <- '')
                       (((@) ((string_of_bits data))
                           (((@) ('' (mip.MSI <- '')
                               (((@) ((string_of_bit ((access_vec_dec data (( 0 :: int)::ii))))) ('')'')))))))))))))
       else () ) in
     (set_Minterrupts_MSI mip_ref (vec_of_bits [access_vec_dec data (( 0 :: int)::ii)]  ::  1 Word.word) \<then>
     clint_dispatch () ) \<then> return (MemValue True))
   else if ((((((addr = MTIMECMP_BASE))) \<and> (((((id0 width)) = (( 8 :: int)::ii))))))) then
     (let (data ::  64 Word.word) = ((Word.ucast data  ::  64 Word.word)) in
     (let (_ :: unit) =
       (if ((get_config_print_platform () )) then
         print_dbg
           (((@) (''clint<8>['')
               (((@) ((string_of_bits addr))
                   (((@) (''] <- '') (((@) ((string_of_bits data)) ('' (mtimecmp)'')))))))))
       else () ) in
     (write_reg mtimecmp_ref ((zero_extend data (( 64 :: int)::ii)  ::  64 Word.word)) \<then>
     clint_dispatch () ) \<then> return (MemValue True)))
   else if ((((((addr = MTIMECMP_BASE))) \<and> (((((id0 width)) = (( 4 :: int)::ii))))))) then
     (let (data ::  32 Word.word) = ((Word.ucast data  ::  32 Word.word)) in
     (let (_ :: unit) =
       (if ((get_config_print_platform () )) then
         print_dbg
           (((@) (''clint<4>['')
               (((@) ((string_of_bits addr))
                   (((@) (''] <- '') (((@) ((string_of_bits data)) ('' (mtimecmp)'')))))))))
       else () ) in
     (read_reg mtimecmp_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
     (write_reg
       mtimecmp_ref
       ((update_subrange_vec_dec w__0 (( 31 :: int)::ii) (( 0 :: int)::ii) ((zero_extend data (( 32 :: int)::ii)  ::  32 Word.word))
          ::  64 Word.word)) \<then>
     clint_dispatch () ) \<then> return (MemValue True)))))
   else if ((((((addr = MTIMECMP_BASE_HI))) \<and> (((((id0 width)) = (( 4 :: int)::ii))))))) then
     (let (data ::  32 Word.word) = ((Word.ucast data  ::  32 Word.word)) in
     (let (_ :: unit) =
       (if ((get_config_print_platform () )) then
         print_dbg
           (((@) (''clint<4>['')
               (((@) ((string_of_bits addr))
                   (((@) (''] <- '') (((@) ((string_of_bits data)) ('' (mtimecmp)'')))))))))
       else () ) in
     (read_reg mtimecmp_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
     (write_reg
       mtimecmp_ref
       ((update_subrange_vec_dec w__1 (( 63 :: int)::ii) (( 32 :: int)::ii) ((zero_extend data (( 32 :: int)::ii)  ::  32 Word.word))
          ::  64 Word.word)) \<then>
     clint_dispatch () ) \<then> return (MemValue True)))))
   else
     (let (_ :: unit) =
       (if ((get_config_print_platform () )) then
         print_dbg
           (((@) (''clint['')
               (((@) ((string_of_bits addr))
                   (((@) (''] <- '') (((@) ((string_of_bits data)) ('' (<unmapped>)'')))))))))
       else () ) in
     return (MemException (E_SAMO_Access_Fault () )))))\<close> 
  for  addr  :: "(64)Word.word " 
  and  width  :: " int " 
  and  data  :: "('int8_times_n::len)Word.word "


\<comment> \<open>\<open>val tick_clock : unit -> M unit\<close>\<close>

definition tick_clock  :: \<open> unit \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> tick_clock _ = (
   read_reg mcountinhibit_ref \<bind> ((\<lambda> (w__0 :: Counterin) . 
   ((if (((((get_Counterin_CY w__0  ::  1 Word.word)) = ( 0b0 ::  1 Word.word)))) then
      (read_reg mcycle_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
      write_reg mcycle_ref ((add_vec_int w__1 (( 1 :: int)::ii)  ::  64 Word.word))))
    else return () ) \<then>
   (read_reg mtime_ref  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
   write_reg mtime_ref ((add_vec_int w__2 (( 1 :: int)::ii)  ::  64 Word.word)) \<then> clint_dispatch () )))))\<close>


\<comment> \<open>\<open>val undefined_htif_cmd : unit -> M htif_cmd\<close>\<close>

definition undefined_htif_cmd  :: \<open> unit \<Rightarrow>((register_value),(htif_cmd),(exception))monad \<close>  where 
     \<open> undefined_htif_cmd _ = (
   ((return (failwith (''undefined value of unsupported type''))) :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::
      64 Word.word) . 
   return ((| htif_cmd_bits = w__0 |)))))\<close>


\<comment> \<open>\<open>val Mk_htif_cmd : mword ty64 -> htif_cmd\<close>\<close>

definition Mk_htif_cmd  :: \<open>(64)Word.word \<Rightarrow> htif_cmd \<close>  where 
     \<open> Mk_htif_cmd v = ( (| htif_cmd_bits = v |) )\<close> 
  for  v  :: "(64)Word.word "


definition get_htif_cmd_bits  :: \<open> htif_cmd \<Rightarrow>(64)Word.word \<close>  where 
     \<open> get_htif_cmd_bits v = ( (subrange_vec_dec(htif_cmd_bits   v) (( 63 :: int)::ii) (( 0 :: int)::ii)  ::  64 Word.word))\<close> 
  for  v  :: " htif_cmd "


definition set_htif_cmd_bits  :: \<open>((regstate),(register_value),(htif_cmd))register_ref \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_htif_cmd_bits r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       htif_cmd_bits := ((update_subrange_vec_dec(htif_cmd_bits   r) (( 63 :: int)::ii) (( 0 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(htif_cmd))register_ref " 
  and  v  :: "(64)Word.word "


definition update_htif_cmd_bits  :: \<open> htif_cmd \<Rightarrow>(64)Word.word \<Rightarrow> htif_cmd \<close>  where 
     \<open> update_htif_cmd_bits v x = (
   ( v (|
     htif_cmd_bits := ((update_subrange_vec_dec(htif_cmd_bits   v) (( 63 :: int)::ii) (( 0 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " htif_cmd " 
  and  x  :: "(64)Word.word "


\<comment> \<open>\<open>val _get_htif_cmd_cmd : htif_cmd -> mword ty8\<close>\<close>

definition get_htif_cmd_cmd  :: \<open> htif_cmd \<Rightarrow>(8)Word.word \<close>  where 
     \<open> get_htif_cmd_cmd v = ( (subrange_vec_dec(htif_cmd_bits   v) (( 55 :: int)::ii) (( 48 :: int)::ii)  ::  8 Word.word))\<close> 
  for  v  :: " htif_cmd "


\<comment> \<open>\<open>val _set_htif_cmd_cmd : register_ref regstate register_value htif_cmd -> mword ty8 -> M unit\<close>\<close>

definition set_htif_cmd_cmd  :: \<open>((regstate),(register_value),(htif_cmd))register_ref \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_htif_cmd_cmd r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       htif_cmd_bits := ((update_subrange_vec_dec(htif_cmd_bits   r) (( 55 :: int)::ii) (( 48 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(htif_cmd))register_ref " 
  and  v  :: "(8)Word.word "


\<comment> \<open>\<open>val _update_htif_cmd_cmd : htif_cmd -> mword ty8 -> htif_cmd\<close>\<close>

definition update_htif_cmd_cmd  :: \<open> htif_cmd \<Rightarrow>(8)Word.word \<Rightarrow> htif_cmd \<close>  where 
     \<open> update_htif_cmd_cmd v x = (
   ( v (|
     htif_cmd_bits := ((update_subrange_vec_dec(htif_cmd_bits   v) (( 55 :: int)::ii) (( 48 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " htif_cmd " 
  and  x  :: "(8)Word.word "


\<comment> \<open>\<open>val _get_htif_cmd_device : htif_cmd -> mword ty8\<close>\<close>

definition get_htif_cmd_device  :: \<open> htif_cmd \<Rightarrow>(8)Word.word \<close>  where 
     \<open> get_htif_cmd_device v = ( (subrange_vec_dec(htif_cmd_bits   v) (( 63 :: int)::ii) (( 56 :: int)::ii)  ::  8 Word.word))\<close> 
  for  v  :: " htif_cmd "


\<comment> \<open>\<open>val _set_htif_cmd_device : register_ref regstate register_value htif_cmd -> mword ty8 -> M unit\<close>\<close>

definition set_htif_cmd_device  :: \<open>((regstate),(register_value),(htif_cmd))register_ref \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_htif_cmd_device r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       htif_cmd_bits := ((update_subrange_vec_dec(htif_cmd_bits   r) (( 63 :: int)::ii) (( 56 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(htif_cmd))register_ref " 
  and  v  :: "(8)Word.word "


\<comment> \<open>\<open>val _update_htif_cmd_device : htif_cmd -> mword ty8 -> htif_cmd\<close>\<close>

definition update_htif_cmd_device  :: \<open> htif_cmd \<Rightarrow>(8)Word.word \<Rightarrow> htif_cmd \<close>  where 
     \<open> update_htif_cmd_device v x = (
   ( v (|
     htif_cmd_bits := ((update_subrange_vec_dec(htif_cmd_bits   v) (( 63 :: int)::ii) (( 56 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " htif_cmd " 
  and  x  :: "(8)Word.word "


\<comment> \<open>\<open>val _get_htif_cmd_payload : htif_cmd -> mword ty48\<close>\<close>

definition get_htif_cmd_payload  :: \<open> htif_cmd \<Rightarrow>(48)Word.word \<close>  where 
     \<open> get_htif_cmd_payload v = ( (subrange_vec_dec(htif_cmd_bits   v) (( 47 :: int)::ii) (( 0 :: int)::ii)  ::  48 Word.word))\<close> 
  for  v  :: " htif_cmd "


\<comment> \<open>\<open>val _set_htif_cmd_payload : register_ref regstate register_value htif_cmd -> mword ty48 -> M unit\<close>\<close>

definition set_htif_cmd_payload  :: \<open>((regstate),(register_value),(htif_cmd))register_ref \<Rightarrow>(48)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_htif_cmd_payload r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       htif_cmd_bits := ((update_subrange_vec_dec(htif_cmd_bits   r) (( 47 :: int)::ii) (( 0 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(htif_cmd))register_ref " 
  and  v  :: "(48)Word.word "


\<comment> \<open>\<open>val _update_htif_cmd_payload : htif_cmd -> mword ty48 -> htif_cmd\<close>\<close>

definition update_htif_cmd_payload  :: \<open> htif_cmd \<Rightarrow>(48)Word.word \<Rightarrow> htif_cmd \<close>  where 
     \<open> update_htif_cmd_payload v x = (
   ( v (|
     htif_cmd_bits := ((update_subrange_vec_dec(htif_cmd_bits   v) (( 47 :: int)::ii) (( 0 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " htif_cmd " 
  and  x  :: "(48)Word.word "


\<comment> \<open>\<open>val reset_htif : unit -> M unit\<close>\<close>

definition reset_htif  :: \<open> unit \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> reset_htif _ = (
   (write_reg htif_cmd_write_ref B0 \<then>
   write_reg htif_payload_writes_ref ( 0x0 ::  4 Word.word)) \<then>
   write_reg htif_tohost_ref ((EXTZ (( 64 :: int)::ii) ( 0b0 ::  1 Word.word)  ::  64 Word.word)))\<close>


\<comment> \<open>\<open>val htif_load : forall 'int8_times_n. Size 'int8_times_n => AccessType unit -> mword ty64 -> integer -> M (MemoryOpResult (mword 'int8_times_n))\<close>\<close>

definition htif_load  :: \<open>(unit)AccessType \<Rightarrow>(64)Word.word \<Rightarrow> int \<Rightarrow>((register_value),((('int8_times_n::len)Word.word)MemoryOpResult),(exception))monad \<close>  where 
     \<open> htif_load t paddr width = (
   (if ((get_config_print_platform () )) then
      (read_reg htif_tohost_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
      return ((print_dbg
                 (((@) (''htif['')
                     (((@) ((string_of_bits paddr))
                         (((@) (''] -> '') ((string_of_bits w__0))))))))))))
    else return () ) \<then>
   (if ((((((width = (( 8 :: int)::ii)))) \<and> (((paddr = ((plat_htif_tohost ()   ::  64 Word.word)))))))) then
     (read_reg htif_tohost_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
     return (MemValue ((Word.ucast ((zero_extend w__1 (( 64 :: int)::ii)  ::  64 Word.word))  :: ( 'int8_times_n::len)Word.word)))))
   else if ((((((width = (( 4 :: int)::ii)))) \<and> (((paddr = ((plat_htif_tohost ()   ::  64 Word.word))))))))
   then
     (read_reg htif_tohost_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
     return (MemValue ((Word.ucast
                          ((zero_extend ((subrange_vec_dec w__2 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
                              (( 32 :: int)::ii)
                             ::  32 Word.word))
                         :: ( 'int8_times_n::len)Word.word)))))
   else if ((((((width = (( 4 :: int)::ii)))) \<and> (((paddr = ((add_vec_int ((plat_htif_tohost ()   ::  64 Word.word)) (( 4 :: int)::ii)  ::  64 Word.word))))))))
   then
     (read_reg htif_tohost_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__3 ::  64 Word.word) . 
     return (MemValue ((Word.ucast
                          ((zero_extend ((subrange_vec_dec w__3 (( 63 :: int)::ii) (( 32 :: int)::ii)  ::  32 Word.word))
                              (( 32 :: int)::ii)
                             ::  32 Word.word))
                         :: ( 'int8_times_n::len)Word.word)))))
   else
     return ((case  t of
       Execute (_) => MemException (E_Fetch_Access_Fault () )
     | Read (Data1) => MemException (E_Load_Access_Fault () )
     | _ => MemException (E_SAMO_Access_Fault () )
     ))))\<close> 
  for  t  :: "(unit)AccessType " 
  and  paddr  :: "(64)Word.word " 
  and  width  :: " int "


\<comment> \<open>\<open>val htif_store : forall 'int8_times_n. Size 'int8_times_n => mword ty64 -> integer -> mword 'int8_times_n -> M (MemoryOpResult bool)\<close>\<close>

definition htif_store  :: \<open>(64)Word.word \<Rightarrow> int \<Rightarrow>('int8_times_n::len)Word.word \<Rightarrow>((register_value),((bool)MemoryOpResult),(exception))monad \<close>  where 
     \<open> htif_store paddr width data = (
   (let (_ :: unit) =
     (if ((get_config_print_platform () )) then
       print_dbg
         (((@) (''htif['')
             (((@) ((string_of_bits paddr))
                 (((@) (''] <- '') ((string_of_bits data))))))))
     else () ) in
   ((if (((width = (( 8 :: int)::ii)))) then
      (let (data ::  64 Word.word) = ((Word.ucast data  ::  64 Word.word)) in
      (write_reg htif_cmd_write_ref B1 \<then>
      (read_reg htif_payload_writes_ref  :: ( 4 Word.word) M)) \<bind> ((\<lambda> (w__0 ::  4 Word.word) . 
      write_reg htif_payload_writes_ref ((add_vec_int w__0 (( 1 :: int)::ii)  ::  4 Word.word)) \<then>
      write_reg htif_tohost_ref ((EXTZ (( 64 :: int)::ii) data  ::  64 Word.word)))))
    else if ((((((width = (( 4 :: int)::ii)))) \<and> (((paddr = ((plat_htif_tohost ()   ::  64 Word.word))))))))
    then
      (let (data ::  32 Word.word) = ((Word.ucast data  ::  32 Word.word)) in
      (read_reg htif_tohost_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
      ((if (((data = ((subrange_vec_dec w__1 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))))) then
         (read_reg htif_payload_writes_ref  :: ( 4 Word.word) M) \<bind> ((\<lambda> (w__2 ::  4 Word.word) . 
         write_reg htif_payload_writes_ref ((add_vec_int w__2 (( 1 :: int)::ii)  ::  4 Word.word))))
       else write_reg htif_payload_writes_ref ( 0x1 ::  4 Word.word)) \<then>
      (read_reg htif_tohost_ref  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__3 ::  64 Word.word) . 
      write_reg htif_tohost_ref ((update_subrange_vec_dec w__3 (( 31 :: int)::ii) (( 0 :: int)::ii) data  ::  64 Word.word)))))))
    else if ((((((width = (( 4 :: int)::ii)))) \<and> (((paddr = ((add_vec_int ((plat_htif_tohost ()   ::  64 Word.word)) (( 4 :: int)::ii)  ::  64 Word.word))))))))
    then
      (let (data ::  32 Word.word) = ((Word.ucast data  ::  32 Word.word)) in
      (read_reg htif_tohost_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__4 ::  64 Word.word) . 
      (((if (((((subrange_vec_dec data (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) = ((subrange_vec_dec w__4 (( 47 :: int)::ii) (( 32 :: int)::ii)  ::  16 Word.word))))) then
         (read_reg htif_payload_writes_ref  :: ( 4 Word.word) M) \<bind> ((\<lambda> (w__5 ::  4 Word.word) . 
         write_reg htif_payload_writes_ref ((add_vec_int w__5 (( 1 :: int)::ii)  ::  4 Word.word))))
       else write_reg htif_payload_writes_ref ( 0x1 ::  4 Word.word)) \<then>
      write_reg htif_cmd_write_ref B1) \<then>
      (read_reg htif_tohost_ref  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__6 ::  64 Word.word) . 
      write_reg htif_tohost_ref ((update_subrange_vec_dec w__6 (( 63 :: int)::ii) (( 32 :: int)::ii) data  ::  64 Word.word)))))))
    else write_reg htif_tohost_ref ((EXTZ (( 64 :: int)::ii) data  ::  64 Word.word))) \<then>
   or_boolM
     (and_boolM (read_reg htif_cmd_write_ref \<bind> ((\<lambda> (w__7 :: bitU) .  return (((w__7 = B1))))))
        ((read_reg htif_payload_writes_ref  :: ( 4 Word.word) M) \<bind> ((\<lambda> (w__8 ::  4 Word.word) . 
         return ((((Word.uint w__8)) > (( 0 :: int)::ii)))))))
     ((read_reg htif_payload_writes_ref  :: ( 4 Word.word) M) \<bind> ((\<lambda> (w__10 ::  4 Word.word) . 
      return ((((Word.uint w__10)) > (( 2 :: int)::ii))))))) \<bind> ((\<lambda> (w__11 :: bool) . 
   (if w__11 then
      (read_reg htif_tohost_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__12 ::  64 Word.word) . 
      (let cmd = (Mk_htif_cmd w__12) in
      (let b__0 = ((get_htif_cmd_device cmd  ::  8 Word.word)) in
      if (((b__0 = ( 0x00 ::  8 Word.word)))) then
        (let (_ :: unit) =
          (if ((get_config_print_platform () )) then
            print_dbg
              (((@) (''htif-syscall-proxy cmd: '')
                  ((string_of_bits ((get_htif_cmd_payload cmd  ::  48 Word.word))))))
          else () ) in
        if (((((access_vec_dec ((get_htif_cmd_payload cmd  ::  48 Word.word)) (( 0 :: int)::ii))) = B1))) then
          write_reg htif_done_ref True \<then>
          write_reg
            htif_exit_code_ref
            ((shiftr
                ((zero_extend ((get_htif_cmd_payload cmd  ::  48 Word.word)) (( 64 :: int)::ii)  ::  64 Word.word))
                (( 1 :: int)::ii)
               ::  64 Word.word))
        else return () )
      else if (((b__0 = ( 0x01 ::  8 Word.word)))) then
        (let (_ :: unit) =
          (if ((get_config_print_platform () )) then
            print_dbg
              (((@) (''htif-term cmd: '')
                  ((string_of_bits ((get_htif_cmd_payload cmd  ::  48 Word.word))))))
          else () ) in
        (let b__2 = ((get_htif_cmd_cmd cmd  ::  8 Word.word)) in
        (let (_ :: unit) =
          (if (((b__2 = ( 0x00 ::  8 Word.word)))) then () 
          else if (((b__2 = ( 0x01 ::  8 Word.word)))) then
            plat_term_write
              ((subrange_vec_dec ((get_htif_cmd_payload cmd  ::  48 Word.word)) (( 7 :: int)::ii) (( 0 :: int)::ii)
                 ::  8 Word.word))
          else print_endline (((@) (''Unknown term cmd: '') ((string_of_bits b__2))))) in
        reset_htif () )))
      else return ((print_endline (((@) (''htif-???? cmd: '') ((string_of_bits data))))))))))
    else return () ) \<then>
   return (MemValue True)))))\<close> 
  for  paddr  :: "(64)Word.word " 
  and  width  :: " int " 
  and  data  :: "('int8_times_n::len)Word.word "


\<comment> \<open>\<open>val htif_tick : unit -> M unit\<close>\<close>

definition htif_tick  :: \<open> unit \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> htif_tick _ = (
   ((if ((get_config_print_platform () )) then
      (read_reg htif_tohost_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
      return ((print_dbg (((@) (''htif::tick '') ((string_of_bits w__0))))))))
    else return () ) \<then>
   (read_reg htif_tohost_ref  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
   write_reg htif_tohost_ref w__1)))\<close>


\<comment> \<open>\<open>val within_mmio_readable : mword ty64 -> integer -> bool\<close>\<close>

definition within_mmio_readable  :: \<open>(64)Word.word \<Rightarrow> int \<Rightarrow> bool \<close>  where 
     \<open> within_mmio_readable (addr :: xlenbits) (width :: int) = (
   (((within_clint addr width)) \<or> (((((within_htif_readable addr width)) \<and> (((( 1 :: int)::ii) \<le> ((id0 width)))))))))\<close> 
  for  addr  :: "(64)Word.word " 
  and  width  :: " int "


\<comment> \<open>\<open>val within_mmio_writable : mword ty64 -> integer -> bool\<close>\<close>

definition within_mmio_writable  :: \<open>(64)Word.word \<Rightarrow> int \<Rightarrow> bool \<close>  where 
     \<open> within_mmio_writable (addr :: xlenbits) (width :: int) = (
   (((within_clint addr width)) \<or> (((((within_htif_writable addr width)) \<and> ((((id0 width)) \<le> (( 8 :: int)::ii))))))))\<close> 
  for  addr  :: "(64)Word.word " 
  and  width  :: " int "


\<comment> \<open>\<open>val mmio_read : forall 'int8_times_n. Size 'int8_times_n => AccessType unit -> mword ty64 -> integer -> M (MemoryOpResult (mword 'int8_times_n))\<close>\<close>

definition mmio_read  :: \<open>(ext_access_type)AccessType \<Rightarrow>(64)Word.word \<Rightarrow> int \<Rightarrow>((register_value),((('int8_times_n::len)Word.word)MemoryOpResult),(exception))monad \<close>  where 
     \<open> mmio_read (t :: ext_access_type AccessType) (paddr :: xlenbits) (width :: int) = (
   if ((within_clint paddr width)) then
     (clint_load t paddr width  :: ( (( 'int8_times_n::len)Word.word)MemoryOpResult) M)
   else if (((((within_htif_readable paddr width)) \<and> (((( 1 :: int)::ii) \<le> ((id0 width))))))) then
     (htif_load t paddr width  :: ( (( 'int8_times_n::len)Word.word)MemoryOpResult) M)
   else
     return ((case  t of
       Execute (_) => MemException (E_Fetch_Access_Fault () )
     | Read (Data1) => MemException (E_Load_Access_Fault () )
     | _ => MemException (E_SAMO_Access_Fault () )
     )))\<close> 
  for  t  :: "(ext_access_type)AccessType " 
  and  paddr  :: "(64)Word.word " 
  and  width  :: " int "


\<comment> \<open>\<open>val mmio_write : forall 'int8_times_n. Size 'int8_times_n => mword ty64 -> integer -> mword 'int8_times_n -> M (MemoryOpResult bool)\<close>\<close>

definition mmio_write  :: \<open>(64)Word.word \<Rightarrow> int \<Rightarrow>('int8_times_n::len)Word.word \<Rightarrow>((register_value),((bool)MemoryOpResult),(exception))monad \<close>  where 
     \<open> mmio_write (paddr :: xlenbits) (width :: int) (data :: ( 'int8_times_n::len)Word.word) = (
   if ((within_clint paddr width)) then clint_store paddr width data
   else if (((((within_htif_writable paddr width)) \<and> ((((id0 width)) \<le> (( 8 :: int)::ii)))))) then
     htif_store paddr width data
   else return (MemException (E_SAMO_Access_Fault () )))\<close> 
  for  paddr  :: "(64)Word.word " 
  and  width  :: " int " 
  and  data  :: "('int8_times_n::len)Word.word "


\<comment> \<open>\<open>val init_platform : unit -> M unit\<close>\<close>

definition init_platform  :: \<open> unit \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> init_platform _ = (
   (((write_reg htif_tohost_ref ((EXTZ (( 64 :: int)::ii) ( 0b0 ::  1 Word.word)  ::  64 Word.word)) \<then>
   write_reg htif_done_ref False) \<then>
   write_reg htif_exit_code_ref ((EXTZ (( 64 :: int)::ii) ( 0b0 ::  1 Word.word)  ::  64 Word.word))) \<then>
   write_reg htif_cmd_write_ref B0) \<then>
   write_reg htif_payload_writes_ref ((EXTZ (( 4 :: int)::ii) ( 0b0 ::  1 Word.word)  ::  4 Word.word)))\<close>


\<comment> \<open>\<open>val tick_platform : unit -> M unit\<close>\<close>

definition tick_platform  :: \<open> unit \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> tick_platform _ = ( htif_tick ()  )\<close>


\<comment> \<open>\<open>val handle_illegal : unit -> M unit\<close>\<close>

definition handle_illegal  :: \<open> unit \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> handle_illegal _ = (
   (if ((plat_mtval_has_illegal_inst_bits () )) then
      (read_reg instbits_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) .  return (Some w__0)))
    else return None) \<bind> ((\<lambda> info . 
   (let (t :: sync_exception) =
     ((| sync_exception_trap = (E_Illegal_Instr () ), 
        sync_exception_excinfo = info, 
        sync_exception_ext_exception = None |)) in
   read_reg cur_privilege_ref \<bind> ((\<lambda> (w__1 :: Privilege) . 
   (read_reg PC_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
   (exception_handler w__1 (CTL_TRAP t) w__2  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__3 ::  64 Word.word) . 
   set_next_pc w__3))))))))))\<close>


\<comment> \<open>\<open>val platform_wfi : unit -> M unit\<close>\<close>

definition platform_wfi  :: \<open> unit \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> platform_wfi _ = (
   (let (_ :: unit) = (cancel_reservation () ) in
   (read_reg mtime_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (read_reg mtimecmp_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
   if ((zopz0zI_u w__0 w__1)) then
     (read_reg mtimecmp_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
     (write_reg mtime_ref w__2 \<then>
     (read_reg mtimecmp_ref  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__3 ::  64 Word.word) . 
     write_reg mcycle_ref w__3))))
   else return () ))))))\<close>


\<comment> \<open>\<open>val is_aligned_addr : mword ty64 -> integer -> bool\<close>\<close>

definition is_aligned_addr  :: \<open>(64)Word.word \<Rightarrow> int \<Rightarrow> bool \<close>  where 
     \<open> is_aligned_addr (addr :: xlenbits) (width :: int) = (
   (((((Word.uint addr)) mod width)) = (( 0 :: int)::ii)))\<close> 
  for  addr  :: "(64)Word.word " 
  and  width  :: " int "


\<comment> \<open>\<open>val read_kind_of_flags : bool -> bool -> bool -> maybe read_kind\<close>\<close>

fun read_kind_of_flags  :: \<open> bool \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow>(read_kind)option \<close>  where 
     \<open> read_kind_of_flags (False :: bool) (False :: bool) (False :: bool) = ( Some Read_plain )\<close>
|\<open> read_kind_of_flags (True :: bool) (False :: bool) (False :: bool) = ( Some Read_RISCV_acquire )\<close>
|\<open> read_kind_of_flags (True :: bool) (True :: bool) (False :: bool) = ( Some Read_RISCV_strong_acquire )\<close>
|\<open> read_kind_of_flags (False :: bool) (False :: bool) (True :: bool) = ( Some Read_RISCV_reserved )\<close>
|\<open> read_kind_of_flags (True :: bool) (False :: bool) (True :: bool) = ( Some Read_RISCV_reserved_acquire )\<close>
|\<open> read_kind_of_flags (True :: bool) (True :: bool) (True :: bool) = ( Some Read_RISCV_reserved_strong_acquire )\<close>
|\<open> read_kind_of_flags (False :: bool) (True :: bool) (False :: bool) = ( None )\<close>
|\<open> read_kind_of_flags (False :: bool) (True :: bool) (True :: bool) = ( None )\<close>


\<comment> \<open>\<open>val phys_mem_read : forall 'int8_times_n. Size 'int8_times_n => AccessType unit -> mword ty64 -> integer -> bool -> bool -> bool -> bool -> M (MemoryOpResult ((mword 'int8_times_n * unit)))\<close>\<close>

definition phys_mem_read  :: \<open>(ext_access_type)AccessType \<Rightarrow>(64)Word.word \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow>((register_value),((('int8_times_n::len)Word.word*unit)MemoryOpResult),(exception))monad \<close>  where 
     \<open> phys_mem_read (t :: ext_access_type AccessType) (paddr :: xlenbits) (width :: int) (aq :: bool) (rl ::
  bool) (res :: bool) (meta :: bool) = (
   (case  ((read_kind_of_flags aq rl res)) of
     Some (rk) =>
      (read_ram rk paddr width meta  :: ((( 'int8_times_n::len)Word.word * unit)) M) \<bind> ((\<lambda> (w__0 ::
        (( 'int8_times_n::len)Word.word * unit)) . 
      return (Some w__0)))
   | None => return None
   ) \<bind> ((\<lambda> (w__1 ::  ((( 'int8_times_n::len)Word.word * unit))option) . 
   (let result = w__1 in
   return ((case  (t, result) of
     (Execute (_), None) => MemException (E_Fetch_Access_Fault () )
   | (Read (Data1), None) => MemException (E_Load_Access_Fault () )
   | (_, None) => MemException (E_SAMO_Access_Fault () )
   | (_, Some ((v, m))) =>
      (let (_ :: unit) =
        (if ((get_config_print_mem () )) then
          print_dbg
            (((@) (''mem['')
                (((@) ((accessType_to_str t))
                    (((@) ('','')
                        (((@) ((string_of_bits paddr))
                            (((@) (''] -> '') ((string_of_bits v))))))))))))
        else () ) in
      MemValue (v, m))
   ))))))\<close> 
  for  t  :: "(ext_access_type)AccessType " 
  and  paddr  :: "(64)Word.word " 
  and  width  :: " int " 
  and  aq  :: " bool " 
  and  rl  :: " bool " 
  and  res  :: " bool " 
  and  meta  :: " bool "


\<comment> \<open>\<open>val checked_mem_read : forall 'int8_times_n. Size 'int8_times_n => AccessType unit -> mword ty64 -> integer -> bool -> bool -> bool -> bool -> M (MemoryOpResult ((mword 'int8_times_n * unit)))\<close>\<close>

definition checked_mem_read  :: \<open>(ext_access_type)AccessType \<Rightarrow>(64)Word.word \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow>((register_value),((('int8_times_n::len)Word.word*unit)MemoryOpResult),(exception))monad \<close>  where 
     \<open> checked_mem_read (t :: ext_access_type AccessType) (paddr :: xlenbits) (width :: int) (aq ::
  bool) (rl :: bool) (res :: bool) (meta :: bool) = (
   if ((within_mmio_readable paddr width)) then
     (mmio_read t paddr width  :: ( (( 'int8_times_n::len)Word.word)MemoryOpResult) M) \<bind> ((\<lambda> (w__0 :: (( 'int8_times_n::len)Word.word)
       MemoryOpResult) . 
     return ((MemoryOpResult_add_meta w__0 default_meta
               :: ((( 'int8_times_n::len)Word.word * unit)) MemoryOpResult))))
   else if ((within_phys_mem paddr width)) then
     (case  ((ext_check_phys_mem_read t paddr width aq rl res meta)) of
       Ext_PhysAddr_OK (_) =>
        (phys_mem_read t paddr width aq rl res meta
          :: ( ((( 'int8_times_n::len)Word.word * unit))MemoryOpResult) M)
     | Ext_PhysAddr_Error (e) => return (MemException e)
     )
   else
     return ((case  t of
       Execute (_) => MemException (E_Fetch_Access_Fault () )
     | Read (Data1) => MemException (E_Load_Access_Fault () )
     | _ => MemException (E_SAMO_Access_Fault () )
     )))\<close> 
  for  t  :: "(ext_access_type)AccessType " 
  and  paddr  :: "(64)Word.word " 
  and  width  :: " int " 
  and  aq  :: " bool " 
  and  rl  :: " bool " 
  and  res  :: " bool " 
  and  meta  :: " bool "


\<comment> \<open>\<open>val pmp_mem_read : forall 'int8_times_n. Size 'int8_times_n => AccessType unit -> Privilege -> mword ty64 -> integer -> bool -> bool -> bool -> bool -> M (MemoryOpResult ((mword 'int8_times_n * unit)))\<close>\<close>

definition pmp_mem_read  :: \<open>(ext_access_type)AccessType \<Rightarrow> Privilege \<Rightarrow>(64)Word.word \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow>((register_value),((('int8_times_n::len)Word.word*unit)MemoryOpResult),(exception))monad \<close>  where 
     \<open> pmp_mem_read (t :: ext_access_type AccessType) (p :: Privilege) (paddr :: xlenbits) (width ::
  int) (aq :: bool) (rl :: bool) (res :: bool) (meta :: bool) = (
   if ((\<not> ((plat_enable_pmp () )))) then
     (checked_mem_read t paddr width aq rl res meta
       :: ( ((( 'int8_times_n::len)Word.word * unit))MemoryOpResult) M)
   else
     pmpCheck paddr width t p \<bind> ((\<lambda> (w__1 ::  ExceptionType option) . 
     (case  w__1 of
       None =>
        (checked_mem_read t paddr width aq rl res meta
          :: ( ((( 'int8_times_n::len)Word.word * unit))MemoryOpResult) M)
     | Some (e) => return (MemException e)
     ))))\<close> 
  for  t  :: "(ext_access_type)AccessType " 
  and  p  :: " Privilege " 
  and  paddr  :: "(64)Word.word " 
  and  width  :: " int " 
  and  aq  :: " bool " 
  and  rl  :: " bool " 
  and  res  :: " bool " 
  and  meta  :: " bool "


\<comment> \<open>\<open>val rvfi_read : forall 'int8_times_n. Size 'int8_times_n => mword ty64 -> integer -> MemoryOpResult ((mword 'int8_times_n * unit)) -> unit\<close>\<close>

definition rvfi_read  :: \<open>(64)Word.word \<Rightarrow> int \<Rightarrow>(('int8_times_n::len)Word.word*unit)MemoryOpResult \<Rightarrow> unit \<close>  where 
     \<open> rvfi_read addr width result = ( ()  )\<close> 
  for  addr  :: "(64)Word.word " 
  and  width  :: " int " 
  and  result  :: "(('int8_times_n::len)Word.word*unit)MemoryOpResult "


\<comment> \<open>\<open>val mem_read : forall 'int8_times_n. Size 'int8_times_n => AccessType unit -> mword ty64 -> integer -> bool -> bool -> bool -> M (MemoryOpResult (mword 'int8_times_n))\<close>\<close>

\<comment> \<open>\<open>val mem_read_priv : forall 'int8_times_n. Size 'int8_times_n => AccessType unit -> Privilege -> mword ty64 -> integer -> bool -> bool -> bool -> M (MemoryOpResult (mword 'int8_times_n))\<close>\<close>

\<comment> \<open>\<open>val mem_read_meta : forall 'int8_times_n. Size 'int8_times_n => AccessType unit -> mword ty64 -> integer -> bool -> bool -> bool -> bool -> M (MemoryOpResult ((mword 'int8_times_n * unit)))\<close>\<close>

\<comment> \<open>\<open>val mem_read_priv_meta : forall 'int8_times_n. Size 'int8_times_n => AccessType unit -> Privilege -> mword ty64 -> integer -> bool -> bool -> bool -> bool -> M (MemoryOpResult ((mword 'int8_times_n * unit)))\<close>\<close>

definition mem_read_priv_meta  :: \<open>(unit)AccessType \<Rightarrow> Privilege \<Rightarrow>(64)Word.word \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow>((register_value),((('int8_times_n::len)Word.word*unit)MemoryOpResult),(exception))monad \<close>  where 
     \<open> mem_read_priv_meta typ1 priv paddr width aq rl res meta = (
   (if ((((((aq \<or> res))) \<and> ((\<not> ((is_aligned_addr paddr width))))))) then
      return (MemException (E_Load_Addr_Align () ))
    else
      (case  (aq, rl, res) of
        (False, True, False) => throw (Error_not_implemented (''load.rl''))
      | (False, True, True) => throw (Error_not_implemented (''lr.rl''))
      | (_, _, _) =>
         (pmp_mem_read typ1 priv paddr width aq rl res meta
           :: ( ((( 'int8_times_n::len)Word.word * unit))MemoryOpResult) M)
      )) \<bind> ((\<lambda> (result :: ((( 'int8_times_n::len)Word.word * unit)) MemoryOpResult) . 
   (let (_ :: unit) = (rvfi_read paddr width result) in
   return result))))\<close> 
  for  typ1  :: "(unit)AccessType " 
  and  priv  :: " Privilege " 
  and  paddr  :: "(64)Word.word " 
  and  width  :: " int " 
  and  aq  :: " bool " 
  and  rl  :: " bool " 
  and  res  :: " bool " 
  and  meta  :: " bool "


definition mem_read_meta  :: \<open>(unit)AccessType \<Rightarrow>(64)Word.word \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow>((register_value),((('int8_times_n::len)Word.word*unit)MemoryOpResult),(exception))monad \<close>  where 
     \<open> mem_read_meta typ1 paddr width aq rl res meta = (
   read_reg mstatus_ref \<bind> ((\<lambda> (w__0 :: Mstatus) . 
   read_reg cur_privilege_ref \<bind> ((\<lambda> (w__1 :: Privilege) . 
   effectivePrivilege typ1 w__0 w__1 \<bind> ((\<lambda> (w__2 :: Privilege) . 
   (mem_read_priv_meta typ1 w__2 paddr width aq rl res meta
     :: ( ((( 'int8_times_n::len)Word.word * unit))MemoryOpResult) M))))))))\<close> 
  for  typ1  :: "(unit)AccessType " 
  and  paddr  :: "(64)Word.word " 
  and  width  :: " int " 
  and  aq  :: " bool " 
  and  rl  :: " bool " 
  and  res  :: " bool " 
  and  meta  :: " bool "


definition mem_read_priv  :: \<open>(unit)AccessType \<Rightarrow> Privilege \<Rightarrow>(64)Word.word \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow>((register_value),((('int8_times_n::len)Word.word)MemoryOpResult),(exception))monad \<close>  where 
     \<open> mem_read_priv typ1 priv paddr width aq rl res = (
   (mem_read_priv_meta typ1 priv paddr width aq rl res False
     :: ( ((( 'int8_times_n::len)Word.word * unit))MemoryOpResult) M) \<bind> ((\<lambda> (w__0 :: ((( 'int8_times_n::len)Word.word * unit))
     MemoryOpResult) . 
   return ((MemoryOpResult_drop_meta w__0  :: (( 'int8_times_n::len)Word.word) MemoryOpResult)))))\<close> 
  for  typ1  :: "(unit)AccessType " 
  and  priv  :: " Privilege " 
  and  paddr  :: "(64)Word.word " 
  and  width  :: " int " 
  and  aq  :: " bool " 
  and  rl  :: " bool " 
  and  res  :: " bool "


definition mem_read  :: \<open>(unit)AccessType \<Rightarrow>(64)Word.word \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow>((register_value),((('int8_times_n::len)Word.word)MemoryOpResult),(exception))monad \<close>  where 
     \<open> mem_read typ1 paddr width aq rel res = (
   read_reg mstatus_ref \<bind> ((\<lambda> (w__0 :: Mstatus) . 
   read_reg cur_privilege_ref \<bind> ((\<lambda> (w__1 :: Privilege) . 
   effectivePrivilege typ1 w__0 w__1 \<bind> ((\<lambda> (w__2 :: Privilege) . 
   (mem_read_priv typ1 w__2 paddr width aq rel res  :: ( (( 'int8_times_n::len)Word.word)MemoryOpResult) M))))))))\<close> 
  for  typ1  :: "(unit)AccessType " 
  and  paddr  :: "(64)Word.word " 
  and  width  :: " int " 
  and  aq  :: " bool " 
  and  rel  :: " bool " 
  and  res  :: " bool "


\<comment> \<open>\<open>val mem_write_ea : mword ty64 -> integer -> bool -> bool -> bool -> M (MemoryOpResult unit)\<close>\<close>

definition mem_write_ea  :: \<open>(64)Word.word \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow>((register_value),((unit)MemoryOpResult),(exception))monad \<close>  where 
     \<open> mem_write_ea addr width aq rl con = (
   if ((((((rl \<or> con))) \<and> ((\<not> ((is_aligned_addr addr width))))))) then
     return (MemException (E_SAMO_Addr_Align () ))
   else
     (case  (aq, rl, con) of
       (False, False, False) => write_ram_ea Write_plain addr width \<then> return (MemValue () )
     | (False, True, False) => write_ram_ea Write_RISCV_release addr width \<then> return (MemValue () )
     | (False, False, True) =>
        write_ram_ea Write_RISCV_conditional addr width \<then> return (MemValue () )
     | (False, True, True) =>
        write_ram_ea Write_RISCV_conditional_release addr width \<then> return (MemValue () )
     | (True, False, False) => throw (Error_not_implemented (''store.aq''))
     | (True, True, False) =>
        write_ram_ea Write_RISCV_strong_release addr width \<then> return (MemValue () )
     | (True, False, True) => throw (Error_not_implemented (''sc.aq''))
     | (True, True, True) =>
        write_ram_ea Write_RISCV_conditional_strong_release addr width \<then> return (MemValue () )
     ))\<close> 
  for  addr  :: "(64)Word.word " 
  and  width  :: " int " 
  and  aq  :: " bool " 
  and  rl  :: " bool " 
  and  con  :: " bool "


\<comment> \<open>\<open>val rvfi_write : forall 'int8_times_n. Size 'int8_times_n => mword ty64 -> integer -> mword 'int8_times_n -> unit -> unit\<close>\<close>

definition rvfi_write  :: \<open>(64)Word.word \<Rightarrow> int \<Rightarrow>('int8_times_n::len)Word.word \<Rightarrow> unit \<Rightarrow> unit \<close>  where 
     \<open> rvfi_write addr width value1 meta = ( ()  )\<close> 
  for  addr  :: "(64)Word.word " 
  and  width  :: " int " 
  and  value1  :: "('int8_times_n::len)Word.word " 
  and  meta  :: " unit "


\<comment> \<open>\<open>val phys_mem_write : forall 'int8_times_n. Size 'int8_times_n => write_kind -> mword ty64 -> integer -> mword 'int8_times_n -> unit -> M (MemoryOpResult bool)\<close>\<close>

definition phys_mem_write  :: \<open> write_kind \<Rightarrow>(64)Word.word \<Rightarrow> int \<Rightarrow>('int8_times_n::len)Word.word \<Rightarrow> unit \<Rightarrow>((register_value),((bool)MemoryOpResult),(exception))monad \<close>  where 
     \<open> phys_mem_write (wk :: write_kind) (paddr :: xlenbits) (width :: int) (data ::
  ( 'int8_times_n::len)Word.word) (meta :: mem_meta) = (
   (let (_ :: unit) = (rvfi_write paddr width data meta) in
   write_ram wk paddr width data meta \<bind> ((\<lambda> (w__0 :: bool) . 
   (let result = (MemValue w__0) in
   (let (_ :: unit) =
     (if ((get_config_print_mem () )) then
       print_dbg
         (((@) (''mem['')
             (((@) ((string_of_bits paddr))
                 (((@) (''] <- '') ((string_of_bits data))))))))
     else () ) in
   return result))))))\<close> 
  for  wk  :: " write_kind " 
  and  paddr  :: "(64)Word.word " 
  and  width  :: " int " 
  and  data  :: "('int8_times_n::len)Word.word " 
  and  meta  :: " unit "


\<comment> \<open>\<open>val checked_mem_write : forall 'int8_times_n. Size 'int8_times_n => write_kind -> mword ty64 -> integer -> mword 'int8_times_n -> unit -> M (MemoryOpResult bool)\<close>\<close>

definition checked_mem_write  :: \<open> write_kind \<Rightarrow>(64)Word.word \<Rightarrow> int \<Rightarrow>('int8_times_n::len)Word.word \<Rightarrow> unit \<Rightarrow>((register_value),((bool)MemoryOpResult),(exception))monad \<close>  where 
     \<open> checked_mem_write (wk :: write_kind) (paddr :: xlenbits) (width :: int) (data ::
  ( 'int8_times_n::len)Word.word) (meta :: mem_meta) = (
   if ((within_mmio_writable paddr width)) then mmio_write paddr width data
   else if ((within_phys_mem paddr width)) then
     (case  ((ext_check_phys_mem_write wk paddr width data meta)) of
       Ext_PhysAddr_OK (_) => phys_mem_write wk paddr width data meta
     | Ext_PhysAddr_Error (e) => return (MemException e)
     )
   else return (MemException (E_SAMO_Access_Fault () )))\<close> 
  for  wk  :: " write_kind " 
  and  paddr  :: "(64)Word.word " 
  and  width  :: " int " 
  and  data  :: "('int8_times_n::len)Word.word " 
  and  meta  :: " unit "


\<comment> \<open>\<open>val pmp_mem_write : forall 'int8_times_n. Size 'int8_times_n => write_kind -> mword ty64 -> integer -> mword 'int8_times_n -> AccessType unit -> Privilege -> unit -> M (MemoryOpResult bool)\<close>\<close>

definition pmp_mem_write  :: \<open> write_kind \<Rightarrow>(64)Word.word \<Rightarrow> int \<Rightarrow>('int8_times_n::len)Word.word \<Rightarrow>(ext_access_type)AccessType \<Rightarrow> Privilege \<Rightarrow> unit \<Rightarrow>((register_value),((bool)MemoryOpResult),(exception))monad \<close>  where 
     \<open> pmp_mem_write (wk :: write_kind) (paddr :: xlenbits) (width :: int) (data :: ( 'int8_times_n::len)Word.word) (typ1 :: ext_access_type
  AccessType) (priv :: Privilege) (meta :: mem_meta) = (
   if ((\<not> ((plat_enable_pmp () )))) then checked_mem_write wk paddr width data meta
   else
     pmpCheck paddr width typ1 priv \<bind> ((\<lambda> (w__1 ::  ExceptionType option) . 
     (case  w__1 of
       None => checked_mem_write wk paddr width data meta
     | Some (e) => return (MemException e)
     ))))\<close> 
  for  wk  :: " write_kind " 
  and  paddr  :: "(64)Word.word " 
  and  width  :: " int " 
  and  data  :: "('int8_times_n::len)Word.word " 
  and  typ1  :: "(ext_access_type)AccessType " 
  and  priv  :: " Privilege " 
  and  meta  :: " unit "


\<comment> \<open>\<open>val mem_write_value_priv_meta : forall 'int8_times_n. Size 'int8_times_n => mword ty64 -> integer -> mword 'int8_times_n -> AccessType unit -> Privilege -> unit -> bool -> bool -> bool -> M (MemoryOpResult bool)\<close>\<close>

definition mem_write_value_priv_meta  :: \<open>(64)Word.word \<Rightarrow> int \<Rightarrow>('int8_times_n::len)Word.word \<Rightarrow>(unit)AccessType \<Rightarrow> Privilege \<Rightarrow> unit \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow>((register_value),((bool)MemoryOpResult),(exception))monad \<close>  where 
     \<open> mem_write_value_priv_meta paddr width value1 typ1 priv meta aq rl con = (
   (let (_ :: unit) = (rvfi_write paddr width value1 meta) in
   if ((((((rl \<or> con))) \<and> ((\<not> ((is_aligned_addr paddr width))))))) then
     return (MemException (E_SAMO_Addr_Align () ))
   else
     (case  (aq, rl, con) of
       (False, False, False) => return Write_plain
     | (False, True, False) => return Write_RISCV_release
     | (False, False, True) => return Write_RISCV_conditional
     | (False, True, True) => return Write_RISCV_conditional_release
     | (True, True, False) => return Write_RISCV_strong_release
     | (True, True, True) => return Write_RISCV_conditional_strong_release
     | (True, False, False) => throw (Error_not_implemented (''store.aq''))
     | (True, False, True) => throw (Error_not_implemented (''sc.aq''))
     ) \<bind> ((\<lambda> (wk :: write_kind) . 
     pmp_mem_write wk paddr width value1 typ1 priv meta))))\<close> 
  for  paddr  :: "(64)Word.word " 
  and  width  :: " int " 
  and  value1  :: "('int8_times_n::len)Word.word " 
  and  typ1  :: "(unit)AccessType " 
  and  priv  :: " Privilege " 
  and  meta  :: " unit " 
  and  aq  :: " bool " 
  and  rl  :: " bool " 
  and  con  :: " bool "


\<comment> \<open>\<open>val mem_write_value_priv : forall 'int8_times_n. Size 'int8_times_n => mword ty64 -> integer -> mword 'int8_times_n -> Privilege -> bool -> bool -> bool -> M (MemoryOpResult bool)\<close>\<close>

definition mem_write_value_priv  :: \<open>(64)Word.word \<Rightarrow> int \<Rightarrow>('int8_times_n::len)Word.word \<Rightarrow> Privilege \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow>((register_value),((bool)MemoryOpResult),(exception))monad \<close>  where 
     \<open> mem_write_value_priv paddr width value1 priv aq rl con = (
   mem_write_value_priv_meta paddr width value1 (Write default_write_acc) priv default_meta aq rl con )\<close> 
  for  paddr  :: "(64)Word.word " 
  and  width  :: " int " 
  and  value1  :: "('int8_times_n::len)Word.word " 
  and  priv  :: " Privilege " 
  and  aq  :: " bool " 
  and  rl  :: " bool " 
  and  con  :: " bool "


\<comment> \<open>\<open>val mem_write_value_meta : forall 'int8_times_n. Size 'int8_times_n => mword ty64 -> integer -> mword 'int8_times_n -> unit -> unit -> bool -> bool -> bool -> M (MemoryOpResult bool)\<close>\<close>

definition mem_write_value_meta  :: \<open>(64)Word.word \<Rightarrow> int \<Rightarrow>('int8_times_n::len)Word.word \<Rightarrow> unit \<Rightarrow> unit \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow>((register_value),((bool)MemoryOpResult),(exception))monad \<close>  where 
     \<open> mem_write_value_meta paddr width value1 ext_acc meta aq rl con = (
   (let typ1 = (Write ext_acc) in
   read_reg mstatus_ref \<bind> ((\<lambda> (w__0 :: Mstatus) . 
   read_reg cur_privilege_ref \<bind> ((\<lambda> (w__1 :: Privilege) . 
   effectivePrivilege typ1 w__0 w__1 \<bind> ((\<lambda> ep . 
   mem_write_value_priv_meta paddr width value1 typ1 ep meta aq rl con))))))))\<close> 
  for  paddr  :: "(64)Word.word " 
  and  width  :: " int " 
  and  value1  :: "('int8_times_n::len)Word.word " 
  and  ext_acc  :: " unit " 
  and  meta  :: " unit " 
  and  aq  :: " bool " 
  and  rl  :: " bool " 
  and  con  :: " bool "


\<comment> \<open>\<open>val mem_write_value : forall 'int8_times_n. Size 'int8_times_n => mword ty64 -> integer -> mword 'int8_times_n -> bool -> bool -> bool -> M (MemoryOpResult bool)\<close>\<close>

definition mem_write_value  :: \<open>(64)Word.word \<Rightarrow> int \<Rightarrow>('int8_times_n::len)Word.word \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow>((register_value),((bool)MemoryOpResult),(exception))monad \<close>  where 
     \<open> mem_write_value paddr width value1 aq rl con = (
   mem_write_value_meta paddr width value1 default_write_acc default_meta aq rl con )\<close> 
  for  paddr  :: "(64)Word.word " 
  and  width  :: " int " 
  and  value1  :: "('int8_times_n::len)Word.word " 
  and  aq  :: " bool " 
  and  rl  :: " bool " 
  and  con  :: " bool "


definition default_sv32_ext_pte  :: \<open>(10)Word.word \<close>  where 
     \<open> default_sv32_ext_pte = ( ( 0b0000000000 ::  10 Word.word))\<close>


\<comment> \<open>\<open>val undefined_PTE_Bits : unit -> M PTE_Bits\<close>\<close>

definition undefined_PTE_Bits  :: \<open> unit \<Rightarrow>((register_value),(PTE_Bits),(exception))monad \<close>  where 
     \<open> undefined_PTE_Bits _ = (
   ((return (failwith (''undefined value of unsupported type''))) :: ( 8 Word.word) M) \<bind> ((\<lambda> (w__0 ::
      8 Word.word) . 
   return ((| PTE_Bits_bits = w__0 |)))))\<close>


\<comment> \<open>\<open>val Mk_PTE_Bits : mword ty8 -> PTE_Bits\<close>\<close>

definition Mk_PTE_Bits  :: \<open>(8)Word.word \<Rightarrow> PTE_Bits \<close>  where 
     \<open> Mk_PTE_Bits v = ( (| PTE_Bits_bits = v |) )\<close> 
  for  v  :: "(8)Word.word "


definition get_PTE_Bits_bits  :: \<open> PTE_Bits \<Rightarrow>(8)Word.word \<close>  where 
     \<open> get_PTE_Bits_bits v = ( (subrange_vec_dec(PTE_Bits_bits   v) (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))\<close> 
  for  v  :: " PTE_Bits "


definition set_PTE_Bits_bits  :: \<open>((regstate),(register_value),(PTE_Bits))register_ref \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_PTE_Bits_bits r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       PTE_Bits_bits := ((update_subrange_vec_dec(PTE_Bits_bits   r) (( 7 :: int)::ii) (( 0 :: int)::ii) v  ::  8 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(PTE_Bits))register_ref " 
  and  v  :: "(8)Word.word "


definition update_PTE_Bits_bits  :: \<open> PTE_Bits \<Rightarrow>(8)Word.word \<Rightarrow> PTE_Bits \<close>  where 
     \<open> update_PTE_Bits_bits v x = (
   ( v (|
     PTE_Bits_bits := ((update_subrange_vec_dec(PTE_Bits_bits   v) (( 7 :: int)::ii) (( 0 :: int)::ii) x  ::  8 Word.word)) |)))\<close> 
  for  v  :: " PTE_Bits " 
  and  x  :: "(8)Word.word "


definition get_PTE_Bits_A  :: \<open> PTE_Bits \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_PTE_Bits_A v = ( (subrange_vec_dec(PTE_Bits_bits   v) (( 6 :: int)::ii) (( 6 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " PTE_Bits "


definition set_PTE_Bits_A  :: \<open>((regstate),(register_value),(PTE_Bits))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_PTE_Bits_A r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       PTE_Bits_bits := ((update_subrange_vec_dec(PTE_Bits_bits   r) (( 6 :: int)::ii) (( 6 :: int)::ii) v  ::  8 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(PTE_Bits))register_ref " 
  and  v  :: "(1)Word.word "


definition update_PTE_Bits_A  :: \<open> PTE_Bits \<Rightarrow>(1)Word.word \<Rightarrow> PTE_Bits \<close>  where 
     \<open> update_PTE_Bits_A v x = (
   ( v (|
     PTE_Bits_bits := ((update_subrange_vec_dec(PTE_Bits_bits   v) (( 6 :: int)::ii) (( 6 :: int)::ii) x  ::  8 Word.word)) |)))\<close> 
  for  v  :: " PTE_Bits " 
  and  x  :: "(1)Word.word "


definition get_PTE_Bits_D  :: \<open> PTE_Bits \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_PTE_Bits_D v = ( (subrange_vec_dec(PTE_Bits_bits   v) (( 7 :: int)::ii) (( 7 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " PTE_Bits "


definition set_PTE_Bits_D  :: \<open>((regstate),(register_value),(PTE_Bits))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_PTE_Bits_D r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       PTE_Bits_bits := ((update_subrange_vec_dec(PTE_Bits_bits   r) (( 7 :: int)::ii) (( 7 :: int)::ii) v  ::  8 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(PTE_Bits))register_ref " 
  and  v  :: "(1)Word.word "


definition update_PTE_Bits_D  :: \<open> PTE_Bits \<Rightarrow>(1)Word.word \<Rightarrow> PTE_Bits \<close>  where 
     \<open> update_PTE_Bits_D v x = (
   ( v (|
     PTE_Bits_bits := ((update_subrange_vec_dec(PTE_Bits_bits   v) (( 7 :: int)::ii) (( 7 :: int)::ii) x  ::  8 Word.word)) |)))\<close> 
  for  v  :: " PTE_Bits " 
  and  x  :: "(1)Word.word "


definition get_PTE_Bits_G  :: \<open> PTE_Bits \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_PTE_Bits_G v = ( (subrange_vec_dec(PTE_Bits_bits   v) (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " PTE_Bits "


definition set_PTE_Bits_G  :: \<open>((regstate),(register_value),(PTE_Bits))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_PTE_Bits_G r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       PTE_Bits_bits := ((update_subrange_vec_dec(PTE_Bits_bits   r) (( 5 :: int)::ii) (( 5 :: int)::ii) v  ::  8 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(PTE_Bits))register_ref " 
  and  v  :: "(1)Word.word "


definition update_PTE_Bits_G  :: \<open> PTE_Bits \<Rightarrow>(1)Word.word \<Rightarrow> PTE_Bits \<close>  where 
     \<open> update_PTE_Bits_G v x = (
   ( v (|
     PTE_Bits_bits := ((update_subrange_vec_dec(PTE_Bits_bits   v) (( 5 :: int)::ii) (( 5 :: int)::ii) x  ::  8 Word.word)) |)))\<close> 
  for  v  :: " PTE_Bits " 
  and  x  :: "(1)Word.word "


definition get_PTE_Bits_R  :: \<open> PTE_Bits \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_PTE_Bits_R v = ( (subrange_vec_dec(PTE_Bits_bits   v) (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " PTE_Bits "


definition set_PTE_Bits_R  :: \<open>((regstate),(register_value),(PTE_Bits))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_PTE_Bits_R r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       PTE_Bits_bits := ((update_subrange_vec_dec(PTE_Bits_bits   r) (( 1 :: int)::ii) (( 1 :: int)::ii) v  ::  8 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(PTE_Bits))register_ref " 
  and  v  :: "(1)Word.word "


definition update_PTE_Bits_R  :: \<open> PTE_Bits \<Rightarrow>(1)Word.word \<Rightarrow> PTE_Bits \<close>  where 
     \<open> update_PTE_Bits_R v x = (
   ( v (|
     PTE_Bits_bits := ((update_subrange_vec_dec(PTE_Bits_bits   v) (( 1 :: int)::ii) (( 1 :: int)::ii) x  ::  8 Word.word)) |)))\<close> 
  for  v  :: " PTE_Bits " 
  and  x  :: "(1)Word.word "


definition get_PTE_Bits_U  :: \<open> PTE_Bits \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_PTE_Bits_U v = ( (subrange_vec_dec(PTE_Bits_bits   v) (( 4 :: int)::ii) (( 4 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " PTE_Bits "


definition set_PTE_Bits_U  :: \<open>((regstate),(register_value),(PTE_Bits))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_PTE_Bits_U r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       PTE_Bits_bits := ((update_subrange_vec_dec(PTE_Bits_bits   r) (( 4 :: int)::ii) (( 4 :: int)::ii) v  ::  8 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(PTE_Bits))register_ref " 
  and  v  :: "(1)Word.word "


definition update_PTE_Bits_U  :: \<open> PTE_Bits \<Rightarrow>(1)Word.word \<Rightarrow> PTE_Bits \<close>  where 
     \<open> update_PTE_Bits_U v x = (
   ( v (|
     PTE_Bits_bits := ((update_subrange_vec_dec(PTE_Bits_bits   v) (( 4 :: int)::ii) (( 4 :: int)::ii) x  ::  8 Word.word)) |)))\<close> 
  for  v  :: " PTE_Bits " 
  and  x  :: "(1)Word.word "


definition get_PTE_Bits_V  :: \<open> PTE_Bits \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_PTE_Bits_V v = ( (subrange_vec_dec(PTE_Bits_bits   v) (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " PTE_Bits "


definition set_PTE_Bits_V  :: \<open>((regstate),(register_value),(PTE_Bits))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_PTE_Bits_V r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       PTE_Bits_bits := ((update_subrange_vec_dec(PTE_Bits_bits   r) (( 0 :: int)::ii) (( 0 :: int)::ii) v  ::  8 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(PTE_Bits))register_ref " 
  and  v  :: "(1)Word.word "


definition update_PTE_Bits_V  :: \<open> PTE_Bits \<Rightarrow>(1)Word.word \<Rightarrow> PTE_Bits \<close>  where 
     \<open> update_PTE_Bits_V v x = (
   ( v (|
     PTE_Bits_bits := ((update_subrange_vec_dec(PTE_Bits_bits   v) (( 0 :: int)::ii) (( 0 :: int)::ii) x  ::  8 Word.word)) |)))\<close> 
  for  v  :: " PTE_Bits " 
  and  x  :: "(1)Word.word "


definition get_PTE_Bits_W  :: \<open> PTE_Bits \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_PTE_Bits_W v = ( (subrange_vec_dec(PTE_Bits_bits   v) (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " PTE_Bits "


definition set_PTE_Bits_W  :: \<open>((regstate),(register_value),(PTE_Bits))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_PTE_Bits_W r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       PTE_Bits_bits := ((update_subrange_vec_dec(PTE_Bits_bits   r) (( 2 :: int)::ii) (( 2 :: int)::ii) v  ::  8 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(PTE_Bits))register_ref " 
  and  v  :: "(1)Word.word "


definition update_PTE_Bits_W  :: \<open> PTE_Bits \<Rightarrow>(1)Word.word \<Rightarrow> PTE_Bits \<close>  where 
     \<open> update_PTE_Bits_W v x = (
   ( v (|
     PTE_Bits_bits := ((update_subrange_vec_dec(PTE_Bits_bits   v) (( 2 :: int)::ii) (( 2 :: int)::ii) x  ::  8 Word.word)) |)))\<close> 
  for  v  :: " PTE_Bits " 
  and  x  :: "(1)Word.word "


definition get_PTE_Bits_X  :: \<open> PTE_Bits \<Rightarrow>(1)Word.word \<close>  where 
     \<open> get_PTE_Bits_X v = ( (subrange_vec_dec(PTE_Bits_bits   v) (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word))\<close> 
  for  v  :: " PTE_Bits "


definition set_PTE_Bits_X  :: \<open>((regstate),(register_value),(PTE_Bits))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_PTE_Bits_X r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       PTE_Bits_bits := ((update_subrange_vec_dec(PTE_Bits_bits   r) (( 3 :: int)::ii) (( 3 :: int)::ii) v  ::  8 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(PTE_Bits))register_ref " 
  and  v  :: "(1)Word.word "


definition update_PTE_Bits_X  :: \<open> PTE_Bits \<Rightarrow>(1)Word.word \<Rightarrow> PTE_Bits \<close>  where 
     \<open> update_PTE_Bits_X v x = (
   ( v (|
     PTE_Bits_bits := ((update_subrange_vec_dec(PTE_Bits_bits   v) (( 3 :: int)::ii) (( 3 :: int)::ii) x  ::  8 Word.word)) |)))\<close> 
  for  v  :: " PTE_Bits " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val isPTEPtr : mword ty8 -> mword ty10 -> bool\<close>\<close>

definition isPTEPtr  :: \<open>(8)Word.word \<Rightarrow>(10)Word.word \<Rightarrow> bool \<close>  where 
     \<open> isPTEPtr (p :: pteAttribs) (ext :: extPte) = (
   (let a = (Mk_PTE_Bits p) in
   ((((((get_PTE_Bits_R a  ::  1 Word.word)) = ( 0b0 ::  1 Word.word)))) \<and> ((((((((get_PTE_Bits_W a  ::  1 Word.word)) = ( 0b0 ::  1 Word.word)))) \<and> (((((get_PTE_Bits_X a  ::  1 Word.word)) = ( 0b0 ::  1 Word.word))))))))))\<close> 
  for  p  :: "(8)Word.word " 
  and  ext  :: "(10)Word.word "


\<comment> \<open>\<open>val isInvalidPTE : mword ty8 -> mword ty10 -> bool\<close>\<close>

definition isInvalidPTE  :: \<open>(8)Word.word \<Rightarrow>(10)Word.word \<Rightarrow> bool \<close>  where 
     \<open> isInvalidPTE (p :: pteAttribs) (ext :: extPte) = (
   (let a = (Mk_PTE_Bits p) in
   ((((((get_PTE_Bits_V a  ::  1 Word.word)) = ( 0b0 ::  1 Word.word)))) \<or> ((((((((get_PTE_Bits_W a  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))) \<and> (((((get_PTE_Bits_R a  ::  1 Word.word)) = ( 0b0 ::  1 Word.word))))))))))\<close> 
  for  p  :: "(8)Word.word " 
  and  ext  :: "(10)Word.word "


\<comment> \<open>\<open>val to_pte_check : bool -> PTE_Check\<close>\<close>

definition to_pte_check  :: \<open> bool \<Rightarrow> PTE_Check \<close>  where 
     \<open> to_pte_check b = ( if b then PTE_Check_Success ()  else PTE_Check_Failure (() , () ))\<close> 
  for  b  :: " bool "


\<comment> \<open>\<open>val checkPTEPermission : AccessType unit -> Privilege -> bool -> bool -> PTE_Bits -> mword ty10 -> unit -> M PTE_Check\<close>\<close>

fun checkPTEPermission  :: \<open>(ext_access_type)AccessType \<Rightarrow> Privilege \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow> PTE_Bits \<Rightarrow>(10)Word.word \<Rightarrow> unit \<Rightarrow>((register_value),(PTE_Check),(exception))monad \<close>  where 
     \<open> checkPTEPermission ((Read (_)) :: ext_access_type AccessType) (User :: Privilege) (mxr :: bool) (do_sum ::
  bool) (p :: PTE_Bits) (ext :: extPte) (ext_ptw :: ext_ptw) = (
      return ((to_pte_check
                 ((((((((get_PTE_Bits_U p  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))) \<and> ((((((((get_PTE_Bits_R p  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))) \<or> ((((((((get_PTE_Bits_X p  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))) \<and> mxr))))))))))))\<close> 
  for  mxr  :: " bool " 
  and  do_sum  :: " bool " 
  and  p  :: " PTE_Bits " 
  and  ext  :: "(10)Word.word " 
  and  ext_ptw  :: " unit "
|\<open> checkPTEPermission ((Write (_)) :: ext_access_type AccessType) (User :: Privilege) (mxr :: bool) (do_sum ::
  bool) (p :: PTE_Bits) (ext :: extPte) (ext_ptw :: ext_ptw) = (
      return ((to_pte_check
                 ((((((((get_PTE_Bits_U p  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))) \<and> (((((get_PTE_Bits_W p  ::  1 Word.word)) = ( 0b1 ::  1 Word.word))))))))))\<close> 
  for  mxr  :: " bool " 
  and  do_sum  :: " bool " 
  and  p  :: " PTE_Bits " 
  and  ext  :: "(10)Word.word " 
  and  ext_ptw  :: " unit "
|\<open> checkPTEPermission ((ReadWrite ((_, _))) :: ext_access_type AccessType) (User :: Privilege) (mxr :: bool) (do_sum ::
  bool) (p :: PTE_Bits) (ext :: extPte) (ext_ptw :: ext_ptw) = (
      return ((to_pte_check
                 ((((((((get_PTE_Bits_U p  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))) \<and> ((((((((get_PTE_Bits_W p  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))) \<and> ((((((((get_PTE_Bits_R p  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))) \<or> ((((((((get_PTE_Bits_X p  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))) \<and> mxr)))))))))))))))\<close> 
  for  mxr  :: " bool " 
  and  do_sum  :: " bool " 
  and  p  :: " PTE_Bits " 
  and  ext  :: "(10)Word.word " 
  and  ext_ptw  :: " unit "
|\<open> checkPTEPermission ((Execute (_)) :: ext_access_type AccessType) (User :: Privilege) (mxr :: bool) (do_sum ::
  bool) (p :: PTE_Bits) (ext :: extPte) (ext_ptw :: ext_ptw) = (
      return ((to_pte_check
                 ((((((((get_PTE_Bits_U p  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))) \<and> (((((get_PTE_Bits_X p  ::  1 Word.word)) = ( 0b1 ::  1 Word.word))))))))))\<close> 
  for  mxr  :: " bool " 
  and  do_sum  :: " bool " 
  and  p  :: " PTE_Bits " 
  and  ext  :: "(10)Word.word " 
  and  ext_ptw  :: " unit "
|\<open> checkPTEPermission ((Read (_)) :: ext_access_type AccessType) (Supervisor :: Privilege) (mxr :: bool) (do_sum ::
  bool) (p :: PTE_Bits) (ext :: extPte) (ext_ptw :: ext_ptw) = (
      return ((to_pte_check
                 (((((((((((get_PTE_Bits_U p  ::  1 Word.word)) = ( 0b0 ::  1 Word.word)))) \<or> do_sum))) \<and> ((((((((get_PTE_Bits_R p  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))) \<or> ((((((((get_PTE_Bits_X p  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))) \<and> mxr))))))))))))\<close> 
  for  mxr  :: " bool " 
  and  do_sum  :: " bool " 
  and  p  :: " PTE_Bits " 
  and  ext  :: "(10)Word.word " 
  and  ext_ptw  :: " unit "
|\<open> checkPTEPermission ((Write (_)) :: ext_access_type AccessType) (Supervisor :: Privilege) (mxr :: bool) (do_sum ::
  bool) (p :: PTE_Bits) (ext :: extPte) (ext_ptw :: ext_ptw) = (
      return ((to_pte_check
                 (((((((((((get_PTE_Bits_U p  ::  1 Word.word)) = ( 0b0 ::  1 Word.word)))) \<or> do_sum))) \<and> (((((get_PTE_Bits_W p  ::  1 Word.word)) = ( 0b1 ::  1 Word.word))))))))))\<close> 
  for  mxr  :: " bool " 
  and  do_sum  :: " bool " 
  and  p  :: " PTE_Bits " 
  and  ext  :: "(10)Word.word " 
  and  ext_ptw  :: " unit "
|\<open> checkPTEPermission ((ReadWrite ((_, _))) :: ext_access_type AccessType) (Supervisor :: Privilege) (mxr :: bool) (do_sum ::
  bool) (p :: PTE_Bits) (ext :: extPte) (ext_ptw :: ext_ptw) = (
      return ((to_pte_check
                 (((((((((((get_PTE_Bits_U p  ::  1 Word.word)) = ( 0b0 ::  1 Word.word)))) \<or> do_sum))) \<and> ((((((((get_PTE_Bits_W p  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))) \<and> ((((((((get_PTE_Bits_R p  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))) \<or> ((((((((get_PTE_Bits_X p  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))) \<and> mxr)))))))))))))))\<close> 
  for  mxr  :: " bool " 
  and  do_sum  :: " bool " 
  and  p  :: " PTE_Bits " 
  and  ext  :: "(10)Word.word " 
  and  ext_ptw  :: " unit "
|\<open> checkPTEPermission ((Execute (_)) :: ext_access_type AccessType) (Supervisor :: Privilege) (mxr :: bool) (do_sum ::
  bool) (p :: PTE_Bits) (ext :: extPte) (ext_ptw :: ext_ptw) = (
      return ((to_pte_check
                 ((((((((get_PTE_Bits_U p  ::  1 Word.word)) = ( 0b0 ::  1 Word.word)))) \<and> (((((get_PTE_Bits_X p  ::  1 Word.word)) = ( 0b1 ::  1 Word.word))))))))))\<close> 
  for  mxr  :: " bool " 
  and  do_sum  :: " bool " 
  and  p  :: " PTE_Bits " 
  and  ext  :: "(10)Word.word " 
  and  ext_ptw  :: " unit "
|\<open> checkPTEPermission (_ :: ext_access_type AccessType) (Machine :: Privilege) (mxr :: bool) (do_sum ::
  bool) (p :: PTE_Bits) (ext :: extPte) (ext_ptw :: ext_ptw) = ( internal_error (''m-mode mem perm check''))\<close> 
  for  mxr  :: " bool " 
  and  do_sum  :: " bool " 
  and  p  :: " PTE_Bits " 
  and  ext  :: "(10)Word.word " 
  and  ext_ptw  :: " unit "


\<comment> \<open>\<open>val update_PTE_Bits : PTE_Bits -> AccessType unit -> mword ty10 -> maybe ((PTE_Bits * mword ty10))\<close>\<close>

definition update_PTE_Bits  :: \<open> PTE_Bits \<Rightarrow>(ext_access_type)AccessType \<Rightarrow>(10)Word.word \<Rightarrow>(PTE_Bits*(10)Word.word)option \<close>  where 
     \<open> update_PTE_Bits (p :: PTE_Bits) (a :: ext_access_type AccessType) (ext :: extPte) = (
   (let update_d =
     ((((((get_PTE_Bits_D p  ::  1 Word.word)) = ( 0b0 ::  1 Word.word)))) \<and> ((case  a of
         Execute (_) => False
       | Read (_) => False
       | Write (_) => True
       | ReadWrite ((_, _)) => True
       ))) in
   (let update_a = (((get_PTE_Bits_A p  ::  1 Word.word)) = ( 0b0 ::  1 Word.word)) in
   if (((update_d \<or> update_a))) then
     (let np = (update_PTE_Bits_A p ( 0b1 ::  1 Word.word)) in
     (let np = (if update_d then update_PTE_Bits_D np ( 0b1 ::  1 Word.word) else np) in
     Some (np, ext)))
   else None)))\<close> 
  for  p  :: " PTE_Bits " 
  and  a  :: "(ext_access_type)AccessType " 
  and  ext  :: "(10)Word.word "


fun ptw_error_to_str  :: \<open> PTW_Error \<Rightarrow> string \<close>  where 
     \<open> ptw_error_to_str (PTW_Invalid_Addr (_)) = ( (''invalid-source-addr''))\<close>
|\<open> ptw_error_to_str (PTW_Access (_)) = ( (''mem-access-error''))\<close>
|\<open> ptw_error_to_str (PTW_Invalid_PTE (_)) = ( (''invalid-pte''))\<close>
|\<open> ptw_error_to_str (PTW_No_Permission (_)) = ( (''no-permission''))\<close>
|\<open> ptw_error_to_str (PTW_Misaligned (_)) = ( (''misaligned-superpage''))\<close>
|\<open> ptw_error_to_str (PTW_PTE_Update (_)) = ( (''pte-update-needed''))\<close>
|\<open> ptw_error_to_str (PTW_Ext_Error (e)) = ( (''extension-error''))\<close> 
  for  e  :: " unit "


\<comment> \<open>\<open>val ext_get_ptw_error : unit -> PTW_Error\<close>\<close>

definition ext_get_ptw_error  :: \<open> unit \<Rightarrow> PTW_Error \<close>  where 
     \<open> ext_get_ptw_error eptwf = ( PTW_No_Permission ()  )\<close> 
  for  eptwf  :: " unit "


\<comment> \<open>\<open>val translationException : AccessType unit -> PTW_Error -> ExceptionType\<close>\<close>

fun translationException  :: \<open>(ext_access_type)AccessType \<Rightarrow> PTW_Error \<Rightarrow> ExceptionType \<close>  where 
     \<open> translationException (_ :: ext_access_type AccessType) ((PTW_Ext_Error (e)) :: PTW_Error) = ( E_Extension ((ext_translate_exception e)))\<close> 
  for  e  :: " unit "
|\<open> translationException ((ReadWrite (_)) :: ext_access_type AccessType) ((PTW_Access (_)) :: PTW_Error) = ( E_SAMO_Access_Fault ()  )\<close>
|\<open> translationException ((ReadWrite (_)) :: ext_access_type AccessType) (_ :: PTW_Error) = ( E_SAMO_Page_Fault ()  )\<close>
|\<open> translationException ((Read (_)) :: ext_access_type AccessType) ((PTW_Access (_)) :: PTW_Error) = ( E_Load_Access_Fault ()  )\<close>
|\<open> translationException ((Read (_)) :: ext_access_type AccessType) (_ :: PTW_Error) = ( E_Load_Page_Fault ()  )\<close>
|\<open> translationException ((Write (_)) :: ext_access_type AccessType) ((PTW_Access (_)) :: PTW_Error) = ( E_SAMO_Access_Fault ()  )\<close>
|\<open> translationException ((Write (_)) :: ext_access_type AccessType) (_ :: PTW_Error) = ( E_SAMO_Page_Fault ()  )\<close>
|\<open> translationException ((Execute (_)) :: ext_access_type AccessType) ((PTW_Access (_)) :: PTW_Error) = ( E_Fetch_Access_Fault ()  )\<close>
|\<open> translationException ((Execute (_)) :: ext_access_type AccessType) (_ :: PTW_Error) = ( E_Fetch_Page_Fault ()  )\<close>


definition PAGESIZE_BITS  :: \<open> int \<close>  where 
     \<open> PAGESIZE_BITS = ( (( 12 :: int)::ii))\<close>


\<comment> \<open>\<open>val curAsid32 : mword ty32 -> mword ty9\<close>\<close>

definition curAsid32  :: \<open>(32)Word.word \<Rightarrow>(9)Word.word \<close>  where 
     \<open> curAsid32 satp1 = (
   (let s = (Mk_Satp32 satp1) in
   (get_Satp32_Asid s  ::  9 Word.word)))\<close> 
  for  satp1  :: "(32)Word.word "


\<comment> \<open>\<open>val curPTB32 : mword ty32 -> mword ty34\<close>\<close>

definition curPTB32  :: \<open>(32)Word.word \<Rightarrow>(34)Word.word \<close>  where 
     \<open> curPTB32 satp1 = (
   (let (s :: Satp32) = (Mk_Satp32 satp1) in
   (shiftl ((EXTZ (( 34 :: int)::ii) ((get_Satp32_PPN s  ::  22 Word.word))  ::  34 Word.word)) PAGESIZE_BITS
     ::  34 Word.word)))\<close> 
  for  satp1  :: "(32)Word.word "


definition SV32_LEVEL_BITS  :: \<open> int \<close>  where 
     \<open> SV32_LEVEL_BITS = ( (( 10 :: int)::ii))\<close>


definition SV32_LEVELS  :: \<open> int \<close>  where 
     \<open> SV32_LEVELS = ( (( 2 :: int)::ii))\<close>


definition PTE32_LOG_SIZE  :: \<open> int \<close>  where 
     \<open> PTE32_LOG_SIZE = ( (( 2 :: int)::ii))\<close>


definition PTE32_SIZE  :: \<open> int \<close>  where 
     \<open> PTE32_SIZE = ( (( 4 :: int)::ii))\<close>


\<comment> \<open>\<open>val undefined_SV32_Vaddr : unit -> M SV32_Vaddr\<close>\<close>

definition undefined_SV32_Vaddr  :: \<open> unit \<Rightarrow>((register_value),(SV32_Vaddr),(exception))monad \<close>  where 
     \<open> undefined_SV32_Vaddr _ = (
   ((return (failwith (''undefined value of unsupported type''))) :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::
      32 Word.word) . 
   return ((| SV32_Vaddr_bits = w__0 |)))))\<close>


\<comment> \<open>\<open>val Mk_SV32_Vaddr : mword ty32 -> SV32_Vaddr\<close>\<close>

definition Mk_SV32_Vaddr  :: \<open>(32)Word.word \<Rightarrow> SV32_Vaddr \<close>  where 
     \<open> Mk_SV32_Vaddr v = ( (| SV32_Vaddr_bits = v |) )\<close> 
  for  v  :: "(32)Word.word "


definition get_SV32_Vaddr_bits  :: \<open> SV32_Vaddr \<Rightarrow>(32)Word.word \<close>  where 
     \<open> get_SV32_Vaddr_bits v = ( (subrange_vec_dec(SV32_Vaddr_bits   v) (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))\<close> 
  for  v  :: " SV32_Vaddr "


definition set_SV32_Vaddr_bits  :: \<open>((regstate),(register_value),(SV32_Vaddr))register_ref \<Rightarrow>(32)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_SV32_Vaddr_bits r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       SV32_Vaddr_bits :=
         ((update_subrange_vec_dec(SV32_Vaddr_bits   r) (( 31 :: int)::ii) (( 0 :: int)::ii) v  ::  32 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(SV32_Vaddr))register_ref " 
  and  v  :: "(32)Word.word "


definition update_SV32_Vaddr_bits  :: \<open> SV32_Vaddr \<Rightarrow>(32)Word.word \<Rightarrow> SV32_Vaddr \<close>  where 
     \<open> update_SV32_Vaddr_bits v x = (
   ( v (|
     SV32_Vaddr_bits := ((update_subrange_vec_dec(SV32_Vaddr_bits   v) (( 31 :: int)::ii) (( 0 :: int)::ii) x  ::  32 Word.word)) |)))\<close> 
  for  v  :: " SV32_Vaddr " 
  and  x  :: "(32)Word.word "


\<comment> \<open>\<open>val _get_SV32_Vaddr_PgOfs : SV32_Vaddr -> mword ty12\<close>\<close>

definition get_SV32_Vaddr_PgOfs  :: \<open> SV32_Vaddr \<Rightarrow>(12)Word.word \<close>  where 
     \<open> get_SV32_Vaddr_PgOfs v = ( (subrange_vec_dec(SV32_Vaddr_bits   v) (( 11 :: int)::ii) (( 0 :: int)::ii)  ::  12 Word.word))\<close> 
  for  v  :: " SV32_Vaddr "


\<comment> \<open>\<open>val _set_SV32_Vaddr_PgOfs : register_ref regstate register_value SV32_Vaddr -> mword ty12 -> M unit\<close>\<close>

definition set_SV32_Vaddr_PgOfs  :: \<open>((regstate),(register_value),(SV32_Vaddr))register_ref \<Rightarrow>(12)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_SV32_Vaddr_PgOfs r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       SV32_Vaddr_bits :=
         ((update_subrange_vec_dec(SV32_Vaddr_bits   r) (( 11 :: int)::ii) (( 0 :: int)::ii) v  ::  32 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(SV32_Vaddr))register_ref " 
  and  v  :: "(12)Word.word "


\<comment> \<open>\<open>val _update_SV32_Vaddr_PgOfs : SV32_Vaddr -> mword ty12 -> SV32_Vaddr\<close>\<close>

definition update_SV32_Vaddr_PgOfs  :: \<open> SV32_Vaddr \<Rightarrow>(12)Word.word \<Rightarrow> SV32_Vaddr \<close>  where 
     \<open> update_SV32_Vaddr_PgOfs v x = (
   ( v (|
     SV32_Vaddr_bits := ((update_subrange_vec_dec(SV32_Vaddr_bits   v) (( 11 :: int)::ii) (( 0 :: int)::ii) x  ::  32 Word.word)) |)))\<close> 
  for  v  :: " SV32_Vaddr " 
  and  x  :: "(12)Word.word "


\<comment> \<open>\<open>val _update_SV32_Paddr_PgOfs : SV32_Paddr -> mword ty12 -> SV32_Paddr\<close>\<close>

\<comment> \<open>\<open>val _update_SV39_Paddr_PgOfs : SV39_Paddr -> mword ty12 -> SV39_Paddr\<close>\<close>

\<comment> \<open>\<open>val _update_SV39_Vaddr_PgOfs : SV39_Vaddr -> mword ty12 -> SV39_Vaddr\<close>\<close>

\<comment> \<open>\<open>val _update_SV48_Paddr_PgOfs : SV48_Paddr -> mword ty12 -> SV48_Paddr\<close>\<close>

\<comment> \<open>\<open>val _update_SV48_Vaddr_PgOfs : SV48_Vaddr -> mword ty12 -> SV48_Vaddr\<close>\<close>

\<comment> \<open>\<open>val _get_SV32_Paddr_PgOfs : SV32_Paddr -> mword ty12\<close>\<close>

\<comment> \<open>\<open>val _get_SV39_Paddr_PgOfs : SV39_Paddr -> mword ty12\<close>\<close>

\<comment> \<open>\<open>val _get_SV39_Vaddr_PgOfs : SV39_Vaddr -> mword ty12\<close>\<close>

\<comment> \<open>\<open>val _get_SV48_Paddr_PgOfs : SV48_Paddr -> mword ty12\<close>\<close>

\<comment> \<open>\<open>val _get_SV48_Vaddr_PgOfs : SV48_Vaddr -> mword ty12\<close>\<close>

\<comment> \<open>\<open>val _set_SV32_Paddr_PgOfs : register_ref regstate register_value SV32_Paddr -> mword ty12 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _set_SV39_Paddr_PgOfs : register_ref regstate register_value SV39_Paddr -> mword ty12 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _set_SV39_Vaddr_PgOfs : register_ref regstate register_value SV39_Vaddr -> mword ty12 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _set_SV48_Paddr_PgOfs : register_ref regstate register_value SV48_Paddr -> mword ty12 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _set_SV48_Vaddr_PgOfs : register_ref regstate register_value SV48_Vaddr -> mword ty12 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _get_SV32_Vaddr_VPNi : SV32_Vaddr -> mword ty20\<close>\<close>

definition get_SV32_Vaddr_VPNi  :: \<open> SV32_Vaddr \<Rightarrow>(20)Word.word \<close>  where 
     \<open> get_SV32_Vaddr_VPNi v = ( (subrange_vec_dec(SV32_Vaddr_bits   v) (( 31 :: int)::ii) (( 12 :: int)::ii)  ::  20 Word.word))\<close> 
  for  v  :: " SV32_Vaddr "


\<comment> \<open>\<open>val _set_SV32_Vaddr_VPNi : register_ref regstate register_value SV32_Vaddr -> mword ty20 -> M unit\<close>\<close>

definition set_SV32_Vaddr_VPNi  :: \<open>((regstate),(register_value),(SV32_Vaddr))register_ref \<Rightarrow>(20)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_SV32_Vaddr_VPNi r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       SV32_Vaddr_bits :=
         ((update_subrange_vec_dec(SV32_Vaddr_bits   r) (( 31 :: int)::ii) (( 12 :: int)::ii) v  ::  32 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(SV32_Vaddr))register_ref " 
  and  v  :: "(20)Word.word "


\<comment> \<open>\<open>val _update_SV32_Vaddr_VPNi : SV32_Vaddr -> mword ty20 -> SV32_Vaddr\<close>\<close>

definition update_SV32_Vaddr_VPNi  :: \<open> SV32_Vaddr \<Rightarrow>(20)Word.word \<Rightarrow> SV32_Vaddr \<close>  where 
     \<open> update_SV32_Vaddr_VPNi v x = (
   ( v (|
     SV32_Vaddr_bits := ((update_subrange_vec_dec(SV32_Vaddr_bits   v) (( 31 :: int)::ii) (( 12 :: int)::ii) x  ::  32 Word.word)) |)))\<close> 
  for  v  :: " SV32_Vaddr " 
  and  x  :: "(20)Word.word "


\<comment> \<open>\<open>val _update_SV39_Vaddr_VPNi : SV39_Vaddr -> mword ty27 -> SV39_Vaddr\<close>\<close>

\<comment> \<open>\<open>val _update_SV48_Vaddr_VPNi : SV48_Vaddr -> mword ty27 -> SV48_Vaddr\<close>\<close>

\<comment> \<open>\<open>val _get_SV39_Vaddr_VPNi : SV39_Vaddr -> mword ty27\<close>\<close>

\<comment> \<open>\<open>val _get_SV48_Vaddr_VPNi : SV48_Vaddr -> mword ty27\<close>\<close>

\<comment> \<open>\<open>val _set_SV39_Vaddr_VPNi : register_ref regstate register_value SV39_Vaddr -> mword ty27 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _set_SV48_Vaddr_VPNi : register_ref regstate register_value SV48_Vaddr -> mword ty27 -> M unit\<close>\<close>

\<comment> \<open>\<open>val undefined_SV32_Paddr : unit -> M SV32_Paddr\<close>\<close>

definition undefined_SV32_Paddr  :: \<open> unit \<Rightarrow>((register_value),(SV32_Paddr),(exception))monad \<close>  where 
     \<open> undefined_SV32_Paddr _ = (
   ((return (failwith (''undefined value of unsupported type''))) :: ( 34 Word.word) M) \<bind> ((\<lambda> (w__0 ::
      34 Word.word) . 
   return ((| SV32_Paddr_bits = w__0 |)))))\<close>


\<comment> \<open>\<open>val Mk_SV32_Paddr : mword ty34 -> SV32_Paddr\<close>\<close>

definition Mk_SV32_Paddr  :: \<open>(34)Word.word \<Rightarrow> SV32_Paddr \<close>  where 
     \<open> Mk_SV32_Paddr v = ( (| SV32_Paddr_bits = v |) )\<close> 
  for  v  :: "(34)Word.word "


definition get_SV32_Paddr_bits  :: \<open> SV32_Paddr \<Rightarrow>(34)Word.word \<close>  where 
     \<open> get_SV32_Paddr_bits v = ( (subrange_vec_dec(SV32_Paddr_bits   v) (( 33 :: int)::ii) (( 0 :: int)::ii)  ::  34 Word.word))\<close> 
  for  v  :: " SV32_Paddr "


definition set_SV32_Paddr_bits  :: \<open>((regstate),(register_value),(SV32_Paddr))register_ref \<Rightarrow>(34)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_SV32_Paddr_bits r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       SV32_Paddr_bits :=
         ((update_subrange_vec_dec(SV32_Paddr_bits   r) (( 33 :: int)::ii) (( 0 :: int)::ii) v  ::  34 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(SV32_Paddr))register_ref " 
  and  v  :: "(34)Word.word "


definition update_SV32_Paddr_bits  :: \<open> SV32_Paddr \<Rightarrow>(34)Word.word \<Rightarrow> SV32_Paddr \<close>  where 
     \<open> update_SV32_Paddr_bits v x = (
   ( v (|
     SV32_Paddr_bits := ((update_subrange_vec_dec(SV32_Paddr_bits   v) (( 33 :: int)::ii) (( 0 :: int)::ii) x  ::  34 Word.word)) |)))\<close> 
  for  v  :: " SV32_Paddr " 
  and  x  :: "(34)Word.word "


\<comment> \<open>\<open>val _get_SV32_Paddr_PPNi : SV32_Paddr -> mword ty22\<close>\<close>

definition get_SV32_Paddr_PPNi  :: \<open> SV32_Paddr \<Rightarrow>(22)Word.word \<close>  where 
     \<open> get_SV32_Paddr_PPNi v = ( (subrange_vec_dec(SV32_Paddr_bits   v) (( 33 :: int)::ii) (( 12 :: int)::ii)  ::  22 Word.word))\<close> 
  for  v  :: " SV32_Paddr "


\<comment> \<open>\<open>val _set_SV32_Paddr_PPNi : register_ref regstate register_value SV32_Paddr -> mword ty22 -> M unit\<close>\<close>

definition set_SV32_Paddr_PPNi  :: \<open>((regstate),(register_value),(SV32_Paddr))register_ref \<Rightarrow>(22)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_SV32_Paddr_PPNi r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       SV32_Paddr_bits :=
         ((update_subrange_vec_dec(SV32_Paddr_bits   r) (( 33 :: int)::ii) (( 12 :: int)::ii) v  ::  34 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(SV32_Paddr))register_ref " 
  and  v  :: "(22)Word.word "


\<comment> \<open>\<open>val _update_SV32_Paddr_PPNi : SV32_Paddr -> mword ty22 -> SV32_Paddr\<close>\<close>

definition update_SV32_Paddr_PPNi  :: \<open> SV32_Paddr \<Rightarrow>(22)Word.word \<Rightarrow> SV32_Paddr \<close>  where 
     \<open> update_SV32_Paddr_PPNi v x = (
   ( v (|
     SV32_Paddr_bits := ((update_subrange_vec_dec(SV32_Paddr_bits   v) (( 33 :: int)::ii) (( 12 :: int)::ii) x  ::  34 Word.word)) |)))\<close> 
  for  v  :: " SV32_Paddr " 
  and  x  :: "(22)Word.word "


\<comment> \<open>\<open>val _update_SV32_PTE_PPNi : SV32_PTE -> mword ty22 -> SV32_PTE\<close>\<close>

\<comment> \<open>\<open>val _update_SV39_PTE_PPNi : SV39_PTE -> mword ty44 -> SV39_PTE\<close>\<close>

\<comment> \<open>\<open>val _update_SV39_Paddr_PPNi : SV39_Paddr -> mword ty44 -> SV39_Paddr\<close>\<close>

\<comment> \<open>\<open>val _update_SV48_PTE_PPNi : SV48_PTE -> mword ty44 -> SV48_PTE\<close>\<close>

\<comment> \<open>\<open>val _update_SV48_Paddr_PPNi : SV48_Paddr -> mword ty44 -> SV48_Paddr\<close>\<close>

\<comment> \<open>\<open>val _get_SV32_PTE_PPNi : SV32_PTE -> mword ty22\<close>\<close>

\<comment> \<open>\<open>val _get_SV39_PTE_PPNi : SV39_PTE -> mword ty44\<close>\<close>

\<comment> \<open>\<open>val _get_SV39_Paddr_PPNi : SV39_Paddr -> mword ty44\<close>\<close>

\<comment> \<open>\<open>val _get_SV48_PTE_PPNi : SV48_PTE -> mword ty44\<close>\<close>

\<comment> \<open>\<open>val _get_SV48_Paddr_PPNi : SV48_Paddr -> mword ty44\<close>\<close>

\<comment> \<open>\<open>val _set_SV32_PTE_PPNi : register_ref regstate register_value SV32_PTE -> mword ty22 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _set_SV39_PTE_PPNi : register_ref regstate register_value SV39_PTE -> mword ty44 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _set_SV39_Paddr_PPNi : register_ref regstate register_value SV39_Paddr -> mword ty44 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _set_SV48_PTE_PPNi : register_ref regstate register_value SV48_PTE -> mword ty44 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _set_SV48_Paddr_PPNi : register_ref regstate register_value SV48_Paddr -> mword ty44 -> M unit\<close>\<close>

definition get_SV32_Paddr_PgOfs  :: \<open> SV32_Paddr \<Rightarrow>(12)Word.word \<close>  where 
     \<open> get_SV32_Paddr_PgOfs v = ( (subrange_vec_dec(SV32_Paddr_bits   v) (( 11 :: int)::ii) (( 0 :: int)::ii)  ::  12 Word.word))\<close> 
  for  v  :: " SV32_Paddr "


definition set_SV32_Paddr_PgOfs  :: \<open>((regstate),(register_value),(SV32_Paddr))register_ref \<Rightarrow>(12)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_SV32_Paddr_PgOfs r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       SV32_Paddr_bits :=
         ((update_subrange_vec_dec(SV32_Paddr_bits   r) (( 11 :: int)::ii) (( 0 :: int)::ii) v  ::  34 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(SV32_Paddr))register_ref " 
  and  v  :: "(12)Word.word "


definition update_SV32_Paddr_PgOfs  :: \<open> SV32_Paddr \<Rightarrow>(12)Word.word \<Rightarrow> SV32_Paddr \<close>  where 
     \<open> update_SV32_Paddr_PgOfs v x = (
   ( v (|
     SV32_Paddr_bits := ((update_subrange_vec_dec(SV32_Paddr_bits   v) (( 11 :: int)::ii) (( 0 :: int)::ii) x  ::  34 Word.word)) |)))\<close> 
  for  v  :: " SV32_Paddr " 
  and  x  :: "(12)Word.word "


\<comment> \<open>\<open>val undefined_SV32_PTE : unit -> M SV32_PTE\<close>\<close>

definition undefined_SV32_PTE  :: \<open> unit \<Rightarrow>((register_value),(SV32_PTE),(exception))monad \<close>  where 
     \<open> undefined_SV32_PTE _ = (
   ((return (failwith (''undefined value of unsupported type''))) :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::
      32 Word.word) . 
   return ((| SV32_PTE_bits = w__0 |)))))\<close>


\<comment> \<open>\<open>val Mk_SV32_PTE : mword ty32 -> SV32_PTE\<close>\<close>

definition Mk_SV32_PTE  :: \<open>(32)Word.word \<Rightarrow> SV32_PTE \<close>  where 
     \<open> Mk_SV32_PTE v = ( (| SV32_PTE_bits = v |) )\<close> 
  for  v  :: "(32)Word.word "


definition get_SV32_PTE_bits  :: \<open> SV32_PTE \<Rightarrow>(32)Word.word \<close>  where 
     \<open> get_SV32_PTE_bits v = ( (subrange_vec_dec(SV32_PTE_bits   v) (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))\<close> 
  for  v  :: " SV32_PTE "


definition set_SV32_PTE_bits  :: \<open>((regstate),(register_value),(SV32_PTE))register_ref \<Rightarrow>(32)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_SV32_PTE_bits r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       SV32_PTE_bits := ((update_subrange_vec_dec(SV32_PTE_bits   r) (( 31 :: int)::ii) (( 0 :: int)::ii) v  ::  32 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(SV32_PTE))register_ref " 
  and  v  :: "(32)Word.word "


definition update_SV32_PTE_bits  :: \<open> SV32_PTE \<Rightarrow>(32)Word.word \<Rightarrow> SV32_PTE \<close>  where 
     \<open> update_SV32_PTE_bits v x = (
   ( v (|
     SV32_PTE_bits := ((update_subrange_vec_dec(SV32_PTE_bits   v) (( 31 :: int)::ii) (( 0 :: int)::ii) x  ::  32 Word.word)) |)))\<close> 
  for  v  :: " SV32_PTE " 
  and  x  :: "(32)Word.word "


\<comment> \<open>\<open>val _get_SV32_PTE_BITS : SV32_PTE -> mword ty8\<close>\<close>

definition get_SV32_PTE_BITS  :: \<open> SV32_PTE \<Rightarrow>(8)Word.word \<close>  where 
     \<open> get_SV32_PTE_BITS v = ( (subrange_vec_dec(SV32_PTE_bits   v) (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))\<close> 
  for  v  :: " SV32_PTE "


\<comment> \<open>\<open>val _set_SV32_PTE_BITS : register_ref regstate register_value SV32_PTE -> mword ty8 -> M unit\<close>\<close>

definition set_SV32_PTE_BITS  :: \<open>((regstate),(register_value),(SV32_PTE))register_ref \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_SV32_PTE_BITS r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       SV32_PTE_bits := ((update_subrange_vec_dec(SV32_PTE_bits   r) (( 7 :: int)::ii) (( 0 :: int)::ii) v  ::  32 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(SV32_PTE))register_ref " 
  and  v  :: "(8)Word.word "


\<comment> \<open>\<open>val _update_SV32_PTE_BITS : SV32_PTE -> mword ty8 -> SV32_PTE\<close>\<close>

definition update_SV32_PTE_BITS  :: \<open> SV32_PTE \<Rightarrow>(8)Word.word \<Rightarrow> SV32_PTE \<close>  where 
     \<open> update_SV32_PTE_BITS v x = (
   ( v (|
     SV32_PTE_bits := ((update_subrange_vec_dec(SV32_PTE_bits   v) (( 7 :: int)::ii) (( 0 :: int)::ii) x  ::  32 Word.word)) |)))\<close> 
  for  v  :: " SV32_PTE " 
  and  x  :: "(8)Word.word "


\<comment> \<open>\<open>val _update_SV39_PTE_BITS : SV39_PTE -> mword ty8 -> SV39_PTE\<close>\<close>

\<comment> \<open>\<open>val _update_SV48_PTE_BITS : SV48_PTE -> mword ty8 -> SV48_PTE\<close>\<close>

\<comment> \<open>\<open>val _get_SV39_PTE_BITS : SV39_PTE -> mword ty8\<close>\<close>

\<comment> \<open>\<open>val _get_SV48_PTE_BITS : SV48_PTE -> mword ty8\<close>\<close>

\<comment> \<open>\<open>val _set_SV39_PTE_BITS : register_ref regstate register_value SV39_PTE -> mword ty8 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _set_SV48_PTE_BITS : register_ref regstate register_value SV48_PTE -> mword ty8 -> M unit\<close>\<close>

definition get_SV32_PTE_PPNi  :: \<open> SV32_PTE \<Rightarrow>(22)Word.word \<close>  where 
     \<open> get_SV32_PTE_PPNi v = ( (subrange_vec_dec(SV32_PTE_bits   v) (( 31 :: int)::ii) (( 10 :: int)::ii)  ::  22 Word.word))\<close> 
  for  v  :: " SV32_PTE "


definition set_SV32_PTE_PPNi  :: \<open>((regstate),(register_value),(SV32_PTE))register_ref \<Rightarrow>(22)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_SV32_PTE_PPNi r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       SV32_PTE_bits := ((update_subrange_vec_dec(SV32_PTE_bits   r) (( 31 :: int)::ii) (( 10 :: int)::ii) v  ::  32 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(SV32_PTE))register_ref " 
  and  v  :: "(22)Word.word "


definition update_SV32_PTE_PPNi  :: \<open> SV32_PTE \<Rightarrow>(22)Word.word \<Rightarrow> SV32_PTE \<close>  where 
     \<open> update_SV32_PTE_PPNi v x = (
   ( v (|
     SV32_PTE_bits := ((update_subrange_vec_dec(SV32_PTE_bits   v) (( 31 :: int)::ii) (( 10 :: int)::ii) x  ::  32 Word.word)) |)))\<close> 
  for  v  :: " SV32_PTE " 
  and  x  :: "(22)Word.word "


\<comment> \<open>\<open>val _get_SV32_PTE_RSW : SV32_PTE -> mword ty2\<close>\<close>

definition get_SV32_PTE_RSW  :: \<open> SV32_PTE \<Rightarrow>(2)Word.word \<close>  where 
     \<open> get_SV32_PTE_RSW v = ( (subrange_vec_dec(SV32_PTE_bits   v) (( 9 :: int)::ii) (( 8 :: int)::ii)  ::  2 Word.word))\<close> 
  for  v  :: " SV32_PTE "


\<comment> \<open>\<open>val _set_SV32_PTE_RSW : register_ref regstate register_value SV32_PTE -> mword ty2 -> M unit\<close>\<close>

definition set_SV32_PTE_RSW  :: \<open>((regstate),(register_value),(SV32_PTE))register_ref \<Rightarrow>(2)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_SV32_PTE_RSW r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       SV32_PTE_bits := ((update_subrange_vec_dec(SV32_PTE_bits   r) (( 9 :: int)::ii) (( 8 :: int)::ii) v  ::  32 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(SV32_PTE))register_ref " 
  and  v  :: "(2)Word.word "


\<comment> \<open>\<open>val _update_SV32_PTE_RSW : SV32_PTE -> mword ty2 -> SV32_PTE\<close>\<close>

definition update_SV32_PTE_RSW  :: \<open> SV32_PTE \<Rightarrow>(2)Word.word \<Rightarrow> SV32_PTE \<close>  where 
     \<open> update_SV32_PTE_RSW v x = (
   ( v (|
     SV32_PTE_bits := ((update_subrange_vec_dec(SV32_PTE_bits   v) (( 9 :: int)::ii) (( 8 :: int)::ii) x  ::  32 Word.word)) |)))\<close> 
  for  v  :: " SV32_PTE " 
  and  x  :: "(2)Word.word "


\<comment> \<open>\<open>val _update_SV39_PTE_RSW : SV39_PTE -> mword ty2 -> SV39_PTE\<close>\<close>

\<comment> \<open>\<open>val _update_SV48_PTE_RSW : SV48_PTE -> mword ty2 -> SV48_PTE\<close>\<close>

\<comment> \<open>\<open>val _get_SV39_PTE_RSW : SV39_PTE -> mword ty2\<close>\<close>

\<comment> \<open>\<open>val _get_SV48_PTE_RSW : SV48_PTE -> mword ty2\<close>\<close>

\<comment> \<open>\<open>val _set_SV39_PTE_RSW : register_ref regstate register_value SV39_PTE -> mword ty2 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _set_SV48_PTE_RSW : register_ref regstate register_value SV48_PTE -> mword ty2 -> M unit\<close>\<close>

\<comment> \<open>\<open>val curAsid64 : mword ty64 -> mword ty16\<close>\<close>

definition curAsid64  :: \<open>(64)Word.word \<Rightarrow>(16)Word.word \<close>  where 
     \<open> curAsid64 satp1 = (
   (let s = (Mk_Satp64 satp1) in
   (get_Satp64_Asid s  ::  16 Word.word)))\<close> 
  for  satp1  :: "(64)Word.word "


\<comment> \<open>\<open>val curPTB64 : mword ty64 -> mword ty56\<close>\<close>

definition curPTB64  :: \<open>(64)Word.word \<Rightarrow>(56)Word.word \<close>  where 
     \<open> curPTB64 satp1 = (
   (let s = (Mk_Satp64 satp1) in
   (shiftl ((EXTZ (( 56 :: int)::ii) ((get_Satp64_PPN s  ::  44 Word.word))  ::  56 Word.word)) PAGESIZE_BITS
     ::  56 Word.word)))\<close> 
  for  satp1  :: "(64)Word.word "


definition SV39_LEVEL_BITS  :: \<open> int \<close>  where 
     \<open> SV39_LEVEL_BITS = ( (( 9 :: int)::ii))\<close>


definition SV39_LEVELS  :: \<open> int \<close>  where 
     \<open> SV39_LEVELS = ( (( 3 :: int)::ii))\<close>


definition PTE39_LOG_SIZE  :: \<open> int \<close>  where 
     \<open> PTE39_LOG_SIZE = ( (( 3 :: int)::ii))\<close>


definition PTE39_SIZE  :: \<open> int \<close>  where 
     \<open> PTE39_SIZE = ( (( 8 :: int)::ii))\<close>


\<comment> \<open>\<open>val undefined_SV39_Vaddr : unit -> M SV39_Vaddr\<close>\<close>

definition undefined_SV39_Vaddr  :: \<open> unit \<Rightarrow>((register_value),(SV39_Vaddr),(exception))monad \<close>  where 
     \<open> undefined_SV39_Vaddr _ = (
   ((return (failwith (''undefined value of unsupported type''))) :: ( 39 Word.word) M) \<bind> ((\<lambda> (w__0 ::
      39 Word.word) . 
   return ((| SV39_Vaddr_bits = w__0 |)))))\<close>


\<comment> \<open>\<open>val Mk_SV39_Vaddr : mword ty39 -> SV39_Vaddr\<close>\<close>

definition Mk_SV39_Vaddr  :: \<open>(39)Word.word \<Rightarrow> SV39_Vaddr \<close>  where 
     \<open> Mk_SV39_Vaddr v = ( (| SV39_Vaddr_bits = v |) )\<close> 
  for  v  :: "(39)Word.word "


definition get_SV39_Vaddr_bits  :: \<open> SV39_Vaddr \<Rightarrow>(39)Word.word \<close>  where 
     \<open> get_SV39_Vaddr_bits v = ( (subrange_vec_dec(SV39_Vaddr_bits   v) (( 38 :: int)::ii) (( 0 :: int)::ii)  ::  39 Word.word))\<close> 
  for  v  :: " SV39_Vaddr "


definition set_SV39_Vaddr_bits  :: \<open>((regstate),(register_value),(SV39_Vaddr))register_ref \<Rightarrow>(39)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_SV39_Vaddr_bits r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       SV39_Vaddr_bits :=
         ((update_subrange_vec_dec(SV39_Vaddr_bits   r) (( 38 :: int)::ii) (( 0 :: int)::ii) v  ::  39 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(SV39_Vaddr))register_ref " 
  and  v  :: "(39)Word.word "


definition update_SV39_Vaddr_bits  :: \<open> SV39_Vaddr \<Rightarrow>(39)Word.word \<Rightarrow> SV39_Vaddr \<close>  where 
     \<open> update_SV39_Vaddr_bits v x = (
   ( v (|
     SV39_Vaddr_bits := ((update_subrange_vec_dec(SV39_Vaddr_bits   v) (( 38 :: int)::ii) (( 0 :: int)::ii) x  ::  39 Word.word)) |)))\<close> 
  for  v  :: " SV39_Vaddr " 
  and  x  :: "(39)Word.word "


definition get_SV39_Vaddr_PgOfs  :: \<open> SV39_Vaddr \<Rightarrow>(12)Word.word \<close>  where 
     \<open> get_SV39_Vaddr_PgOfs v = ( (subrange_vec_dec(SV39_Vaddr_bits   v) (( 11 :: int)::ii) (( 0 :: int)::ii)  ::  12 Word.word))\<close> 
  for  v  :: " SV39_Vaddr "


definition set_SV39_Vaddr_PgOfs  :: \<open>((regstate),(register_value),(SV39_Vaddr))register_ref \<Rightarrow>(12)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_SV39_Vaddr_PgOfs r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       SV39_Vaddr_bits :=
         ((update_subrange_vec_dec(SV39_Vaddr_bits   r) (( 11 :: int)::ii) (( 0 :: int)::ii) v  ::  39 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(SV39_Vaddr))register_ref " 
  and  v  :: "(12)Word.word "


definition update_SV39_Vaddr_PgOfs  :: \<open> SV39_Vaddr \<Rightarrow>(12)Word.word \<Rightarrow> SV39_Vaddr \<close>  where 
     \<open> update_SV39_Vaddr_PgOfs v x = (
   ( v (|
     SV39_Vaddr_bits := ((update_subrange_vec_dec(SV39_Vaddr_bits   v) (( 11 :: int)::ii) (( 0 :: int)::ii) x  ::  39 Word.word)) |)))\<close> 
  for  v  :: " SV39_Vaddr " 
  and  x  :: "(12)Word.word "


definition get_SV39_Vaddr_VPNi  :: \<open> SV39_Vaddr \<Rightarrow>(27)Word.word \<close>  where 
     \<open> get_SV39_Vaddr_VPNi v = ( (subrange_vec_dec(SV39_Vaddr_bits   v) (( 38 :: int)::ii) (( 12 :: int)::ii)  ::  27 Word.word))\<close> 
  for  v  :: " SV39_Vaddr "


definition set_SV39_Vaddr_VPNi  :: \<open>((regstate),(register_value),(SV39_Vaddr))register_ref \<Rightarrow>(27)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_SV39_Vaddr_VPNi r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       SV39_Vaddr_bits :=
         ((update_subrange_vec_dec(SV39_Vaddr_bits   r) (( 38 :: int)::ii) (( 12 :: int)::ii) v  ::  39 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(SV39_Vaddr))register_ref " 
  and  v  :: "(27)Word.word "


definition update_SV39_Vaddr_VPNi  :: \<open> SV39_Vaddr \<Rightarrow>(27)Word.word \<Rightarrow> SV39_Vaddr \<close>  where 
     \<open> update_SV39_Vaddr_VPNi v x = (
   ( v (|
     SV39_Vaddr_bits := ((update_subrange_vec_dec(SV39_Vaddr_bits   v) (( 38 :: int)::ii) (( 12 :: int)::ii) x  ::  39 Word.word)) |)))\<close> 
  for  v  :: " SV39_Vaddr " 
  and  x  :: "(27)Word.word "


\<comment> \<open>\<open>val undefined_SV39_Paddr : unit -> M SV39_Paddr\<close>\<close>

definition undefined_SV39_Paddr  :: \<open> unit \<Rightarrow>((register_value),(SV39_Paddr),(exception))monad \<close>  where 
     \<open> undefined_SV39_Paddr _ = (
   ((return (failwith (''undefined value of unsupported type''))) :: ( 56 Word.word) M) \<bind> ((\<lambda> (w__0 ::
      56 Word.word) . 
   return ((| SV39_Paddr_bits = w__0 |)))))\<close>


\<comment> \<open>\<open>val Mk_SV39_Paddr : mword ty56 -> SV39_Paddr\<close>\<close>

definition Mk_SV39_Paddr  :: \<open>(56)Word.word \<Rightarrow> SV39_Paddr \<close>  where 
     \<open> Mk_SV39_Paddr v = ( (| SV39_Paddr_bits = v |) )\<close> 
  for  v  :: "(56)Word.word "


definition get_SV39_Paddr_bits  :: \<open> SV39_Paddr \<Rightarrow>(56)Word.word \<close>  where 
     \<open> get_SV39_Paddr_bits v = ( (subrange_vec_dec(SV39_Paddr_bits   v) (( 55 :: int)::ii) (( 0 :: int)::ii)  ::  56 Word.word))\<close> 
  for  v  :: " SV39_Paddr "


definition set_SV39_Paddr_bits  :: \<open>((regstate),(register_value),(SV39_Paddr))register_ref \<Rightarrow>(56)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_SV39_Paddr_bits r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       SV39_Paddr_bits :=
         ((update_subrange_vec_dec(SV39_Paddr_bits   r) (( 55 :: int)::ii) (( 0 :: int)::ii) v  ::  56 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(SV39_Paddr))register_ref " 
  and  v  :: "(56)Word.word "


definition update_SV39_Paddr_bits  :: \<open> SV39_Paddr \<Rightarrow>(56)Word.word \<Rightarrow> SV39_Paddr \<close>  where 
     \<open> update_SV39_Paddr_bits v x = (
   ( v (|
     SV39_Paddr_bits := ((update_subrange_vec_dec(SV39_Paddr_bits   v) (( 55 :: int)::ii) (( 0 :: int)::ii) x  ::  56 Word.word)) |)))\<close> 
  for  v  :: " SV39_Paddr " 
  and  x  :: "(56)Word.word "


definition get_SV39_Paddr_PPNi  :: \<open> SV39_Paddr \<Rightarrow>(44)Word.word \<close>  where 
     \<open> get_SV39_Paddr_PPNi v = ( (subrange_vec_dec(SV39_Paddr_bits   v) (( 55 :: int)::ii) (( 12 :: int)::ii)  ::  44 Word.word))\<close> 
  for  v  :: " SV39_Paddr "


definition set_SV39_Paddr_PPNi  :: \<open>((regstate),(register_value),(SV39_Paddr))register_ref \<Rightarrow>(44)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_SV39_Paddr_PPNi r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       SV39_Paddr_bits :=
         ((update_subrange_vec_dec(SV39_Paddr_bits   r) (( 55 :: int)::ii) (( 12 :: int)::ii) v  ::  56 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(SV39_Paddr))register_ref " 
  and  v  :: "(44)Word.word "


definition update_SV39_Paddr_PPNi  :: \<open> SV39_Paddr \<Rightarrow>(44)Word.word \<Rightarrow> SV39_Paddr \<close>  where 
     \<open> update_SV39_Paddr_PPNi v x = (
   ( v (|
     SV39_Paddr_bits := ((update_subrange_vec_dec(SV39_Paddr_bits   v) (( 55 :: int)::ii) (( 12 :: int)::ii) x  ::  56 Word.word)) |)))\<close> 
  for  v  :: " SV39_Paddr " 
  and  x  :: "(44)Word.word "


definition get_SV39_Paddr_PgOfs  :: \<open> SV39_Paddr \<Rightarrow>(12)Word.word \<close>  where 
     \<open> get_SV39_Paddr_PgOfs v = ( (subrange_vec_dec(SV39_Paddr_bits   v) (( 11 :: int)::ii) (( 0 :: int)::ii)  ::  12 Word.word))\<close> 
  for  v  :: " SV39_Paddr "


definition set_SV39_Paddr_PgOfs  :: \<open>((regstate),(register_value),(SV39_Paddr))register_ref \<Rightarrow>(12)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_SV39_Paddr_PgOfs r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       SV39_Paddr_bits :=
         ((update_subrange_vec_dec(SV39_Paddr_bits   r) (( 11 :: int)::ii) (( 0 :: int)::ii) v  ::  56 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(SV39_Paddr))register_ref " 
  and  v  :: "(12)Word.word "


definition update_SV39_Paddr_PgOfs  :: \<open> SV39_Paddr \<Rightarrow>(12)Word.word \<Rightarrow> SV39_Paddr \<close>  where 
     \<open> update_SV39_Paddr_PgOfs v x = (
   ( v (|
     SV39_Paddr_bits := ((update_subrange_vec_dec(SV39_Paddr_bits   v) (( 11 :: int)::ii) (( 0 :: int)::ii) x  ::  56 Word.word)) |)))\<close> 
  for  v  :: " SV39_Paddr " 
  and  x  :: "(12)Word.word "


\<comment> \<open>\<open>val undefined_SV39_PTE : unit -> M SV39_PTE\<close>\<close>

definition undefined_SV39_PTE  :: \<open> unit \<Rightarrow>((register_value),(SV39_PTE),(exception))monad \<close>  where 
     \<open> undefined_SV39_PTE _ = (
   ((return (failwith (''undefined value of unsupported type''))) :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::
      64 Word.word) . 
   return ((| SV39_PTE_bits = w__0 |)))))\<close>


\<comment> \<open>\<open>val Mk_SV39_PTE : mword ty64 -> SV39_PTE\<close>\<close>

definition Mk_SV39_PTE  :: \<open>(64)Word.word \<Rightarrow> SV39_PTE \<close>  where 
     \<open> Mk_SV39_PTE v = ( (| SV39_PTE_bits = v |) )\<close> 
  for  v  :: "(64)Word.word "


definition get_SV39_PTE_bits  :: \<open> SV39_PTE \<Rightarrow>(64)Word.word \<close>  where 
     \<open> get_SV39_PTE_bits v = ( (subrange_vec_dec(SV39_PTE_bits   v) (( 63 :: int)::ii) (( 0 :: int)::ii)  ::  64 Word.word))\<close> 
  for  v  :: " SV39_PTE "


definition set_SV39_PTE_bits  :: \<open>((regstate),(register_value),(SV39_PTE))register_ref \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_SV39_PTE_bits r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       SV39_PTE_bits := ((update_subrange_vec_dec(SV39_PTE_bits   r) (( 63 :: int)::ii) (( 0 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(SV39_PTE))register_ref " 
  and  v  :: "(64)Word.word "


definition update_SV39_PTE_bits  :: \<open> SV39_PTE \<Rightarrow>(64)Word.word \<Rightarrow> SV39_PTE \<close>  where 
     \<open> update_SV39_PTE_bits v x = (
   ( v (|
     SV39_PTE_bits := ((update_subrange_vec_dec(SV39_PTE_bits   v) (( 63 :: int)::ii) (( 0 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " SV39_PTE " 
  and  x  :: "(64)Word.word "


definition get_SV39_PTE_BITS  :: \<open> SV39_PTE \<Rightarrow>(8)Word.word \<close>  where 
     \<open> get_SV39_PTE_BITS v = ( (subrange_vec_dec(SV39_PTE_bits   v) (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))\<close> 
  for  v  :: " SV39_PTE "


definition set_SV39_PTE_BITS  :: \<open>((regstate),(register_value),(SV39_PTE))register_ref \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_SV39_PTE_BITS r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       SV39_PTE_bits := ((update_subrange_vec_dec(SV39_PTE_bits   r) (( 7 :: int)::ii) (( 0 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(SV39_PTE))register_ref " 
  and  v  :: "(8)Word.word "


definition update_SV39_PTE_BITS  :: \<open> SV39_PTE \<Rightarrow>(8)Word.word \<Rightarrow> SV39_PTE \<close>  where 
     \<open> update_SV39_PTE_BITS v x = (
   ( v (|
     SV39_PTE_bits := ((update_subrange_vec_dec(SV39_PTE_bits   v) (( 7 :: int)::ii) (( 0 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " SV39_PTE " 
  and  x  :: "(8)Word.word "


\<comment> \<open>\<open>val _get_SV39_PTE_Ext : SV39_PTE -> mword ty10\<close>\<close>

definition get_SV39_PTE_Ext  :: \<open> SV39_PTE \<Rightarrow>(10)Word.word \<close>  where 
     \<open> get_SV39_PTE_Ext v = ( (subrange_vec_dec(SV39_PTE_bits   v) (( 63 :: int)::ii) (( 54 :: int)::ii)  ::  10 Word.word))\<close> 
  for  v  :: " SV39_PTE "


\<comment> \<open>\<open>val _set_SV39_PTE_Ext : register_ref regstate register_value SV39_PTE -> mword ty10 -> M unit\<close>\<close>

definition set_SV39_PTE_Ext  :: \<open>((regstate),(register_value),(SV39_PTE))register_ref \<Rightarrow>(10)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_SV39_PTE_Ext r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       SV39_PTE_bits := ((update_subrange_vec_dec(SV39_PTE_bits   r) (( 63 :: int)::ii) (( 54 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(SV39_PTE))register_ref " 
  and  v  :: "(10)Word.word "


\<comment> \<open>\<open>val _update_SV39_PTE_Ext : SV39_PTE -> mword ty10 -> SV39_PTE\<close>\<close>

definition update_SV39_PTE_Ext  :: \<open> SV39_PTE \<Rightarrow>(10)Word.word \<Rightarrow> SV39_PTE \<close>  where 
     \<open> update_SV39_PTE_Ext v x = (
   ( v (|
     SV39_PTE_bits := ((update_subrange_vec_dec(SV39_PTE_bits   v) (( 63 :: int)::ii) (( 54 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " SV39_PTE " 
  and  x  :: "(10)Word.word "


\<comment> \<open>\<open>val _update_SV48_PTE_Ext : SV48_PTE -> mword ty10 -> SV48_PTE\<close>\<close>

\<comment> \<open>\<open>val _get_SV48_PTE_Ext : SV48_PTE -> mword ty10\<close>\<close>

\<comment> \<open>\<open>val _set_SV48_PTE_Ext : register_ref regstate register_value SV48_PTE -> mword ty10 -> M unit\<close>\<close>

definition get_SV39_PTE_PPNi  :: \<open> SV39_PTE \<Rightarrow>(44)Word.word \<close>  where 
     \<open> get_SV39_PTE_PPNi v = ( (subrange_vec_dec(SV39_PTE_bits   v) (( 53 :: int)::ii) (( 10 :: int)::ii)  ::  44 Word.word))\<close> 
  for  v  :: " SV39_PTE "


definition set_SV39_PTE_PPNi  :: \<open>((regstate),(register_value),(SV39_PTE))register_ref \<Rightarrow>(44)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_SV39_PTE_PPNi r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       SV39_PTE_bits := ((update_subrange_vec_dec(SV39_PTE_bits   r) (( 53 :: int)::ii) (( 10 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(SV39_PTE))register_ref " 
  and  v  :: "(44)Word.word "


definition update_SV39_PTE_PPNi  :: \<open> SV39_PTE \<Rightarrow>(44)Word.word \<Rightarrow> SV39_PTE \<close>  where 
     \<open> update_SV39_PTE_PPNi v x = (
   ( v (|
     SV39_PTE_bits := ((update_subrange_vec_dec(SV39_PTE_bits   v) (( 53 :: int)::ii) (( 10 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " SV39_PTE " 
  and  x  :: "(44)Word.word "


definition get_SV39_PTE_RSW  :: \<open> SV39_PTE \<Rightarrow>(2)Word.word \<close>  where 
     \<open> get_SV39_PTE_RSW v = ( (subrange_vec_dec(SV39_PTE_bits   v) (( 9 :: int)::ii) (( 8 :: int)::ii)  ::  2 Word.word))\<close> 
  for  v  :: " SV39_PTE "


definition set_SV39_PTE_RSW  :: \<open>((regstate),(register_value),(SV39_PTE))register_ref \<Rightarrow>(2)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_SV39_PTE_RSW r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       SV39_PTE_bits := ((update_subrange_vec_dec(SV39_PTE_bits   r) (( 9 :: int)::ii) (( 8 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(SV39_PTE))register_ref " 
  and  v  :: "(2)Word.word "


definition update_SV39_PTE_RSW  :: \<open> SV39_PTE \<Rightarrow>(2)Word.word \<Rightarrow> SV39_PTE \<close>  where 
     \<open> update_SV39_PTE_RSW v x = (
   ( v (|
     SV39_PTE_bits := ((update_subrange_vec_dec(SV39_PTE_bits   v) (( 9 :: int)::ii) (( 8 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " SV39_PTE " 
  and  x  :: "(2)Word.word "


definition SV48_LEVEL_BITS  :: \<open> int \<close>  where 
     \<open> SV48_LEVEL_BITS = ( (( 9 :: int)::ii))\<close>


definition SV48_LEVELS  :: \<open> int \<close>  where 
     \<open> SV48_LEVELS = ( (( 4 :: int)::ii))\<close>


definition PTE48_LOG_SIZE  :: \<open> int \<close>  where 
     \<open> PTE48_LOG_SIZE = ( (( 3 :: int)::ii))\<close>


definition PTE48_SIZE  :: \<open> int \<close>  where 
     \<open> PTE48_SIZE = ( (( 8 :: int)::ii))\<close>


\<comment> \<open>\<open>val undefined_SV48_Vaddr : unit -> M SV48_Vaddr\<close>\<close>

definition undefined_SV48_Vaddr  :: \<open> unit \<Rightarrow>((register_value),(SV48_Vaddr),(exception))monad \<close>  where 
     \<open> undefined_SV48_Vaddr _ = (
   ((return (failwith (''undefined value of unsupported type''))) :: ( 48 Word.word) M) \<bind> ((\<lambda> (w__0 ::
      48 Word.word) . 
   return ((| SV48_Vaddr_bits = w__0 |)))))\<close>


\<comment> \<open>\<open>val Mk_SV48_Vaddr : mword ty48 -> SV48_Vaddr\<close>\<close>

definition Mk_SV48_Vaddr  :: \<open>(48)Word.word \<Rightarrow> SV48_Vaddr \<close>  where 
     \<open> Mk_SV48_Vaddr v = ( (| SV48_Vaddr_bits = v |) )\<close> 
  for  v  :: "(48)Word.word "


definition get_SV48_Vaddr_bits  :: \<open> SV48_Vaddr \<Rightarrow>(48)Word.word \<close>  where 
     \<open> get_SV48_Vaddr_bits v = ( (subrange_vec_dec(SV48_Vaddr_bits   v) (( 47 :: int)::ii) (( 0 :: int)::ii)  ::  48 Word.word))\<close> 
  for  v  :: " SV48_Vaddr "


definition set_SV48_Vaddr_bits  :: \<open>((regstate),(register_value),(SV48_Vaddr))register_ref \<Rightarrow>(48)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_SV48_Vaddr_bits r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       SV48_Vaddr_bits :=
         ((update_subrange_vec_dec(SV48_Vaddr_bits   r) (( 47 :: int)::ii) (( 0 :: int)::ii) v  ::  48 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(SV48_Vaddr))register_ref " 
  and  v  :: "(48)Word.word "


definition update_SV48_Vaddr_bits  :: \<open> SV48_Vaddr \<Rightarrow>(48)Word.word \<Rightarrow> SV48_Vaddr \<close>  where 
     \<open> update_SV48_Vaddr_bits v x = (
   ( v (|
     SV48_Vaddr_bits := ((update_subrange_vec_dec(SV48_Vaddr_bits   v) (( 47 :: int)::ii) (( 0 :: int)::ii) x  ::  48 Word.word)) |)))\<close> 
  for  v  :: " SV48_Vaddr " 
  and  x  :: "(48)Word.word "


definition get_SV48_Vaddr_PgOfs  :: \<open> SV48_Vaddr \<Rightarrow>(12)Word.word \<close>  where 
     \<open> get_SV48_Vaddr_PgOfs v = ( (subrange_vec_dec(SV48_Vaddr_bits   v) (( 11 :: int)::ii) (( 0 :: int)::ii)  ::  12 Word.word))\<close> 
  for  v  :: " SV48_Vaddr "


definition set_SV48_Vaddr_PgOfs  :: \<open>((regstate),(register_value),(SV48_Vaddr))register_ref \<Rightarrow>(12)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_SV48_Vaddr_PgOfs r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       SV48_Vaddr_bits :=
         ((update_subrange_vec_dec(SV48_Vaddr_bits   r) (( 11 :: int)::ii) (( 0 :: int)::ii) v  ::  48 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(SV48_Vaddr))register_ref " 
  and  v  :: "(12)Word.word "


definition update_SV48_Vaddr_PgOfs  :: \<open> SV48_Vaddr \<Rightarrow>(12)Word.word \<Rightarrow> SV48_Vaddr \<close>  where 
     \<open> update_SV48_Vaddr_PgOfs v x = (
   ( v (|
     SV48_Vaddr_bits := ((update_subrange_vec_dec(SV48_Vaddr_bits   v) (( 11 :: int)::ii) (( 0 :: int)::ii) x  ::  48 Word.word)) |)))\<close> 
  for  v  :: " SV48_Vaddr " 
  and  x  :: "(12)Word.word "


definition get_SV48_Vaddr_VPNi  :: \<open> SV48_Vaddr \<Rightarrow>(27)Word.word \<close>  where 
     \<open> get_SV48_Vaddr_VPNi v = ( (subrange_vec_dec(SV48_Vaddr_bits   v) (( 38 :: int)::ii) (( 12 :: int)::ii)  ::  27 Word.word))\<close> 
  for  v  :: " SV48_Vaddr "


definition set_SV48_Vaddr_VPNi  :: \<open>((regstate),(register_value),(SV48_Vaddr))register_ref \<Rightarrow>(27)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_SV48_Vaddr_VPNi r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       SV48_Vaddr_bits :=
         ((update_subrange_vec_dec(SV48_Vaddr_bits   r) (( 38 :: int)::ii) (( 12 :: int)::ii) v  ::  48 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(SV48_Vaddr))register_ref " 
  and  v  :: "(27)Word.word "


definition update_SV48_Vaddr_VPNi  :: \<open> SV48_Vaddr \<Rightarrow>(27)Word.word \<Rightarrow> SV48_Vaddr \<close>  where 
     \<open> update_SV48_Vaddr_VPNi v x = (
   ( v (|
     SV48_Vaddr_bits := ((update_subrange_vec_dec(SV48_Vaddr_bits   v) (( 38 :: int)::ii) (( 12 :: int)::ii) x  ::  48 Word.word)) |)))\<close> 
  for  v  :: " SV48_Vaddr " 
  and  x  :: "(27)Word.word "


\<comment> \<open>\<open>val undefined_SV48_Paddr : unit -> M SV48_Paddr\<close>\<close>

definition undefined_SV48_Paddr  :: \<open> unit \<Rightarrow>((register_value),(SV48_Paddr),(exception))monad \<close>  where 
     \<open> undefined_SV48_Paddr _ = (
   ((return (failwith (''undefined value of unsupported type''))) :: ( 56 Word.word) M) \<bind> ((\<lambda> (w__0 ::
      56 Word.word) . 
   return ((| SV48_Paddr_bits = w__0 |)))))\<close>


\<comment> \<open>\<open>val Mk_SV48_Paddr : mword ty56 -> SV48_Paddr\<close>\<close>

definition Mk_SV48_Paddr  :: \<open>(56)Word.word \<Rightarrow> SV48_Paddr \<close>  where 
     \<open> Mk_SV48_Paddr v = ( (| SV48_Paddr_bits = v |) )\<close> 
  for  v  :: "(56)Word.word "


definition get_SV48_Paddr_bits  :: \<open> SV48_Paddr \<Rightarrow>(56)Word.word \<close>  where 
     \<open> get_SV48_Paddr_bits v = ( (subrange_vec_dec(SV48_Paddr_bits   v) (( 55 :: int)::ii) (( 0 :: int)::ii)  ::  56 Word.word))\<close> 
  for  v  :: " SV48_Paddr "


definition set_SV48_Paddr_bits  :: \<open>((regstate),(register_value),(SV48_Paddr))register_ref \<Rightarrow>(56)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_SV48_Paddr_bits r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       SV48_Paddr_bits :=
         ((update_subrange_vec_dec(SV48_Paddr_bits   r) (( 55 :: int)::ii) (( 0 :: int)::ii) v  ::  56 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(SV48_Paddr))register_ref " 
  and  v  :: "(56)Word.word "


definition update_SV48_Paddr_bits  :: \<open> SV48_Paddr \<Rightarrow>(56)Word.word \<Rightarrow> SV48_Paddr \<close>  where 
     \<open> update_SV48_Paddr_bits v x = (
   ( v (|
     SV48_Paddr_bits := ((update_subrange_vec_dec(SV48_Paddr_bits   v) (( 55 :: int)::ii) (( 0 :: int)::ii) x  ::  56 Word.word)) |)))\<close> 
  for  v  :: " SV48_Paddr " 
  and  x  :: "(56)Word.word "


definition get_SV48_Paddr_PPNi  :: \<open> SV48_Paddr \<Rightarrow>(44)Word.word \<close>  where 
     \<open> get_SV48_Paddr_PPNi v = ( (subrange_vec_dec(SV48_Paddr_bits   v) (( 55 :: int)::ii) (( 12 :: int)::ii)  ::  44 Word.word))\<close> 
  for  v  :: " SV48_Paddr "


definition set_SV48_Paddr_PPNi  :: \<open>((regstate),(register_value),(SV48_Paddr))register_ref \<Rightarrow>(44)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_SV48_Paddr_PPNi r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       SV48_Paddr_bits :=
         ((update_subrange_vec_dec(SV48_Paddr_bits   r) (( 55 :: int)::ii) (( 12 :: int)::ii) v  ::  56 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(SV48_Paddr))register_ref " 
  and  v  :: "(44)Word.word "


definition update_SV48_Paddr_PPNi  :: \<open> SV48_Paddr \<Rightarrow>(44)Word.word \<Rightarrow> SV48_Paddr \<close>  where 
     \<open> update_SV48_Paddr_PPNi v x = (
   ( v (|
     SV48_Paddr_bits := ((update_subrange_vec_dec(SV48_Paddr_bits   v) (( 55 :: int)::ii) (( 12 :: int)::ii) x  ::  56 Word.word)) |)))\<close> 
  for  v  :: " SV48_Paddr " 
  and  x  :: "(44)Word.word "


definition get_SV48_Paddr_PgOfs  :: \<open> SV48_Paddr \<Rightarrow>(12)Word.word \<close>  where 
     \<open> get_SV48_Paddr_PgOfs v = ( (subrange_vec_dec(SV48_Paddr_bits   v) (( 11 :: int)::ii) (( 0 :: int)::ii)  ::  12 Word.word))\<close> 
  for  v  :: " SV48_Paddr "


definition set_SV48_Paddr_PgOfs  :: \<open>((regstate),(register_value),(SV48_Paddr))register_ref \<Rightarrow>(12)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_SV48_Paddr_PgOfs r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       SV48_Paddr_bits :=
         ((update_subrange_vec_dec(SV48_Paddr_bits   r) (( 11 :: int)::ii) (( 0 :: int)::ii) v  ::  56 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(SV48_Paddr))register_ref " 
  and  v  :: "(12)Word.word "


definition update_SV48_Paddr_PgOfs  :: \<open> SV48_Paddr \<Rightarrow>(12)Word.word \<Rightarrow> SV48_Paddr \<close>  where 
     \<open> update_SV48_Paddr_PgOfs v x = (
   ( v (|
     SV48_Paddr_bits := ((update_subrange_vec_dec(SV48_Paddr_bits   v) (( 11 :: int)::ii) (( 0 :: int)::ii) x  ::  56 Word.word)) |)))\<close> 
  for  v  :: " SV48_Paddr " 
  and  x  :: "(12)Word.word "


\<comment> \<open>\<open>val undefined_SV48_PTE : unit -> M SV48_PTE\<close>\<close>

definition undefined_SV48_PTE  :: \<open> unit \<Rightarrow>((register_value),(SV48_PTE),(exception))monad \<close>  where 
     \<open> undefined_SV48_PTE _ = (
   ((return (failwith (''undefined value of unsupported type''))) :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::
      64 Word.word) . 
   return ((| SV48_PTE_bits = w__0 |)))))\<close>


\<comment> \<open>\<open>val Mk_SV48_PTE : mword ty64 -> SV48_PTE\<close>\<close>

definition Mk_SV48_PTE  :: \<open>(64)Word.word \<Rightarrow> SV48_PTE \<close>  where 
     \<open> Mk_SV48_PTE v = ( (| SV48_PTE_bits = v |) )\<close> 
  for  v  :: "(64)Word.word "


definition get_SV48_PTE_bits  :: \<open> SV48_PTE \<Rightarrow>(64)Word.word \<close>  where 
     \<open> get_SV48_PTE_bits v = ( (subrange_vec_dec(SV48_PTE_bits   v) (( 63 :: int)::ii) (( 0 :: int)::ii)  ::  64 Word.word))\<close> 
  for  v  :: " SV48_PTE "


definition set_SV48_PTE_bits  :: \<open>((regstate),(register_value),(SV48_PTE))register_ref \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_SV48_PTE_bits r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       SV48_PTE_bits := ((update_subrange_vec_dec(SV48_PTE_bits   r) (( 63 :: int)::ii) (( 0 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(SV48_PTE))register_ref " 
  and  v  :: "(64)Word.word "


definition update_SV48_PTE_bits  :: \<open> SV48_PTE \<Rightarrow>(64)Word.word \<Rightarrow> SV48_PTE \<close>  where 
     \<open> update_SV48_PTE_bits v x = (
   ( v (|
     SV48_PTE_bits := ((update_subrange_vec_dec(SV48_PTE_bits   v) (( 63 :: int)::ii) (( 0 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " SV48_PTE " 
  and  x  :: "(64)Word.word "


definition get_SV48_PTE_BITS  :: \<open> SV48_PTE \<Rightarrow>(8)Word.word \<close>  where 
     \<open> get_SV48_PTE_BITS v = ( (subrange_vec_dec(SV48_PTE_bits   v) (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))\<close> 
  for  v  :: " SV48_PTE "


definition set_SV48_PTE_BITS  :: \<open>((regstate),(register_value),(SV48_PTE))register_ref \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_SV48_PTE_BITS r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       SV48_PTE_bits := ((update_subrange_vec_dec(SV48_PTE_bits   r) (( 7 :: int)::ii) (( 0 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(SV48_PTE))register_ref " 
  and  v  :: "(8)Word.word "


definition update_SV48_PTE_BITS  :: \<open> SV48_PTE \<Rightarrow>(8)Word.word \<Rightarrow> SV48_PTE \<close>  where 
     \<open> update_SV48_PTE_BITS v x = (
   ( v (|
     SV48_PTE_bits := ((update_subrange_vec_dec(SV48_PTE_bits   v) (( 7 :: int)::ii) (( 0 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " SV48_PTE " 
  and  x  :: "(8)Word.word "


definition get_SV48_PTE_Ext  :: \<open> SV48_PTE \<Rightarrow>(10)Word.word \<close>  where 
     \<open> get_SV48_PTE_Ext v = ( (subrange_vec_dec(SV48_PTE_bits   v) (( 63 :: int)::ii) (( 54 :: int)::ii)  ::  10 Word.word))\<close> 
  for  v  :: " SV48_PTE "


definition set_SV48_PTE_Ext  :: \<open>((regstate),(register_value),(SV48_PTE))register_ref \<Rightarrow>(10)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_SV48_PTE_Ext r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       SV48_PTE_bits := ((update_subrange_vec_dec(SV48_PTE_bits   r) (( 63 :: int)::ii) (( 54 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(SV48_PTE))register_ref " 
  and  v  :: "(10)Word.word "


definition update_SV48_PTE_Ext  :: \<open> SV48_PTE \<Rightarrow>(10)Word.word \<Rightarrow> SV48_PTE \<close>  where 
     \<open> update_SV48_PTE_Ext v x = (
   ( v (|
     SV48_PTE_bits := ((update_subrange_vec_dec(SV48_PTE_bits   v) (( 63 :: int)::ii) (( 54 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " SV48_PTE " 
  and  x  :: "(10)Word.word "


definition get_SV48_PTE_PPNi  :: \<open> SV48_PTE \<Rightarrow>(44)Word.word \<close>  where 
     \<open> get_SV48_PTE_PPNi v = ( (subrange_vec_dec(SV48_PTE_bits   v) (( 53 :: int)::ii) (( 10 :: int)::ii)  ::  44 Word.word))\<close> 
  for  v  :: " SV48_PTE "


definition set_SV48_PTE_PPNi  :: \<open>((regstate),(register_value),(SV48_PTE))register_ref \<Rightarrow>(44)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_SV48_PTE_PPNi r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       SV48_PTE_bits := ((update_subrange_vec_dec(SV48_PTE_bits   r) (( 53 :: int)::ii) (( 10 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(SV48_PTE))register_ref " 
  and  v  :: "(44)Word.word "


definition update_SV48_PTE_PPNi  :: \<open> SV48_PTE \<Rightarrow>(44)Word.word \<Rightarrow> SV48_PTE \<close>  where 
     \<open> update_SV48_PTE_PPNi v x = (
   ( v (|
     SV48_PTE_bits := ((update_subrange_vec_dec(SV48_PTE_bits   v) (( 53 :: int)::ii) (( 10 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " SV48_PTE " 
  and  x  :: "(44)Word.word "


definition get_SV48_PTE_RSW  :: \<open> SV48_PTE \<Rightarrow>(2)Word.word \<close>  where 
     \<open> get_SV48_PTE_RSW v = ( (subrange_vec_dec(SV48_PTE_bits   v) (( 9 :: int)::ii) (( 8 :: int)::ii)  ::  2 Word.word))\<close> 
  for  v  :: " SV48_PTE "


definition set_SV48_PTE_RSW  :: \<open>((regstate),(register_value),(SV48_PTE))register_ref \<Rightarrow>(2)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> set_SV48_PTE_RSW r_ref v = (
   read_reg r_ref \<bind> ((\<lambda> r . 
   (let r =
     (( r (|
       SV48_PTE_bits := ((update_subrange_vec_dec(SV48_PTE_bits   r) (( 9 :: int)::ii) (( 8 :: int)::ii) v  ::  64 Word.word)) |))) in
   write_reg r_ref r))))\<close> 
  for  r_ref  :: "((regstate),(register_value),(SV48_PTE))register_ref " 
  and  v  :: "(2)Word.word "


definition update_SV48_PTE_RSW  :: \<open> SV48_PTE \<Rightarrow>(2)Word.word \<Rightarrow> SV48_PTE \<close>  where 
     \<open> update_SV48_PTE_RSW v x = (
   ( v (|
     SV48_PTE_bits := ((update_subrange_vec_dec(SV48_PTE_bits   v) (( 9 :: int)::ii) (( 8 :: int)::ii) x  ::  64 Word.word)) |)))\<close> 
  for  v  :: " SV48_PTE " 
  and  x  :: "(2)Word.word "


\<comment> \<open>\<open>val make_TLB_Entry : forall 'asidlen 'palen 'ptelen 'valen. Size 'asidlen, Size 'palen, Size 'ptelen, Size 'valen => mword 'asidlen -> bool -> mword 'valen -> mword 'palen -> mword 'ptelen -> ii -> mword 'palen -> ii -> M (TLB_Entry 'asidlen 'valen 'palen 'ptelen)\<close>\<close>

definition make_TLB_Entry  :: \<open>('asidlen::len)Word.word \<Rightarrow> bool \<Rightarrow>('valen::len)Word.word \<Rightarrow>('palen::len)Word.word \<Rightarrow>('ptelen::len)Word.word \<Rightarrow> int \<Rightarrow>('palen::len)Word.word \<Rightarrow> int \<Rightarrow>((register_value),((('asidlen::len),('valen::len),('palen::len),('ptelen::len))TLB_Entry),(exception))monad \<close>  where 
     \<open> make_TLB_Entry asid global1 vAddr pAddr pte level pteAddr levelBitSize = (
   (let (shift :: ii) = (PAGESIZE_BITS + ((level * levelBitSize))) in
   (let (vAddrMask :: ( 'valen::len)Word.word) =
     ((sub_vec_int
        ((shiftl
            ((xor_vec vAddr
                ((xor_vec vAddr ((EXTZ ((int (size vAddr))) ( 0b1 ::  1 Word.word)  :: ( 'valen::len)Word.word))
                   :: ( 'valen::len)Word.word))
               :: ( 'valen::len)Word.word)) shift
           :: ( 'valen::len)Word.word)) (( 1 :: int)::ii)
       :: ( 'valen::len)Word.word)) in
   (let (vMatchMask :: ( 'valen::len)Word.word) = ((not_vec vAddrMask  :: ( 'valen::len)Word.word)) in
   (read_reg mcycle_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   return ((| TLB_Entry_asid = asid, 
              TLB_Entry_global = global1, 
              TLB_Entry_vAddr = ((and_vec vAddr vMatchMask  :: ( 'valen::len)Word.word)), 
              TLB_Entry_pAddr =
                ((shiftl ((shiftr pAddr shift  :: ( 'palen::len)Word.word)) shift  :: ( 'palen::len)Word.word)), 
              TLB_Entry_vMatchMask = vMatchMask, 
              TLB_Entry_vAddrMask = vAddrMask, 
              TLB_Entry_pte = pte, 
              TLB_Entry_pteAddr = pteAddr, 
              TLB_Entry_age = w__0  |))))))))\<close> 
  for  asid  :: "('asidlen::len)Word.word " 
  and  global1  :: " bool " 
  and  vAddr  :: "('valen::len)Word.word " 
  and  pAddr  :: "('palen::len)Word.word " 
  and  pte  :: "('ptelen::len)Word.word " 
  and  level  :: " int " 
  and  pteAddr  :: "('palen::len)Word.word " 
  and  levelBitSize  :: " int "


\<comment> \<open>\<open>val match_TLB_Entry : forall 'asidlen 'palen 'ptelen 'valen. Size 'asidlen, Size 'valen => TLB_Entry 'asidlen 'valen 'palen 'ptelen -> mword 'asidlen -> mword 'valen -> bool\<close>\<close>

definition match_TLB_Entry  :: \<open>(('asidlen::len),('valen::len),('palen::len),('ptelen::len))TLB_Entry \<Rightarrow>('asidlen::len)Word.word \<Rightarrow>('valen::len)Word.word \<Rightarrow> bool \<close>  where 
     \<open> match_TLB_Entry ent asid vaddr = (
   (((((TLB_Entry_global   ent) \<or> ((((TLB_Entry_asid   ent) = asid)))))) \<and> ((((TLB_Entry_vAddr   ent) = ((and_vec(TLB_Entry_vMatchMask   ent) vaddr  :: ( 'valen::len)Word.word)))))))\<close> 
  for  ent  :: "(('asidlen::len),('valen::len),('palen::len),('ptelen::len))TLB_Entry " 
  and  asid  :: "('asidlen::len)Word.word " 
  and  vaddr  :: "('valen::len)Word.word "


\<comment> \<open>\<open>val flush_TLB_Entry : forall 'asidlen 'palen 'ptelen 'valen. Size 'asidlen, Size 'valen => TLB_Entry 'asidlen 'valen 'palen 'ptelen -> maybe (mword 'asidlen) -> maybe (mword 'valen) -> bool\<close>\<close>

fun flush_TLB_Entry  :: \<open>(('asidlen::len),('valen::len),('palen::len),('ptelen::len))TLB_Entry \<Rightarrow>(('asidlen::len)Word.word)option \<Rightarrow>(('valen::len)Word.word)option \<Rightarrow> bool \<close>  where 
     \<open> flush_TLB_Entry e None None = ( True )\<close> 
  for  e  :: "(('asidlen::len),('valen::len),('palen::len),('ptelen::len))TLB_Entry "
|\<open> flush_TLB_Entry e None (Some (a)) = (
      ((TLB_Entry_vAddr   e) = ((and_vec(TLB_Entry_vMatchMask   e) a  :: ( 'valen::len)Word.word))))\<close> 
  for  e  :: "(('asidlen::len),('valen::len),('palen::len),('ptelen::len))TLB_Entry " 
  and  a  :: "('valen::len)Word.word "
|\<open> flush_TLB_Entry e (Some (i)) None = ( (((((TLB_Entry_asid   e) = i))) \<and> ((\<not>(TLB_Entry_global   e)))))\<close> 
  for  e  :: "(('asidlen::len),('valen::len),('palen::len),('ptelen::len))TLB_Entry " 
  and  i  :: "('asidlen::len)Word.word "
|\<open> flush_TLB_Entry e (Some (i)) (Some (a)) = (
      (((((TLB_Entry_asid   e) = i))) \<and> (((((((TLB_Entry_vAddr   e) = ((and_vec a(TLB_Entry_vMatchMask   e)  :: ( 'valen::len)Word.word))))) \<and> ((\<not>(TLB_Entry_global   e))))))))\<close> 
  for  e  :: "(('asidlen::len),('valen::len),('palen::len),('ptelen::len))TLB_Entry " 
  and  i  :: "('asidlen::len)Word.word " 
  and  a  :: "('valen::len)Word.word "


\<comment> \<open>\<open>val walk39 : mword ty39 -> AccessType unit -> Privilege -> bool -> bool -> mword ty56 -> ii -> bool -> unit -> M (PTW_Result (mword ty56) SV39_PTE)\<close>\<close>

function (sequential,domintros)  walk39  :: \<open>(39)Word.word \<Rightarrow>(unit)AccessType \<Rightarrow> Privilege \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow>(56)Word.word \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> unit \<Rightarrow>((register_value),((((56)Word.word),(SV39_PTE))PTW_Result),(exception))monad \<close>  where 
     \<open> walk39 vaddr ac priv mxr do_sum ptb level global1 ext_ptw = (
   (let va = (Mk_SV39_Vaddr vaddr) in
   (let (pt_ofs :: paddr64) =
     ((shiftl
        ((EXTZ (( 56 :: int)::ii)
            ((subrange_vec_dec
                ((shiftr ((get_SV39_Vaddr_VPNi va  ::  27 Word.word))
                    ((level * SV39_LEVEL_BITS))
                   ::  27 Word.word)) ((SV39_LEVEL_BITS - (( 1 :: int)::ii))) (( 0 :: int)::ii)
               ::  9 Word.word))
           ::  56 Word.word)) PTE39_LOG_SIZE
       ::  56 Word.word)) in
   (let pte_addr = ((add_vec ptb pt_ofs  ::  56 Word.word)) in
   (mem_read_priv (Read Data) Supervisor ((EXTZ (( 64 :: int)::ii) pte_addr  ::  64 Word.word)) (( 8 :: int)::ii) False False
      False
     :: ( ( 64 Word.word)MemoryOpResult) M) \<bind> ((\<lambda> (w__0 :: ( 64 Word.word) MemoryOpResult) . 
   (case  w__0 of
     MemException (_) => return (PTW_Failure (PTW_Access () , ext_ptw))
   | MemValue (v) =>
      (let pte = (Mk_SV39_PTE v) in
      (let pbits = ((get_SV39_PTE_BITS pte  ::  8 Word.word)) in
      (let ext_pte = ((get_SV39_PTE_Ext pte  ::  10 Word.word)) in
      (let pattr = (Mk_PTE_Bits pbits) in
      (let is_global =
        (global1 \<or> (((((get_PTE_Bits_G pattr  ::  1 Word.word)) = ( 0b1 ::  1 Word.word))))) in
      if ((isInvalidPTE pbits ext_pte)) then return (PTW_Failure (PTW_Invalid_PTE () , ext_ptw))
      else if ((isPTEPtr pbits ext_pte)) then
        if ((level > (( 0 :: int)::ii))) then
          (walk39 vaddr ac priv mxr do_sum
             ((shiftl ((EXTZ (( 56 :: int)::ii) ((get_SV39_PTE_PPNi pte  ::  44 Word.word))  ::  56 Word.word))
                 PAGESIZE_BITS
                ::  56 Word.word)) ((level - (( 1 :: int)::ii))) is_global ext_ptw
            :: ( (( 56 Word.word), SV39_PTE)PTW_Result) M)
        else return (PTW_Failure (PTW_Invalid_PTE () , ext_ptw))
      else
        checkPTEPermission ac priv mxr do_sum pattr ext_pte ext_ptw \<bind> ((\<lambda> (w__3 :: PTE_Check) . 
        return ((case  w__3 of
          PTE_Check_Failure ((ext_ptw, ext_ptw_fail)) =>
           PTW_Failure (ext_get_ptw_error ext_ptw_fail, ext_ptw)
        | PTE_Check_Success (ext_ptw) =>
           if ((level > (( 0 :: int)::ii))) then
             (let mask1 =
               ((sub_vec_int
                  ((shiftl
                      ((xor_vec ((get_SV39_PTE_PPNi pte  ::  44 Word.word))
                          ((xor_vec ((get_SV39_PTE_PPNi pte  ::  44 Word.word))
                              ((EXTZ (( 44 :: int)::ii) ( 0b1 ::  1 Word.word)  ::  44 Word.word))
                             ::  44 Word.word))
                         ::  44 Word.word)) ((level * SV39_LEVEL_BITS))
                     ::  44 Word.word)) (( 1 :: int)::ii)
                 ::  44 Word.word)) in
             if (((((and_vec ((get_SV39_PTE_PPNi pte  ::  44 Word.word)) mask1  ::  44 Word.word)) \<noteq> ((EXTZ (( 44 :: int)::ii) ( 0b0 ::  1 Word.word)  ::  44 Word.word))))) then
               PTW_Failure (PTW_Misaligned () , ext_ptw)
             else
               (let ppn =
                 ((or_vec ((get_SV39_PTE_PPNi pte  ::  44 Word.word))
                    ((and_vec
                        ((EXTZ (( 44 :: int)::ii) ((get_SV39_Vaddr_VPNi va  ::  27 Word.word))  ::  44 Word.word))
                        mask1
                       ::  44 Word.word))
                   ::  44 Word.word)) in
               PTW_Success ((concat_vec ppn ((get_SV39_Vaddr_PgOfs va  ::  12 Word.word))  ::  56 Word.word),
                            pte,
                            pte_addr,
                            level,
                            is_global,
                            ext_ptw)))
           else
             PTW_Success ((concat_vec ((get_SV39_PTE_PPNi pte  ::  44 Word.word))
                             ((get_SV39_Vaddr_PgOfs va  ::  12 Word.word))
                            ::  56 Word.word),
                          pte,
                          pte_addr,
                          level,
                          is_global,
                          ext_ptw)
        )))))))))
   )))))))\<close> 
  for  vaddr  :: "(39)Word.word " 
  and  ac  :: "(unit)AccessType " 
  and  priv  :: " Privilege " 
  and  mxr  :: " bool " 
  and  do_sum  :: " bool " 
  and  ptb  :: "(56)Word.word " 
  and  level  :: " int " 
  and  global1  :: " bool " 
  and  ext_ptw  :: " unit " 
by pat_completeness (auto intro!: let_cong bind_cong MemoryOpResult.case_cong)


\<comment> \<open>\<open>val lookup_TLB39 : mword ty16 -> mword ty39 -> M (maybe ((ii * TLB_Entry ty16 ty39 ty56 ty64)))\<close>\<close>

definition lookup_TLB39  :: \<open>(16)Word.word \<Rightarrow>(39)Word.word \<Rightarrow>((register_value),((int*((16),(39),(56),(64))TLB_Entry)option),(exception))monad \<close>  where 
     \<open> lookup_TLB39 asid vaddr = (
   read_reg tlb39_ref \<bind> ((\<lambda> (w__0 ::  ( (16, 39, 56, 64)TLB_Entry)option) . 
   return ((case  w__0 of
     None => None
   | Some (e) => if ((match_TLB_Entry e asid vaddr)) then Some ((( 0 :: int)::ii), e) else None
   )))))\<close> 
  for  asid  :: "(16)Word.word " 
  and  vaddr  :: "(39)Word.word "


\<comment> \<open>\<open>val add_to_TLB39 : mword ty16 -> mword ty39 -> mword ty56 -> SV39_PTE -> mword ty56 -> ii -> bool -> M unit\<close>\<close>

definition add_to_TLB39  :: \<open>(16)Word.word \<Rightarrow>(39)Word.word \<Rightarrow>(56)Word.word \<Rightarrow> SV39_PTE \<Rightarrow>(56)Word.word \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> add_to_TLB39 asid vAddr pAddr pte pteAddr level global1 = (
   make_TLB_Entry asid global1 vAddr pAddr ((get_SV39_PTE_bits pte  ::  64 Word.word)) level pteAddr
     SV39_LEVEL_BITS \<bind> ((\<lambda> (ent :: TLB39_Entry) . 
   write_reg tlb39_ref (Some ent))))\<close> 
  for  asid  :: "(16)Word.word " 
  and  vAddr  :: "(39)Word.word " 
  and  pAddr  :: "(56)Word.word " 
  and  pte  :: " SV39_PTE " 
  and  pteAddr  :: "(56)Word.word " 
  and  level  :: " int " 
  and  global1  :: " bool "


\<comment> \<open>\<open>val write_TLB39 : ii -> TLB_Entry ty16 ty39 ty56 ty64 -> M unit\<close>\<close>

definition write_TLB39  :: \<open> int \<Rightarrow>((16),(39),(56),(64))TLB_Entry \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> write_TLB39 (idx :: ii) (ent :: TLB39_Entry) = ( write_reg tlb39_ref (Some ent))\<close> 
  for  idx  :: " int " 
  and  ent  :: "((16),(39),(56),(64))TLB_Entry "


\<comment> \<open>\<open>val flush_TLB39 : maybe (mword ty16) -> maybe (mword ty39) -> M unit\<close>\<close>

definition flush_TLB39  :: \<open>((16)Word.word)option \<Rightarrow>((39)Word.word)option \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> flush_TLB39 asid addr = (
   read_reg tlb39_ref \<bind> ((\<lambda> (w__0 ::  ( (16, 39, 56, 64)TLB_Entry)option) . 
   (case  w__0 of
     None => return () 
   | Some (e) => if ((flush_TLB_Entry e asid addr)) then write_reg tlb39_ref None else return () 
   ))))\<close> 
  for  asid  :: "((16)Word.word)option " 
  and  addr  :: "((39)Word.word)option "


\<comment> \<open>\<open>val translate39 : mword ty16 -> mword ty56 -> mword ty39 -> AccessType unit -> Privilege -> bool -> bool -> ii -> unit -> M (TR_Result (mword ty56) PTW_Error)\<close>\<close>

definition translate39  :: \<open>(16)Word.word \<Rightarrow>(56)Word.word \<Rightarrow>(39)Word.word \<Rightarrow>(unit)AccessType \<Rightarrow> Privilege \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> unit \<Rightarrow>((register_value),((((56)Word.word),(PTW_Error))TR_Result),(exception))monad \<close>  where 
     \<open> translate39 asid ptb vAddr ac priv mxr do_sum level ext_ptw = (
   lookup_TLB39 asid vAddr \<bind> ((\<lambda> (w__0 ::  ((ii * (16, 39, 56, 64) TLB_Entry))option) . 
   (case  w__0 of
     Some ((idx, ent)) =>
      (let pte = (Mk_SV39_PTE(TLB_Entry_pte   ent)) in
      (let ext_pte = ((get_SV39_PTE_Ext pte  ::  10 Word.word)) in
      (let pteBits = (Mk_PTE_Bits ((get_SV39_PTE_BITS pte  ::  8 Word.word))) in
      checkPTEPermission ac priv mxr do_sum pteBits ext_pte ext_ptw \<bind> ((\<lambda> (w__1 :: PTE_Check) . 
      (case  w__1 of
        PTE_Check_Failure ((ext_ptw, ext_ptw_fail)) =>
         return (TR_Failure (ext_get_ptw_error ext_ptw_fail, ext_ptw))
      | PTE_Check_Success (ext_ptw) =>
         (case  ((update_PTE_Bits pteBits ac ext_pte  ::  ((PTE_Bits *  10 Word.word))option)) of
           None =>
            return (TR_Address ((or_vec(TLB_Entry_pAddr   ent)
                                   ((EXTZ (( 56 :: int)::ii)
                                       ((and_vec vAddr(TLB_Entry_vAddrMask   ent)  ::  39 Word.word))
                                      ::  56 Word.word))
                                  ::  56 Word.word),
                                ext_ptw))
         | Some ((pbits, ext)) =>
            if ((\<not> ((plat_enable_dirty_update () )))) then
              return (TR_Failure (PTW_PTE_Update () , ext_ptw))
            else
              (let n_pte = (update_SV39_PTE_BITS pte ((get_PTE_Bits_bits pbits  ::  8 Word.word))) in
              (let n_pte = (update_SV39_PTE_Ext n_pte ext) in
              (let (n_ent :: TLB39_Entry) = ent in
              (let n_ent =
                (( n_ent (| TLB_Entry_pte := ((get_SV39_PTE_bits n_pte  ::  64 Word.word)) |))) in
              (write_TLB39 idx n_ent \<then>
              mem_write_value_priv ((EXTZ (( 64 :: int)::ii)(TLB_Entry_pteAddr   ent)  ::  64 Word.word)) (( 8 :: int)::ii)
                ((get_SV39_PTE_bits n_pte  ::  64 Word.word)) Supervisor False False False) \<bind> ((\<lambda> (w__2 :: bool
                MemoryOpResult) . 
              (case  w__2 of
                MemValue (_) => return () 
              | MemException (e) => internal_error (''invalid physical address in TLB'')
              ) \<then>
              return (TR_Address ((or_vec(TLB_Entry_pAddr   ent)
                                     ((EXTZ (( 56 :: int)::ii)
                                         ((and_vec vAddr(TLB_Entry_vAddrMask   ent)  ::  39 Word.word))
                                        ::  56 Word.word))
                                    ::  56 Word.word),
                                  ext_ptw))))))))
         )
      ))))))
   | None =>
      (walk39 vAddr ac priv mxr do_sum ptb level False ext_ptw
        :: ( (( 56 Word.word), SV39_PTE)PTW_Result) M) \<bind> ((\<lambda> (w__6 :: (( 56 Word.word), SV39_PTE) PTW_Result) . 
      (case  w__6 of
        PTW_Failure ((f, ext_ptw)) => return (TR_Failure (f, ext_ptw))
      | PTW_Success ((pAddr, pte, pteAddr, level, global1, ext_ptw)) =>
         (case  ((update_PTE_Bits ((Mk_PTE_Bits ((get_SV39_PTE_BITS pte  ::  8 Word.word)))) ac
                   ((get_SV39_PTE_Ext pte  ::  10 Word.word))
                  ::  ((PTE_Bits *  10 Word.word))option)) of
           None =>
            add_to_TLB39 asid vAddr pAddr pte pteAddr level global1 \<then>
            return (TR_Address (pAddr, ext_ptw))
         | Some ((pbits, ext)) =>
            if ((\<not> ((plat_enable_dirty_update () )))) then
              return (TR_Failure (PTW_PTE_Update () , ext_ptw))
            else
              (let (w_pte :: SV39_PTE) =
                (update_SV39_PTE_BITS pte ((get_PTE_Bits_bits pbits  ::  8 Word.word))) in
              (let (w_pte :: SV39_PTE) = (update_SV39_PTE_Ext w_pte ext) in
              mem_write_value_priv ((EXTZ (( 64 :: int)::ii) pteAddr  ::  64 Word.word)) (( 8 :: int)::ii)
                ((get_SV39_PTE_bits w_pte  ::  64 Word.word)) Supervisor False False False \<bind> ((\<lambda> (w__7 :: bool
                MemoryOpResult) . 
              (case  w__7 of
                MemValue (_) =>
                 add_to_TLB39 asid vAddr pAddr w_pte pteAddr level global1 \<then>
                 return (TR_Address (pAddr, ext_ptw))
              | MemException (e) => return (TR_Failure (PTW_Access () , ext_ptw))
              )))))
         )
      )))
   ))))\<close> 
  for  asid  :: "(16)Word.word " 
  and  ptb  :: "(56)Word.word " 
  and  vAddr  :: "(39)Word.word " 
  and  ac  :: "(unit)AccessType " 
  and  priv  :: " Privilege " 
  and  mxr  :: " bool " 
  and  do_sum  :: " bool " 
  and  level  :: " int " 
  and  ext_ptw  :: " unit "


\<comment> \<open>\<open>val init_vmem_sv39 : unit -> M unit\<close>\<close>

definition init_vmem_sv39  :: \<open> unit \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> init_vmem_sv39 _ = ( write_reg tlb39_ref None )\<close>


\<comment> \<open>\<open>val walk48 : mword ty48 -> AccessType unit -> Privilege -> bool -> bool -> mword ty56 -> ii -> bool -> unit -> M (PTW_Result (mword ty56) SV48_PTE)\<close>\<close>

function (sequential,domintros)  walk48  :: \<open>(48)Word.word \<Rightarrow>(unit)AccessType \<Rightarrow> Privilege \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow>(56)Word.word \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> unit \<Rightarrow>((register_value),((((56)Word.word),(SV48_PTE))PTW_Result),(exception))monad \<close>  where 
     \<open> walk48 vaddr ac priv mxr do_sum ptb level global1 ext_ptw = (
   (let va = (Mk_SV48_Vaddr vaddr) in
   (let (pt_ofs :: paddr64) =
     ((shiftl
        ((EXTZ (( 56 :: int)::ii)
            ((subrange_vec_dec
                ((shiftr ((get_SV48_Vaddr_VPNi va  ::  27 Word.word))
                    ((level * SV48_LEVEL_BITS))
                   ::  27 Word.word)) ((SV48_LEVEL_BITS - (( 1 :: int)::ii))) (( 0 :: int)::ii)
               ::  9 Word.word))
           ::  56 Word.word)) PTE48_LOG_SIZE
       ::  56 Word.word)) in
   (let pte_addr = ((add_vec ptb pt_ofs  ::  56 Word.word)) in
   (mem_read_priv (Read Data) Supervisor ((EXTZ (( 64 :: int)::ii) pte_addr  ::  64 Word.word)) (( 8 :: int)::ii) False False
      False
     :: ( ( 64 Word.word)MemoryOpResult) M) \<bind> ((\<lambda> (w__0 :: ( 64 Word.word) MemoryOpResult) . 
   (case  w__0 of
     MemException (_) => return (PTW_Failure (PTW_Access () , ext_ptw))
   | MemValue (v) =>
      (let pte = (Mk_SV48_PTE v) in
      (let pbits = ((get_SV48_PTE_BITS pte  ::  8 Word.word)) in
      (let ext_pte = ((get_SV48_PTE_Ext pte  ::  10 Word.word)) in
      (let pattr = (Mk_PTE_Bits pbits) in
      (let is_global =
        (global1 \<or> (((((get_PTE_Bits_G pattr  ::  1 Word.word)) = ( 0b1 ::  1 Word.word))))) in
      if ((isInvalidPTE pbits ext_pte)) then return (PTW_Failure (PTW_Invalid_PTE () , ext_ptw))
      else if ((isPTEPtr pbits ext_pte)) then
        if ((level > (( 0 :: int)::ii))) then
          (walk48 vaddr ac priv mxr do_sum
             ((shiftl ((EXTZ (( 56 :: int)::ii) ((get_SV48_PTE_PPNi pte  ::  44 Word.word))  ::  56 Word.word))
                 PAGESIZE_BITS
                ::  56 Word.word)) ((level - (( 1 :: int)::ii))) is_global ext_ptw
            :: ( (( 56 Word.word), SV48_PTE)PTW_Result) M)
        else return (PTW_Failure (PTW_Invalid_PTE () , ext_ptw))
      else
        checkPTEPermission ac priv mxr do_sum pattr ext_pte ext_ptw \<bind> ((\<lambda> (w__3 :: PTE_Check) . 
        return ((case  w__3 of
          PTE_Check_Failure ((ext_ptw, ext_ptw_fail)) =>
           PTW_Failure (ext_get_ptw_error ext_ptw_fail, ext_ptw)
        | PTE_Check_Success (ext_ptw) =>
           if ((level > (( 0 :: int)::ii))) then
             (let mask1 =
               ((sub_vec_int
                  ((shiftl
                      ((xor_vec ((get_SV48_PTE_PPNi pte  ::  44 Word.word))
                          ((xor_vec ((get_SV48_PTE_PPNi pte  ::  44 Word.word))
                              ((EXTZ (( 44 :: int)::ii) ( 0b1 ::  1 Word.word)  ::  44 Word.word))
                             ::  44 Word.word))
                         ::  44 Word.word)) ((level * SV48_LEVEL_BITS))
                     ::  44 Word.word)) (( 1 :: int)::ii)
                 ::  44 Word.word)) in
             if (((((and_vec ((get_SV48_PTE_PPNi pte  ::  44 Word.word)) mask1  ::  44 Word.word)) \<noteq> ((EXTZ (( 44 :: int)::ii) ( 0b0 ::  1 Word.word)  ::  44 Word.word))))) then
               PTW_Failure (PTW_Misaligned () , ext_ptw)
             else
               (let ppn =
                 ((or_vec ((get_SV48_PTE_PPNi pte  ::  44 Word.word))
                    ((and_vec
                        ((EXTZ (( 44 :: int)::ii) ((get_SV48_Vaddr_VPNi va  ::  27 Word.word))  ::  44 Word.word))
                        mask1
                       ::  44 Word.word))
                   ::  44 Word.word)) in
               PTW_Success ((concat_vec ppn ((get_SV48_Vaddr_PgOfs va  ::  12 Word.word))  ::  56 Word.word),
                            pte,
                            pte_addr,
                            level,
                            is_global,
                            ext_ptw)))
           else
             PTW_Success ((concat_vec ((get_SV48_PTE_PPNi pte  ::  44 Word.word))
                             ((get_SV48_Vaddr_PgOfs va  ::  12 Word.word))
                            ::  56 Word.word),
                          pte,
                          pte_addr,
                          level,
                          is_global,
                          ext_ptw)
        )))))))))
   )))))))\<close> 
  for  vaddr  :: "(48)Word.word " 
  and  ac  :: "(unit)AccessType " 
  and  priv  :: " Privilege " 
  and  mxr  :: " bool " 
  and  do_sum  :: " bool " 
  and  ptb  :: "(56)Word.word " 
  and  level  :: " int " 
  and  global1  :: " bool " 
  and  ext_ptw  :: " unit " 
by pat_completeness (auto intro!: let_cong bind_cong MemoryOpResult.case_cong)


\<comment> \<open>\<open>val lookup_TLB48 : mword ty16 -> mword ty48 -> M (maybe ((ii * TLB_Entry ty16 ty48 ty56 ty64)))\<close>\<close>

definition lookup_TLB48  :: \<open>(16)Word.word \<Rightarrow>(48)Word.word \<Rightarrow>((register_value),((int*((16),(48),(56),(64))TLB_Entry)option),(exception))monad \<close>  where 
     \<open> lookup_TLB48 asid vaddr = (
   read_reg tlb48_ref \<bind> ((\<lambda> (w__0 ::  ( (16, 48, 56, 64)TLB_Entry)option) . 
   return ((case  w__0 of
     None => None
   | Some (e) => if ((match_TLB_Entry e asid vaddr)) then Some ((( 0 :: int)::ii), e) else None
   )))))\<close> 
  for  asid  :: "(16)Word.word " 
  and  vaddr  :: "(48)Word.word "


\<comment> \<open>\<open>val add_to_TLB48 : mword ty16 -> mword ty48 -> mword ty56 -> SV48_PTE -> mword ty56 -> ii -> bool -> M unit\<close>\<close>

definition add_to_TLB48  :: \<open>(16)Word.word \<Rightarrow>(48)Word.word \<Rightarrow>(56)Word.word \<Rightarrow> SV48_PTE \<Rightarrow>(56)Word.word \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> add_to_TLB48 asid vAddr pAddr pte pteAddr level global1 = (
   make_TLB_Entry asid global1 vAddr pAddr ((get_SV48_PTE_bits pte  ::  64 Word.word)) level pteAddr
     SV48_LEVEL_BITS \<bind> ((\<lambda> (ent :: TLB48_Entry) . 
   write_reg tlb48_ref (Some ent))))\<close> 
  for  asid  :: "(16)Word.word " 
  and  vAddr  :: "(48)Word.word " 
  and  pAddr  :: "(56)Word.word " 
  and  pte  :: " SV48_PTE " 
  and  pteAddr  :: "(56)Word.word " 
  and  level  :: " int " 
  and  global1  :: " bool "


\<comment> \<open>\<open>val write_TLB48 : ii -> TLB_Entry ty16 ty48 ty56 ty64 -> M unit\<close>\<close>

definition write_TLB48  :: \<open> int \<Rightarrow>((16),(48),(56),(64))TLB_Entry \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> write_TLB48 (idx :: ii) (ent :: TLB48_Entry) = ( write_reg tlb48_ref (Some ent))\<close> 
  for  idx  :: " int " 
  and  ent  :: "((16),(48),(56),(64))TLB_Entry "


\<comment> \<open>\<open>val flush_TLB48 : maybe (mword ty16) -> maybe (mword ty48) -> M unit\<close>\<close>

definition flush_TLB48  :: \<open>((16)Word.word)option \<Rightarrow>((48)Word.word)option \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> flush_TLB48 asid addr = (
   read_reg tlb48_ref \<bind> ((\<lambda> (w__0 ::  ( (16, 48, 56, 64)TLB_Entry)option) . 
   (case  w__0 of
     None => return () 
   | Some (e) => if ((flush_TLB_Entry e asid addr)) then write_reg tlb48_ref None else return () 
   ))))\<close> 
  for  asid  :: "((16)Word.word)option " 
  and  addr  :: "((48)Word.word)option "


\<comment> \<open>\<open>val translate48 : mword ty16 -> mword ty56 -> mword ty48 -> AccessType unit -> Privilege -> bool -> bool -> ii -> unit -> M (TR_Result (mword ty56) PTW_Error)\<close>\<close>

definition translate48  :: \<open>(16)Word.word \<Rightarrow>(56)Word.word \<Rightarrow>(48)Word.word \<Rightarrow>(unit)AccessType \<Rightarrow> Privilege \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> unit \<Rightarrow>((register_value),((((56)Word.word),(PTW_Error))TR_Result),(exception))monad \<close>  where 
     \<open> translate48 asid ptb vAddr ac priv mxr do_sum level ext_ptw = (
   (walk48 vAddr ac priv mxr do_sum ptb level False ext_ptw  :: ( (( 56 Word.word), SV48_PTE)PTW_Result) M) \<bind> ((\<lambda> (w__0 :: (( 56 Word.word), SV48_PTE)
     PTW_Result) . 
   (case  w__0 of
     PTW_Failure ((f, ext_ptw)) => return (TR_Failure (f, ext_ptw))
   | PTW_Success ((pAddr, pte, pteAddr, level, global1, ext_ptw)) =>
      (case  ((update_PTE_Bits ((Mk_PTE_Bits ((get_SV48_PTE_BITS pte  ::  8 Word.word)))) ac
                ((get_SV48_PTE_Ext pte  ::  10 Word.word))
               ::  ((PTE_Bits *  10 Word.word))option)) of
        None =>
         add_to_TLB48 asid vAddr pAddr pte pteAddr level global1 \<then>
         return (TR_Address (pAddr, ext_ptw))
      | Some ((pbits, ext)) =>
         if ((\<not> ((plat_enable_dirty_update () )))) then
           return (TR_Failure (PTW_PTE_Update () , ext_ptw))
         else
           (let (w_pte :: SV48_PTE) =
             (update_SV48_PTE_BITS pte ((get_PTE_Bits_bits pbits  ::  8 Word.word))) in
           (let (w_pte :: SV48_PTE) = (update_SV48_PTE_Ext w_pte ext) in
           mem_write_value_priv ((EXTZ (( 64 :: int)::ii) pteAddr  ::  64 Word.word)) (( 8 :: int)::ii)
             ((get_SV48_PTE_bits w_pte  ::  64 Word.word)) Supervisor False False False \<bind> ((\<lambda> (w__1 :: bool
             MemoryOpResult) . 
           (case  w__1 of
             MemValue (_) =>
              add_to_TLB48 asid vAddr pAddr w_pte pteAddr level global1 \<then>
              return (TR_Address (pAddr, ext_ptw))
           | MemException (e) => return (TR_Failure (PTW_Access () , ext_ptw))
           )))))
      )
   ))))\<close> 
  for  asid  :: "(16)Word.word " 
  and  ptb  :: "(56)Word.word " 
  and  vAddr  :: "(48)Word.word " 
  and  ac  :: "(unit)AccessType " 
  and  priv  :: " Privilege " 
  and  mxr  :: " bool " 
  and  do_sum  :: " bool " 
  and  level  :: " int " 
  and  ext_ptw  :: " unit "


\<comment> \<open>\<open>val init_vmem_sv48 : unit -> M unit\<close>\<close>

definition init_vmem_sv48  :: \<open> unit \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> init_vmem_sv48 _ = ( write_reg tlb48_ref None )\<close>


\<comment> \<open>\<open>val legalize_satp : Architecture -> mword ty64 -> mword ty64 -> mword ty64\<close>\<close>

definition legalize_satp  :: \<open> Architecture \<Rightarrow>(64)Word.word \<Rightarrow>(64)Word.word \<Rightarrow>(64)Word.word \<close>  where 
     \<open> legalize_satp (a :: Architecture) (o1 :: xlenbits) (v :: xlenbits) = (
   (legalize_satp64 a o1 v  ::  64 Word.word))\<close> 
  for  a  :: " Architecture " 
  and  o1  :: "(64)Word.word " 
  and  v  :: "(64)Word.word "


\<comment> \<open>\<open>val isValidSv39Addr : mword ty64 -> bool\<close>\<close>

definition isValidSv39Addr  :: \<open>(64)Word.word \<Rightarrow> bool \<close>  where 
     \<open> isValidSv39Addr vAddr = (
   (((subrange_vec_dec vAddr (( 63 :: int)::ii) (( 39 :: int)::ii)  ::  25 Word.word)) = (if (((((access_vec_dec vAddr (( 38 :: int)::ii))) = B1))) then
        (ones (((((( 63 :: int)::ii) - (( 39 :: int)::ii))) + (( 1 :: int)::ii)))  ::  25 Word.word)
      else (zeros_implicit (((((( 63 :: int)::ii) - (( 39 :: int)::ii))) + (( 1 :: int)::ii)))  ::  25 Word.word))))\<close> 
  for  vAddr  :: "(64)Word.word "


\<comment> \<open>\<open>val isValidSv48Addr : mword ty64 -> bool\<close>\<close>

definition isValidSv48Addr  :: \<open>(64)Word.word \<Rightarrow> bool \<close>  where 
     \<open> isValidSv48Addr vAddr = (
   (((subrange_vec_dec vAddr (( 63 :: int)::ii) (( 48 :: int)::ii)  ::  16 Word.word)) = (if (((((access_vec_dec vAddr (( 47 :: int)::ii))) = B1))) then
        (ones (((((( 63 :: int)::ii) - (( 48 :: int)::ii))) + (( 1 :: int)::ii)))  ::  16 Word.word)
      else (zeros_implicit (((((( 63 :: int)::ii) - (( 48 :: int)::ii))) + (( 1 :: int)::ii)))  ::  16 Word.word))))\<close> 
  for  vAddr  :: "(64)Word.word "


\<comment> \<open>\<open>val translationMode : Privilege -> M SATPMode\<close>\<close>

definition translationMode  :: \<open> Privilege \<Rightarrow>((register_value),(SATPMode),(exception))monad \<close>  where 
     \<open> translationMode priv = (
   if (((priv = Machine))) then return Sbare
   else
     read_reg mstatus_ref \<bind> ((\<lambda> (w__0 :: Mstatus) . 
     (let arch = (architecture ((get_mstatus_SXL w__0  ::  2 Word.word))) in
     (case  arch of
       Some (RV64) =>
        (read_reg satp_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
        (let (mbits :: satp_mode) = ((get_Satp64_Mode ((Mk_Satp64 w__1))  ::  4 Word.word)) in
        (case  ((satp64Mode_of_bits RV64 mbits)) of
          Some (m) => return m
        | None => internal_error (''invalid RV64 translation mode in satp'')
        ))))
     | Some (RV32) =>
        (read_reg satp_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__4 ::  64 Word.word) . 
        (let s = (Mk_Satp32 ((subrange_vec_dec w__4 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))) in
        return (if (((((get_Satp32_Mode s  ::  1 Word.word)) = ( 0b0 ::  1 Word.word)))) then Sbare
                else Sv32))))
     | _ => internal_error (''unsupported address translation arch'')
     )))))\<close> 
  for  priv  :: " Privilege "


\<comment> \<open>\<open>val translateAddr_priv : mword ty64 -> AccessType unit -> Privilege -> M (TR_Result (mword ty64) ExceptionType)\<close>\<close>

definition translateAddr_priv  :: \<open>(64)Word.word \<Rightarrow>(unit)AccessType \<Rightarrow> Privilege \<Rightarrow>((register_value),((((64)Word.word),(ExceptionType))TR_Result),(exception))monad \<close>  where 
     \<open> translateAddr_priv vAddr ac effPriv = (
   read_reg mstatus_ref \<bind> ((\<lambda> (w__0 :: Mstatus) . 
   (let (mxr :: bool) = (((get_Mstatus_MXR w__0  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)) in
   read_reg mstatus_ref \<bind> ((\<lambda> (w__1 :: Mstatus) . 
   (let (do_sum :: bool) = (((get_Mstatus_SUM w__1  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)) in
   translationMode effPriv \<bind> ((\<lambda> (mode :: SATPMode) . 
   (read_reg satp_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
   (let asid = ((curAsid64 w__2  ::  16 Word.word)) in
   (read_reg satp_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__3 ::  64 Word.word) . 
   (let ptb = ((curPTB64 w__3  ::  56 Word.word)) in
   (let (ext_ptw :: ext_ptw) = init_ext_ptw in
   (case  mode of
     Sbare => return (TR_Address (vAddr, ext_ptw))
   | Sv39 =>
      if ((isValidSv39Addr vAddr)) then
        (translate39 asid ptb ((subrange_vec_dec vAddr (( 38 :: int)::ii) (( 0 :: int)::ii)  ::  39 Word.word)) ac effPriv mxr
           do_sum ((SV39_LEVELS - (( 1 :: int)::ii))) ext_ptw
          :: ( (( 56 Word.word), PTW_Error)TR_Result) M) \<bind> ((\<lambda> (w__4 :: (( 56 Word.word), PTW_Error) TR_Result) . 
        return ((case  w__4 of
          TR_Address ((pa, ext_ptw)) => TR_Address ((EXTZ (( 64 :: int)::ii) pa  ::  64 Word.word), ext_ptw)
        | TR_Failure ((f, ext_ptw)) => TR_Failure (translationException ac f, ext_ptw)
        ))))
      else return (TR_Failure (translationException ac (PTW_Invalid_Addr () ), ext_ptw))
   | Sv48 =>
      if ((isValidSv48Addr vAddr)) then
        (translate48 asid ptb ((subrange_vec_dec vAddr (( 47 :: int)::ii) (( 0 :: int)::ii)  ::  48 Word.word)) ac effPriv mxr
           do_sum ((SV48_LEVELS - (( 1 :: int)::ii))) ext_ptw
          :: ( (( 56 Word.word), PTW_Error)TR_Result) M) \<bind> ((\<lambda> (w__6 :: (( 56 Word.word), PTW_Error) TR_Result) . 
        return ((case  w__6 of
          TR_Address ((pa, ext_ptw)) => TR_Address ((EXTZ (( 64 :: int)::ii) pa  ::  64 Word.word), ext_ptw)
        | TR_Failure ((f, ext_ptw)) => TR_Failure (translationException ac f, ext_ptw)
        ))))
      else return (TR_Failure (translationException ac (PTW_Invalid_Addr () ), ext_ptw))
   | _ =>
      (internal_error (''unsupported address translation scheme'')
        :: ( (( 64 Word.word), ExceptionType)TR_Result) M)
   )))))))))))))))))\<close> 
  for  vAddr  :: "(64)Word.word " 
  and  ac  :: "(unit)AccessType " 
  and  effPriv  :: " Privilege "


\<comment> \<open>\<open>val translateAddr : mword ty64 -> AccessType unit -> M (TR_Result (mword ty64) ExceptionType)\<close>\<close>

definition translateAddr  :: \<open>(64)Word.word \<Rightarrow>(unit)AccessType \<Rightarrow>((register_value),((((64)Word.word),(ExceptionType))TR_Result),(exception))monad \<close>  where 
     \<open> translateAddr vAddr ac = (
   read_reg mstatus_ref \<bind> ((\<lambda> (w__0 :: Mstatus) . 
   read_reg cur_privilege_ref \<bind> ((\<lambda> (w__1 :: Privilege) . 
   effectivePrivilege ac w__0 w__1 \<bind> ((\<lambda> (w__2 :: Privilege) . 
   (translateAddr_priv vAddr ac w__2  :: ( (( 64 Word.word), ExceptionType)TR_Result) M))))))))\<close> 
  for  vAddr  :: "(64)Word.word " 
  and  ac  :: "(unit)AccessType "


\<comment> \<open>\<open>val flush_TLB : maybe (mword ty64) -> maybe (mword ty64) -> M unit\<close>\<close>

definition flush_TLB  :: \<open>((64)Word.word)option \<Rightarrow>((64)Word.word)option \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> flush_TLB asid_xlen addr_xlen = (
   (let ((addr39 ::  vaddr39 option), (addr48 ::  vaddr48 option)) =
     ((case  addr_xlen of
       None => (None, None)
     | Some (a) =>
        (Some ((subrange_vec_dec a (( 38 :: int)::ii) (( 0 :: int)::ii)  ::  39 Word.word)),
         Some ((subrange_vec_dec a (( 47 :: int)::ii) (( 0 :: int)::ii)  ::  48 Word.word)))
     )) in
   (let (asid ::  asid64 option) =
     ((case  asid_xlen of
       None => None
     | Some (a) => Some ((subrange_vec_dec a (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))
     )) in
   flush_TLB39 asid addr39 \<then> flush_TLB48 asid addr48)))\<close> 
  for  asid_xlen  :: "((64)Word.word)option " 
  and  addr_xlen  :: "((64)Word.word)option "


\<comment> \<open>\<open>val init_vmem : unit -> M unit\<close>\<close>

definition init_vmem  :: \<open> unit \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> init_vmem _ = ( init_vmem_sv39 ()  \<then> init_vmem_sv48 ()  )\<close>


\<comment> \<open>\<open>val execute : ast -> M Retired\<close>\<close>

\<comment> \<open>\<open>val assembly_forwards : ast -> M string\<close>\<close>

\<comment> \<open>\<open>val assembly_backwards : string -> M ast\<close>\<close>

\<comment> \<open>\<open>val assembly_forwards_matches : ast -> bool\<close>\<close>

\<comment> \<open>\<open>val assembly_backwards_matches : string -> bool\<close>\<close>

\<comment> \<open>\<open>val assembly_matches_prefix : string -> maybe ((ast * ii))\<close>\<close>

\<comment> \<open>\<open>val encdec_forwards : ast -> M (mword ty32)\<close>\<close>

\<comment> \<open>\<open>val encdec_backwards : mword ty32 -> M ast\<close>\<close>

\<comment> \<open>\<open>val encdec_forwards_matches : ast -> M bool\<close>\<close>

\<comment> \<open>\<open>val encdec_backwards_matches : mword ty32 -> M bool\<close>\<close>

\<comment> \<open>\<open>val encdec_compressed_forwards : ast -> M (mword ty16)\<close>\<close>

\<comment> \<open>\<open>val encdec_compressed_backwards : mword ty16 -> M ast\<close>\<close>

\<comment> \<open>\<open>val encdec_compressed_forwards_matches : ast -> M bool\<close>\<close>

\<comment> \<open>\<open>val encdec_compressed_backwards_matches : mword ty16 -> M bool\<close>\<close>

\<comment> \<open>\<open>val encdec_uop_forwards : uop -> mword ty7\<close>\<close>

\<comment> \<open>\<open>val encdec_uop_backwards : mword ty7 -> M uop\<close>\<close>

\<comment> \<open>\<open>val encdec_uop_forwards_matches : uop -> bool\<close>\<close>

\<comment> \<open>\<open>val encdec_uop_backwards_matches : mword ty7 -> bool\<close>\<close>

fun encdec_uop_forwards  :: \<open> uop \<Rightarrow>(7)Word.word \<close>  where 
     \<open> encdec_uop_forwards RISCV_LUI = ( ( 0b0110111 ::  7 Word.word))\<close>
|\<open> encdec_uop_forwards RISCV_AUIPC = ( ( 0b0010111 ::  7 Word.word))\<close>


definition encdec_uop_backwards  :: \<open>(7)Word.word \<Rightarrow>((register_value),(uop),(exception))monad \<close>  where 
     \<open> encdec_uop_backwards arg1 = (
   (let b__0 = arg1 in
   if (((b__0 = ( 0b0110111 ::  7 Word.word)))) then return RISCV_LUI
   else if (((b__0 = ( 0b0010111 ::  7 Word.word)))) then return RISCV_AUIPC
   else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))\<close> 
  for  arg1  :: "(7)Word.word "


fun encdec_uop_forwards_matches  :: \<open> uop \<Rightarrow> bool \<close>  where 
     \<open> encdec_uop_forwards_matches RISCV_LUI = ( True )\<close>
|\<open> encdec_uop_forwards_matches RISCV_AUIPC = ( True )\<close>


definition encdec_uop_backwards_matches  :: \<open>(7)Word.word \<Rightarrow> bool \<close>  where 
     \<open> encdec_uop_backwards_matches arg1 = (
   (let b__0 = arg1 in
   if (((b__0 = ( 0b0110111 ::  7 Word.word)))) then True
   else if (((b__0 = ( 0b0010111 ::  7 Word.word)))) then True
   else False))\<close> 
  for  arg1  :: "(7)Word.word "


\<comment> \<open>\<open>val utype_mnemonic_forwards : uop -> string\<close>\<close>

\<comment> \<open>\<open>val utype_mnemonic_backwards : string -> M uop\<close>\<close>

\<comment> \<open>\<open>val utype_mnemonic_forwards_matches : uop -> bool\<close>\<close>

\<comment> \<open>\<open>val utype_mnemonic_backwards_matches : string -> bool\<close>\<close>

\<comment> \<open>\<open>val utype_mnemonic_matches_prefix : string -> maybe ((uop * ii))\<close>\<close>

fun utype_mnemonic_forwards  :: \<open> uop \<Rightarrow> string \<close>  where 
     \<open> utype_mnemonic_forwards RISCV_LUI = ( (''lui''))\<close>
|\<open> utype_mnemonic_forwards RISCV_AUIPC = ( (''auipc''))\<close>


definition utype_mnemonic_backwards  :: \<open> string \<Rightarrow>((register_value),(uop),(exception))monad \<close>  where 
     \<open> utype_mnemonic_backwards arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''lui'')))) then return RISCV_LUI
   else if (((p00 = (''auipc'')))) then return RISCV_AUIPC
   else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))\<close> 
  for  arg1  :: " string "


fun utype_mnemonic_forwards_matches  :: \<open> uop \<Rightarrow> bool \<close>  where 
     \<open> utype_mnemonic_forwards_matches RISCV_LUI = ( True )\<close>
|\<open> utype_mnemonic_forwards_matches RISCV_AUIPC = ( True )\<close>


definition utype_mnemonic_backwards_matches  :: \<open> string \<Rightarrow> bool \<close>  where 
     \<open> utype_mnemonic_backwards_matches arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''lui'')))) then True
   else if (((p00 = (''auipc'')))) then True
   else False))\<close> 
  for  arg1  :: " string "


\<comment> \<open>\<open>val _s761_ : string -> maybe string\<close>\<close>

definition s761  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s761 s7620 = (
   (let s7630 = s7620 in
   if ((string_startswith s7630 (''auipc''))) then  
  (case  ((string_drop s7630 ((string_length (''auipc''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s7620  :: " string "


\<comment> \<open>\<open>val _s757_ : string -> maybe string\<close>\<close>

definition s757  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s757 s7580 = (
   (let s7590 = s7580 in
   if ((string_startswith s7590 (''lui''))) then  
  (case  ((string_drop s7590 ((string_length (''lui''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s7580  :: " string "


definition utype_mnemonic_matches_prefix  :: \<open> string \<Rightarrow>(uop*int)option \<close>  where 
     \<open> utype_mnemonic_matches_prefix arg1 = (
   (let s7600 = arg1 in
   if ((case  ((s757 s7600)) of   Some (s1) => True | _ => False )) then  
  (case  s757 s7600 of
      (Some (s1)) =>
  Some (RISCV_LUI, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s761 s7600)) of   Some (s1) => True | _ => False )) then  
  (case  s761 s7600 of
      (Some (s1)) =>
  Some (RISCV_AUIPC, ((string_length arg1)) - ((string_length s1)))
  )
   else None))\<close> 
  for  arg1  :: " string "


\<comment> \<open>\<open>val encdec_bop_forwards : bop -> mword ty3\<close>\<close>

\<comment> \<open>\<open>val encdec_bop_backwards : mword ty3 -> M bop\<close>\<close>

\<comment> \<open>\<open>val encdec_bop_forwards_matches : bop -> bool\<close>\<close>

\<comment> \<open>\<open>val encdec_bop_backwards_matches : mword ty3 -> bool\<close>\<close>

fun encdec_bop_forwards  :: \<open> bop \<Rightarrow>(3)Word.word \<close>  where 
     \<open> encdec_bop_forwards RISCV_BEQ = ( ( 0b000 ::  3 Word.word))\<close>
|\<open> encdec_bop_forwards RISCV_BNE = ( ( 0b001 ::  3 Word.word))\<close>
|\<open> encdec_bop_forwards RISCV_BLT = ( ( 0b100 ::  3 Word.word))\<close>
|\<open> encdec_bop_forwards RISCV_BGE = ( ( 0b101 ::  3 Word.word))\<close>
|\<open> encdec_bop_forwards RISCV_BLTU = ( ( 0b110 ::  3 Word.word))\<close>
|\<open> encdec_bop_forwards RISCV_BGEU = ( ( 0b111 ::  3 Word.word))\<close>


definition encdec_bop_backwards  :: \<open>(3)Word.word \<Rightarrow>((register_value),(bop),(exception))monad \<close>  where 
     \<open> encdec_bop_backwards arg1 = (
   (let b__0 = arg1 in
   if (((b__0 = ( 0b000 ::  3 Word.word)))) then return RISCV_BEQ
   else if (((b__0 = ( 0b001 ::  3 Word.word)))) then return RISCV_BNE
   else if (((b__0 = ( 0b100 ::  3 Word.word)))) then return RISCV_BLT
   else if (((b__0 = ( 0b101 ::  3 Word.word)))) then return RISCV_BGE
   else if (((b__0 = ( 0b110 ::  3 Word.word)))) then return RISCV_BLTU
   else if (((b__0 = ( 0b111 ::  3 Word.word)))) then return RISCV_BGEU
   else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))\<close> 
  for  arg1  :: "(3)Word.word "


fun encdec_bop_forwards_matches  :: \<open> bop \<Rightarrow> bool \<close>  where 
     \<open> encdec_bop_forwards_matches RISCV_BEQ = ( True )\<close>
|\<open> encdec_bop_forwards_matches RISCV_BNE = ( True )\<close>
|\<open> encdec_bop_forwards_matches RISCV_BLT = ( True )\<close>
|\<open> encdec_bop_forwards_matches RISCV_BGE = ( True )\<close>
|\<open> encdec_bop_forwards_matches RISCV_BLTU = ( True )\<close>
|\<open> encdec_bop_forwards_matches RISCV_BGEU = ( True )\<close>


definition encdec_bop_backwards_matches  :: \<open>(3)Word.word \<Rightarrow> bool \<close>  where 
     \<open> encdec_bop_backwards_matches arg1 = (
   (let b__0 = arg1 in
   if (((b__0 = ( 0b000 ::  3 Word.word)))) then True
   else if (((b__0 = ( 0b001 ::  3 Word.word)))) then True
   else if (((b__0 = ( 0b100 ::  3 Word.word)))) then True
   else if (((b__0 = ( 0b101 ::  3 Word.word)))) then True
   else if (((b__0 = ( 0b110 ::  3 Word.word)))) then True
   else if (((b__0 = ( 0b111 ::  3 Word.word)))) then True
   else False))\<close> 
  for  arg1  :: "(3)Word.word "


\<comment> \<open>\<open>val btype_mnemonic_forwards : bop -> string\<close>\<close>

\<comment> \<open>\<open>val btype_mnemonic_backwards : string -> M bop\<close>\<close>

\<comment> \<open>\<open>val btype_mnemonic_forwards_matches : bop -> bool\<close>\<close>

\<comment> \<open>\<open>val btype_mnemonic_backwards_matches : string -> bool\<close>\<close>

\<comment> \<open>\<open>val btype_mnemonic_matches_prefix : string -> maybe ((bop * ii))\<close>\<close>

fun btype_mnemonic_forwards  :: \<open> bop \<Rightarrow> string \<close>  where 
     \<open> btype_mnemonic_forwards RISCV_BEQ = ( (''beq''))\<close>
|\<open> btype_mnemonic_forwards RISCV_BNE = ( (''bne''))\<close>
|\<open> btype_mnemonic_forwards RISCV_BLT = ( (''blt''))\<close>
|\<open> btype_mnemonic_forwards RISCV_BGE = ( (''bge''))\<close>
|\<open> btype_mnemonic_forwards RISCV_BLTU = ( (''bltu''))\<close>
|\<open> btype_mnemonic_forwards RISCV_BGEU = ( (''bgeu''))\<close>


definition btype_mnemonic_backwards  :: \<open> string \<Rightarrow>((register_value),(bop),(exception))monad \<close>  where 
     \<open> btype_mnemonic_backwards arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''beq'')))) then return RISCV_BEQ
   else if (((p00 = (''bne'')))) then return RISCV_BNE
   else if (((p00 = (''blt'')))) then return RISCV_BLT
   else if (((p00 = (''bge'')))) then return RISCV_BGE
   else if (((p00 = (''bltu'')))) then return RISCV_BLTU
   else if (((p00 = (''bgeu'')))) then return RISCV_BGEU
   else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))\<close> 
  for  arg1  :: " string "


fun btype_mnemonic_forwards_matches  :: \<open> bop \<Rightarrow> bool \<close>  where 
     \<open> btype_mnemonic_forwards_matches RISCV_BEQ = ( True )\<close>
|\<open> btype_mnemonic_forwards_matches RISCV_BNE = ( True )\<close>
|\<open> btype_mnemonic_forwards_matches RISCV_BLT = ( True )\<close>
|\<open> btype_mnemonic_forwards_matches RISCV_BGE = ( True )\<close>
|\<open> btype_mnemonic_forwards_matches RISCV_BLTU = ( True )\<close>
|\<open> btype_mnemonic_forwards_matches RISCV_BGEU = ( True )\<close>


definition btype_mnemonic_backwards_matches  :: \<open> string \<Rightarrow> bool \<close>  where 
     \<open> btype_mnemonic_backwards_matches arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''beq'')))) then True
   else if (((p00 = (''bne'')))) then True
   else if (((p00 = (''blt'')))) then True
   else if (((p00 = (''bge'')))) then True
   else if (((p00 = (''bltu'')))) then True
   else if (((p00 = (''bgeu'')))) then True
   else False))\<close> 
  for  arg1  :: " string "


\<comment> \<open>\<open>val _s785_ : string -> maybe string\<close>\<close>

definition s785  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s785 s7860 = (
   (let s7870 = s7860 in
   if ((string_startswith s7870 (''bgeu''))) then  
  (case  ((string_drop s7870 ((string_length (''bgeu''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s7860  :: " string "


\<comment> \<open>\<open>val _s781_ : string -> maybe string\<close>\<close>

definition s781  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s781 s7820 = (
   (let s7830 = s7820 in
   if ((string_startswith s7830 (''bltu''))) then  
  (case  ((string_drop s7830 ((string_length (''bltu''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s7820  :: " string "


\<comment> \<open>\<open>val _s777_ : string -> maybe string\<close>\<close>

definition s777  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s777 s7780 = (
   (let s7790 = s7780 in
   if ((string_startswith s7790 (''bge''))) then  
  (case  ((string_drop s7790 ((string_length (''bge''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s7780  :: " string "


\<comment> \<open>\<open>val _s773_ : string -> maybe string\<close>\<close>

definition s773  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s773 s7740 = (
   (let s7750 = s7740 in
   if ((string_startswith s7750 (''blt''))) then  
  (case  ((string_drop s7750 ((string_length (''blt''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s7740  :: " string "


\<comment> \<open>\<open>val _s769_ : string -> maybe string\<close>\<close>

definition s769  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s769 s7700 = (
   (let s7710 = s7700 in
   if ((string_startswith s7710 (''bne''))) then  
  (case  ((string_drop s7710 ((string_length (''bne''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s7700  :: " string "


\<comment> \<open>\<open>val _s765_ : string -> maybe string\<close>\<close>

definition s765  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s765 s7660 = (
   (let s7670 = s7660 in
   if ((string_startswith s7670 (''beq''))) then  
  (case  ((string_drop s7670 ((string_length (''beq''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s7660  :: " string "


definition btype_mnemonic_matches_prefix  :: \<open> string \<Rightarrow>(bop*int)option \<close>  where 
     \<open> btype_mnemonic_matches_prefix arg1 = (
   (let s7680 = arg1 in
   if ((case  ((s765 s7680)) of   Some (s1) => True | _ => False )) then  
  (case  s765 s7680 of
      (Some (s1)) =>
  Some (RISCV_BEQ, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s769 s7680)) of   Some (s1) => True | _ => False )) then  
  (case  s769 s7680 of
      (Some (s1)) =>
  Some (RISCV_BNE, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s773 s7680)) of   Some (s1) => True | _ => False )) then  
  (case  s773 s7680 of
      (Some (s1)) =>
  Some (RISCV_BLT, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s777 s7680)) of   Some (s1) => True | _ => False )) then  
  (case  s777 s7680 of
      (Some (s1)) =>
  Some (RISCV_BGE, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s781 s7680)) of   Some (s1) => True | _ => False )) then  
  (case  s781 s7680 of
      (Some (s1)) =>
  Some (RISCV_BLTU, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s785 s7680)) of   Some (s1) => True | _ => False )) then  
  (case  s785 s7680 of
      (Some (s1)) =>
  Some (RISCV_BGEU, ((string_length arg1)) - ((string_length s1)))
  )
   else None))\<close> 
  for  arg1  :: " string "


\<comment> \<open>\<open>val encdec_iop_forwards : iop -> mword ty3\<close>\<close>

\<comment> \<open>\<open>val encdec_iop_backwards : mword ty3 -> M iop\<close>\<close>

\<comment> \<open>\<open>val encdec_iop_forwards_matches : iop -> bool\<close>\<close>

\<comment> \<open>\<open>val encdec_iop_backwards_matches : mword ty3 -> bool\<close>\<close>

fun encdec_iop_forwards  :: \<open> iop \<Rightarrow>(3)Word.word \<close>  where 
     \<open> encdec_iop_forwards RISCV_ADDI = ( ( 0b000 ::  3 Word.word))\<close>
|\<open> encdec_iop_forwards RISCV_SLTI = ( ( 0b010 ::  3 Word.word))\<close>
|\<open> encdec_iop_forwards RISCV_SLTIU = ( ( 0b011 ::  3 Word.word))\<close>
|\<open> encdec_iop_forwards RISCV_ANDI = ( ( 0b111 ::  3 Word.word))\<close>
|\<open> encdec_iop_forwards RISCV_ORI = ( ( 0b110 ::  3 Word.word))\<close>
|\<open> encdec_iop_forwards RISCV_XORI = ( ( 0b100 ::  3 Word.word))\<close>


definition encdec_iop_backwards  :: \<open>(3)Word.word \<Rightarrow>((register_value),(iop),(exception))monad \<close>  where 
     \<open> encdec_iop_backwards arg1 = (
   (let b__0 = arg1 in
   if (((b__0 = ( 0b000 ::  3 Word.word)))) then return RISCV_ADDI
   else if (((b__0 = ( 0b010 ::  3 Word.word)))) then return RISCV_SLTI
   else if (((b__0 = ( 0b011 ::  3 Word.word)))) then return RISCV_SLTIU
   else if (((b__0 = ( 0b111 ::  3 Word.word)))) then return RISCV_ANDI
   else if (((b__0 = ( 0b110 ::  3 Word.word)))) then return RISCV_ORI
   else if (((b__0 = ( 0b100 ::  3 Word.word)))) then return RISCV_XORI
   else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))\<close> 
  for  arg1  :: "(3)Word.word "


fun encdec_iop_forwards_matches  :: \<open> iop \<Rightarrow> bool \<close>  where 
     \<open> encdec_iop_forwards_matches RISCV_ADDI = ( True )\<close>
|\<open> encdec_iop_forwards_matches RISCV_SLTI = ( True )\<close>
|\<open> encdec_iop_forwards_matches RISCV_SLTIU = ( True )\<close>
|\<open> encdec_iop_forwards_matches RISCV_ANDI = ( True )\<close>
|\<open> encdec_iop_forwards_matches RISCV_ORI = ( True )\<close>
|\<open> encdec_iop_forwards_matches RISCV_XORI = ( True )\<close>


definition encdec_iop_backwards_matches  :: \<open>(3)Word.word \<Rightarrow> bool \<close>  where 
     \<open> encdec_iop_backwards_matches arg1 = (
   (let b__0 = arg1 in
   if (((b__0 = ( 0b000 ::  3 Word.word)))) then True
   else if (((b__0 = ( 0b010 ::  3 Word.word)))) then True
   else if (((b__0 = ( 0b011 ::  3 Word.word)))) then True
   else if (((b__0 = ( 0b111 ::  3 Word.word)))) then True
   else if (((b__0 = ( 0b110 ::  3 Word.word)))) then True
   else if (((b__0 = ( 0b100 ::  3 Word.word)))) then True
   else False))\<close> 
  for  arg1  :: "(3)Word.word "


\<comment> \<open>\<open>val itype_mnemonic_forwards : iop -> string\<close>\<close>

\<comment> \<open>\<open>val itype_mnemonic_backwards : string -> M iop\<close>\<close>

\<comment> \<open>\<open>val itype_mnemonic_forwards_matches : iop -> bool\<close>\<close>

\<comment> \<open>\<open>val itype_mnemonic_backwards_matches : string -> bool\<close>\<close>

\<comment> \<open>\<open>val itype_mnemonic_matches_prefix : string -> maybe ((iop * ii))\<close>\<close>

fun itype_mnemonic_forwards  :: \<open> iop \<Rightarrow> string \<close>  where 
     \<open> itype_mnemonic_forwards RISCV_ADDI = ( (''addi''))\<close>
|\<open> itype_mnemonic_forwards RISCV_SLTI = ( (''slti''))\<close>
|\<open> itype_mnemonic_forwards RISCV_SLTIU = ( (''sltiu''))\<close>
|\<open> itype_mnemonic_forwards RISCV_XORI = ( (''xori''))\<close>
|\<open> itype_mnemonic_forwards RISCV_ORI = ( (''ori''))\<close>
|\<open> itype_mnemonic_forwards RISCV_ANDI = ( (''andi''))\<close>


definition itype_mnemonic_backwards  :: \<open> string \<Rightarrow>((register_value),(iop),(exception))monad \<close>  where 
     \<open> itype_mnemonic_backwards arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''addi'')))) then return RISCV_ADDI
   else if (((p00 = (''slti'')))) then return RISCV_SLTI
   else if (((p00 = (''sltiu'')))) then return RISCV_SLTIU
   else if (((p00 = (''xori'')))) then return RISCV_XORI
   else if (((p00 = (''ori'')))) then return RISCV_ORI
   else if (((p00 = (''andi'')))) then return RISCV_ANDI
   else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))\<close> 
  for  arg1  :: " string "


fun itype_mnemonic_forwards_matches  :: \<open> iop \<Rightarrow> bool \<close>  where 
     \<open> itype_mnemonic_forwards_matches RISCV_ADDI = ( True )\<close>
|\<open> itype_mnemonic_forwards_matches RISCV_SLTI = ( True )\<close>
|\<open> itype_mnemonic_forwards_matches RISCV_SLTIU = ( True )\<close>
|\<open> itype_mnemonic_forwards_matches RISCV_XORI = ( True )\<close>
|\<open> itype_mnemonic_forwards_matches RISCV_ORI = ( True )\<close>
|\<open> itype_mnemonic_forwards_matches RISCV_ANDI = ( True )\<close>


definition itype_mnemonic_backwards_matches  :: \<open> string \<Rightarrow> bool \<close>  where 
     \<open> itype_mnemonic_backwards_matches arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''addi'')))) then True
   else if (((p00 = (''slti'')))) then True
   else if (((p00 = (''sltiu'')))) then True
   else if (((p00 = (''xori'')))) then True
   else if (((p00 = (''ori'')))) then True
   else if (((p00 = (''andi'')))) then True
   else False))\<close> 
  for  arg1  :: " string "


\<comment> \<open>\<open>val _s809_ : string -> maybe string\<close>\<close>

definition s809  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s809 s8100 = (
   (let s8110 = s8100 in
   if ((string_startswith s8110 (''andi''))) then  
  (case  ((string_drop s8110 ((string_length (''andi''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s8100  :: " string "


\<comment> \<open>\<open>val _s805_ : string -> maybe string\<close>\<close>

definition s805  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s805 s8060 = (
   (let s8070 = s8060 in
   if ((string_startswith s8070 (''ori''))) then  
  (case  ((string_drop s8070 ((string_length (''ori''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s8060  :: " string "


\<comment> \<open>\<open>val _s801_ : string -> maybe string\<close>\<close>

definition s801  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s801 s8020 = (
   (let s8030 = s8020 in
   if ((string_startswith s8030 (''xori''))) then  
  (case  ((string_drop s8030 ((string_length (''xori''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s8020  :: " string "


\<comment> \<open>\<open>val _s797_ : string -> maybe string\<close>\<close>

definition s797  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s797 s7980 = (
   (let s7990 = s7980 in
   if ((string_startswith s7990 (''sltiu''))) then  
  (case  ((string_drop s7990 ((string_length (''sltiu''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s7980  :: " string "


\<comment> \<open>\<open>val _s793_ : string -> maybe string\<close>\<close>

definition s793  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s793 s7940 = (
   (let s7950 = s7940 in
   if ((string_startswith s7950 (''slti''))) then  
  (case  ((string_drop s7950 ((string_length (''slti''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s7940  :: " string "


\<comment> \<open>\<open>val _s789_ : string -> maybe string\<close>\<close>

definition s789  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s789 s7900 = (
   (let s7910 = s7900 in
   if ((string_startswith s7910 (''addi''))) then  
  (case  ((string_drop s7910 ((string_length (''addi''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s7900  :: " string "


definition itype_mnemonic_matches_prefix  :: \<open> string \<Rightarrow>(iop*int)option \<close>  where 
     \<open> itype_mnemonic_matches_prefix arg1 = (
   (let s7920 = arg1 in
   if ((case  ((s789 s7920)) of   Some (s1) => True | _ => False )) then  
  (case  s789 s7920 of
      (Some (s1)) =>
  Some (RISCV_ADDI, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s793 s7920)) of   Some (s1) => True | _ => False )) then  
  (case  s793 s7920 of
      (Some (s1)) =>
  Some (RISCV_SLTI, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s797 s7920)) of   Some (s1) => True | _ => False )) then  
  (case  s797 s7920 of
      (Some (s1)) =>
  Some (RISCV_SLTIU, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s801 s7920)) of   Some (s1) => True | _ => False )) then  
  (case  s801 s7920 of
      (Some (s1)) =>
  Some (RISCV_XORI, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s805 s7920)) of   Some (s1) => True | _ => False )) then  
  (case  s805 s7920 of
      (Some (s1)) =>
  Some (RISCV_ORI, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s809 s7920)) of   Some (s1) => True | _ => False )) then  
  (case  s809 s7920 of
      (Some (s1)) =>
  Some (RISCV_ANDI, ((string_length arg1)) - ((string_length s1)))
  )
   else None))\<close> 
  for  arg1  :: " string "


\<comment> \<open>\<open>val encdec_sop_forwards : sop -> mword ty3\<close>\<close>

\<comment> \<open>\<open>val encdec_sop_backwards : mword ty3 -> M sop\<close>\<close>

\<comment> \<open>\<open>val encdec_sop_forwards_matches : sop -> bool\<close>\<close>

\<comment> \<open>\<open>val encdec_sop_backwards_matches : mword ty3 -> bool\<close>\<close>

fun encdec_sop_forwards  :: \<open> sop \<Rightarrow>(3)Word.word \<close>  where 
     \<open> encdec_sop_forwards RISCV_SLLI = ( ( 0b001 ::  3 Word.word))\<close>
|\<open> encdec_sop_forwards RISCV_SRLI = ( ( 0b101 ::  3 Word.word))\<close>
|\<open> encdec_sop_forwards RISCV_SRAI = ( ( 0b101 ::  3 Word.word))\<close>


definition encdec_sop_backwards  :: \<open>(3)Word.word \<Rightarrow>((register_value),(sop),(exception))monad \<close>  where 
     \<open> encdec_sop_backwards arg1 = (
   (let b__0 = arg1 in
   if (((b__0 = ( 0b001 ::  3 Word.word)))) then return RISCV_SLLI
   else if (((b__0 = ( 0b101 ::  3 Word.word)))) then return RISCV_SRLI
   else if (((b__0 = ( 0b101 ::  3 Word.word)))) then return RISCV_SRAI
   else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))\<close> 
  for  arg1  :: "(3)Word.word "


fun encdec_sop_forwards_matches  :: \<open> sop \<Rightarrow> bool \<close>  where 
     \<open> encdec_sop_forwards_matches RISCV_SLLI = ( True )\<close>
|\<open> encdec_sop_forwards_matches RISCV_SRLI = ( True )\<close>
|\<open> encdec_sop_forwards_matches RISCV_SRAI = ( True )\<close>


definition encdec_sop_backwards_matches  :: \<open>(3)Word.word \<Rightarrow> bool \<close>  where 
     \<open> encdec_sop_backwards_matches arg1 = (
   (let b__0 = arg1 in
   if (((b__0 = ( 0b001 ::  3 Word.word)))) then True
   else if (((b__0 = ( 0b101 ::  3 Word.word)))) then True
   else if (((b__0 = ( 0b101 ::  3 Word.word)))) then True
   else False))\<close> 
  for  arg1  :: "(3)Word.word "


\<comment> \<open>\<open>val shiftiop_mnemonic_forwards : sop -> string\<close>\<close>

\<comment> \<open>\<open>val shiftiop_mnemonic_backwards : string -> M sop\<close>\<close>

\<comment> \<open>\<open>val shiftiop_mnemonic_forwards_matches : sop -> bool\<close>\<close>

\<comment> \<open>\<open>val shiftiop_mnemonic_backwards_matches : string -> bool\<close>\<close>

\<comment> \<open>\<open>val shiftiop_mnemonic_matches_prefix : string -> maybe ((sop * ii))\<close>\<close>

fun shiftiop_mnemonic_forwards  :: \<open> sop \<Rightarrow> string \<close>  where 
     \<open> shiftiop_mnemonic_forwards RISCV_SLLI = ( (''slli''))\<close>
|\<open> shiftiop_mnemonic_forwards RISCV_SRLI = ( (''srli''))\<close>
|\<open> shiftiop_mnemonic_forwards RISCV_SRAI = ( (''srai''))\<close>


definition shiftiop_mnemonic_backwards  :: \<open> string \<Rightarrow>((register_value),(sop),(exception))monad \<close>  where 
     \<open> shiftiop_mnemonic_backwards arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''slli'')))) then return RISCV_SLLI
   else if (((p00 = (''srli'')))) then return RISCV_SRLI
   else if (((p00 = (''srai'')))) then return RISCV_SRAI
   else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))\<close> 
  for  arg1  :: " string "


fun shiftiop_mnemonic_forwards_matches  :: \<open> sop \<Rightarrow> bool \<close>  where 
     \<open> shiftiop_mnemonic_forwards_matches RISCV_SLLI = ( True )\<close>
|\<open> shiftiop_mnemonic_forwards_matches RISCV_SRLI = ( True )\<close>
|\<open> shiftiop_mnemonic_forwards_matches RISCV_SRAI = ( True )\<close>


definition shiftiop_mnemonic_backwards_matches  :: \<open> string \<Rightarrow> bool \<close>  where 
     \<open> shiftiop_mnemonic_backwards_matches arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''slli'')))) then True
   else if (((p00 = (''srli'')))) then True
   else if (((p00 = (''srai'')))) then True
   else False))\<close> 
  for  arg1  :: " string "


\<comment> \<open>\<open>val _s821_ : string -> maybe string\<close>\<close>

definition s821  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s821 s8220 = (
   (let s8230 = s8220 in
   if ((string_startswith s8230 (''srai''))) then  
  (case  ((string_drop s8230 ((string_length (''srai''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s8220  :: " string "


\<comment> \<open>\<open>val _s817_ : string -> maybe string\<close>\<close>

definition s817  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s817 s8180 = (
   (let s8190 = s8180 in
   if ((string_startswith s8190 (''srli''))) then  
  (case  ((string_drop s8190 ((string_length (''srli''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s8180  :: " string "


\<comment> \<open>\<open>val _s813_ : string -> maybe string\<close>\<close>

definition s813  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s813 s8140 = (
   (let s8150 = s8140 in
   if ((string_startswith s8150 (''slli''))) then  
  (case  ((string_drop s8150 ((string_length (''slli''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s8140  :: " string "


definition shiftiop_mnemonic_matches_prefix  :: \<open> string \<Rightarrow>(sop*int)option \<close>  where 
     \<open> shiftiop_mnemonic_matches_prefix arg1 = (
   (let s8160 = arg1 in
   if ((case  ((s813 s8160)) of   Some (s1) => True | _ => False )) then  
  (case  s813 s8160 of
      (Some (s1)) =>
  Some (RISCV_SLLI, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s817 s8160)) of   Some (s1) => True | _ => False )) then  
  (case  s817 s8160 of
      (Some (s1)) =>
  Some (RISCV_SRLI, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s821 s8160)) of   Some (s1) => True | _ => False )) then  
  (case  s821 s8160 of
      (Some (s1)) =>
  Some (RISCV_SRAI, ((string_length arg1)) - ((string_length s1)))
  )
   else None))\<close> 
  for  arg1  :: " string "


\<comment> \<open>\<open>val rtype_mnemonic_forwards : rop -> string\<close>\<close>

\<comment> \<open>\<open>val rtype_mnemonic_backwards : string -> M rop\<close>\<close>

\<comment> \<open>\<open>val rtype_mnemonic_forwards_matches : rop -> bool\<close>\<close>

\<comment> \<open>\<open>val rtype_mnemonic_backwards_matches : string -> bool\<close>\<close>

\<comment> \<open>\<open>val rtype_mnemonic_matches_prefix : string -> maybe ((rop * ii))\<close>\<close>

fun rtype_mnemonic_forwards  :: \<open> rop \<Rightarrow> string \<close>  where 
     \<open> rtype_mnemonic_forwards RISCV_ADD = ( (''add''))\<close>
|\<open> rtype_mnemonic_forwards RISCV_SLT = ( (''slt''))\<close>
|\<open> rtype_mnemonic_forwards RISCV_SLTU = ( (''sltu''))\<close>
|\<open> rtype_mnemonic_forwards RISCV_AND = ( (''and''))\<close>
|\<open> rtype_mnemonic_forwards RISCV_OR = ( (''or''))\<close>
|\<open> rtype_mnemonic_forwards RISCV_XOR = ( (''xor''))\<close>
|\<open> rtype_mnemonic_forwards RISCV_SLL = ( (''sll''))\<close>
|\<open> rtype_mnemonic_forwards RISCV_SRL = ( (''srl''))\<close>
|\<open> rtype_mnemonic_forwards RISCV_SUB = ( (''sub''))\<close>
|\<open> rtype_mnemonic_forwards RISCV_SRA = ( (''sra''))\<close>


definition rtype_mnemonic_backwards  :: \<open> string \<Rightarrow>((register_value),(rop),(exception))monad \<close>  where 
     \<open> rtype_mnemonic_backwards arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''add'')))) then return RISCV_ADD
   else if (((p00 = (''slt'')))) then return RISCV_SLT
   else if (((p00 = (''sltu'')))) then return RISCV_SLTU
   else if (((p00 = (''and'')))) then return RISCV_AND
   else if (((p00 = (''or'')))) then return RISCV_OR
   else if (((p00 = (''xor'')))) then return RISCV_XOR
   else if (((p00 = (''sll'')))) then return RISCV_SLL
   else if (((p00 = (''srl'')))) then return RISCV_SRL
   else if (((p00 = (''sub'')))) then return RISCV_SUB
   else if (((p00 = (''sra'')))) then return RISCV_SRA
   else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))\<close> 
  for  arg1  :: " string "


fun rtype_mnemonic_forwards_matches  :: \<open> rop \<Rightarrow> bool \<close>  where 
     \<open> rtype_mnemonic_forwards_matches RISCV_ADD = ( True )\<close>
|\<open> rtype_mnemonic_forwards_matches RISCV_SLT = ( True )\<close>
|\<open> rtype_mnemonic_forwards_matches RISCV_SLTU = ( True )\<close>
|\<open> rtype_mnemonic_forwards_matches RISCV_AND = ( True )\<close>
|\<open> rtype_mnemonic_forwards_matches RISCV_OR = ( True )\<close>
|\<open> rtype_mnemonic_forwards_matches RISCV_XOR = ( True )\<close>
|\<open> rtype_mnemonic_forwards_matches RISCV_SLL = ( True )\<close>
|\<open> rtype_mnemonic_forwards_matches RISCV_SRL = ( True )\<close>
|\<open> rtype_mnemonic_forwards_matches RISCV_SUB = ( True )\<close>
|\<open> rtype_mnemonic_forwards_matches RISCV_SRA = ( True )\<close>


definition rtype_mnemonic_backwards_matches  :: \<open> string \<Rightarrow> bool \<close>  where 
     \<open> rtype_mnemonic_backwards_matches arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''add'')))) then True
   else if (((p00 = (''slt'')))) then True
   else if (((p00 = (''sltu'')))) then True
   else if (((p00 = (''and'')))) then True
   else if (((p00 = (''or'')))) then True
   else if (((p00 = (''xor'')))) then True
   else if (((p00 = (''sll'')))) then True
   else if (((p00 = (''srl'')))) then True
   else if (((p00 = (''sub'')))) then True
   else if (((p00 = (''sra'')))) then True
   else False))\<close> 
  for  arg1  :: " string "


\<comment> \<open>\<open>val _s861_ : string -> maybe string\<close>\<close>

definition s861  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s861 s8620 = (
   (let s8630 = s8620 in
   if ((string_startswith s8630 (''sra''))) then  
  (case  ((string_drop s8630 ((string_length (''sra''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s8620  :: " string "


\<comment> \<open>\<open>val _s857_ : string -> maybe string\<close>\<close>

definition s857  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s857 s8580 = (
   (let s8590 = s8580 in
   if ((string_startswith s8590 (''sub''))) then  
  (case  ((string_drop s8590 ((string_length (''sub''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s8580  :: " string "


\<comment> \<open>\<open>val _s853_ : string -> maybe string\<close>\<close>

definition s853  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s853 s8540 = (
   (let s8550 = s8540 in
   if ((string_startswith s8550 (''srl''))) then  
  (case  ((string_drop s8550 ((string_length (''srl''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s8540  :: " string "


\<comment> \<open>\<open>val _s849_ : string -> maybe string\<close>\<close>

definition s849  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s849 s8500 = (
   (let s8510 = s8500 in
   if ((string_startswith s8510 (''sll''))) then  
  (case  ((string_drop s8510 ((string_length (''sll''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s8500  :: " string "


\<comment> \<open>\<open>val _s845_ : string -> maybe string\<close>\<close>

definition s845  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s845 s8460 = (
   (let s8470 = s8460 in
   if ((string_startswith s8470 (''xor''))) then  
  (case  ((string_drop s8470 ((string_length (''xor''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s8460  :: " string "


\<comment> \<open>\<open>val _s841_ : string -> maybe string\<close>\<close>

definition s841  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s841 s8420 = (
   (let s8430 = s8420 in
   if ((string_startswith s8430 (''or''))) then  
  (case  ((string_drop s8430 ((string_length (''or''))))) of   s1 => Some s1 )
   else None))\<close> 
  for  s8420  :: " string "


\<comment> \<open>\<open>val _s837_ : string -> maybe string\<close>\<close>

definition s837  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s837 s8380 = (
   (let s8390 = s8380 in
   if ((string_startswith s8390 (''and''))) then  
  (case  ((string_drop s8390 ((string_length (''and''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s8380  :: " string "


\<comment> \<open>\<open>val _s833_ : string -> maybe string\<close>\<close>

definition s833  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s833 s8340 = (
   (let s8350 = s8340 in
   if ((string_startswith s8350 (''sltu''))) then  
  (case  ((string_drop s8350 ((string_length (''sltu''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s8340  :: " string "


\<comment> \<open>\<open>val _s829_ : string -> maybe string\<close>\<close>

definition s829  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s829 s8300 = (
   (let s8310 = s8300 in
   if ((string_startswith s8310 (''slt''))) then  
  (case  ((string_drop s8310 ((string_length (''slt''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s8300  :: " string "


\<comment> \<open>\<open>val _s825_ : string -> maybe string\<close>\<close>

definition s825  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s825 s8260 = (
   (let s8270 = s8260 in
   if ((string_startswith s8270 (''add''))) then  
  (case  ((string_drop s8270 ((string_length (''add''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s8260  :: " string "


definition rtype_mnemonic_matches_prefix  :: \<open> string \<Rightarrow>(rop*int)option \<close>  where 
     \<open> rtype_mnemonic_matches_prefix arg1 = (
   (let s8280 = arg1 in
   if ((case  ((s825 s8280)) of   Some (s1) => True | _ => False )) then  
  (case  s825 s8280 of
      (Some (s1)) =>
  Some (RISCV_ADD, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s829 s8280)) of   Some (s1) => True | _ => False )) then  
  (case  s829 s8280 of
      (Some (s1)) =>
  Some (RISCV_SLT, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s833 s8280)) of   Some (s1) => True | _ => False )) then  
  (case  s833 s8280 of
      (Some (s1)) =>
  Some (RISCV_SLTU, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s837 s8280)) of   Some (s1) => True | _ => False )) then  
  (case  s837 s8280 of
      (Some (s1)) =>
  Some (RISCV_AND, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s841 s8280)) of   Some (s1) => True | _ => False )) then  
  (case  s841 s8280 of
      (Some (s1)) =>
  Some (RISCV_OR, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s845 s8280)) of   Some (s1) => True | _ => False )) then  
  (case  s845 s8280 of
      (Some (s1)) =>
  Some (RISCV_XOR, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s849 s8280)) of   Some (s1) => True | _ => False )) then  
  (case  s849 s8280 of
      (Some (s1)) =>
  Some (RISCV_SLL, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s853 s8280)) of   Some (s1) => True | _ => False )) then  
  (case  s853 s8280 of
      (Some (s1)) =>
  Some (RISCV_SRL, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s857 s8280)) of   Some (s1) => True | _ => False )) then  
  (case  s857 s8280 of
      (Some (s1)) =>
  Some (RISCV_SUB, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s861 s8280)) of   Some (s1) => True | _ => False )) then  
  (case  s861 s8280 of
      (Some (s1)) =>
  Some (RISCV_SRA, ((string_length arg1)) - ((string_length s1)))
  )
   else None))\<close> 
  for  arg1  :: " string "


\<comment> \<open>\<open>val extend_value : forall 'int8_times_n. Size 'int8_times_n => bool -> MemoryOpResult (mword 'int8_times_n) -> MemoryOpResult (mword ty64)\<close>\<close>

fun extend_value  :: \<open> bool \<Rightarrow>(('int8_times_n::len)Word.word)MemoryOpResult \<Rightarrow>((64)Word.word)MemoryOpResult \<close>  where 
     \<open> extend_value is_unsigned (MemValue (v)) = (
      MemValue (if is_unsigned then (EXTZ (( 64 :: int)::ii) v  ::  64 Word.word)
                else (EXTS (( 64 :: int)::ii) v  ::  64 Word.word)))\<close> 
  for  is_unsigned  :: " bool " 
  and  v  :: "('int8_times_n::len)Word.word "
|\<open> extend_value is_unsigned (MemException (e)) = ( MemException e )\<close> 
  for  is_unsigned  :: " bool " 
  and  e  :: " ExceptionType "


\<comment> \<open>\<open>val process_load : forall 'int8_times_n. Size 'int8_times_n => mword ty5 -> mword ty64 -> MemoryOpResult (mword 'int8_times_n) -> bool -> M Retired\<close>\<close>

definition process_load  :: \<open>(5)Word.word \<Rightarrow>(64)Word.word \<Rightarrow>(('int8_times_n::len)Word.word)MemoryOpResult \<Rightarrow> bool \<Rightarrow>((register_value),(Retired),(exception))monad \<close>  where 
     \<open> process_load rd vaddr value1 is_unsigned = (
   (case  ((extend_value is_unsigned value1  :: ( 64 Word.word) MemoryOpResult)) of
     MemValue (result) => wX_bits rd result \<then> return RETIRE_SUCCESS
   | MemException (e) => handle_mem_exception vaddr e \<then> return RETIRE_FAIL
   ))\<close> 
  for  rd  :: "(5)Word.word " 
  and  vaddr  :: "(64)Word.word " 
  and  value1  :: "(('int8_times_n::len)Word.word)MemoryOpResult " 
  and  is_unsigned  :: " bool "


\<comment> \<open>\<open>val check_misaligned : mword ty64 -> word_width -> bool\<close>\<close>

definition check_misaligned  :: \<open>(64)Word.word \<Rightarrow> word_width \<Rightarrow> bool \<close>  where 
     \<open> check_misaligned (vaddr :: xlenbits) (width :: word_width) = (
   if ((plat_enable_misaligned_access () )) then False
   else
     (case  width of
       BYTE => False
     | HALF => (((access_vec_dec vaddr (( 0 :: int)::ii))) = B1)
     | WORD =>
        ((((((access_vec_dec vaddr (( 0 :: int)::ii))) = B1))) \<or> (((((access_vec_dec vaddr (( 1 :: int)::ii))) = B1))))
     | DOUBLE =>
        ((((((access_vec_dec vaddr (( 0 :: int)::ii))) = B1))) \<or> ((((((((access_vec_dec vaddr (( 1 :: int)::ii))) = B1))) \<or> (((((access_vec_dec vaddr (( 2 :: int)::ii))) = B1)))))))
     ))\<close> 
  for  vaddr  :: "(64)Word.word " 
  and  width  :: " word_width "


\<comment> \<open>\<open>val maybe_aq_forwards : bool -> string\<close>\<close>

\<comment> \<open>\<open>val maybe_aq_backwards : string -> M bool\<close>\<close>

\<comment> \<open>\<open>val maybe_aq_forwards_matches : bool -> bool\<close>\<close>

\<comment> \<open>\<open>val maybe_aq_backwards_matches : string -> bool\<close>\<close>

\<comment> \<open>\<open>val maybe_aq_matches_prefix : string -> maybe ((bool * ii))\<close>\<close>

fun maybe_aq_forwards  :: \<open> bool \<Rightarrow> string \<close>  where 
     \<open> maybe_aq_forwards True = ( (''.aq''))\<close>
|\<open> maybe_aq_forwards False = ( (''''))\<close>


definition maybe_aq_backwards  :: \<open> string \<Rightarrow>((register_value),(bool),(exception))monad \<close>  where 
     \<open> maybe_aq_backwards arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''.aq'')))) then return True
   else if (((p00 = ('''')))) then return False
   else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))\<close> 
  for  arg1  :: " string "


fun maybe_aq_forwards_matches  :: \<open> bool \<Rightarrow> bool \<close>  where 
     \<open> maybe_aq_forwards_matches True = ( True )\<close>
|\<open> maybe_aq_forwards_matches False = ( True )\<close>


definition maybe_aq_backwards_matches  :: \<open> string \<Rightarrow> bool \<close>  where 
     \<open> maybe_aq_backwards_matches arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''.aq'')))) then True
   else if (((p00 = ('''')))) then True
   else False))\<close> 
  for  arg1  :: " string "


\<comment> \<open>\<open>val _s869_ : string -> maybe string\<close>\<close>

definition s869  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s869 s8700 = (
   (let s8710 = s8700 in
   if ((string_startswith s8710 (''''))) then  
  (case  ((string_drop s8710 ((string_length (''''))))) of   s1 => Some s1 )
   else None))\<close> 
  for  s8700  :: " string "


\<comment> \<open>\<open>val _s865_ : string -> maybe string\<close>\<close>

definition s865  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s865 s8660 = (
   (let s8670 = s8660 in
   if ((string_startswith s8670 (''.aq''))) then  
  (case  ((string_drop s8670 ((string_length (''.aq''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s8660  :: " string "


definition maybe_aq_matches_prefix  :: \<open> string \<Rightarrow>(bool*int)option \<close>  where 
     \<open> maybe_aq_matches_prefix arg1 = (
   (let s8680 = arg1 in
   if ((case  ((s865 s8680)) of   Some (s1) => True | _ => False )) then  
  (case  s865 s8680 of
      (Some (s1)) =>
  Some (True, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s869 s8680)) of   Some (s1) => True | _ => False )) then  
  (case  s869 s8680 of
      (Some (s1)) =>
  Some (False, ((string_length arg1)) - ((string_length s1)))
  )
   else None))\<close> 
  for  arg1  :: " string "


\<comment> \<open>\<open>val maybe_rl_forwards : bool -> string\<close>\<close>

\<comment> \<open>\<open>val maybe_rl_backwards : string -> M bool\<close>\<close>

\<comment> \<open>\<open>val maybe_rl_forwards_matches : bool -> bool\<close>\<close>

\<comment> \<open>\<open>val maybe_rl_backwards_matches : string -> bool\<close>\<close>

\<comment> \<open>\<open>val maybe_rl_matches_prefix : string -> maybe ((bool * ii))\<close>\<close>

fun maybe_rl_forwards  :: \<open> bool \<Rightarrow> string \<close>  where 
     \<open> maybe_rl_forwards True = ( (''.rl''))\<close>
|\<open> maybe_rl_forwards False = ( (''''))\<close>


definition maybe_rl_backwards  :: \<open> string \<Rightarrow>((register_value),(bool),(exception))monad \<close>  where 
     \<open> maybe_rl_backwards arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''.rl'')))) then return True
   else if (((p00 = ('''')))) then return False
   else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))\<close> 
  for  arg1  :: " string "


fun maybe_rl_forwards_matches  :: \<open> bool \<Rightarrow> bool \<close>  where 
     \<open> maybe_rl_forwards_matches True = ( True )\<close>
|\<open> maybe_rl_forwards_matches False = ( True )\<close>


definition maybe_rl_backwards_matches  :: \<open> string \<Rightarrow> bool \<close>  where 
     \<open> maybe_rl_backwards_matches arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''.rl'')))) then True
   else if (((p00 = ('''')))) then True
   else False))\<close> 
  for  arg1  :: " string "


\<comment> \<open>\<open>val _s877_ : string -> maybe string\<close>\<close>

definition s877  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s877 s8780 = (
   (let s8790 = s8780 in
   if ((string_startswith s8790 (''''))) then  
  (case  ((string_drop s8790 ((string_length (''''))))) of   s1 => Some s1 )
   else None))\<close> 
  for  s8780  :: " string "


\<comment> \<open>\<open>val _s873_ : string -> maybe string\<close>\<close>

definition s873  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s873 s8740 = (
   (let s8750 = s8740 in
   if ((string_startswith s8750 (''.rl''))) then  
  (case  ((string_drop s8750 ((string_length (''.rl''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s8740  :: " string "


definition maybe_rl_matches_prefix  :: \<open> string \<Rightarrow>(bool*int)option \<close>  where 
     \<open> maybe_rl_matches_prefix arg1 = (
   (let s8760 = arg1 in
   if ((case  ((s873 s8760)) of   Some (s1) => True | _ => False )) then  
  (case  s873 s8760 of
      (Some (s1)) =>
  Some (True, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s877 s8760)) of   Some (s1) => True | _ => False )) then  
  (case  s877 s8760 of
      (Some (s1)) =>
  Some (False, ((string_length arg1)) - ((string_length s1)))
  )
   else None))\<close> 
  for  arg1  :: " string "


\<comment> \<open>\<open>val maybe_u_forwards : bool -> string\<close>\<close>

\<comment> \<open>\<open>val maybe_u_backwards : string -> M bool\<close>\<close>

\<comment> \<open>\<open>val maybe_u_forwards_matches : bool -> bool\<close>\<close>

\<comment> \<open>\<open>val maybe_u_backwards_matches : string -> bool\<close>\<close>

\<comment> \<open>\<open>val maybe_u_matches_prefix : string -> maybe ((bool * ii))\<close>\<close>

fun maybe_u_forwards  :: \<open> bool \<Rightarrow> string \<close>  where 
     \<open> maybe_u_forwards True = ( (''u''))\<close>
|\<open> maybe_u_forwards False = ( (''''))\<close>


definition maybe_u_backwards  :: \<open> string \<Rightarrow>((register_value),(bool),(exception))monad \<close>  where 
     \<open> maybe_u_backwards arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''u'')))) then return True
   else if (((p00 = ('''')))) then return False
   else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))\<close> 
  for  arg1  :: " string "


fun maybe_u_forwards_matches  :: \<open> bool \<Rightarrow> bool \<close>  where 
     \<open> maybe_u_forwards_matches True = ( True )\<close>
|\<open> maybe_u_forwards_matches False = ( True )\<close>


definition maybe_u_backwards_matches  :: \<open> string \<Rightarrow> bool \<close>  where 
     \<open> maybe_u_backwards_matches arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''u'')))) then True
   else if (((p00 = ('''')))) then True
   else False))\<close> 
  for  arg1  :: " string "


\<comment> \<open>\<open>val _s885_ : string -> maybe string\<close>\<close>

definition s885  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s885 s8860 = (
   (let s8870 = s8860 in
   if ((string_startswith s8870 (''''))) then  
  (case  ((string_drop s8870 ((string_length (''''))))) of   s1 => Some s1 )
   else None))\<close> 
  for  s8860  :: " string "


\<comment> \<open>\<open>val _s881_ : string -> maybe string\<close>\<close>

definition s881  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s881 s8820 = (
   (let s8830 = s8820 in
   if ((string_startswith s8830 (''u''))) then  
  (case  ((string_drop s8830 ((string_length (''u''))))) of   s1 => Some s1 )
   else None))\<close> 
  for  s8820  :: " string "


definition maybe_u_matches_prefix  :: \<open> string \<Rightarrow>(bool*int)option \<close>  where 
     \<open> maybe_u_matches_prefix arg1 = (
   (let s8840 = arg1 in
   if ((case  ((s881 s8840)) of   Some (s1) => True | _ => False )) then  
  (case  s881 s8840 of
      (Some (s1)) =>
  Some (True, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s885 s8840)) of   Some (s1) => True | _ => False )) then  
  (case  s885 s8840 of
      (Some (s1)) =>
  Some (False, ((string_length arg1)) - ((string_length s1)))
  )
   else None))\<close> 
  for  arg1  :: " string "


\<comment> \<open>\<open>val shiftw_mnemonic_forwards : sop -> string\<close>\<close>

\<comment> \<open>\<open>val shiftw_mnemonic_backwards : string -> M sop\<close>\<close>

\<comment> \<open>\<open>val shiftw_mnemonic_forwards_matches : sop -> bool\<close>\<close>

\<comment> \<open>\<open>val shiftw_mnemonic_backwards_matches : string -> bool\<close>\<close>

\<comment> \<open>\<open>val shiftw_mnemonic_matches_prefix : string -> maybe ((sop * ii))\<close>\<close>

fun shiftw_mnemonic_forwards  :: \<open> sop \<Rightarrow> string \<close>  where 
     \<open> shiftw_mnemonic_forwards RISCV_SLLI = ( (''slli''))\<close>
|\<open> shiftw_mnemonic_forwards RISCV_SRLI = ( (''srli''))\<close>
|\<open> shiftw_mnemonic_forwards RISCV_SRAI = ( (''srai''))\<close>


definition shiftw_mnemonic_backwards  :: \<open> string \<Rightarrow>((register_value),(sop),(exception))monad \<close>  where 
     \<open> shiftw_mnemonic_backwards arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''slli'')))) then return RISCV_SLLI
   else if (((p00 = (''srli'')))) then return RISCV_SRLI
   else if (((p00 = (''srai'')))) then return RISCV_SRAI
   else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))\<close> 
  for  arg1  :: " string "


fun shiftw_mnemonic_forwards_matches  :: \<open> sop \<Rightarrow> bool \<close>  where 
     \<open> shiftw_mnemonic_forwards_matches RISCV_SLLI = ( True )\<close>
|\<open> shiftw_mnemonic_forwards_matches RISCV_SRLI = ( True )\<close>
|\<open> shiftw_mnemonic_forwards_matches RISCV_SRAI = ( True )\<close>


definition shiftw_mnemonic_backwards_matches  :: \<open> string \<Rightarrow> bool \<close>  where 
     \<open> shiftw_mnemonic_backwards_matches arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''slli'')))) then True
   else if (((p00 = (''srli'')))) then True
   else if (((p00 = (''srai'')))) then True
   else False))\<close> 
  for  arg1  :: " string "


\<comment> \<open>\<open>val _s897_ : string -> maybe string\<close>\<close>

definition s897  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s897 s8980 = (
   (let s8990 = s8980 in
   if ((string_startswith s8990 (''srai''))) then  
  (case  ((string_drop s8990 ((string_length (''srai''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s8980  :: " string "


\<comment> \<open>\<open>val _s893_ : string -> maybe string\<close>\<close>

definition s893  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s893 s8940 = (
   (let s8950 = s8940 in
   if ((string_startswith s8950 (''srli''))) then  
  (case  ((string_drop s8950 ((string_length (''srli''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s8940  :: " string "


\<comment> \<open>\<open>val _s889_ : string -> maybe string\<close>\<close>

definition s889  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s889 s8900 = (
   (let s8910 = s8900 in
   if ((string_startswith s8910 (''slli''))) then  
  (case  ((string_drop s8910 ((string_length (''slli''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s8900  :: " string "


definition shiftw_mnemonic_matches_prefix  :: \<open> string \<Rightarrow>(sop*int)option \<close>  where 
     \<open> shiftw_mnemonic_matches_prefix arg1 = (
   (let s8920 = arg1 in
   if ((case  ((s889 s8920)) of   Some (s1) => True | _ => False )) then  
  (case  s889 s8920 of
      (Some (s1)) =>
  Some (RISCV_SLLI, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s893 s8920)) of   Some (s1) => True | _ => False )) then  
  (case  s893 s8920 of
      (Some (s1)) =>
  Some (RISCV_SRLI, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s897 s8920)) of   Some (s1) => True | _ => False )) then  
  (case  s897 s8920 of
      (Some (s1)) =>
  Some (RISCV_SRAI, ((string_length arg1)) - ((string_length s1)))
  )
   else None))\<close> 
  for  arg1  :: " string "


\<comment> \<open>\<open>val rtypew_mnemonic_forwards : ropw -> string\<close>\<close>

\<comment> \<open>\<open>val rtypew_mnemonic_backwards : string -> M ropw\<close>\<close>

\<comment> \<open>\<open>val rtypew_mnemonic_forwards_matches : ropw -> bool\<close>\<close>

\<comment> \<open>\<open>val rtypew_mnemonic_backwards_matches : string -> bool\<close>\<close>

\<comment> \<open>\<open>val rtypew_mnemonic_matches_prefix : string -> maybe ((ropw * ii))\<close>\<close>

fun rtypew_mnemonic_forwards  :: \<open> ropw \<Rightarrow> string \<close>  where 
     \<open> rtypew_mnemonic_forwards RISCV_ADDW = ( (''addw''))\<close>
|\<open> rtypew_mnemonic_forwards RISCV_SUBW = ( (''subw''))\<close>
|\<open> rtypew_mnemonic_forwards RISCV_SLLW = ( (''sllw''))\<close>
|\<open> rtypew_mnemonic_forwards RISCV_SRLW = ( (''srlw''))\<close>
|\<open> rtypew_mnemonic_forwards RISCV_SRAW = ( (''sraw''))\<close>


definition rtypew_mnemonic_backwards  :: \<open> string \<Rightarrow>((register_value),(ropw),(exception))monad \<close>  where 
     \<open> rtypew_mnemonic_backwards arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''addw'')))) then return RISCV_ADDW
   else if (((p00 = (''subw'')))) then return RISCV_SUBW
   else if (((p00 = (''sllw'')))) then return RISCV_SLLW
   else if (((p00 = (''srlw'')))) then return RISCV_SRLW
   else if (((p00 = (''sraw'')))) then return RISCV_SRAW
   else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))\<close> 
  for  arg1  :: " string "


fun rtypew_mnemonic_forwards_matches  :: \<open> ropw \<Rightarrow> bool \<close>  where 
     \<open> rtypew_mnemonic_forwards_matches RISCV_ADDW = ( True )\<close>
|\<open> rtypew_mnemonic_forwards_matches RISCV_SUBW = ( True )\<close>
|\<open> rtypew_mnemonic_forwards_matches RISCV_SLLW = ( True )\<close>
|\<open> rtypew_mnemonic_forwards_matches RISCV_SRLW = ( True )\<close>
|\<open> rtypew_mnemonic_forwards_matches RISCV_SRAW = ( True )\<close>


definition rtypew_mnemonic_backwards_matches  :: \<open> string \<Rightarrow> bool \<close>  where 
     \<open> rtypew_mnemonic_backwards_matches arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''addw'')))) then True
   else if (((p00 = (''subw'')))) then True
   else if (((p00 = (''sllw'')))) then True
   else if (((p00 = (''srlw'')))) then True
   else if (((p00 = (''sraw'')))) then True
   else False))\<close> 
  for  arg1  :: " string "


\<comment> \<open>\<open>val _s917_ : string -> maybe string\<close>\<close>

definition s917  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s917 s9180 = (
   (let s9190 = s9180 in
   if ((string_startswith s9190 (''sraw''))) then  
  (case  ((string_drop s9190 ((string_length (''sraw''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s9180  :: " string "


\<comment> \<open>\<open>val _s913_ : string -> maybe string\<close>\<close>

definition s913  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s913 s9140 = (
   (let s9150 = s9140 in
   if ((string_startswith s9150 (''srlw''))) then  
  (case  ((string_drop s9150 ((string_length (''srlw''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s9140  :: " string "


\<comment> \<open>\<open>val _s909_ : string -> maybe string\<close>\<close>

definition s909  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s909 s9100 = (
   (let s9110 = s9100 in
   if ((string_startswith s9110 (''sllw''))) then  
  (case  ((string_drop s9110 ((string_length (''sllw''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s9100  :: " string "


\<comment> \<open>\<open>val _s905_ : string -> maybe string\<close>\<close>

definition s905  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s905 s9060 = (
   (let s9070 = s9060 in
   if ((string_startswith s9070 (''subw''))) then  
  (case  ((string_drop s9070 ((string_length (''subw''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s9060  :: " string "


\<comment> \<open>\<open>val _s901_ : string -> maybe string\<close>\<close>

definition s901  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s901 s9020 = (
   (let s9030 = s9020 in
   if ((string_startswith s9030 (''addw''))) then  
  (case  ((string_drop s9030 ((string_length (''addw''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s9020  :: " string "


definition rtypew_mnemonic_matches_prefix  :: \<open> string \<Rightarrow>(ropw*int)option \<close>  where 
     \<open> rtypew_mnemonic_matches_prefix arg1 = (
   (let s9040 = arg1 in
   if ((case  ((s901 s9040)) of   Some (s1) => True | _ => False )) then  
  (case  s901 s9040 of
      (Some (s1)) =>
  Some (RISCV_ADDW, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s905 s9040)) of   Some (s1) => True | _ => False )) then  
  (case  s905 s9040 of
      (Some (s1)) =>
  Some (RISCV_SUBW, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s909 s9040)) of   Some (s1) => True | _ => False )) then  
  (case  s909 s9040 of
      (Some (s1)) =>
  Some (RISCV_SLLW, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s913 s9040)) of   Some (s1) => True | _ => False )) then  
  (case  s913 s9040 of
      (Some (s1)) =>
  Some (RISCV_SRLW, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s917 s9040)) of   Some (s1) => True | _ => False )) then  
  (case  s917 s9040 of
      (Some (s1)) =>
  Some (RISCV_SRAW, ((string_length arg1)) - ((string_length s1)))
  )
   else None))\<close> 
  for  arg1  :: " string "


\<comment> \<open>\<open>val shiftiwop_mnemonic_forwards : sopw -> string\<close>\<close>

\<comment> \<open>\<open>val shiftiwop_mnemonic_backwards : string -> M sopw\<close>\<close>

\<comment> \<open>\<open>val shiftiwop_mnemonic_forwards_matches : sopw -> bool\<close>\<close>

\<comment> \<open>\<open>val shiftiwop_mnemonic_backwards_matches : string -> bool\<close>\<close>

\<comment> \<open>\<open>val shiftiwop_mnemonic_matches_prefix : string -> maybe ((sopw * ii))\<close>\<close>

fun shiftiwop_mnemonic_forwards  :: \<open> sopw \<Rightarrow> string \<close>  where 
     \<open> shiftiwop_mnemonic_forwards RISCV_SLLIW = ( (''slliw''))\<close>
|\<open> shiftiwop_mnemonic_forwards RISCV_SRLIW = ( (''srliw''))\<close>
|\<open> shiftiwop_mnemonic_forwards RISCV_SRAIW = ( (''sraiw''))\<close>


definition shiftiwop_mnemonic_backwards  :: \<open> string \<Rightarrow>((register_value),(sopw),(exception))monad \<close>  where 
     \<open> shiftiwop_mnemonic_backwards arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''slliw'')))) then return RISCV_SLLIW
   else if (((p00 = (''srliw'')))) then return RISCV_SRLIW
   else if (((p00 = (''sraiw'')))) then return RISCV_SRAIW
   else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))\<close> 
  for  arg1  :: " string "


fun shiftiwop_mnemonic_forwards_matches  :: \<open> sopw \<Rightarrow> bool \<close>  where 
     \<open> shiftiwop_mnemonic_forwards_matches RISCV_SLLIW = ( True )\<close>
|\<open> shiftiwop_mnemonic_forwards_matches RISCV_SRLIW = ( True )\<close>
|\<open> shiftiwop_mnemonic_forwards_matches RISCV_SRAIW = ( True )\<close>


definition shiftiwop_mnemonic_backwards_matches  :: \<open> string \<Rightarrow> bool \<close>  where 
     \<open> shiftiwop_mnemonic_backwards_matches arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''slliw'')))) then True
   else if (((p00 = (''srliw'')))) then True
   else if (((p00 = (''sraiw'')))) then True
   else False))\<close> 
  for  arg1  :: " string "


\<comment> \<open>\<open>val _s929_ : string -> maybe string\<close>\<close>

definition s929  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s929 s9300 = (
   (let s9310 = s9300 in
   if ((string_startswith s9310 (''sraiw''))) then  
  (case  ((string_drop s9310 ((string_length (''sraiw''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s9300  :: " string "


\<comment> \<open>\<open>val _s925_ : string -> maybe string\<close>\<close>

definition s925  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s925 s9260 = (
   (let s9270 = s9260 in
   if ((string_startswith s9270 (''srliw''))) then  
  (case  ((string_drop s9270 ((string_length (''srliw''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s9260  :: " string "


\<comment> \<open>\<open>val _s921_ : string -> maybe string\<close>\<close>

definition s921  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s921 s9220 = (
   (let s9230 = s9220 in
   if ((string_startswith s9230 (''slliw''))) then  
  (case  ((string_drop s9230 ((string_length (''slliw''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s9220  :: " string "


definition shiftiwop_mnemonic_matches_prefix  :: \<open> string \<Rightarrow>(sopw*int)option \<close>  where 
     \<open> shiftiwop_mnemonic_matches_prefix arg1 = (
   (let s9240 = arg1 in
   if ((case  ((s921 s9240)) of   Some (s1) => True | _ => False )) then  
  (case  s921 s9240 of
      (Some (s1)) =>
  Some (RISCV_SLLIW, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s925 s9240)) of   Some (s1) => True | _ => False )) then  
  (case  s925 s9240 of
      (Some (s1)) =>
  Some (RISCV_SRLIW, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s929 s9240)) of   Some (s1) => True | _ => False )) then  
  (case  s929 s9240 of
      (Some (s1)) =>
  Some (RISCV_SRAIW, ((string_length arg1)) - ((string_length s1)))
  )
   else None))\<close> 
  for  arg1  :: " string "


\<comment> \<open>\<open>val bit_maybe_r_forwards : mword ty1 -> M string\<close>\<close>

\<comment> \<open>\<open>val bit_maybe_r_backwards : string -> M (mword ty1)\<close>\<close>

\<comment> \<open>\<open>val bit_maybe_r_forwards_matches : mword ty1 -> bool\<close>\<close>

\<comment> \<open>\<open>val bit_maybe_r_backwards_matches : string -> bool\<close>\<close>

\<comment> \<open>\<open>val bit_maybe_r_matches_prefix : string -> maybe ((mword ty1 * ii))\<close>\<close>

definition bit_maybe_r_forwards  :: \<open>(1)Word.word \<Rightarrow>((register_value),(string),(exception))monad \<close>  where 
     \<open> bit_maybe_r_forwards arg1 = (
   (let b__0 = arg1 in
   if (((b__0 = ( 0b1 ::  1 Word.word)))) then return (''r'')
   else if (((b__0 = ( 0b0 ::  1 Word.word)))) then return ('''')
   else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))\<close> 
  for  arg1  :: "(1)Word.word "


definition bit_maybe_r_backwards  :: \<open> string \<Rightarrow>((register_value),((1)Word.word),(exception))monad \<close>  where 
     \<open> bit_maybe_r_backwards arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''r'')))) then return ( 0b1 ::  1 Word.word)
   else if (((p00 = ('''')))) then return ( 0b0 ::  1 Word.word)
   else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))\<close> 
  for  arg1  :: " string "


definition bit_maybe_r_forwards_matches  :: \<open>(1)Word.word \<Rightarrow> bool \<close>  where 
     \<open> bit_maybe_r_forwards_matches arg1 = (
   (let b__0 = arg1 in
   if (((b__0 = ( 0b1 ::  1 Word.word)))) then True
   else if (((b__0 = ( 0b0 ::  1 Word.word)))) then True
   else False))\<close> 
  for  arg1  :: "(1)Word.word "


definition bit_maybe_r_backwards_matches  :: \<open> string \<Rightarrow> bool \<close>  where 
     \<open> bit_maybe_r_backwards_matches arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''r'')))) then True
   else if (((p00 = ('''')))) then True
   else False))\<close> 
  for  arg1  :: " string "


\<comment> \<open>\<open>val _s937_ : string -> maybe string\<close>\<close>

definition s937  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s937 s9380 = (
   (let s9390 = s9380 in
   if ((string_startswith s9390 (''''))) then  
  (case  ((string_drop s9390 ((string_length (''''))))) of   s1 => Some s1 )
   else None))\<close> 
  for  s9380  :: " string "


\<comment> \<open>\<open>val _s933_ : string -> maybe string\<close>\<close>

definition s933  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s933 s9340 = (
   (let s9350 = s9340 in
   if ((string_startswith s9350 (''r''))) then  
  (case  ((string_drop s9350 ((string_length (''r''))))) of   s1 => Some s1 )
   else None))\<close> 
  for  s9340  :: " string "


definition bit_maybe_r_matches_prefix  :: \<open> string \<Rightarrow>((1)Word.word*int)option \<close>  where 
     \<open> bit_maybe_r_matches_prefix arg1 = (
   (let s9360 = arg1 in
   if ((case  ((s933 s9360)) of   Some (s1) => True | _ => False )) then  
  (case  s933 s9360 of
      (Some (s1)) =>
  Some (( 0b1 :: 1 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s937 s9360)) of   Some (s1) => True | _ => False )) then  
  (case  s937 s9360 of
      (Some (s1)) =>
  Some (( 0b0 :: 1 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else None))\<close> 
  for  arg1  :: " string "


\<comment> \<open>\<open>val bit_maybe_w_forwards : mword ty1 -> M string\<close>\<close>

\<comment> \<open>\<open>val bit_maybe_w_backwards : string -> M (mword ty1)\<close>\<close>

\<comment> \<open>\<open>val bit_maybe_w_forwards_matches : mword ty1 -> bool\<close>\<close>

\<comment> \<open>\<open>val bit_maybe_w_backwards_matches : string -> bool\<close>\<close>

\<comment> \<open>\<open>val bit_maybe_w_matches_prefix : string -> maybe ((mword ty1 * ii))\<close>\<close>

definition bit_maybe_w_forwards  :: \<open>(1)Word.word \<Rightarrow>((register_value),(string),(exception))monad \<close>  where 
     \<open> bit_maybe_w_forwards arg1 = (
   (let b__0 = arg1 in
   if (((b__0 = ( 0b1 ::  1 Word.word)))) then return (''w'')
   else if (((b__0 = ( 0b0 ::  1 Word.word)))) then return ('''')
   else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))\<close> 
  for  arg1  :: "(1)Word.word "


definition bit_maybe_w_backwards  :: \<open> string \<Rightarrow>((register_value),((1)Word.word),(exception))monad \<close>  where 
     \<open> bit_maybe_w_backwards arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''w'')))) then return ( 0b1 ::  1 Word.word)
   else if (((p00 = ('''')))) then return ( 0b0 ::  1 Word.word)
   else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))\<close> 
  for  arg1  :: " string "


definition bit_maybe_w_forwards_matches  :: \<open>(1)Word.word \<Rightarrow> bool \<close>  where 
     \<open> bit_maybe_w_forwards_matches arg1 = (
   (let b__0 = arg1 in
   if (((b__0 = ( 0b1 ::  1 Word.word)))) then True
   else if (((b__0 = ( 0b0 ::  1 Word.word)))) then True
   else False))\<close> 
  for  arg1  :: "(1)Word.word "


definition bit_maybe_w_backwards_matches  :: \<open> string \<Rightarrow> bool \<close>  where 
     \<open> bit_maybe_w_backwards_matches arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''w'')))) then True
   else if (((p00 = ('''')))) then True
   else False))\<close> 
  for  arg1  :: " string "


\<comment> \<open>\<open>val _s945_ : string -> maybe string\<close>\<close>

definition s945  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s945 s9460 = (
   (let s9470 = s9460 in
   if ((string_startswith s9470 (''''))) then  
  (case  ((string_drop s9470 ((string_length (''''))))) of   s1 => Some s1 )
   else None))\<close> 
  for  s9460  :: " string "


\<comment> \<open>\<open>val _s941_ : string -> maybe string\<close>\<close>

definition s941  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s941 s9420 = (
   (let s9430 = s9420 in
   if ((string_startswith s9430 (''w''))) then  
  (case  ((string_drop s9430 ((string_length (''w''))))) of   s1 => Some s1 )
   else None))\<close> 
  for  s9420  :: " string "


definition bit_maybe_w_matches_prefix  :: \<open> string \<Rightarrow>((1)Word.word*int)option \<close>  where 
     \<open> bit_maybe_w_matches_prefix arg1 = (
   (let s9440 = arg1 in
   if ((case  ((s941 s9440)) of   Some (s1) => True | _ => False )) then  
  (case  s941 s9440 of
      (Some (s1)) =>
  Some (( 0b1 :: 1 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s945 s9440)) of   Some (s1) => True | _ => False )) then  
  (case  s945 s9440 of
      (Some (s1)) =>
  Some (( 0b0 :: 1 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else None))\<close> 
  for  arg1  :: " string "


\<comment> \<open>\<open>val bit_maybe_i_forwards : mword ty1 -> M string\<close>\<close>

\<comment> \<open>\<open>val bit_maybe_i_backwards : string -> M (mword ty1)\<close>\<close>

\<comment> \<open>\<open>val bit_maybe_i_forwards_matches : mword ty1 -> bool\<close>\<close>

\<comment> \<open>\<open>val bit_maybe_i_backwards_matches : string -> bool\<close>\<close>

\<comment> \<open>\<open>val bit_maybe_i_matches_prefix : string -> maybe ((mword ty1 * ii))\<close>\<close>

definition bit_maybe_i_forwards  :: \<open>(1)Word.word \<Rightarrow>((register_value),(string),(exception))monad \<close>  where 
     \<open> bit_maybe_i_forwards arg1 = (
   (let b__0 = arg1 in
   if (((b__0 = ( 0b1 ::  1 Word.word)))) then return (''i'')
   else if (((b__0 = ( 0b0 ::  1 Word.word)))) then return ('''')
   else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))\<close> 
  for  arg1  :: "(1)Word.word "


definition bit_maybe_i_backwards  :: \<open> string \<Rightarrow>((register_value),((1)Word.word),(exception))monad \<close>  where 
     \<open> bit_maybe_i_backwards arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''i'')))) then return ( 0b1 ::  1 Word.word)
   else if (((p00 = ('''')))) then return ( 0b0 ::  1 Word.word)
   else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))\<close> 
  for  arg1  :: " string "


definition bit_maybe_i_forwards_matches  :: \<open>(1)Word.word \<Rightarrow> bool \<close>  where 
     \<open> bit_maybe_i_forwards_matches arg1 = (
   (let b__0 = arg1 in
   if (((b__0 = ( 0b1 ::  1 Word.word)))) then True
   else if (((b__0 = ( 0b0 ::  1 Word.word)))) then True
   else False))\<close> 
  for  arg1  :: "(1)Word.word "


definition bit_maybe_i_backwards_matches  :: \<open> string \<Rightarrow> bool \<close>  where 
     \<open> bit_maybe_i_backwards_matches arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''i'')))) then True
   else if (((p00 = ('''')))) then True
   else False))\<close> 
  for  arg1  :: " string "


\<comment> \<open>\<open>val _s953_ : string -> maybe string\<close>\<close>

definition s953  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s953 s9540 = (
   (let s9550 = s9540 in
   if ((string_startswith s9550 (''''))) then  
  (case  ((string_drop s9550 ((string_length (''''))))) of   s1 => Some s1 )
   else None))\<close> 
  for  s9540  :: " string "


\<comment> \<open>\<open>val _s949_ : string -> maybe string\<close>\<close>

definition s949  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s949 s9500 = (
   (let s9510 = s9500 in
   if ((string_startswith s9510 (''i''))) then  
  (case  ((string_drop s9510 ((string_length (''i''))))) of   s1 => Some s1 )
   else None))\<close> 
  for  s9500  :: " string "


definition bit_maybe_i_matches_prefix  :: \<open> string \<Rightarrow>((1)Word.word*int)option \<close>  where 
     \<open> bit_maybe_i_matches_prefix arg1 = (
   (let s9520 = arg1 in
   if ((case  ((s949 s9520)) of   Some (s1) => True | _ => False )) then  
  (case  s949 s9520 of
      (Some (s1)) =>
  Some (( 0b1 :: 1 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s953 s9520)) of   Some (s1) => True | _ => False )) then  
  (case  s953 s9520 of
      (Some (s1)) =>
  Some (( 0b0 :: 1 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else None))\<close> 
  for  arg1  :: " string "


\<comment> \<open>\<open>val bit_maybe_o_forwards : mword ty1 -> M string\<close>\<close>

\<comment> \<open>\<open>val bit_maybe_o_backwards : string -> M (mword ty1)\<close>\<close>

\<comment> \<open>\<open>val bit_maybe_o_forwards_matches : mword ty1 -> bool\<close>\<close>

\<comment> \<open>\<open>val bit_maybe_o_backwards_matches : string -> bool\<close>\<close>

\<comment> \<open>\<open>val bit_maybe_o_matches_prefix : string -> maybe ((mword ty1 * ii))\<close>\<close>

definition bit_maybe_o_forwards  :: \<open>(1)Word.word \<Rightarrow>((register_value),(string),(exception))monad \<close>  where 
     \<open> bit_maybe_o_forwards arg1 = (
   (let b__0 = arg1 in
   if (((b__0 = ( 0b1 ::  1 Word.word)))) then return (''o'')
   else if (((b__0 = ( 0b0 ::  1 Word.word)))) then return ('''')
   else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))\<close> 
  for  arg1  :: "(1)Word.word "


definition bit_maybe_o_backwards  :: \<open> string \<Rightarrow>((register_value),((1)Word.word),(exception))monad \<close>  where 
     \<open> bit_maybe_o_backwards arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''o'')))) then return ( 0b1 ::  1 Word.word)
   else if (((p00 = ('''')))) then return ( 0b0 ::  1 Word.word)
   else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))\<close> 
  for  arg1  :: " string "


definition bit_maybe_o_forwards_matches  :: \<open>(1)Word.word \<Rightarrow> bool \<close>  where 
     \<open> bit_maybe_o_forwards_matches arg1 = (
   (let b__0 = arg1 in
   if (((b__0 = ( 0b1 ::  1 Word.word)))) then True
   else if (((b__0 = ( 0b0 ::  1 Word.word)))) then True
   else False))\<close> 
  for  arg1  :: "(1)Word.word "


definition bit_maybe_o_backwards_matches  :: \<open> string \<Rightarrow> bool \<close>  where 
     \<open> bit_maybe_o_backwards_matches arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''o'')))) then True
   else if (((p00 = ('''')))) then True
   else False))\<close> 
  for  arg1  :: " string "


\<comment> \<open>\<open>val _s961_ : string -> maybe string\<close>\<close>

definition s961  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s961 s9620 = (
   (let s9630 = s9620 in
   if ((string_startswith s9630 (''''))) then  
  (case  ((string_drop s9630 ((string_length (''''))))) of   s1 => Some s1 )
   else None))\<close> 
  for  s9620  :: " string "


\<comment> \<open>\<open>val _s957_ : string -> maybe string\<close>\<close>

definition s957  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s957 s9580 = (
   (let s9590 = s9580 in
   if ((string_startswith s9590 (''o''))) then  
  (case  ((string_drop s9590 ((string_length (''o''))))) of   s1 => Some s1 )
   else None))\<close> 
  for  s9580  :: " string "


definition bit_maybe_o_matches_prefix  :: \<open> string \<Rightarrow>((1)Word.word*int)option \<close>  where 
     \<open> bit_maybe_o_matches_prefix arg1 = (
   (let s9600 = arg1 in
   if ((case  ((s957 s9600)) of   Some (s1) => True | _ => False )) then  
  (case  s957 s9600 of
      (Some (s1)) =>
  Some (( 0b1 :: 1 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s961 s9600)) of   Some (s1) => True | _ => False )) then  
  (case  s961 s9600 of
      (Some (s1)) =>
  Some (( 0b0 :: 1 Word.word), ((string_length arg1)) - ((string_length s1)))
  )
   else None))\<close> 
  for  arg1  :: " string "


\<comment> \<open>\<open>val fence_bits_forwards : mword ty4 -> M string\<close>\<close>

\<comment> \<open>\<open>val fence_bits_backwards : string -> M (mword ty4)\<close>\<close>

\<comment> \<open>\<open>val fence_bits_forwards_matches : mword ty4 -> bool\<close>\<close>

\<comment> \<open>\<open>val fence_bits_backwards_matches : string -> bool\<close>\<close>

\<comment> \<open>\<open>val fence_bits_matches_prefix : string -> maybe ((mword ty4 * ii))\<close>\<close>

definition fence_bits_forwards  :: \<open>(4)Word.word \<Rightarrow>((register_value),(string),(exception))monad \<close>  where 
     \<open> fence_bits_forwards v__0 = (
      (let (i :: 1 bits) = ((subrange_vec_dec v__0 (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word)) in
      (let (w :: 1 bits) = ((subrange_vec_dec v__0 (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) in
      (let (r :: 1 bits) = ((subrange_vec_dec v__0 (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word)) in
      (let (o1 :: 1 bits) = ((subrange_vec_dec v__0 (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word)) in
      (let (i :: 1 bits) = ((subrange_vec_dec v__0 (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word)) in
      bit_maybe_i_forwards i \<bind> ((\<lambda> (w__0 :: string) . 
      bit_maybe_o_forwards o1 \<bind> ((\<lambda> (w__1 :: string) . 
      bit_maybe_r_forwards r \<bind> ((\<lambda> (w__2 :: string) . 
      bit_maybe_w_forwards w \<bind> ((\<lambda> (w__3 :: string) . 
      return ((string_append w__0
                 ((string_append w__1 ((string_append w__2 ((string_append w__3 ('''')))))))))))))))))))))))\<close> 
  for  v__0  :: "(4)Word.word "


\<comment> \<open>\<open>val _s965_ : string -> maybe ((mword ty1 * mword ty1 * mword ty1 * mword ty1))\<close>\<close>

definition s965  :: \<open> string \<Rightarrow>((1)Word.word*(1)Word.word*(1)Word.word*(1)Word.word)option \<close>  where 
     \<open> s965 s9670 = (
      (case  ((bit_maybe_i_matches_prefix s9670  ::  (( 1 Word.word * ii))option)) of
        Some ((i, s9680)) => 
  (case  ((string_drop s9670 s9680)) of
        s9690 =>
  (case  ((bit_maybe_o_matches_prefix s9690 :: (( 1 Word.word * ii)) option)) of
        Some ((o1, s9700)) =>
  (case  ((string_drop s9690 s9700)) of
        s9710 =>
  (case  ((bit_maybe_r_matches_prefix s9710 :: (( 1 Word.word * ii)) option)) of
        Some ((r, s9720)) =>
  (case  ((string_drop s9710 s9720)) of
        s9730 =>
  (case  ((bit_maybe_w_matches_prefix s9730 :: (( 1 Word.word * ii)) option)) of
        Some ((w, s9740)) =>
  (let p00 = (string_drop s9730 s9740) in
  if (((p00 = ('''')))) then Some (i, o1, r, w) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s9670  :: " string "


definition fence_bits_backwards  :: \<open> string \<Rightarrow>((register_value),((4)Word.word),(exception))monad \<close>  where 
     \<open> fence_bits_backwards arg1 = (
   (let s9750 = arg1 in
   if ((case  ((s965 s9750  ::  (( 1 Word.word *  1 Word.word *  1 Word.word *  1 Word.word))option)) of
       Some ((i, o1, r, w)) => True
     | _ => False
     )) then  (case 
 (s965 s9750 :: (( 1 Word.word * 1 Word.word * 1 Word.word * 1 Word.word)) option) of
     (Some ((i, o1, r, w))) =>
 return
   ((concat_vec i
       ((concat_vec o1 ((concat_vec r w :: 2 Word.word)) :: 3 Word.word))
    :: 4 Word.word))
 )
   else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))\<close> 
  for  arg1  :: " string "


definition fence_bits_forwards_matches  :: \<open>(4)Word.word \<Rightarrow> bool \<close>  where 
     \<open> fence_bits_forwards_matches v__1 = ( True )\<close> 
  for  v__1  :: "(4)Word.word "


\<comment> \<open>\<open>val _s976_ : string -> maybe ((mword ty1 * mword ty1 * mword ty1 * mword ty1))\<close>\<close>

definition s976  :: \<open> string \<Rightarrow>((1)Word.word*(1)Word.word*(1)Word.word*(1)Word.word)option \<close>  where 
     \<open> s976 s9780 = (
      (case  ((bit_maybe_i_matches_prefix s9780  ::  (( 1 Word.word * ii))option)) of
        Some ((i, s9790)) => 
  (case  ((string_drop s9780 s9790)) of
        s9800 =>
  (case  ((bit_maybe_o_matches_prefix s9800 :: (( 1 Word.word * ii)) option)) of
        Some ((o1, s9810)) =>
  (case  ((string_drop s9800 s9810)) of
        s9820 =>
  (case  ((bit_maybe_r_matches_prefix s9820 :: (( 1 Word.word * ii)) option)) of
        Some ((r, s9830)) =>
  (case  ((string_drop s9820 s9830)) of
        s9840 =>
  (case  ((bit_maybe_w_matches_prefix s9840 :: (( 1 Word.word * ii)) option)) of
        Some ((w, s9850)) =>
  (let p00 = (string_drop s9840 s9850) in
  if (((p00 = ('''')))) then Some (i, o1, r, w) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s9780  :: " string "


definition fence_bits_backwards_matches  :: \<open> string \<Rightarrow> bool \<close>  where 
     \<open> fence_bits_backwards_matches arg1 = (
   (let s9860 = arg1 in
   if ((case  ((s976 s9860  ::  (( 1 Word.word *  1 Word.word *  1 Word.word *  1 Word.word))option)) of
       Some ((i, o1, r, w)) => True
     | _ => False
     )) then  (case 
 (s976 s9860 :: (( 1 Word.word * 1 Word.word * 1 Word.word * 1 Word.word)) option) of
     (Some ((i, o1, r, w))) =>
 True
 )
   else False))\<close> 
  for  arg1  :: " string "


\<comment> \<open>\<open>val _s987_ : string -> maybe ((mword ty1 * mword ty1 * mword ty1 * mword ty1 * string))\<close>\<close>

definition s987  :: \<open> string \<Rightarrow>((1)Word.word*(1)Word.word*(1)Word.word*(1)Word.word*string)option \<close>  where 
     \<open> s987 s9890 = (
      (case  ((bit_maybe_i_matches_prefix s9890  ::  (( 1 Word.word * ii))option)) of
        Some ((i, s9900)) => 
  (case  ((string_drop s9890 s9900)) of
        s9910 =>
  (case  ((bit_maybe_o_matches_prefix s9910 :: (( 1 Word.word * ii)) option)) of
        Some ((o1, s9920)) =>
  (case  ((string_drop s9910 s9920)) of
        s9930 =>
  (case  ((bit_maybe_r_matches_prefix s9930 :: (( 1 Word.word * ii)) option)) of
        Some ((r, s9940)) =>
  (case  ((string_drop s9930 s9940)) of
        s9950 =>
  (case  ((bit_maybe_w_matches_prefix s9950 :: (( 1 Word.word * ii)) option)) of
        Some ((w, s9960)) =>
  (case  ((string_drop s9950 s9960)) of   s1 => Some (i, o1, r, w, s1) )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s9890  :: " string "


definition fence_bits_matches_prefix  :: \<open> string \<Rightarrow>((4)Word.word*int)option \<close>  where 
     \<open> fence_bits_matches_prefix arg1 = (
   (let s9970 = arg1 in
   if ((case  ((s987 s9970  ::  (( 1 Word.word *  1 Word.word *  1 Word.word *  1 Word.word * string))option)) of
       Some ((i, o1, r, w, s1)) => True
     | _ => False
     )) then  (case 
 (s987 s9970 :: (( 1 Word.word * 1 Word.word * 1 Word.word * 1 Word.word * string)) option) of
     (Some ((i, o1, r, w, s1))) =>
 Some
   ((concat_vec i
       ((concat_vec o1 ((concat_vec r w :: 2 Word.word)) :: 3 Word.word)) :: 4 Word.word),
   ((string_length arg1)) - ((string_length s1)))
 )
   else None))\<close> 
  for  arg1  :: " string "


\<comment> \<open>\<open>val aqrl_str : bool -> bool -> string\<close>\<close>

fun aqrl_str  :: \<open> bool \<Rightarrow> bool \<Rightarrow> string \<close>  where 
     \<open> aqrl_str (False :: bool) (False :: bool) = ( (''''))\<close>
|\<open> aqrl_str (False :: bool) (True :: bool) = ( (''.rl''))\<close>
|\<open> aqrl_str (True :: bool) (False :: bool) = ( (''.aq''))\<close>
|\<open> aqrl_str (True :: bool) (True :: bool) = ( (''.aqrl''))\<close>


\<comment> \<open>\<open>val lrsc_width_str : word_width -> string\<close>\<close>

fun lrsc_width_str  :: \<open> word_width \<Rightarrow> string \<close>  where 
     \<open> lrsc_width_str BYTE = ( (''.b''))\<close>
|\<open> lrsc_width_str HALF = ( (''.h''))\<close>
|\<open> lrsc_width_str WORD = ( (''.w''))\<close>
|\<open> lrsc_width_str DOUBLE = ( (''.d''))\<close>


\<comment> \<open>\<open>val amo_width_valid : word_width -> bool\<close>\<close>

fun amo_width_valid  :: \<open> word_width \<Rightarrow> bool \<close>  where 
     \<open> amo_width_valid WORD = ( True )\<close>
|\<open> amo_width_valid DOUBLE = ( (( 64 :: int)::ii) \<ge> (( 64 :: int)::ii))\<close>
|\<open> amo_width_valid _ = ( False )\<close>


\<comment> \<open>\<open>val process_loadres : forall 'int8_times_n. Size 'int8_times_n => mword ty5 -> mword ty64 -> MemoryOpResult (mword 'int8_times_n) -> bool -> M Retired\<close>\<close>

definition process_loadres  :: \<open>(5)Word.word \<Rightarrow>(64)Word.word \<Rightarrow>(('int8_times_n::len)Word.word)MemoryOpResult \<Rightarrow> bool \<Rightarrow>((register_value),(Retired),(exception))monad \<close>  where 
     \<open> process_loadres rd addr value1 is_unsigned = (
   (case  ((extend_value is_unsigned value1  :: ( 64 Word.word) MemoryOpResult)) of
     MemValue (result) =>
      (let (_ :: unit) = (load_reservation addr) in
      wX_bits rd result \<then> return RETIRE_SUCCESS)
   | MemException (e) => handle_mem_exception addr e \<then> return RETIRE_FAIL
   ))\<close> 
  for  rd  :: "(5)Word.word " 
  and  addr  :: "(64)Word.word " 
  and  value1  :: "(('int8_times_n::len)Word.word)MemoryOpResult " 
  and  is_unsigned  :: " bool "


\<comment> \<open>\<open>val encdec_amoop_forwards : amoop -> mword ty5\<close>\<close>

\<comment> \<open>\<open>val encdec_amoop_backwards : mword ty5 -> M amoop\<close>\<close>

\<comment> \<open>\<open>val encdec_amoop_forwards_matches : amoop -> bool\<close>\<close>

\<comment> \<open>\<open>val encdec_amoop_backwards_matches : mword ty5 -> bool\<close>\<close>

fun encdec_amoop_forwards  :: \<open> amoop \<Rightarrow>(5)Word.word \<close>  where 
     \<open> encdec_amoop_forwards AMOSWAP = ( ( 0b00001 ::  5 Word.word))\<close>
|\<open> encdec_amoop_forwards AMOADD = ( ( 0b00000 ::  5 Word.word))\<close>
|\<open> encdec_amoop_forwards AMOXOR = ( ( 0b00100 ::  5 Word.word))\<close>
|\<open> encdec_amoop_forwards AMOAND = ( ( 0b01100 ::  5 Word.word))\<close>
|\<open> encdec_amoop_forwards AMOOR = ( ( 0b01000 ::  5 Word.word))\<close>
|\<open> encdec_amoop_forwards AMOMIN = ( ( 0b10000 ::  5 Word.word))\<close>
|\<open> encdec_amoop_forwards AMOMAX = ( ( 0b10100 ::  5 Word.word))\<close>
|\<open> encdec_amoop_forwards AMOMINU = ( ( 0b11000 ::  5 Word.word))\<close>
|\<open> encdec_amoop_forwards AMOMAXU = ( ( 0b11100 ::  5 Word.word))\<close>


definition encdec_amoop_backwards  :: \<open>(5)Word.word \<Rightarrow>((register_value),(amoop),(exception))monad \<close>  where 
     \<open> encdec_amoop_backwards arg1 = (
   (let b__0 = arg1 in
   if (((b__0 = ( 0b00001 ::  5 Word.word)))) then return AMOSWAP
   else if (((b__0 = ( 0b00000 ::  5 Word.word)))) then return AMOADD
   else if (((b__0 = ( 0b00100 ::  5 Word.word)))) then return AMOXOR
   else if (((b__0 = ( 0b01100 ::  5 Word.word)))) then return AMOAND
   else if (((b__0 = ( 0b01000 ::  5 Word.word)))) then return AMOOR
   else if (((b__0 = ( 0b10000 ::  5 Word.word)))) then return AMOMIN
   else if (((b__0 = ( 0b10100 ::  5 Word.word)))) then return AMOMAX
   else if (((b__0 = ( 0b11000 ::  5 Word.word)))) then return AMOMINU
   else if (((b__0 = ( 0b11100 ::  5 Word.word)))) then return AMOMAXU
   else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))\<close> 
  for  arg1  :: "(5)Word.word "


fun encdec_amoop_forwards_matches  :: \<open> amoop \<Rightarrow> bool \<close>  where 
     \<open> encdec_amoop_forwards_matches AMOSWAP = ( True )\<close>
|\<open> encdec_amoop_forwards_matches AMOADD = ( True )\<close>
|\<open> encdec_amoop_forwards_matches AMOXOR = ( True )\<close>
|\<open> encdec_amoop_forwards_matches AMOAND = ( True )\<close>
|\<open> encdec_amoop_forwards_matches AMOOR = ( True )\<close>
|\<open> encdec_amoop_forwards_matches AMOMIN = ( True )\<close>
|\<open> encdec_amoop_forwards_matches AMOMAX = ( True )\<close>
|\<open> encdec_amoop_forwards_matches AMOMINU = ( True )\<close>
|\<open> encdec_amoop_forwards_matches AMOMAXU = ( True )\<close>


definition encdec_amoop_backwards_matches  :: \<open>(5)Word.word \<Rightarrow> bool \<close>  where 
     \<open> encdec_amoop_backwards_matches arg1 = (
   (let b__0 = arg1 in
   if (((b__0 = ( 0b00001 ::  5 Word.word)))) then True
   else if (((b__0 = ( 0b00000 ::  5 Word.word)))) then True
   else if (((b__0 = ( 0b00100 ::  5 Word.word)))) then True
   else if (((b__0 = ( 0b01100 ::  5 Word.word)))) then True
   else if (((b__0 = ( 0b01000 ::  5 Word.word)))) then True
   else if (((b__0 = ( 0b10000 ::  5 Word.word)))) then True
   else if (((b__0 = ( 0b10100 ::  5 Word.word)))) then True
   else if (((b__0 = ( 0b11000 ::  5 Word.word)))) then True
   else if (((b__0 = ( 0b11100 ::  5 Word.word)))) then True
   else False))\<close> 
  for  arg1  :: "(5)Word.word "


\<comment> \<open>\<open>val amo_mnemonic_forwards : amoop -> string\<close>\<close>

\<comment> \<open>\<open>val amo_mnemonic_backwards : string -> M amoop\<close>\<close>

\<comment> \<open>\<open>val amo_mnemonic_forwards_matches : amoop -> bool\<close>\<close>

\<comment> \<open>\<open>val amo_mnemonic_backwards_matches : string -> bool\<close>\<close>

\<comment> \<open>\<open>val amo_mnemonic_matches_prefix : string -> maybe ((amoop * ii))\<close>\<close>

fun amo_mnemonic_forwards  :: \<open> amoop \<Rightarrow> string \<close>  where 
     \<open> amo_mnemonic_forwards AMOSWAP = ( (''amoswap''))\<close>
|\<open> amo_mnemonic_forwards AMOADD = ( (''amoadd''))\<close>
|\<open> amo_mnemonic_forwards AMOXOR = ( (''amoxor''))\<close>
|\<open> amo_mnemonic_forwards AMOAND = ( (''amoand''))\<close>
|\<open> amo_mnemonic_forwards AMOOR = ( (''amoor''))\<close>
|\<open> amo_mnemonic_forwards AMOMIN = ( (''amomin''))\<close>
|\<open> amo_mnemonic_forwards AMOMAX = ( (''amomax''))\<close>
|\<open> amo_mnemonic_forwards AMOMINU = ( (''amominu''))\<close>
|\<open> amo_mnemonic_forwards AMOMAXU = ( (''amomaxu''))\<close>


definition amo_mnemonic_backwards  :: \<open> string \<Rightarrow>((register_value),(amoop),(exception))monad \<close>  where 
     \<open> amo_mnemonic_backwards arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''amoswap'')))) then return AMOSWAP
   else if (((p00 = (''amoadd'')))) then return AMOADD
   else if (((p00 = (''amoxor'')))) then return AMOXOR
   else if (((p00 = (''amoand'')))) then return AMOAND
   else if (((p00 = (''amoor'')))) then return AMOOR
   else if (((p00 = (''amomin'')))) then return AMOMIN
   else if (((p00 = (''amomax'')))) then return AMOMAX
   else if (((p00 = (''amominu'')))) then return AMOMINU
   else if (((p00 = (''amomaxu'')))) then return AMOMAXU
   else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))\<close> 
  for  arg1  :: " string "


fun amo_mnemonic_forwards_matches  :: \<open> amoop \<Rightarrow> bool \<close>  where 
     \<open> amo_mnemonic_forwards_matches AMOSWAP = ( True )\<close>
|\<open> amo_mnemonic_forwards_matches AMOADD = ( True )\<close>
|\<open> amo_mnemonic_forwards_matches AMOXOR = ( True )\<close>
|\<open> amo_mnemonic_forwards_matches AMOAND = ( True )\<close>
|\<open> amo_mnemonic_forwards_matches AMOOR = ( True )\<close>
|\<open> amo_mnemonic_forwards_matches AMOMIN = ( True )\<close>
|\<open> amo_mnemonic_forwards_matches AMOMAX = ( True )\<close>
|\<open> amo_mnemonic_forwards_matches AMOMINU = ( True )\<close>
|\<open> amo_mnemonic_forwards_matches AMOMAXU = ( True )\<close>


definition amo_mnemonic_backwards_matches  :: \<open> string \<Rightarrow> bool \<close>  where 
     \<open> amo_mnemonic_backwards_matches arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''amoswap'')))) then True
   else if (((p00 = (''amoadd'')))) then True
   else if (((p00 = (''amoxor'')))) then True
   else if (((p00 = (''amoand'')))) then True
   else if (((p00 = (''amoor'')))) then True
   else if (((p00 = (''amomin'')))) then True
   else if (((p00 = (''amomax'')))) then True
   else if (((p00 = (''amominu'')))) then True
   else if (((p00 = (''amomaxu'')))) then True
   else False))\<close> 
  for  arg1  :: " string "


\<comment> \<open>\<open>val _s1030_ : string -> maybe string\<close>\<close>

definition s1030  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s1030 s10310 = (
   (let s10320 = s10310 in
   if ((string_startswith s10320 (''amomaxu''))) then  
  (case  ((string_drop s10320 ((string_length (''amomaxu''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s10310  :: " string "


\<comment> \<open>\<open>val _s1026_ : string -> maybe string\<close>\<close>

definition s1026  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s1026 s10270 = (
   (let s10280 = s10270 in
   if ((string_startswith s10280 (''amominu''))) then  
  (case  ((string_drop s10280 ((string_length (''amominu''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s10270  :: " string "


\<comment> \<open>\<open>val _s1022_ : string -> maybe string\<close>\<close>

definition s1022  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s1022 s10230 = (
   (let s10240 = s10230 in
   if ((string_startswith s10240 (''amomax''))) then  
  (case  ((string_drop s10240 ((string_length (''amomax''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s10230  :: " string "


\<comment> \<open>\<open>val _s1018_ : string -> maybe string\<close>\<close>

definition s1018  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s1018 s10190 = (
   (let s10200 = s10190 in
   if ((string_startswith s10200 (''amomin''))) then  
  (case  ((string_drop s10200 ((string_length (''amomin''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s10190  :: " string "


\<comment> \<open>\<open>val _s1014_ : string -> maybe string\<close>\<close>

definition s1014  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s1014 s10150 = (
   (let s10160 = s10150 in
   if ((string_startswith s10160 (''amoor''))) then  
  (case  ((string_drop s10160 ((string_length (''amoor''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s10150  :: " string "


\<comment> \<open>\<open>val _s1010_ : string -> maybe string\<close>\<close>

definition s1010  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s1010 s10110 = (
   (let s10120 = s10110 in
   if ((string_startswith s10120 (''amoand''))) then  
  (case  ((string_drop s10120 ((string_length (''amoand''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s10110  :: " string "


\<comment> \<open>\<open>val _s1006_ : string -> maybe string\<close>\<close>

definition s1006  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s1006 s10070 = (
   (let s10080 = s10070 in
   if ((string_startswith s10080 (''amoxor''))) then  
  (case  ((string_drop s10080 ((string_length (''amoxor''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s10070  :: " string "


\<comment> \<open>\<open>val _s1002_ : string -> maybe string\<close>\<close>

definition s1002  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s1002 s10030 = (
   (let s10040 = s10030 in
   if ((string_startswith s10040 (''amoadd''))) then  
  (case  ((string_drop s10040 ((string_length (''amoadd''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s10030  :: " string "


\<comment> \<open>\<open>val _s998_ : string -> maybe string\<close>\<close>

definition s998  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s998 s9990 = (
   (let s10000 = s9990 in
   if ((string_startswith s10000 (''amoswap''))) then  
  (case  ((string_drop s10000 ((string_length (''amoswap''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s9990  :: " string "


definition amo_mnemonic_matches_prefix  :: \<open> string \<Rightarrow>(amoop*int)option \<close>  where 
     \<open> amo_mnemonic_matches_prefix arg1 = (
   (let s10010 = arg1 in
   if ((case  ((s998 s10010)) of   Some (s1) => True | _ => False )) then  
  (case  s998 s10010 of
      (Some (s1)) =>
  Some (AMOSWAP, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s1002 s10010)) of   Some (s1) => True | _ => False )) then  
  (case  s1002 s10010 of
      (Some (s1)) =>
  Some (AMOADD, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s1006 s10010)) of   Some (s1) => True | _ => False )) then  
  (case  s1006 s10010 of
      (Some (s1)) =>
  Some (AMOXOR, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s1010 s10010)) of   Some (s1) => True | _ => False )) then  
  (case  s1010 s10010 of
      (Some (s1)) =>
  Some (AMOAND, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s1014 s10010)) of   Some (s1) => True | _ => False )) then  
  (case  s1014 s10010 of
      (Some (s1)) =>
  Some (AMOOR, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s1018 s10010)) of   Some (s1) => True | _ => False )) then  
  (case  s1018 s10010 of
      (Some (s1)) =>
  Some (AMOMIN, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s1022 s10010)) of   Some (s1) => True | _ => False )) then  
  (case  s1022 s10010 of
      (Some (s1)) =>
  Some (AMOMAX, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s1026 s10010)) of   Some (s1) => True | _ => False )) then  
  (case  s1026 s10010 of
      (Some (s1)) =>
  Some (AMOMINU, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s1030 s10010)) of   Some (s1) => True | _ => False )) then  
  (case  s1030 s10010 of
      (Some (s1)) =>
  Some (AMOMAXU, ((string_length arg1)) - ((string_length s1)))
  )
   else None))\<close> 
  for  arg1  :: " string "


\<comment> \<open>\<open>val encdec_mul_op_forwards : (bool * bool * bool) -> mword ty3\<close>\<close>

\<comment> \<open>\<open>val encdec_mul_op_backwards : mword ty3 -> M (bool * bool * bool)\<close>\<close>

\<comment> \<open>\<open>val encdec_mul_op_forwards_matches : (bool * bool * bool) -> bool\<close>\<close>

\<comment> \<open>\<open>val encdec_mul_op_backwards_matches : mword ty3 -> bool\<close>\<close>

fun encdec_mul_op_forwards  :: \<open> bool*bool*bool \<Rightarrow>(3)Word.word \<close>  where 
     \<open> encdec_mul_op_forwards (False, True, True) = ( ( 0b000 ::  3 Word.word))\<close>
|\<open> encdec_mul_op_forwards (True, True, True) = ( ( 0b001 ::  3 Word.word))\<close>
|\<open> encdec_mul_op_forwards (True, True, False) = ( ( 0b010 ::  3 Word.word))\<close>
|\<open> encdec_mul_op_forwards (True, False, False) = ( ( 0b011 ::  3 Word.word))\<close>


definition encdec_mul_op_backwards  :: \<open>(3)Word.word \<Rightarrow>((register_value),(bool*bool*bool),(exception))monad \<close>  where 
     \<open> encdec_mul_op_backwards arg1 = (
   (let b__0 = arg1 in
   if (((b__0 = ( 0b000 ::  3 Word.word)))) then return (False, True, True)
   else if (((b__0 = ( 0b001 ::  3 Word.word)))) then return (True, True, True)
   else if (((b__0 = ( 0b010 ::  3 Word.word)))) then return (True, True, False)
   else if (((b__0 = ( 0b011 ::  3 Word.word)))) then return (True, False, False)
   else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))\<close> 
  for  arg1  :: "(3)Word.word "


fun encdec_mul_op_forwards_matches  :: \<open> bool*bool*bool \<Rightarrow> bool \<close>  where 
     \<open> encdec_mul_op_forwards_matches (False, True, True) = ( True )\<close>
|\<open> encdec_mul_op_forwards_matches (True, True, True) = ( True )\<close>
|\<open> encdec_mul_op_forwards_matches (True, True, False) = ( True )\<close>
|\<open> encdec_mul_op_forwards_matches (True, False, False) = ( True )\<close>
|\<open> encdec_mul_op_forwards_matches _ = ( False )\<close>


definition encdec_mul_op_backwards_matches  :: \<open>(3)Word.word \<Rightarrow> bool \<close>  where 
     \<open> encdec_mul_op_backwards_matches arg1 = (
   (let b__0 = arg1 in
   if (((b__0 = ( 0b000 ::  3 Word.word)))) then True
   else if (((b__0 = ( 0b001 ::  3 Word.word)))) then True
   else if (((b__0 = ( 0b010 ::  3 Word.word)))) then True
   else if (((b__0 = ( 0b011 ::  3 Word.word)))) then True
   else False))\<close> 
  for  arg1  :: "(3)Word.word "


\<comment> \<open>\<open>val mul_mnemonic_forwards : (bool * bool * bool) -> string\<close>\<close>

\<comment> \<open>\<open>val mul_mnemonic_backwards : string -> M (bool * bool * bool)\<close>\<close>

\<comment> \<open>\<open>val mul_mnemonic_forwards_matches : (bool * bool * bool) -> bool\<close>\<close>

\<comment> \<open>\<open>val mul_mnemonic_backwards_matches : string -> bool\<close>\<close>

\<comment> \<open>\<open>val mul_mnemonic_matches_prefix : string -> maybe (((bool * bool * bool) * ii))\<close>\<close>

fun mul_mnemonic_forwards  :: \<open> bool*bool*bool \<Rightarrow> string \<close>  where 
     \<open> mul_mnemonic_forwards (False, True, True) = ( (''mul''))\<close>
|\<open> mul_mnemonic_forwards (True, True, True) = ( (''mulh''))\<close>
|\<open> mul_mnemonic_forwards (True, True, False) = ( (''mulhsu''))\<close>
|\<open> mul_mnemonic_forwards (True, False, False) = ( (''mulhu''))\<close>


definition mul_mnemonic_backwards  :: \<open> string \<Rightarrow>((register_value),(bool*bool*bool),(exception))monad \<close>  where 
     \<open> mul_mnemonic_backwards arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''mul'')))) then return (False, True, True)
   else if (((p00 = (''mulh'')))) then return (True, True, True)
   else if (((p00 = (''mulhsu'')))) then return (True, True, False)
   else if (((p00 = (''mulhu'')))) then return (True, False, False)
   else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))\<close> 
  for  arg1  :: " string "


fun mul_mnemonic_forwards_matches  :: \<open> bool*bool*bool \<Rightarrow> bool \<close>  where 
     \<open> mul_mnemonic_forwards_matches (False, True, True) = ( True )\<close>
|\<open> mul_mnemonic_forwards_matches (True, True, True) = ( True )\<close>
|\<open> mul_mnemonic_forwards_matches (True, True, False) = ( True )\<close>
|\<open> mul_mnemonic_forwards_matches (True, False, False) = ( True )\<close>
|\<open> mul_mnemonic_forwards_matches _ = ( False )\<close>


definition mul_mnemonic_backwards_matches  :: \<open> string \<Rightarrow> bool \<close>  where 
     \<open> mul_mnemonic_backwards_matches arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''mul'')))) then True
   else if (((p00 = (''mulh'')))) then True
   else if (((p00 = (''mulhsu'')))) then True
   else if (((p00 = (''mulhu'')))) then True
   else False))\<close> 
  for  arg1  :: " string "


\<comment> \<open>\<open>val _s1046_ : string -> maybe string\<close>\<close>

definition s1046  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s1046 s10470 = (
   (let s10480 = s10470 in
   if ((string_startswith s10480 (''mulhu''))) then  
  (case  ((string_drop s10480 ((string_length (''mulhu''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s10470  :: " string "


\<comment> \<open>\<open>val _s1042_ : string -> maybe string\<close>\<close>

definition s1042  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s1042 s10430 = (
   (let s10440 = s10430 in
   if ((string_startswith s10440 (''mulhsu''))) then  
  (case  ((string_drop s10440 ((string_length (''mulhsu''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s10430  :: " string "


\<comment> \<open>\<open>val _s1038_ : string -> maybe string\<close>\<close>

definition s1038  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s1038 s10390 = (
   (let s10400 = s10390 in
   if ((string_startswith s10400 (''mulh''))) then  
  (case  ((string_drop s10400 ((string_length (''mulh''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s10390  :: " string "


\<comment> \<open>\<open>val _s1034_ : string -> maybe string\<close>\<close>

definition s1034  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s1034 s10350 = (
   (let s10360 = s10350 in
   if ((string_startswith s10360 (''mul''))) then  
  (case  ((string_drop s10360 ((string_length (''mul''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s10350  :: " string "


definition mul_mnemonic_matches_prefix  :: \<open> string \<Rightarrow>((bool*bool*bool)*int)option \<close>  where 
     \<open> mul_mnemonic_matches_prefix arg1 = (
   (let s10370 = arg1 in
   if ((case  ((s1034 s10370)) of   Some (s1) => True | _ => False )) then  
  (case  s1034 s10370 of
      (Some (s1)) =>
  Some ((False, True, True), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s1038 s10370)) of   Some (s1) => True | _ => False )) then  
  (case  s1038 s10370 of
      (Some (s1)) =>
  Some ((True, True, True), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s1042 s10370)) of   Some (s1) => True | _ => False )) then  
  (case  s1042 s10370 of
      (Some (s1)) =>
  Some ((True, True, False), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s1046 s10370)) of   Some (s1) => True | _ => False )) then  
  (case  s1046 s10370 of
      (Some (s1)) =>
  Some ((True, False, False), ((string_length arg1)) - ((string_length s1)))
  )
   else None))\<close> 
  for  arg1  :: " string "


\<comment> \<open>\<open>val maybe_not_u_forwards : bool -> string\<close>\<close>

\<comment> \<open>\<open>val maybe_not_u_backwards : string -> M bool\<close>\<close>

\<comment> \<open>\<open>val maybe_not_u_forwards_matches : bool -> bool\<close>\<close>

\<comment> \<open>\<open>val maybe_not_u_backwards_matches : string -> bool\<close>\<close>

\<comment> \<open>\<open>val maybe_not_u_matches_prefix : string -> maybe ((bool * ii))\<close>\<close>

fun maybe_not_u_forwards  :: \<open> bool \<Rightarrow> string \<close>  where 
     \<open> maybe_not_u_forwards False = ( (''u''))\<close>
|\<open> maybe_not_u_forwards True = ( (''''))\<close>


definition maybe_not_u_backwards  :: \<open> string \<Rightarrow>((register_value),(bool),(exception))monad \<close>  where 
     \<open> maybe_not_u_backwards arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''u'')))) then return False
   else if (((p00 = ('''')))) then return True
   else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))\<close> 
  for  arg1  :: " string "


fun maybe_not_u_forwards_matches  :: \<open> bool \<Rightarrow> bool \<close>  where 
     \<open> maybe_not_u_forwards_matches False = ( True )\<close>
|\<open> maybe_not_u_forwards_matches True = ( True )\<close>


definition maybe_not_u_backwards_matches  :: \<open> string \<Rightarrow> bool \<close>  where 
     \<open> maybe_not_u_backwards_matches arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''u'')))) then True
   else if (((p00 = ('''')))) then True
   else False))\<close> 
  for  arg1  :: " string "


\<comment> \<open>\<open>val _s1054_ : string -> maybe string\<close>\<close>

definition s1054  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s1054 s10550 = (
   (let s10560 = s10550 in
   if ((string_startswith s10560 (''''))) then  
  (case  ((string_drop s10560 ((string_length (''''))))) of   s1 => Some s1 )
   else None))\<close> 
  for  s10550  :: " string "


\<comment> \<open>\<open>val _s1050_ : string -> maybe string\<close>\<close>

definition s1050  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s1050 s10510 = (
   (let s10520 = s10510 in
   if ((string_startswith s10520 (''u''))) then  
  (case  ((string_drop s10520 ((string_length (''u''))))) of   s1 => Some s1 )
   else None))\<close> 
  for  s10510  :: " string "


definition maybe_not_u_matches_prefix  :: \<open> string \<Rightarrow>(bool*int)option \<close>  where 
     \<open> maybe_not_u_matches_prefix arg1 = (
   (let s10530 = arg1 in
   if ((case  ((s1050 s10530)) of   Some (s1) => True | _ => False )) then  
  (case  s1050 s10530 of
      (Some (s1)) =>
  Some (False, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s1054 s10530)) of   Some (s1) => True | _ => False )) then  
  (case  s1054 s10530 of
      (Some (s1)) =>
  Some (True, ((string_length arg1)) - ((string_length s1)))
  )
   else None))\<close> 
  for  arg1  :: " string "


\<comment> \<open>\<open>val encdec_csrop_forwards : csrop -> mword ty2\<close>\<close>

\<comment> \<open>\<open>val encdec_csrop_backwards : mword ty2 -> M csrop\<close>\<close>

\<comment> \<open>\<open>val encdec_csrop_forwards_matches : csrop -> bool\<close>\<close>

\<comment> \<open>\<open>val encdec_csrop_backwards_matches : mword ty2 -> bool\<close>\<close>

fun encdec_csrop_forwards  :: \<open> csrop \<Rightarrow>(2)Word.word \<close>  where 
     \<open> encdec_csrop_forwards CSRRW = ( ( 0b01 ::  2 Word.word))\<close>
|\<open> encdec_csrop_forwards CSRRS = ( ( 0b10 ::  2 Word.word))\<close>
|\<open> encdec_csrop_forwards CSRRC = ( ( 0b11 ::  2 Word.word))\<close>


definition encdec_csrop_backwards  :: \<open>(2)Word.word \<Rightarrow>((register_value),(csrop),(exception))monad \<close>  where 
     \<open> encdec_csrop_backwards arg1 = (
   (let b__0 = arg1 in
   if (((b__0 = ( 0b01 ::  2 Word.word)))) then return CSRRW
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then return CSRRS
   else if (((b__0 = ( 0b11 ::  2 Word.word)))) then return CSRRC
   else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))\<close> 
  for  arg1  :: "(2)Word.word "


fun encdec_csrop_forwards_matches  :: \<open> csrop \<Rightarrow> bool \<close>  where 
     \<open> encdec_csrop_forwards_matches CSRRW = ( True )\<close>
|\<open> encdec_csrop_forwards_matches CSRRS = ( True )\<close>
|\<open> encdec_csrop_forwards_matches CSRRC = ( True )\<close>


definition encdec_csrop_backwards_matches  :: \<open>(2)Word.word \<Rightarrow> bool \<close>  where 
     \<open> encdec_csrop_backwards_matches arg1 = (
   (let b__0 = arg1 in
   if (((b__0 = ( 0b01 ::  2 Word.word)))) then True
   else if (((b__0 = ( 0b10 ::  2 Word.word)))) then True
   else if (((b__0 = ( 0b11 ::  2 Word.word)))) then True
   else False))\<close> 
  for  arg1  :: "(2)Word.word "


\<comment> \<open>\<open>val readCSR : mword ty12 -> M (mword ty64)\<close>\<close>

definition readCSR  :: \<open>(12)Word.word \<Rightarrow>((register_value),((64)Word.word),(exception))monad \<close>  where 
     \<open> readCSR csr = (
   (case  (csr, (( 64 :: int)::ii)) of
     (b__0, g__336) =>
      if (((b__0 = ( 0xF11 ::  12 Word.word)))) then
        (read_reg mvendorid_ref  :: ( 32 Word.word) M) \<bind> ((\<lambda> (w__0 ::  32 Word.word) . 
        return ((EXTZ (( 64 :: int)::ii) w__0  ::  64 Word.word))))
      else if (((b__0 = ( 0xF12 ::  12 Word.word)))) then (read_reg marchid_ref  :: ( 64 Word.word) M)
      else if (((b__0 = ( 0xF13 ::  12 Word.word)))) then (read_reg mimpid_ref  :: ( 64 Word.word) M)
      else if (((b__0 = ( 0xF14 ::  12 Word.word)))) then (read_reg mhartid_ref  :: ( 64 Word.word) M)
      else if (((b__0 = ( 0x300 ::  12 Word.word)))) then
        read_reg mstatus_ref \<bind> ((\<lambda> (w__4 :: Mstatus) . 
        return ((get_Mstatus_bits w__4  ::  64 Word.word))))
      else if (((b__0 = ( 0x301 ::  12 Word.word)))) then
        read_reg misa_ref \<bind> ((\<lambda> (w__5 :: Misa) .  return ((get_Misa_bits w__5  ::  64 Word.word))))
      else if (((b__0 = ( 0x302 ::  12 Word.word)))) then
        read_reg medeleg_ref \<bind> ((\<lambda> (w__6 :: Medeleg) . 
        return ((get_Medeleg_bits w__6  ::  64 Word.word))))
      else if (((b__0 = ( 0x303 ::  12 Word.word)))) then
        read_reg mideleg_ref \<bind> ((\<lambda> (w__7 :: Minterrupts) . 
        return ((get_Minterrupts_bits w__7  ::  64 Word.word))))
      else if (((b__0 = ( 0x304 ::  12 Word.word)))) then
        read_reg mie_ref \<bind> ((\<lambda> (w__8 :: Minterrupts) . 
        return ((get_Minterrupts_bits w__8  ::  64 Word.word))))
      else if (((b__0 = ( 0x305 ::  12 Word.word)))) then (get_mtvec ()   :: ( 64 Word.word) M)
      else if (((b__0 = ( 0x306 ::  12 Word.word)))) then
        read_reg mcounteren_ref \<bind> ((\<lambda> (w__10 :: Counteren) . 
        return ((EXTZ (( 64 :: int)::ii) ((get_Counteren_bits w__10  ::  32 Word.word))  ::  64 Word.word))))
      else if (((b__0 = ( 0x320 ::  12 Word.word)))) then
        read_reg mcountinhibit_ref \<bind> ((\<lambda> (w__11 :: Counterin) . 
        return ((EXTZ (( 64 :: int)::ii) ((get_Counterin_bits w__11  ::  32 Word.word))  ::  64 Word.word))))
      else if (((b__0 = ( 0x340 ::  12 Word.word)))) then (read_reg mscratch_ref  :: ( 64 Word.word) M)
      else if (((b__0 = ( 0x341 ::  12 Word.word)))) then
        (get_xret_target Machine  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__13 ::  64 Word.word) . 
        (pc_alignment_mask ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__14 ::  64 Word.word) . 
        return ((and_vec w__13 w__14  ::  64 Word.word))))))
      else if (((b__0 = ( 0x342 ::  12 Word.word)))) then
        read_reg mcause_ref \<bind> ((\<lambda> (w__15 :: Mcause) . 
        return ((get_Mcause_bits w__15  ::  64 Word.word))))
      else if (((b__0 = ( 0x343 ::  12 Word.word)))) then (read_reg mtval_ref  :: ( 64 Word.word) M)
      else if (((b__0 = ( 0x344 ::  12 Word.word)))) then
        read_reg mip_ref \<bind> ((\<lambda> (w__17 :: Minterrupts) . 
        return ((get_Minterrupts_bits w__17  ::  64 Word.word))))
      else if (((b__0 = ( 0x3A0 ::  12 Word.word)))) then (pmpReadCfgReg (( 0 :: int)::ii)  :: ( 64 Word.word) M)
      else if (((b__0 = ( 0x3A2 ::  12 Word.word)))) then (pmpReadCfgReg (( 2 :: int)::ii)  :: ( 64 Word.word) M)
      else if (((b__0 = ( 0x3B0 ::  12 Word.word)))) then (read_reg pmpaddr0_ref  :: ( 64 Word.word) M)
      else if (((b__0 = ( 0x3B1 ::  12 Word.word)))) then (read_reg pmpaddr1_ref  :: ( 64 Word.word) M)
      else if (((b__0 = ( 0x3B2 ::  12 Word.word)))) then (read_reg pmpaddr2_ref  :: ( 64 Word.word) M)
      else if (((b__0 = ( 0x3B3 ::  12 Word.word)))) then (read_reg pmpaddr3_ref  :: ( 64 Word.word) M)
      else if (((b__0 = ( 0x3B4 ::  12 Word.word)))) then (read_reg pmpaddr4_ref  :: ( 64 Word.word) M)
      else if (((b__0 = ( 0x3B5 ::  12 Word.word)))) then (read_reg pmpaddr5_ref  :: ( 64 Word.word) M)
      else if (((b__0 = ( 0x3B6 ::  12 Word.word)))) then (read_reg pmpaddr6_ref  :: ( 64 Word.word) M)
      else if (((b__0 = ( 0x3B7 ::  12 Word.word)))) then (read_reg pmpaddr7_ref  :: ( 64 Word.word) M)
      else if (((b__0 = ( 0x3B8 ::  12 Word.word)))) then (read_reg pmpaddr8_ref  :: ( 64 Word.word) M)
      else if (((b__0 = ( 0x3B9 ::  12 Word.word)))) then (read_reg pmpaddr9_ref  :: ( 64 Word.word) M)
      else if (((b__0 = ( 0x3BA ::  12 Word.word)))) then (read_reg pmpaddr10_ref  :: ( 64 Word.word) M)
      else if (((b__0 = ( 0x3BB ::  12 Word.word)))) then (read_reg pmpaddr11_ref  :: ( 64 Word.word) M)
      else if (((b__0 = ( 0x3BC ::  12 Word.word)))) then (read_reg pmpaddr12_ref  :: ( 64 Word.word) M)
      else if (((b__0 = ( 0x3BD ::  12 Word.word)))) then (read_reg pmpaddr13_ref  :: ( 64 Word.word) M)
      else if (((b__0 = ( 0x3BE ::  12 Word.word)))) then (read_reg pmpaddr14_ref  :: ( 64 Word.word) M)
      else if (((b__0 = ( 0x3BF ::  12 Word.word)))) then (read_reg pmpaddr15_ref  :: ( 64 Word.word) M)
      else if (((b__0 = ( 0xB00 ::  12 Word.word)))) then
        (read_reg mcycle_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__36 ::  64 Word.word) . 
        return ((subrange_vec_dec w__36 (((( 64 :: int)::ii) - (( 1 :: int)::ii))) (( 0 :: int)::ii)  ::  64 Word.word))))
      else if (((b__0 = ( 0xB02 ::  12 Word.word)))) then
        (read_reg minstret_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__37 ::  64 Word.word) . 
        return ((subrange_vec_dec w__37 (((( 64 :: int)::ii) - (( 1 :: int)::ii))) (( 0 :: int)::ii)  ::  64 Word.word))))
      else if (((b__0 = ( 0x7A0 ::  12 Word.word)))) then
        (read_reg tselect_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__38 ::  64 Word.word) . 
        return ((not_vec w__38  ::  64 Word.word))))
      else if (((b__0 = ( 0x100 ::  12 Word.word)))) then
        read_reg mstatus_ref \<bind> ((\<lambda> (w__39 :: Mstatus) . 
        return ((get_Sstatus_bits ((lower_mstatus w__39))  ::  64 Word.word))))
      else if (((b__0 = ( 0x102 ::  12 Word.word)))) then
        read_reg sedeleg_ref \<bind> ((\<lambda> (w__40 :: Sedeleg) . 
        return ((get_Sedeleg_bits w__40  ::  64 Word.word))))
      else if (((b__0 = ( 0x103 ::  12 Word.word)))) then
        read_reg sideleg_ref \<bind> ((\<lambda> (w__41 :: Sinterrupts) . 
        return ((get_Sinterrupts_bits w__41  ::  64 Word.word))))
      else if (((b__0 = ( 0x104 ::  12 Word.word)))) then
        read_reg mie_ref \<bind> ((\<lambda> (w__42 :: Minterrupts) . 
        read_reg mideleg_ref \<bind> ((\<lambda> (w__43 :: Minterrupts) . 
        return ((get_Sinterrupts_bits ((lower_mie w__42 w__43))  ::  64 Word.word))))))
      else if (((b__0 = ( 0x105 ::  12 Word.word)))) then (get_stvec ()   :: ( 64 Word.word) M)
      else if (((b__0 = ( 0x106 ::  12 Word.word)))) then
        read_reg scounteren_ref \<bind> ((\<lambda> (w__45 :: Counteren) . 
        return ((EXTZ (( 64 :: int)::ii) ((get_Counteren_bits w__45  ::  32 Word.word))  ::  64 Word.word))))
      else if (((b__0 = ( 0x140 ::  12 Word.word)))) then (read_reg sscratch_ref  :: ( 64 Word.word) M)
      else if (((b__0 = ( 0x141 ::  12 Word.word)))) then
        (get_xret_target Supervisor  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__47 ::  64 Word.word) . 
        (pc_alignment_mask ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__48 ::  64 Word.word) . 
        return ((and_vec w__47 w__48  ::  64 Word.word))))))
      else if (((b__0 = ( 0x142 ::  12 Word.word)))) then
        read_reg scause_ref \<bind> ((\<lambda> (w__49 :: Mcause) . 
        return ((get_Mcause_bits w__49  ::  64 Word.word))))
      else if (((b__0 = ( 0x143 ::  12 Word.word)))) then (read_reg stval_ref  :: ( 64 Word.word) M)
      else if (((b__0 = ( 0x144 ::  12 Word.word)))) then
        read_reg mip_ref \<bind> ((\<lambda> (w__51 :: Minterrupts) . 
        read_reg mideleg_ref \<bind> ((\<lambda> (w__52 :: Minterrupts) . 
        return ((get_Sinterrupts_bits ((lower_mip w__51 w__52))  ::  64 Word.word))))))
      else if (((b__0 = ( 0x180 ::  12 Word.word)))) then (read_reg satp_ref  :: ( 64 Word.word) M)
      else if (((b__0 = ( 0xC00 ::  12 Word.word)))) then
        (read_reg mcycle_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__54 ::  64 Word.word) . 
        return ((subrange_vec_dec w__54 (((( 64 :: int)::ii) - (( 1 :: int)::ii))) (( 0 :: int)::ii)  ::  64 Word.word))))
      else if (((b__0 = ( 0xC01 ::  12 Word.word)))) then
        (read_reg mtime_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__55 ::  64 Word.word) . 
        return ((subrange_vec_dec w__55 (((( 64 :: int)::ii) - (( 1 :: int)::ii))) (( 0 :: int)::ii)  ::  64 Word.word))))
      else if (((b__0 = ( 0xC02 ::  12 Word.word)))) then
        (read_reg minstret_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__56 ::  64 Word.word) . 
        return ((subrange_vec_dec w__56 (((( 64 :: int)::ii) - (( 1 :: int)::ii))) (( 0 :: int)::ii)  ::  64 Word.word))))
      else
        (ext_read_CSR csr  :: ( ( 64 Word.word)option) M) \<bind> ((\<lambda> (w__57 ::  ( 64 Word.word)option) . 
        return ((case  w__57 of
          Some (res) => res
        | None =>
           (let (_ :: unit) = (print_bits0 (''unhandled read to CSR '') csr) in
           (EXTZ (( 64 :: int)::ii) ( 0x0 ::  4 Word.word)  ::  64 Word.word))
        ))))
   ) \<bind> ((\<lambda> (res :: xlenbits) . 
   (let (_ :: unit) =
     (if ((get_config_print_reg () )) then
       print_dbg
         (((@) (''CSR '')
             (((@) ((csr_name csr)) (((@) ('' -> '') ((string_of_bits res))))))))
     else () ) in
   return res))))\<close> 
  for  csr  :: "(12)Word.word "


\<comment> \<open>\<open>val writeCSR : mword ty12 -> mword ty64 -> M unit\<close>\<close>

definition writeCSR  :: \<open>(12)Word.word \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> writeCSR (csr :: csreg) (value1 :: xlenbits) = (
   (case  (csr, (( 64 :: int)::ii)) of
     (b__0, g__335) =>
      if (((b__0 = ( 0x300 ::  12 Word.word)))) then
        read_reg mstatus_ref \<bind> ((\<lambda> (w__0 :: Mstatus) . 
        legalize_mstatus w__0 value1 \<bind> ((\<lambda> (w__1 :: Mstatus) . 
        (write_reg mstatus_ref w__1 \<then>
        read_reg mstatus_ref) \<bind> ((\<lambda> (w__2 :: Mstatus) . 
        return (Some ((get_Mstatus_bits w__2  ::  64 Word.word)))))))))
      else if (((b__0 = ( 0x301 ::  12 Word.word)))) then
        read_reg misa_ref \<bind> ((\<lambda> (w__3 :: Misa) . 
        legalize_misa w__3 value1 \<bind> ((\<lambda> (w__4 :: Misa) . 
        (write_reg misa_ref w__4 \<then>
        read_reg misa_ref) \<bind> ((\<lambda> (w__5 :: Misa) . 
        return (Some ((get_Misa_bits w__5  ::  64 Word.word)))))))))
      else if (((b__0 = ( 0x302 ::  12 Word.word)))) then
        read_reg medeleg_ref \<bind> ((\<lambda> (w__6 :: Medeleg) . 
        (write_reg medeleg_ref ((legalize_medeleg w__6 value1)) \<then>
        read_reg medeleg_ref) \<bind> ((\<lambda> (w__7 :: Medeleg) . 
        return (Some ((get_Medeleg_bits w__7  ::  64 Word.word)))))))
      else if (((b__0 = ( 0x303 ::  12 Word.word)))) then
        read_reg mideleg_ref \<bind> ((\<lambda> (w__8 :: Minterrupts) . 
        (write_reg mideleg_ref ((legalize_mideleg w__8 value1)) \<then>
        read_reg mideleg_ref) \<bind> ((\<lambda> (w__9 :: Minterrupts) . 
        return (Some ((get_Minterrupts_bits w__9  ::  64 Word.word)))))))
      else if (((b__0 = ( 0x304 ::  12 Word.word)))) then
        read_reg mie_ref \<bind> ((\<lambda> (w__10 :: Minterrupts) . 
        legalize_mie w__10 value1 \<bind> ((\<lambda> (w__11 :: Minterrupts) . 
        (write_reg mie_ref w__11 \<then>
        read_reg mie_ref) \<bind> ((\<lambda> (w__12 :: Minterrupts) . 
        return (Some ((get_Minterrupts_bits w__12  ::  64 Word.word)))))))))
      else if (((b__0 = ( 0x305 ::  12 Word.word)))) then
        (set_mtvec value1  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__13 ::  64 Word.word) .  return (Some w__13)))
      else if (((b__0 = ( 0x306 ::  12 Word.word)))) then
        read_reg mcounteren_ref \<bind> ((\<lambda> (w__14 :: Counteren) . 
        (write_reg mcounteren_ref ((legalize_mcounteren w__14 value1)) \<then>
        read_reg mcounteren_ref) \<bind> ((\<lambda> (w__15 :: Counteren) . 
        return (Some ((EXTZ (( 64 :: int)::ii) ((get_Counteren_bits w__15  ::  32 Word.word))  ::  64 Word.word)))))))
      else if (((b__0 = ( 0x320 ::  12 Word.word)))) then
        read_reg mcountinhibit_ref \<bind> ((\<lambda> (w__16 :: Counterin) . 
        (write_reg mcountinhibit_ref ((legalize_mcountinhibit w__16 value1)) \<then>
        read_reg mcountinhibit_ref) \<bind> ((\<lambda> (w__17 :: Counterin) . 
        return (Some ((EXTZ (( 64 :: int)::ii) ((get_Counterin_bits w__17  ::  32 Word.word))  ::  64 Word.word)))))))
      else if (((b__0 = ( 0x340 ::  12 Word.word)))) then
        (write_reg mscratch_ref value1 \<then>
        (read_reg mscratch_ref  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__18 ::  64 Word.word) . 
        return (Some w__18)))
      else if (((b__0 = ( 0x341 ::  12 Word.word)))) then
        (set_xret_target Machine value1  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__19 ::  64 Word.word) . 
        return (Some w__19)))
      else if (((b__0 = ( 0x342 ::  12 Word.word)))) then
        (set_Mcause_bits mcause_ref value1 \<then>
        read_reg mcause_ref) \<bind> ((\<lambda> (w__20 :: Mcause) . 
        return (Some ((get_Mcause_bits w__20  ::  64 Word.word)))))
      else if (((b__0 = ( 0x343 ::  12 Word.word)))) then
        (write_reg mtval_ref value1 \<then>
        (read_reg mtval_ref  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__21 ::  64 Word.word) .  return (Some w__21)))
      else if (((b__0 = ( 0x344 ::  12 Word.word)))) then
        read_reg mip_ref \<bind> ((\<lambda> (w__22 :: Minterrupts) . 
        legalize_mip w__22 value1 \<bind> ((\<lambda> (w__23 :: Minterrupts) . 
        (write_reg mip_ref w__23 \<then>
        read_reg mip_ref) \<bind> ((\<lambda> (w__24 :: Minterrupts) . 
        return (Some ((get_Minterrupts_bits w__24  ::  64 Word.word)))))))))
      else if (((b__0 = ( 0x3A0 ::  12 Word.word)))) then
        (pmpWriteCfgReg (( 0 :: int)::ii) value1 \<then>
        (pmpReadCfgReg (( 0 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__25 ::  64 Word.word) .  return (Some w__25)))
      else if (((b__0 = ( 0x3A2 ::  12 Word.word)))) then
        (pmpWriteCfgReg (( 2 :: int)::ii) value1 \<then>
        (pmpReadCfgReg (( 2 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__26 ::  64 Word.word) .  return (Some w__26)))
      else if (((b__0 = ( 0x3B0 ::  12 Word.word)))) then
        read_reg pmp0cfg_ref \<bind> ((\<lambda> (w__27 :: Pmpcfg_ent) . 
        read_reg pmp1cfg_ref \<bind> ((\<lambda> (w__28 :: Pmpcfg_ent) . 
        pmpTORLocked w__28 \<bind> ((\<lambda> (w__29 :: bool) . 
        (read_reg pmpaddr0_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__30 ::  64 Word.word) . 
        (write_reg pmpaddr0_ref ((pmpWriteAddr ((pmpLocked w__27)) w__29 w__30 value1  ::  64 Word.word)) \<then>
        (read_reg pmpaddr0_ref  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__31 ::  64 Word.word) . 
        return (Some w__31)))))))))))
      else if (((b__0 = ( 0x3B1 ::  12 Word.word)))) then
        read_reg pmp1cfg_ref \<bind> ((\<lambda> (w__32 :: Pmpcfg_ent) . 
        read_reg pmp2cfg_ref \<bind> ((\<lambda> (w__33 :: Pmpcfg_ent) . 
        pmpTORLocked w__33 \<bind> ((\<lambda> (w__34 :: bool) . 
        (read_reg pmpaddr1_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__35 ::  64 Word.word) . 
        (write_reg pmpaddr1_ref ((pmpWriteAddr ((pmpLocked w__32)) w__34 w__35 value1  ::  64 Word.word)) \<then>
        (read_reg pmpaddr1_ref  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__36 ::  64 Word.word) . 
        return (Some w__36)))))))))))
      else if (((b__0 = ( 0x3B2 ::  12 Word.word)))) then
        read_reg pmp2cfg_ref \<bind> ((\<lambda> (w__37 :: Pmpcfg_ent) . 
        read_reg pmp3cfg_ref \<bind> ((\<lambda> (w__38 :: Pmpcfg_ent) . 
        pmpTORLocked w__38 \<bind> ((\<lambda> (w__39 :: bool) . 
        (read_reg pmpaddr2_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__40 ::  64 Word.word) . 
        (write_reg pmpaddr2_ref ((pmpWriteAddr ((pmpLocked w__37)) w__39 w__40 value1  ::  64 Word.word)) \<then>
        (read_reg pmpaddr2_ref  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__41 ::  64 Word.word) . 
        return (Some w__41)))))))))))
      else if (((b__0 = ( 0x3B3 ::  12 Word.word)))) then
        read_reg pmp3cfg_ref \<bind> ((\<lambda> (w__42 :: Pmpcfg_ent) . 
        read_reg pmp4cfg_ref \<bind> ((\<lambda> (w__43 :: Pmpcfg_ent) . 
        pmpTORLocked w__43 \<bind> ((\<lambda> (w__44 :: bool) . 
        (read_reg pmpaddr3_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__45 ::  64 Word.word) . 
        (write_reg pmpaddr3_ref ((pmpWriteAddr ((pmpLocked w__42)) w__44 w__45 value1  ::  64 Word.word)) \<then>
        (read_reg pmpaddr3_ref  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__46 ::  64 Word.word) . 
        return (Some w__46)))))))))))
      else if (((b__0 = ( 0x3B4 ::  12 Word.word)))) then
        read_reg pmp4cfg_ref \<bind> ((\<lambda> (w__47 :: Pmpcfg_ent) . 
        read_reg pmp5cfg_ref \<bind> ((\<lambda> (w__48 :: Pmpcfg_ent) . 
        pmpTORLocked w__48 \<bind> ((\<lambda> (w__49 :: bool) . 
        (read_reg pmpaddr4_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__50 ::  64 Word.word) . 
        (write_reg pmpaddr4_ref ((pmpWriteAddr ((pmpLocked w__47)) w__49 w__50 value1  ::  64 Word.word)) \<then>
        (read_reg pmpaddr4_ref  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__51 ::  64 Word.word) . 
        return (Some w__51)))))))))))
      else if (((b__0 = ( 0x3B5 ::  12 Word.word)))) then
        read_reg pmp5cfg_ref \<bind> ((\<lambda> (w__52 :: Pmpcfg_ent) . 
        read_reg pmp6cfg_ref \<bind> ((\<lambda> (w__53 :: Pmpcfg_ent) . 
        pmpTORLocked w__53 \<bind> ((\<lambda> (w__54 :: bool) . 
        (read_reg pmpaddr5_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__55 ::  64 Word.word) . 
        (write_reg pmpaddr5_ref ((pmpWriteAddr ((pmpLocked w__52)) w__54 w__55 value1  ::  64 Word.word)) \<then>
        (read_reg pmpaddr5_ref  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__56 ::  64 Word.word) . 
        return (Some w__56)))))))))))
      else if (((b__0 = ( 0x3B6 ::  12 Word.word)))) then
        read_reg pmp6cfg_ref \<bind> ((\<lambda> (w__57 :: Pmpcfg_ent) . 
        read_reg pmp7cfg_ref \<bind> ((\<lambda> (w__58 :: Pmpcfg_ent) . 
        pmpTORLocked w__58 \<bind> ((\<lambda> (w__59 :: bool) . 
        (read_reg pmpaddr6_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__60 ::  64 Word.word) . 
        (write_reg pmpaddr6_ref ((pmpWriteAddr ((pmpLocked w__57)) w__59 w__60 value1  ::  64 Word.word)) \<then>
        (read_reg pmpaddr6_ref  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__61 ::  64 Word.word) . 
        return (Some w__61)))))))))))
      else if (((b__0 = ( 0x3B7 ::  12 Word.word)))) then
        read_reg pmp7cfg_ref \<bind> ((\<lambda> (w__62 :: Pmpcfg_ent) . 
        read_reg pmp8cfg_ref \<bind> ((\<lambda> (w__63 :: Pmpcfg_ent) . 
        pmpTORLocked w__63 \<bind> ((\<lambda> (w__64 :: bool) . 
        (read_reg pmpaddr7_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__65 ::  64 Word.word) . 
        (write_reg pmpaddr7_ref ((pmpWriteAddr ((pmpLocked w__62)) w__64 w__65 value1  ::  64 Word.word)) \<then>
        (read_reg pmpaddr7_ref  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__66 ::  64 Word.word) . 
        return (Some w__66)))))))))))
      else if (((b__0 = ( 0x3B8 ::  12 Word.word)))) then
        read_reg pmp8cfg_ref \<bind> ((\<lambda> (w__67 :: Pmpcfg_ent) . 
        read_reg pmp9cfg_ref \<bind> ((\<lambda> (w__68 :: Pmpcfg_ent) . 
        pmpTORLocked w__68 \<bind> ((\<lambda> (w__69 :: bool) . 
        (read_reg pmpaddr8_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__70 ::  64 Word.word) . 
        (write_reg pmpaddr8_ref ((pmpWriteAddr ((pmpLocked w__67)) w__69 w__70 value1  ::  64 Word.word)) \<then>
        (read_reg pmpaddr8_ref  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__71 ::  64 Word.word) . 
        return (Some w__71)))))))))))
      else if (((b__0 = ( 0x3B9 ::  12 Word.word)))) then
        read_reg pmp9cfg_ref \<bind> ((\<lambda> (w__72 :: Pmpcfg_ent) . 
        read_reg pmp10cfg_ref \<bind> ((\<lambda> (w__73 :: Pmpcfg_ent) . 
        pmpTORLocked w__73 \<bind> ((\<lambda> (w__74 :: bool) . 
        (read_reg pmpaddr9_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__75 ::  64 Word.word) . 
        (write_reg pmpaddr9_ref ((pmpWriteAddr ((pmpLocked w__72)) w__74 w__75 value1  ::  64 Word.word)) \<then>
        (read_reg pmpaddr9_ref  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__76 ::  64 Word.word) . 
        return (Some w__76)))))))))))
      else if (((b__0 = ( 0x3BA ::  12 Word.word)))) then
        read_reg pmp10cfg_ref \<bind> ((\<lambda> (w__77 :: Pmpcfg_ent) . 
        read_reg pmp11cfg_ref \<bind> ((\<lambda> (w__78 :: Pmpcfg_ent) . 
        pmpTORLocked w__78 \<bind> ((\<lambda> (w__79 :: bool) . 
        (read_reg pmpaddr10_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__80 ::  64 Word.word) . 
        (write_reg pmpaddr10_ref ((pmpWriteAddr ((pmpLocked w__77)) w__79 w__80 value1  ::  64 Word.word)) \<then>
        (read_reg pmpaddr10_ref  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__81 ::  64 Word.word) . 
        return (Some w__81)))))))))))
      else if (((b__0 = ( 0x3BB ::  12 Word.word)))) then
        read_reg pmp11cfg_ref \<bind> ((\<lambda> (w__82 :: Pmpcfg_ent) . 
        read_reg pmp12cfg_ref \<bind> ((\<lambda> (w__83 :: Pmpcfg_ent) . 
        pmpTORLocked w__83 \<bind> ((\<lambda> (w__84 :: bool) . 
        (read_reg pmpaddr11_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__85 ::  64 Word.word) . 
        (write_reg pmpaddr11_ref ((pmpWriteAddr ((pmpLocked w__82)) w__84 w__85 value1  ::  64 Word.word)) \<then>
        (read_reg pmpaddr11_ref  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__86 ::  64 Word.word) . 
        return (Some w__86)))))))))))
      else if (((b__0 = ( 0x3BC ::  12 Word.word)))) then
        read_reg pmp12cfg_ref \<bind> ((\<lambda> (w__87 :: Pmpcfg_ent) . 
        read_reg pmp13cfg_ref \<bind> ((\<lambda> (w__88 :: Pmpcfg_ent) . 
        pmpTORLocked w__88 \<bind> ((\<lambda> (w__89 :: bool) . 
        (read_reg pmpaddr12_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__90 ::  64 Word.word) . 
        (write_reg pmpaddr12_ref ((pmpWriteAddr ((pmpLocked w__87)) w__89 w__90 value1  ::  64 Word.word)) \<then>
        (read_reg pmpaddr12_ref  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__91 ::  64 Word.word) . 
        return (Some w__91)))))))))))
      else if (((b__0 = ( 0x3BD ::  12 Word.word)))) then
        read_reg pmp13cfg_ref \<bind> ((\<lambda> (w__92 :: Pmpcfg_ent) . 
        read_reg pmp14cfg_ref \<bind> ((\<lambda> (w__93 :: Pmpcfg_ent) . 
        pmpTORLocked w__93 \<bind> ((\<lambda> (w__94 :: bool) . 
        (read_reg pmpaddr13_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__95 ::  64 Word.word) . 
        (write_reg pmpaddr13_ref ((pmpWriteAddr ((pmpLocked w__92)) w__94 w__95 value1  ::  64 Word.word)) \<then>
        (read_reg pmpaddr13_ref  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__96 ::  64 Word.word) . 
        return (Some w__96)))))))))))
      else if (((b__0 = ( 0x3BE ::  12 Word.word)))) then
        read_reg pmp14cfg_ref \<bind> ((\<lambda> (w__97 :: Pmpcfg_ent) . 
        read_reg pmp15cfg_ref \<bind> ((\<lambda> (w__98 :: Pmpcfg_ent) . 
        pmpTORLocked w__98 \<bind> ((\<lambda> (w__99 :: bool) . 
        (read_reg pmpaddr14_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__100 ::  64 Word.word) . 
        (write_reg
          pmpaddr14_ref
          ((pmpWriteAddr ((pmpLocked w__97)) w__99 w__100 value1  ::  64 Word.word)) \<then>
        (read_reg pmpaddr14_ref  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__101 ::  64 Word.word) . 
        return (Some w__101)))))))))))
      else if (((b__0 = ( 0x3BF ::  12 Word.word)))) then
        read_reg pmp15cfg_ref \<bind> ((\<lambda> (w__102 :: Pmpcfg_ent) . 
        (read_reg pmpaddr15_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__103 ::  64 Word.word) . 
        (write_reg
          pmpaddr15_ref
          ((pmpWriteAddr ((pmpLocked w__102)) False w__103 value1  ::  64 Word.word)) \<then>
        (read_reg pmpaddr15_ref  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__104 ::  64 Word.word) . 
        return (Some w__104)))))))
      else if (((b__0 = ( 0xB00 ::  12 Word.word)))) then
        (read_reg mcycle_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__105 ::  64 Word.word) . 
        write_reg
          mcycle_ref
          ((update_subrange_vec_dec w__105 (((( 64 :: int)::ii) - (( 1 :: int)::ii))) (( 0 :: int)::ii) value1
             ::  64 Word.word)) \<then>
        return (Some value1)))
      else if (((b__0 = ( 0xB02 ::  12 Word.word)))) then
        (read_reg minstret_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__106 ::  64 Word.word) . 
        (write_reg
          minstret_ref
          ((update_subrange_vec_dec w__106 (((( 64 :: int)::ii) - (( 1 :: int)::ii))) (( 0 :: int)::ii) value1
             ::  64 Word.word)) \<then>
        write_reg minstret_written_ref True) \<then> return (Some value1)))
      else if (((b__0 = ( 0x7A0 ::  12 Word.word)))) then
        (write_reg tselect_ref value1 \<then>
        (read_reg tselect_ref  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__107 ::  64 Word.word) . 
        return (Some w__107)))
      else if (((b__0 = ( 0x100 ::  12 Word.word)))) then
        read_reg mstatus_ref \<bind> ((\<lambda> (w__108 :: Mstatus) . 
        legalize_sstatus w__108 value1 \<bind> ((\<lambda> (w__109 :: Mstatus) . 
        (write_reg mstatus_ref w__109 \<then>
        read_reg mstatus_ref) \<bind> ((\<lambda> (w__110 :: Mstatus) . 
        return (Some ((get_Mstatus_bits w__110  ::  64 Word.word)))))))))
      else if (((b__0 = ( 0x102 ::  12 Word.word)))) then
        read_reg sedeleg_ref \<bind> ((\<lambda> (w__111 :: Sedeleg) . 
        (write_reg sedeleg_ref ((legalize_sedeleg w__111 value1)) \<then>
        read_reg sedeleg_ref) \<bind> ((\<lambda> (w__112 :: Sedeleg) . 
        return (Some ((get_Sedeleg_bits w__112  ::  64 Word.word)))))))
      else if (((b__0 = ( 0x103 ::  12 Word.word)))) then
        (set_Sinterrupts_bits sideleg_ref value1 \<then>
        read_reg sideleg_ref) \<bind> ((\<lambda> (w__113 :: Sinterrupts) . 
        return (Some ((get_Sinterrupts_bits w__113  ::  64 Word.word)))))
      else if (((b__0 = ( 0x104 ::  12 Word.word)))) then
        read_reg mie_ref \<bind> ((\<lambda> (w__114 :: Minterrupts) . 
        read_reg mideleg_ref \<bind> ((\<lambda> (w__115 :: Minterrupts) . 
        legalize_sie w__114 w__115 value1 \<bind> ((\<lambda> (w__116 :: Minterrupts) . 
        (write_reg mie_ref w__116 \<then>
        read_reg mie_ref) \<bind> ((\<lambda> (w__117 :: Minterrupts) . 
        return (Some ((get_Minterrupts_bits w__117  ::  64 Word.word)))))))))))
      else if (((b__0 = ( 0x105 ::  12 Word.word)))) then
        (set_stvec value1  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__118 ::  64 Word.word) .  return (Some w__118)))
      else if (((b__0 = ( 0x106 ::  12 Word.word)))) then
        read_reg scounteren_ref \<bind> ((\<lambda> (w__119 :: Counteren) . 
        (write_reg scounteren_ref ((legalize_scounteren w__119 value1)) \<then>
        read_reg scounteren_ref) \<bind> ((\<lambda> (w__120 :: Counteren) . 
        return (Some ((EXTZ (( 64 :: int)::ii) ((get_Counteren_bits w__120  ::  32 Word.word))  ::  64 Word.word)))))))
      else if (((b__0 = ( 0x140 ::  12 Word.word)))) then
        (write_reg sscratch_ref value1 \<then>
        (read_reg sscratch_ref  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__121 ::  64 Word.word) . 
        return (Some w__121)))
      else if (((b__0 = ( 0x141 ::  12 Word.word)))) then
        (set_xret_target Supervisor value1  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__122 ::  64 Word.word) . 
        return (Some w__122)))
      else if (((b__0 = ( 0x142 ::  12 Word.word)))) then
        (set_Mcause_bits scause_ref value1 \<then>
        read_reg scause_ref) \<bind> ((\<lambda> (w__123 :: Mcause) . 
        return (Some ((get_Mcause_bits w__123  ::  64 Word.word)))))
      else if (((b__0 = ( 0x143 ::  12 Word.word)))) then
        (write_reg stval_ref value1 \<then>
        (read_reg stval_ref  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__124 ::  64 Word.word) .  return (Some w__124)))
      else if (((b__0 = ( 0x144 ::  12 Word.word)))) then
        read_reg mip_ref \<bind> ((\<lambda> (w__125 :: Minterrupts) . 
        read_reg mideleg_ref \<bind> ((\<lambda> (w__126 :: Minterrupts) . 
        legalize_sip w__125 w__126 value1 \<bind> ((\<lambda> (w__127 :: Minterrupts) . 
        (write_reg mip_ref w__127 \<then>
        read_reg mip_ref) \<bind> ((\<lambda> (w__128 :: Minterrupts) . 
        return (Some ((get_Minterrupts_bits w__128  ::  64 Word.word)))))))))))
      else if (((b__0 = ( 0x180 ::  12 Word.word)))) then
        cur_Architecture ()  \<bind> ((\<lambda> (w__129 :: Architecture) . 
        (read_reg satp_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__130 ::  64 Word.word) . 
        (write_reg satp_ref ((legalize_satp w__129 w__130 value1  ::  64 Word.word)) \<then>
        (read_reg satp_ref  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__131 ::  64 Word.word) .  return (Some w__131)))))))
      else (ext_write_CSR csr value1  :: ( ( 64 Word.word)option) M)
   ) \<bind> ((\<lambda> (res ::  xlenbits option) . 
   return ((case  res of
     Some (v) =>
      if ((get_config_print_reg () )) then
        print_dbg
          (((@) (''CSR '')
              (((@) ((csr_name csr))
                  (((@) ('' <- '')
                      (((@) ((string_of_bits v))
                          (((@) ('' (input: '') (((@) ((string_of_bits value1)) ('')'')))))))))))))
      else () 
   | None => print_bits0 (''unhandled write to CSR '') csr
   )))))\<close> 
  for  csr  :: "(12)Word.word " 
  and  value1  :: "(64)Word.word "


\<comment> \<open>\<open>val maybe_i_forwards : bool -> string\<close>\<close>

\<comment> \<open>\<open>val maybe_i_backwards : string -> M bool\<close>\<close>

\<comment> \<open>\<open>val maybe_i_forwards_matches : bool -> bool\<close>\<close>

\<comment> \<open>\<open>val maybe_i_backwards_matches : string -> bool\<close>\<close>

\<comment> \<open>\<open>val maybe_i_matches_prefix : string -> maybe ((bool * ii))\<close>\<close>

fun maybe_i_forwards  :: \<open> bool \<Rightarrow> string \<close>  where 
     \<open> maybe_i_forwards True = ( (''i''))\<close>
|\<open> maybe_i_forwards False = ( (''''))\<close>


definition maybe_i_backwards  :: \<open> string \<Rightarrow>((register_value),(bool),(exception))monad \<close>  where 
     \<open> maybe_i_backwards arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''i'')))) then return True
   else if (((p00 = ('''')))) then return False
   else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))\<close> 
  for  arg1  :: " string "


fun maybe_i_forwards_matches  :: \<open> bool \<Rightarrow> bool \<close>  where 
     \<open> maybe_i_forwards_matches True = ( True )\<close>
|\<open> maybe_i_forwards_matches False = ( True )\<close>


definition maybe_i_backwards_matches  :: \<open> string \<Rightarrow> bool \<close>  where 
     \<open> maybe_i_backwards_matches arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''i'')))) then True
   else if (((p00 = ('''')))) then True
   else False))\<close> 
  for  arg1  :: " string "


\<comment> \<open>\<open>val _s1062_ : string -> maybe string\<close>\<close>

definition s1062  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s1062 s10630 = (
   (let s10640 = s10630 in
   if ((string_startswith s10640 (''''))) then  
  (case  ((string_drop s10640 ((string_length (''''))))) of   s1 => Some s1 )
   else None))\<close> 
  for  s10630  :: " string "


\<comment> \<open>\<open>val _s1058_ : string -> maybe string\<close>\<close>

definition s1058  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s1058 s10590 = (
   (let s10600 = s10590 in
   if ((string_startswith s10600 (''i''))) then  
  (case  ((string_drop s10600 ((string_length (''i''))))) of   s1 => Some s1 )
   else None))\<close> 
  for  s10590  :: " string "


definition maybe_i_matches_prefix  :: \<open> string \<Rightarrow>(bool*int)option \<close>  where 
     \<open> maybe_i_matches_prefix arg1 = (
   (let s10610 = arg1 in
   if ((case  ((s1058 s10610)) of   Some (s1) => True | _ => False )) then  
  (case  s1058 s10610 of
      (Some (s1)) =>
  Some (True, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s1062 s10610)) of   Some (s1) => True | _ => False )) then  
  (case  s1062 s10610 of
      (Some (s1)) =>
  Some (False, ((string_length arg1)) - ((string_length s1)))
  )
   else None))\<close> 
  for  arg1  :: " string "


\<comment> \<open>\<open>val csr_mnemonic_forwards : csrop -> string\<close>\<close>

\<comment> \<open>\<open>val csr_mnemonic_backwards : string -> M csrop\<close>\<close>

\<comment> \<open>\<open>val csr_mnemonic_forwards_matches : csrop -> bool\<close>\<close>

\<comment> \<open>\<open>val csr_mnemonic_backwards_matches : string -> bool\<close>\<close>

\<comment> \<open>\<open>val csr_mnemonic_matches_prefix : string -> maybe ((csrop * ii))\<close>\<close>

fun csr_mnemonic_forwards  :: \<open> csrop \<Rightarrow> string \<close>  where 
     \<open> csr_mnemonic_forwards CSRRW = ( (''csrrw''))\<close>
|\<open> csr_mnemonic_forwards CSRRS = ( (''csrrs''))\<close>
|\<open> csr_mnemonic_forwards CSRRC = ( (''csrrc''))\<close>


definition csr_mnemonic_backwards  :: \<open> string \<Rightarrow>((register_value),(csrop),(exception))monad \<close>  where 
     \<open> csr_mnemonic_backwards arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''csrrw'')))) then return CSRRW
   else if (((p00 = (''csrrs'')))) then return CSRRS
   else if (((p00 = (''csrrc'')))) then return CSRRC
   else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))\<close> 
  for  arg1  :: " string "


fun csr_mnemonic_forwards_matches  :: \<open> csrop \<Rightarrow> bool \<close>  where 
     \<open> csr_mnemonic_forwards_matches CSRRW = ( True )\<close>
|\<open> csr_mnemonic_forwards_matches CSRRS = ( True )\<close>
|\<open> csr_mnemonic_forwards_matches CSRRC = ( True )\<close>


definition csr_mnemonic_backwards_matches  :: \<open> string \<Rightarrow> bool \<close>  where 
     \<open> csr_mnemonic_backwards_matches arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''csrrw'')))) then True
   else if (((p00 = (''csrrs'')))) then True
   else if (((p00 = (''csrrc'')))) then True
   else False))\<close> 
  for  arg1  :: " string "


\<comment> \<open>\<open>val _s1074_ : string -> maybe string\<close>\<close>

definition s1074  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s1074 s10750 = (
   (let s10760 = s10750 in
   if ((string_startswith s10760 (''csrrc''))) then  
  (case  ((string_drop s10760 ((string_length (''csrrc''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s10750  :: " string "


\<comment> \<open>\<open>val _s1070_ : string -> maybe string\<close>\<close>

definition s1070  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s1070 s10710 = (
   (let s10720 = s10710 in
   if ((string_startswith s10720 (''csrrs''))) then  
  (case  ((string_drop s10720 ((string_length (''csrrs''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s10710  :: " string "


\<comment> \<open>\<open>val _s1066_ : string -> maybe string\<close>\<close>

definition s1066  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s1066 s10670 = (
   (let s10680 = s10670 in
   if ((string_startswith s10680 (''csrrw''))) then  
  (case  ((string_drop s10680 ((string_length (''csrrw''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s10670  :: " string "


definition csr_mnemonic_matches_prefix  :: \<open> string \<Rightarrow>(csrop*int)option \<close>  where 
     \<open> csr_mnemonic_matches_prefix arg1 = (
   (let s10690 = arg1 in
   if ((case  ((s1066 s10690)) of   Some (s1) => True | _ => False )) then  
  (case  s1066 s10690 of
      (Some (s1)) =>
  Some (CSRRW, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s1070 s10690)) of   Some (s1) => True | _ => False )) then  
  (case  s1070 s10690 of
      (Some (s1)) =>
  Some (CSRRS, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s1074 s10690)) of   Some (s1) => True | _ => False )) then  
  (case  s1074 s10690 of
      (Some (s1)) =>
  Some (CSRRC, ((string_length arg1)) - ((string_length s1)))
  )
   else None))\<close> 
  for  arg1  :: " string "


\<comment> \<open>\<open>val encdec_rounding_mode_forwards : rounding_mode -> mword ty3\<close>\<close>

\<comment> \<open>\<open>val encdec_rounding_mode_backwards : mword ty3 -> M rounding_mode\<close>\<close>

\<comment> \<open>\<open>val encdec_rounding_mode_forwards_matches : rounding_mode -> bool\<close>\<close>

\<comment> \<open>\<open>val encdec_rounding_mode_backwards_matches : mword ty3 -> bool\<close>\<close>

fun encdec_rounding_mode_forwards  :: \<open> rounding_mode \<Rightarrow>(3)Word.word \<close>  where 
     \<open> encdec_rounding_mode_forwards RM_RNE = ( ( 0b000 ::  3 Word.word))\<close>
|\<open> encdec_rounding_mode_forwards RM_RTZ = ( ( 0b001 ::  3 Word.word))\<close>
|\<open> encdec_rounding_mode_forwards RM_RDN = ( ( 0b010 ::  3 Word.word))\<close>
|\<open> encdec_rounding_mode_forwards RM_RUP = ( ( 0b011 ::  3 Word.word))\<close>
|\<open> encdec_rounding_mode_forwards RM_RMM = ( ( 0b100 ::  3 Word.word))\<close>
|\<open> encdec_rounding_mode_forwards RM_DYN = ( ( 0b111 ::  3 Word.word))\<close>


definition encdec_rounding_mode_backwards  :: \<open>(3)Word.word \<Rightarrow>((register_value),(rounding_mode),(exception))monad \<close>  where 
     \<open> encdec_rounding_mode_backwards arg1 = (
   (let b__0 = arg1 in
   if (((b__0 = ( 0b000 ::  3 Word.word)))) then return RM_RNE
   else if (((b__0 = ( 0b001 ::  3 Word.word)))) then return RM_RTZ
   else if (((b__0 = ( 0b010 ::  3 Word.word)))) then return RM_RDN
   else if (((b__0 = ( 0b011 ::  3 Word.word)))) then return RM_RUP
   else if (((b__0 = ( 0b100 ::  3 Word.word)))) then return RM_RMM
   else if (((b__0 = ( 0b111 ::  3 Word.word)))) then return RM_DYN
   else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))\<close> 
  for  arg1  :: "(3)Word.word "


fun encdec_rounding_mode_forwards_matches  :: \<open> rounding_mode \<Rightarrow> bool \<close>  where 
     \<open> encdec_rounding_mode_forwards_matches RM_RNE = ( True )\<close>
|\<open> encdec_rounding_mode_forwards_matches RM_RTZ = ( True )\<close>
|\<open> encdec_rounding_mode_forwards_matches RM_RDN = ( True )\<close>
|\<open> encdec_rounding_mode_forwards_matches RM_RUP = ( True )\<close>
|\<open> encdec_rounding_mode_forwards_matches RM_RMM = ( True )\<close>
|\<open> encdec_rounding_mode_forwards_matches RM_DYN = ( True )\<close>


definition encdec_rounding_mode_backwards_matches  :: \<open>(3)Word.word \<Rightarrow> bool \<close>  where 
     \<open> encdec_rounding_mode_backwards_matches arg1 = (
   (let b__0 = arg1 in
   if (((b__0 = ( 0b000 ::  3 Word.word)))) then True
   else if (((b__0 = ( 0b001 ::  3 Word.word)))) then True
   else if (((b__0 = ( 0b010 ::  3 Word.word)))) then True
   else if (((b__0 = ( 0b011 ::  3 Word.word)))) then True
   else if (((b__0 = ( 0b100 ::  3 Word.word)))) then True
   else if (((b__0 = ( 0b111 ::  3 Word.word)))) then True
   else False))\<close> 
  for  arg1  :: "(3)Word.word "


\<comment> \<open>\<open>val frm_mnemonic_forwards : rounding_mode -> string\<close>\<close>

\<comment> \<open>\<open>val frm_mnemonic_backwards : string -> M rounding_mode\<close>\<close>

\<comment> \<open>\<open>val frm_mnemonic_forwards_matches : rounding_mode -> bool\<close>\<close>

\<comment> \<open>\<open>val frm_mnemonic_backwards_matches : string -> bool\<close>\<close>

\<comment> \<open>\<open>val frm_mnemonic_matches_prefix : string -> maybe ((rounding_mode * ii))\<close>\<close>

fun frm_mnemonic_forwards  :: \<open> rounding_mode \<Rightarrow> string \<close>  where 
     \<open> frm_mnemonic_forwards RM_RNE = ( (''rne''))\<close>
|\<open> frm_mnemonic_forwards RM_RTZ = ( (''rtz''))\<close>
|\<open> frm_mnemonic_forwards RM_RDN = ( (''rdn''))\<close>
|\<open> frm_mnemonic_forwards RM_RUP = ( (''rup''))\<close>
|\<open> frm_mnemonic_forwards RM_RMM = ( (''rmm''))\<close>
|\<open> frm_mnemonic_forwards RM_DYN = ( (''dyn''))\<close>


definition frm_mnemonic_backwards  :: \<open> string \<Rightarrow>((register_value),(rounding_mode),(exception))monad \<close>  where 
     \<open> frm_mnemonic_backwards arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''rne'')))) then return RM_RNE
   else if (((p00 = (''rtz'')))) then return RM_RTZ
   else if (((p00 = (''rdn'')))) then return RM_RDN
   else if (((p00 = (''rup'')))) then return RM_RUP
   else if (((p00 = (''rmm'')))) then return RM_RMM
   else if (((p00 = (''dyn'')))) then return RM_DYN
   else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))\<close> 
  for  arg1  :: " string "


fun frm_mnemonic_forwards_matches  :: \<open> rounding_mode \<Rightarrow> bool \<close>  where 
     \<open> frm_mnemonic_forwards_matches RM_RNE = ( True )\<close>
|\<open> frm_mnemonic_forwards_matches RM_RTZ = ( True )\<close>
|\<open> frm_mnemonic_forwards_matches RM_RDN = ( True )\<close>
|\<open> frm_mnemonic_forwards_matches RM_RUP = ( True )\<close>
|\<open> frm_mnemonic_forwards_matches RM_RMM = ( True )\<close>
|\<open> frm_mnemonic_forwards_matches RM_DYN = ( True )\<close>


definition frm_mnemonic_backwards_matches  :: \<open> string \<Rightarrow> bool \<close>  where 
     \<open> frm_mnemonic_backwards_matches arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''rne'')))) then True
   else if (((p00 = (''rtz'')))) then True
   else if (((p00 = (''rdn'')))) then True
   else if (((p00 = (''rup'')))) then True
   else if (((p00 = (''rmm'')))) then True
   else if (((p00 = (''dyn'')))) then True
   else False))\<close> 
  for  arg1  :: " string "


\<comment> \<open>\<open>val _s1098_ : string -> maybe string\<close>\<close>

definition s1098  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s1098 s10990 = (
   (let s11000 = s10990 in
   if ((string_startswith s11000 (''dyn''))) then  
  (case  ((string_drop s11000 ((string_length (''dyn''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s10990  :: " string "


\<comment> \<open>\<open>val _s1094_ : string -> maybe string\<close>\<close>

definition s1094  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s1094 s10950 = (
   (let s10960 = s10950 in
   if ((string_startswith s10960 (''rmm''))) then  
  (case  ((string_drop s10960 ((string_length (''rmm''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s10950  :: " string "


\<comment> \<open>\<open>val _s1090_ : string -> maybe string\<close>\<close>

definition s1090  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s1090 s10910 = (
   (let s10920 = s10910 in
   if ((string_startswith s10920 (''rup''))) then  
  (case  ((string_drop s10920 ((string_length (''rup''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s10910  :: " string "


\<comment> \<open>\<open>val _s1086_ : string -> maybe string\<close>\<close>

definition s1086  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s1086 s10870 = (
   (let s10880 = s10870 in
   if ((string_startswith s10880 (''rdn''))) then  
  (case  ((string_drop s10880 ((string_length (''rdn''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s10870  :: " string "


\<comment> \<open>\<open>val _s1082_ : string -> maybe string\<close>\<close>

definition s1082  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s1082 s10830 = (
   (let s10840 = s10830 in
   if ((string_startswith s10840 (''rtz''))) then  
  (case  ((string_drop s10840 ((string_length (''rtz''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s10830  :: " string "


\<comment> \<open>\<open>val _s1078_ : string -> maybe string\<close>\<close>

definition s1078  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s1078 s10790 = (
   (let s10800 = s10790 in
   if ((string_startswith s10800 (''rne''))) then  
  (case  ((string_drop s10800 ((string_length (''rne''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s10790  :: " string "


definition frm_mnemonic_matches_prefix  :: \<open> string \<Rightarrow>(rounding_mode*int)option \<close>  where 
     \<open> frm_mnemonic_matches_prefix arg1 = (
   (let s10810 = arg1 in
   if ((case  ((s1078 s10810)) of   Some (s1) => True | _ => False )) then  
  (case  s1078 s10810 of
      (Some (s1)) =>
  Some (RM_RNE, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s1082 s10810)) of   Some (s1) => True | _ => False )) then  
  (case  s1082 s10810 of
      (Some (s1)) =>
  Some (RM_RTZ, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s1086 s10810)) of   Some (s1) => True | _ => False )) then  
  (case  s1086 s10810 of
      (Some (s1)) =>
  Some (RM_RDN, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s1090 s10810)) of   Some (s1) => True | _ => False )) then  
  (case  s1090 s10810 of
      (Some (s1)) =>
  Some (RM_RUP, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s1094 s10810)) of   Some (s1) => True | _ => False )) then  
  (case  s1094 s10810 of
      (Some (s1)) =>
  Some (RM_RMM, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s1098 s10810)) of   Some (s1) => True | _ => False )) then  
  (case  s1098 s10810 of
      (Some (s1)) =>
  Some (RM_DYN, ((string_length arg1)) - ((string_length s1)))
  )
   else None))\<close> 
  for  arg1  :: " string "


\<comment> \<open>\<open>val select_instr_or_fcsr_rm : rounding_mode -> M rounding_mode\<close>\<close>

definition select_instr_or_fcsr_rm  :: \<open> rounding_mode \<Rightarrow>((register_value),(rounding_mode),(exception))monad \<close>  where 
     \<open> select_instr_or_fcsr_rm instr_rm = (
   if (((instr_rm = RM_DYN))) then
     read_reg fcsr_ref \<bind> ((\<lambda> (w__0 :: Fcsr) . 
     encdec_rounding_mode_backwards ((get_Fcsr_FRM w__0  ::  3 Word.word))))
   else return instr_rm )\<close> 
  for  instr_rm  :: " rounding_mode "


\<comment> \<open>\<open>val nxFlag : unit -> mword ty5\<close>\<close>

definition nxFlag  :: \<open> unit \<Rightarrow>(5)Word.word \<close>  where 
     \<open> nxFlag _ = ( ( 0b00001 ::  5 Word.word))\<close>


\<comment> \<open>\<open>val ufFlag : unit -> mword ty5\<close>\<close>

definition ufFlag  :: \<open> unit \<Rightarrow>(5)Word.word \<close>  where 
     \<open> ufFlag _ = ( ( 0b00010 ::  5 Word.word))\<close>


\<comment> \<open>\<open>val ofFlag : unit -> mword ty5\<close>\<close>

definition ofFlag  :: \<open> unit \<Rightarrow>(5)Word.word \<close>  where 
     \<open> ofFlag _ = ( ( 0b00100 ::  5 Word.word))\<close>


\<comment> \<open>\<open>val dzFlag : unit -> mword ty5\<close>\<close>

definition dzFlag  :: \<open> unit \<Rightarrow>(5)Word.word \<close>  where 
     \<open> dzFlag _ = ( ( 0b01000 ::  5 Word.word))\<close>


\<comment> \<open>\<open>val nvFlag : unit -> mword ty5\<close>\<close>

definition nvFlag  :: \<open> unit \<Rightarrow>(5)Word.word \<close>  where 
     \<open> nvFlag _ = ( ( 0b10000 ::  5 Word.word))\<close>


\<comment> \<open>\<open>val fsplit_S : mword ty32 -> (mword ty1 * mword ty8 * mword ty23)\<close>\<close>

definition fsplit_S  :: \<open>(32)Word.word \<Rightarrow>(1)Word.word*(8)Word.word*(23)Word.word \<close>  where 
     \<open> fsplit_S x32 = (
   ((subrange_vec_dec x32 (( 31 :: int)::ii) (( 31 :: int)::ii)  ::  1 Word.word),
    (subrange_vec_dec x32 (( 30 :: int)::ii) (( 23 :: int)::ii)  ::  8 Word.word),
    (subrange_vec_dec x32 (( 22 :: int)::ii) (( 0 :: int)::ii)  ::  23 Word.word)))\<close> 
  for  x32  :: "(32)Word.word "


\<comment> \<open>\<open>val fmake_S : mword ty1 -> mword ty8 -> mword ty23 -> mword ty32\<close>\<close>

definition fmake_S  :: \<open>(1)Word.word \<Rightarrow>(8)Word.word \<Rightarrow>(23)Word.word \<Rightarrow>(32)Word.word \<close>  where 
     \<open> fmake_S sign exp1 mant = ( (concat_vec sign ((concat_vec exp1 mant  ::  31 Word.word))  ::  32 Word.word))\<close> 
  for  sign  :: "(1)Word.word " 
  and  exp1  :: "(8)Word.word " 
  and  mant  :: "(23)Word.word "


\<comment> \<open>\<open>val canonical_NaN_S : unit -> mword ty32\<close>\<close>

definition canonical_NaN_S  :: \<open> unit \<Rightarrow>(32)Word.word \<close>  where 
     \<open> canonical_NaN_S _ = ( ( 0x7FC00000 ::  32 Word.word))\<close>


\<comment> \<open>\<open>val f_is_neg_inf_S : mword ty32 -> bool\<close>\<close>

definition f_is_neg_inf_S  :: \<open>(32)Word.word \<Rightarrow> bool \<close>  where 
     \<open> f_is_neg_inf_S x32 = (
   (let (sign, exp1, mant) = ((fsplit_S x32  :: ( 1 Word.word *  8 Word.word *  23 Word.word))) in
   ((((sign = ( 0b1 ::  1 Word.word)))) \<and> ((((((exp1 = ((ones (( 8 :: int)::ii)  ::  8 Word.word))))) \<and> (((mant = ((zeros_implicit (( 23 :: int)::ii)  ::  23 Word.word)))))))))))\<close> 
  for  x32  :: "(32)Word.word "


\<comment> \<open>\<open>val f_is_neg_norm_S : mword ty32 -> bool\<close>\<close>

definition f_is_neg_norm_S  :: \<open>(32)Word.word \<Rightarrow> bool \<close>  where 
     \<open> f_is_neg_norm_S x32 = (
   (let (sign, exp1, mant) = ((fsplit_S x32  :: ( 1 Word.word *  8 Word.word *  23 Word.word))) in
   ((((sign = ( 0b1 ::  1 Word.word)))) \<and> ((((((exp1 \<noteq> ((zeros_implicit (( 8 :: int)::ii)  ::  8 Word.word))))) \<and> (((exp1 \<noteq> ((ones (( 8 :: int)::ii)  ::  8 Word.word)))))))))))\<close> 
  for  x32  :: "(32)Word.word "


\<comment> \<open>\<open>val f_is_neg_subnorm_S : mword ty32 -> bool\<close>\<close>

definition f_is_neg_subnorm_S  :: \<open>(32)Word.word \<Rightarrow> bool \<close>  where 
     \<open> f_is_neg_subnorm_S x32 = (
   (let (sign, exp1, mant) = ((fsplit_S x32  :: ( 1 Word.word *  8 Word.word *  23 Word.word))) in
   ((((sign = ( 0b1 ::  1 Word.word)))) \<and> ((((((exp1 = ((zeros_implicit (( 8 :: int)::ii)  ::  8 Word.word))))) \<and> (((mant \<noteq> ((zeros_implicit (( 23 :: int)::ii)  ::  23 Word.word)))))))))))\<close> 
  for  x32  :: "(32)Word.word "


\<comment> \<open>\<open>val f_is_neg_zero_S : mword ty32 -> bool\<close>\<close>

definition f_is_neg_zero_S  :: \<open>(32)Word.word \<Rightarrow> bool \<close>  where 
     \<open> f_is_neg_zero_S x32 = (
   (let (sign, exp1, mant) = ((fsplit_S x32  :: ( 1 Word.word *  8 Word.word *  23 Word.word))) in
   ((((sign = ((ones (( 1 :: int)::ii)  ::  1 Word.word))))) \<and> ((((((exp1 = ((zeros_implicit (( 8 :: int)::ii)  ::  8 Word.word))))) \<and> (((mant = ((zeros_implicit (( 23 :: int)::ii)  ::  23 Word.word)))))))))))\<close> 
  for  x32  :: "(32)Word.word "


\<comment> \<open>\<open>val f_is_pos_zero_S : mword ty32 -> bool\<close>\<close>

definition f_is_pos_zero_S  :: \<open>(32)Word.word \<Rightarrow> bool \<close>  where 
     \<open> f_is_pos_zero_S x32 = (
   (let (sign, exp1, mant) = ((fsplit_S x32  :: ( 1 Word.word *  8 Word.word *  23 Word.word))) in
   ((((sign = ((zeros_implicit (( 1 :: int)::ii)  ::  1 Word.word))))) \<and> ((((((exp1 = ((zeros_implicit (( 8 :: int)::ii)  ::  8 Word.word))))) \<and> (((mant = ((zeros_implicit (( 23 :: int)::ii)  ::  23 Word.word)))))))))))\<close> 
  for  x32  :: "(32)Word.word "


\<comment> \<open>\<open>val f_is_pos_subnorm_S : mword ty32 -> bool\<close>\<close>

definition f_is_pos_subnorm_S  :: \<open>(32)Word.word \<Rightarrow> bool \<close>  where 
     \<open> f_is_pos_subnorm_S x32 = (
   (let (sign, exp1, mant) = ((fsplit_S x32  :: ( 1 Word.word *  8 Word.word *  23 Word.word))) in
   ((((sign = ((zeros_implicit (( 1 :: int)::ii)  ::  1 Word.word))))) \<and> ((((((exp1 = ((zeros_implicit (( 8 :: int)::ii)  ::  8 Word.word))))) \<and> (((mant \<noteq> ((zeros_implicit (( 23 :: int)::ii)  ::  23 Word.word)))))))))))\<close> 
  for  x32  :: "(32)Word.word "


\<comment> \<open>\<open>val f_is_pos_norm_S : mword ty32 -> bool\<close>\<close>

definition f_is_pos_norm_S  :: \<open>(32)Word.word \<Rightarrow> bool \<close>  where 
     \<open> f_is_pos_norm_S x32 = (
   (let (sign, exp1, mant) = ((fsplit_S x32  :: ( 1 Word.word *  8 Word.word *  23 Word.word))) in
   ((((sign = ((zeros_implicit (( 1 :: int)::ii)  ::  1 Word.word))))) \<and> ((((((exp1 \<noteq> ((zeros_implicit (( 8 :: int)::ii)  ::  8 Word.word))))) \<and> (((exp1 \<noteq> ((ones (( 8 :: int)::ii)  ::  8 Word.word)))))))))))\<close> 
  for  x32  :: "(32)Word.word "


\<comment> \<open>\<open>val f_is_pos_inf_S : mword ty32 -> bool\<close>\<close>

definition f_is_pos_inf_S  :: \<open>(32)Word.word \<Rightarrow> bool \<close>  where 
     \<open> f_is_pos_inf_S x32 = (
   (let (sign, exp1, mant) = ((fsplit_S x32  :: ( 1 Word.word *  8 Word.word *  23 Word.word))) in
   ((((sign = ((zeros_implicit (( 1 :: int)::ii)  ::  1 Word.word))))) \<and> ((((((exp1 = ((ones (( 8 :: int)::ii)  ::  8 Word.word))))) \<and> (((mant = ((zeros_implicit (( 23 :: int)::ii)  ::  23 Word.word)))))))))))\<close> 
  for  x32  :: "(32)Word.word "


\<comment> \<open>\<open>val f_is_SNaN_S : mword ty32 -> bool\<close>\<close>

definition f_is_SNaN_S  :: \<open>(32)Word.word \<Rightarrow> bool \<close>  where 
     \<open> f_is_SNaN_S x32 = (
   (let (sign, exp1, mant) = ((fsplit_S x32  :: ( 1 Word.word *  8 Word.word *  23 Word.word))) in
   ((((exp1 = ((ones (( 8 :: int)::ii)  ::  8 Word.word))))) \<and> ((((((((access_vec_dec mant (( 22 :: int)::ii))) = B0))) \<and> (((mant \<noteq> ((zeros_implicit (( 23 :: int)::ii)  ::  23 Word.word)))))))))))\<close> 
  for  x32  :: "(32)Word.word "


\<comment> \<open>\<open>val f_is_QNaN_S : mword ty32 -> bool\<close>\<close>

definition f_is_QNaN_S  :: \<open>(32)Word.word \<Rightarrow> bool \<close>  where 
     \<open> f_is_QNaN_S x32 = (
   (let (sign, exp1, mant) = ((fsplit_S x32  :: ( 1 Word.word *  8 Word.word *  23 Word.word))) in
   ((((exp1 = ((ones (( 8 :: int)::ii)  ::  8 Word.word))))) \<and> (((((access_vec_dec mant (( 22 :: int)::ii))) = B1))))))\<close> 
  for  x32  :: "(32)Word.word "


\<comment> \<open>\<open>val f_is_NaN_S : mword ty32 -> bool\<close>\<close>

definition f_is_NaN_S  :: \<open>(32)Word.word \<Rightarrow> bool \<close>  where 
     \<open> f_is_NaN_S x32 = (
   (let (sign, exp1, mant) = ((fsplit_S x32  :: ( 1 Word.word *  8 Word.word *  23 Word.word))) in
   ((((exp1 = ((ones (( 8 :: int)::ii)  ::  8 Word.word))))) \<and> (((mant \<noteq> ((zeros_implicit (( 23 :: int)::ii)  ::  23 Word.word))))))))\<close> 
  for  x32  :: "(32)Word.word "


\<comment> \<open>\<open>val negate_S : mword ty32 -> mword ty32\<close>\<close>

definition negate_S  :: \<open>(32)Word.word \<Rightarrow>(32)Word.word \<close>  where 
     \<open> negate_S x32 = (
   (let (sign, exp1, mant) = ((fsplit_S x32  :: ( 1 Word.word *  8 Word.word *  23 Word.word))) in
   (let new_sign = (if (((sign = ( 0b0 ::  1 Word.word)))) then ( 0b1 ::  1 Word.word) else ( 0b0 ::  1 Word.word)) in
   (fmake_S new_sign exp1 mant  ::  32 Word.word))))\<close> 
  for  x32  :: "(32)Word.word "


\<comment> \<open>\<open>val feq_quiet_S : mword ty32 -> mword ty32 -> (bool * mword ty5)\<close>\<close>

definition feq_quiet_S  :: \<open>(32)Word.word \<Rightarrow>(32)Word.word \<Rightarrow> bool*(5)Word.word \<close>  where 
     \<open> feq_quiet_S v1 v2 = (
   (let (s1, e1, m1) = ((fsplit_S v1  :: ( 1 Word.word *  8 Word.word *  23 Word.word))) in
   (let (s2, e2, m2) = ((fsplit_S v2  :: ( 1 Word.word *  8 Word.word *  23 Word.word))) in
   (let v1Is0 = (((f_is_neg_zero_S v1)) \<or> ((f_is_pos_zero_S v1))) in
   (let v2Is0 = (((f_is_neg_zero_S v2)) \<or> ((f_is_pos_zero_S v2))) in
   (let result = ((((v1 = v2))) \<or> (((v1Is0 \<and> v2Is0)))) in
   (let fflags =
     (if (((((f_is_SNaN_S v1)) \<or> ((f_is_SNaN_S v2))))) then (nvFlag ()   ::  5 Word.word)
     else (zeros_implicit (( 5 :: int)::ii)  ::  5 Word.word)) in
   (result, fflags))))))))\<close> 
  for  v1  :: "(32)Word.word " 
  and  v2  :: "(32)Word.word "


\<comment> \<open>\<open>val flt_S : mword ty32 -> mword ty32 -> bool -> (bool * mword ty5)\<close>\<close>

definition flt_S  :: \<open>(32)Word.word \<Rightarrow>(32)Word.word \<Rightarrow> bool \<Rightarrow> bool*(5)Word.word \<close>  where 
     \<open> flt_S v1 v2 is_quiet = (
   (let (s1, e1, m1) = ((fsplit_S v1  :: ( 1 Word.word *  8 Word.word *  23 Word.word))) in
   (let (s2, e2, m2) = ((fsplit_S v2  :: ( 1 Word.word *  8 Word.word *  23 Word.word))) in
   (let (result :: bool) =
     (if ((((((s1 = ( 0b0 ::  1 Word.word)))) \<and> (((s2 = ( 0b0 ::  1 Word.word))))))) then
       if (((e1 = e2))) then ((Word.uint m1)) < ((Word.uint m2))
       else ((Word.uint e1)) < ((Word.uint e2))
     else if ((((((s1 = ( 0b0 ::  1 Word.word)))) \<and> (((s2 = ( 0b1 ::  1 Word.word))))))) then False
     else if ((((((s1 = ( 0b1 ::  1 Word.word)))) \<and> (((s2 = ( 0b0 ::  1 Word.word))))))) then True
     else if (((e1 = e2))) then ((Word.uint m1)) > ((Word.uint m2))
     else ((Word.uint e1)) > ((Word.uint e2))) in
   (let fflags =
     (if is_quiet then
       if (((((f_is_SNaN_S v1)) \<or> ((f_is_SNaN_S v2))))) then (nvFlag ()   ::  5 Word.word)
       else (zeros_implicit (( 5 :: int)::ii)  ::  5 Word.word)
     else if (((((f_is_NaN_S v1)) \<or> ((f_is_NaN_S v2))))) then (nvFlag ()   ::  5 Word.word)
     else (zeros_implicit (( 5 :: int)::ii)  ::  5 Word.word)) in
   (result, fflags))))))\<close> 
  for  v1  :: "(32)Word.word " 
  and  v2  :: "(32)Word.word " 
  and  is_quiet  :: " bool "


\<comment> \<open>\<open>val fle_S : mword ty32 -> mword ty32 -> bool -> (bool * mword ty5)\<close>\<close>

definition fle_S  :: \<open>(32)Word.word \<Rightarrow>(32)Word.word \<Rightarrow> bool \<Rightarrow> bool*(5)Word.word \<close>  where 
     \<open> fle_S v1 v2 is_quiet = (
   (let (s1, e1, m1) = ((fsplit_S v1  :: ( 1 Word.word *  8 Word.word *  23 Word.word))) in
   (let (s2, e2, m2) = ((fsplit_S v2  :: ( 1 Word.word *  8 Word.word *  23 Word.word))) in
   (let v1Is0 = (((f_is_neg_zero_S v1)) \<or> ((f_is_pos_zero_S v1))) in
   (let v2Is0 = (((f_is_neg_zero_S v2)) \<or> ((f_is_pos_zero_S v2))) in
   (let (result :: bool) =
     (if ((((((s1 = ( 0b0 ::  1 Word.word)))) \<and> (((s2 = ( 0b0 ::  1 Word.word))))))) then
       if (((e1 = e2))) then ((Word.uint m1)) \<le> ((Word.uint m2))
       else ((Word.uint e1)) < ((Word.uint e2))
     else if ((((((s1 = ( 0b0 ::  1 Word.word)))) \<and> (((s2 = ( 0b1 ::  1 Word.word))))))) then
       (v1Is0 \<and> v2Is0)
     else if ((((((s1 = ( 0b1 ::  1 Word.word)))) \<and> (((s2 = ( 0b0 ::  1 Word.word))))))) then True
     else if (((e1 = e2))) then ((Word.uint m1)) \<ge> ((Word.uint m2))
     else ((Word.uint e1)) > ((Word.uint e2))) in
   (let fflags =
     (if is_quiet then
       if (((((f_is_SNaN_S v1)) \<or> ((f_is_SNaN_S v2))))) then (nvFlag ()   ::  5 Word.word)
       else (zeros_implicit (( 5 :: int)::ii)  ::  5 Word.word)
     else if (((((f_is_NaN_S v1)) \<or> ((f_is_NaN_S v2))))) then (nvFlag ()   ::  5 Word.word)
     else (zeros_implicit (( 5 :: int)::ii)  ::  5 Word.word)) in
   (result, fflags))))))))\<close> 
  for  v1  :: "(32)Word.word " 
  and  v2  :: "(32)Word.word " 
  and  is_quiet  :: " bool "


\<comment> \<open>\<open>val nan_box : mword ty32 -> mword ty64\<close>\<close>

definition nan_box  :: \<open>(32)Word.word \<Rightarrow>(64)Word.word \<close>  where 
     \<open> nan_box val_32b = ( (concat_vec ( 0xFFFFFFFF ::  32 Word.word) val_32b  ::  64 Word.word))\<close> 
  for  val_32b  :: "(32)Word.word "


\<comment> \<open>\<open>val nan_unbox : mword ty64 -> mword ty32\<close>\<close>

definition nan_unbox  :: \<open>(64)Word.word \<Rightarrow>(32)Word.word \<close>  where 
     \<open> nan_unbox regval = (
   if (((((subrange_vec_dec regval (( 63 :: int)::ii) (( 32 :: int)::ii)  ::  32 Word.word)) = ( 0xFFFFFFFF ::  32 Word.word))))
   then
     (subrange_vec_dec regval (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)
   else (canonical_NaN_S ()   ::  32 Word.word))\<close> 
  for  regval  :: "(64)Word.word "


\<comment> \<open>\<open>val is_RV32F_or_RV64F : unit -> M bool\<close>\<close>

definition is_RV32F_or_RV64F  :: \<open> unit \<Rightarrow>((register_value),(bool),(exception))monad \<close>  where 
     \<open> is_RV32F_or_RV64F _ = (
   and_boolM ((haveFExt () )) (return (((((((( 64 :: int)::ii) = (( 32 :: int)::ii)))) \<or> ((((( 64 :: int)::ii) = (( 64 :: int)::ii)))))))))\<close>


\<comment> \<open>\<open>val is_RV64F : unit -> M bool\<close>\<close>

definition is_RV64F  :: \<open> unit \<Rightarrow>((register_value),(bool),(exception))monad \<close>  where 
     \<open> is_RV64F _ = ( and_boolM ((haveFExt () )) (return ((((( 64 :: int)::ii) = (( 64 :: int)::ii))))))\<close>


\<comment> \<open>\<open>val is_RV32D_or_RV64D : unit -> M bool\<close>\<close>

definition is_RV32D_or_RV64D  :: \<open> unit \<Rightarrow>((register_value),(bool),(exception))monad \<close>  where 
     \<open> is_RV32D_or_RV64D _ = (
   and_boolM ((haveDExt () )) (return (((((((( 64 :: int)::ii) = (( 32 :: int)::ii)))) \<or> ((((( 64 :: int)::ii) = (( 64 :: int)::ii)))))))))\<close>


\<comment> \<open>\<open>val is_RV64D : unit -> M bool\<close>\<close>

definition is_RV64D  :: \<open> unit \<Rightarrow>((register_value),(bool),(exception))monad \<close>  where 
     \<open> is_RV64D _ = ( and_boolM ((haveDExt () )) (return ((((( 64 :: int)::ii) = (( 64 :: int)::ii))))))\<close>


\<comment> \<open>\<open>val process_fload64 : mword ty5 -> mword ty64 -> MemoryOpResult (mword ty64) -> M Retired\<close>\<close>

fun process_fload64  :: \<open>(5)Word.word \<Rightarrow>(64)Word.word \<Rightarrow>((64)Word.word)MemoryOpResult \<Rightarrow>((register_value),(Retired),(exception))monad \<close>  where 
     \<open> process_fload64 rd addr (MemValue (result)) = ( wF_bits rd result \<then> return RETIRE_SUCCESS )\<close> 
  for  rd  :: "(5)Word.word " 
  and  addr  :: "(64)Word.word " 
  and  result  :: "(64)Word.word "
|\<open> process_fload64 rd addr (MemException (e)) = ( handle_mem_exception addr e \<then> return RETIRE_FAIL )\<close> 
  for  rd  :: "(5)Word.word " 
  and  addr  :: "(64)Word.word " 
  and  e  :: " ExceptionType "


\<comment> \<open>\<open>val process_fload32 : mword ty5 -> mword ty64 -> MemoryOpResult (mword ty32) -> M Retired\<close>\<close>

fun process_fload32  :: \<open>(5)Word.word \<Rightarrow>(64)Word.word \<Rightarrow>((32)Word.word)MemoryOpResult \<Rightarrow>((register_value),(Retired),(exception))monad \<close>  where 
     \<open> process_fload32 rd addr (MemValue (result)) = ( wF_bits rd ((nan_box result  ::  64 Word.word)) \<then> return RETIRE_SUCCESS )\<close> 
  for  rd  :: "(5)Word.word " 
  and  addr  :: "(64)Word.word " 
  and  result  :: "(32)Word.word "
|\<open> process_fload32 rd addr (MemException (e)) = ( handle_mem_exception addr e \<then> return RETIRE_FAIL )\<close> 
  for  rd  :: "(5)Word.word " 
  and  addr  :: "(64)Word.word " 
  and  e  :: " ExceptionType "


\<comment> \<open>\<open>val process_fstore : mword ty64 -> MemoryOpResult bool -> M Retired\<close>\<close>

fun process_fstore  :: \<open>(64)Word.word \<Rightarrow>(bool)MemoryOpResult \<Rightarrow>((register_value),(Retired),(exception))monad \<close>  where 
     \<open> process_fstore vaddr (MemValue (True)) = ( return RETIRE_SUCCESS )\<close> 
  for  vaddr  :: "(64)Word.word "
|\<open> process_fstore vaddr (MemValue (False)) = ( internal_error (''store got false from mem_write_value''))\<close> 
  for  vaddr  :: "(64)Word.word "
|\<open> process_fstore vaddr (MemException (e)) = ( handle_mem_exception vaddr e \<then> return RETIRE_FAIL )\<close> 
  for  vaddr  :: "(64)Word.word " 
  and  e  :: " ExceptionType "


\<comment> \<open>\<open>val f_madd_type_mnemonic_S_forwards : f_madd_op_S -> string\<close>\<close>

\<comment> \<open>\<open>val f_madd_type_mnemonic_S_backwards : string -> M f_madd_op_S\<close>\<close>

\<comment> \<open>\<open>val f_madd_type_mnemonic_S_forwards_matches : f_madd_op_S -> bool\<close>\<close>

\<comment> \<open>\<open>val f_madd_type_mnemonic_S_backwards_matches : string -> bool\<close>\<close>

\<comment> \<open>\<open>val f_madd_type_mnemonic_S_matches_prefix : string -> maybe ((f_madd_op_S * ii))\<close>\<close>

fun f_madd_type_mnemonic_S_forwards  :: \<open> f_madd_op_S \<Rightarrow> string \<close>  where 
     \<open> f_madd_type_mnemonic_S_forwards FMADD_S = ( (''fmadd.s''))\<close>
|\<open> f_madd_type_mnemonic_S_forwards FMSUB_S = ( (''fmsub.s''))\<close>
|\<open> f_madd_type_mnemonic_S_forwards FNMSUB_S = ( (''fnmsub.s''))\<close>
|\<open> f_madd_type_mnemonic_S_forwards FNMADD_S = ( (''fnmadd.s''))\<close>


definition f_madd_type_mnemonic_S_backwards  :: \<open> string \<Rightarrow>((register_value),(f_madd_op_S),(exception))monad \<close>  where 
     \<open> f_madd_type_mnemonic_S_backwards arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''fmadd.s'')))) then return FMADD_S
   else if (((p00 = (''fmsub.s'')))) then return FMSUB_S
   else if (((p00 = (''fnmsub.s'')))) then return FNMSUB_S
   else if (((p00 = (''fnmadd.s'')))) then return FNMADD_S
   else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))\<close> 
  for  arg1  :: " string "


fun f_madd_type_mnemonic_S_forwards_matches  :: \<open> f_madd_op_S \<Rightarrow> bool \<close>  where 
     \<open> f_madd_type_mnemonic_S_forwards_matches FMADD_S = ( True )\<close>
|\<open> f_madd_type_mnemonic_S_forwards_matches FMSUB_S = ( True )\<close>
|\<open> f_madd_type_mnemonic_S_forwards_matches FNMSUB_S = ( True )\<close>
|\<open> f_madd_type_mnemonic_S_forwards_matches FNMADD_S = ( True )\<close>


definition f_madd_type_mnemonic_S_backwards_matches  :: \<open> string \<Rightarrow> bool \<close>  where 
     \<open> f_madd_type_mnemonic_S_backwards_matches arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''fmadd.s'')))) then True
   else if (((p00 = (''fmsub.s'')))) then True
   else if (((p00 = (''fnmsub.s'')))) then True
   else if (((p00 = (''fnmadd.s'')))) then True
   else False))\<close> 
  for  arg1  :: " string "


\<comment> \<open>\<open>val _s1114_ : string -> maybe string\<close>\<close>

definition s1114  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s1114 s11150 = (
   (let s11160 = s11150 in
   if ((string_startswith s11160 (''fnmadd.s''))) then  
  (case  ((string_drop s11160 ((string_length (''fnmadd.s''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s11150  :: " string "


\<comment> \<open>\<open>val _s1110_ : string -> maybe string\<close>\<close>

definition s1110  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s1110 s11110 = (
   (let s11120 = s11110 in
   if ((string_startswith s11120 (''fnmsub.s''))) then  
  (case  ((string_drop s11120 ((string_length (''fnmsub.s''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s11110  :: " string "


\<comment> \<open>\<open>val _s1106_ : string -> maybe string\<close>\<close>

definition s1106  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s1106 s11070 = (
   (let s11080 = s11070 in
   if ((string_startswith s11080 (''fmsub.s''))) then  
  (case  ((string_drop s11080 ((string_length (''fmsub.s''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s11070  :: " string "


\<comment> \<open>\<open>val _s1102_ : string -> maybe string\<close>\<close>

definition s1102  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s1102 s11030 = (
   (let s11040 = s11030 in
   if ((string_startswith s11040 (''fmadd.s''))) then  
  (case  ((string_drop s11040 ((string_length (''fmadd.s''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s11030  :: " string "


definition f_madd_type_mnemonic_S_matches_prefix  :: \<open> string \<Rightarrow>(f_madd_op_S*int)option \<close>  where 
     \<open> f_madd_type_mnemonic_S_matches_prefix arg1 = (
   (let s11050 = arg1 in
   if ((case  ((s1102 s11050)) of   Some (s1) => True | _ => False )) then  
  (case  s1102 s11050 of
      (Some (s1)) =>
  Some (FMADD_S, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s1106 s11050)) of   Some (s1) => True | _ => False )) then  
  (case  s1106 s11050 of
      (Some (s1)) =>
  Some (FMSUB_S, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s1110 s11050)) of   Some (s1) => True | _ => False )) then  
  (case  s1110 s11050 of
      (Some (s1)) =>
  Some (FNMSUB_S, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s1114 s11050)) of   Some (s1) => True | _ => False )) then  
  (case  s1114 s11050 of
      (Some (s1)) =>
  Some (FNMADD_S, ((string_length arg1)) - ((string_length s1)))
  )
   else None))\<close> 
  for  arg1  :: " string "


\<comment> \<open>\<open>val f_bin_rm_type_mnemonic_S_forwards : f_bin_rm_op_S -> string\<close>\<close>

\<comment> \<open>\<open>val f_bin_rm_type_mnemonic_S_backwards : string -> M f_bin_rm_op_S\<close>\<close>

\<comment> \<open>\<open>val f_bin_rm_type_mnemonic_S_forwards_matches : f_bin_rm_op_S -> bool\<close>\<close>

\<comment> \<open>\<open>val f_bin_rm_type_mnemonic_S_backwards_matches : string -> bool\<close>\<close>

\<comment> \<open>\<open>val f_bin_rm_type_mnemonic_S_matches_prefix : string -> maybe ((f_bin_rm_op_S * ii))\<close>\<close>

fun f_bin_rm_type_mnemonic_S_forwards  :: \<open> f_bin_rm_op_S \<Rightarrow> string \<close>  where 
     \<open> f_bin_rm_type_mnemonic_S_forwards FADD_S = ( (''fadd.s''))\<close>
|\<open> f_bin_rm_type_mnemonic_S_forwards FSUB_S = ( (''fsub.s''))\<close>
|\<open> f_bin_rm_type_mnemonic_S_forwards FMUL_S = ( (''fmul.s''))\<close>
|\<open> f_bin_rm_type_mnemonic_S_forwards FDIV_S = ( (''fdiv.s''))\<close>


definition f_bin_rm_type_mnemonic_S_backwards  :: \<open> string \<Rightarrow>((register_value),(f_bin_rm_op_S),(exception))monad \<close>  where 
     \<open> f_bin_rm_type_mnemonic_S_backwards arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''fadd.s'')))) then return FADD_S
   else if (((p00 = (''fsub.s'')))) then return FSUB_S
   else if (((p00 = (''fmul.s'')))) then return FMUL_S
   else if (((p00 = (''fdiv.s'')))) then return FDIV_S
   else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))\<close> 
  for  arg1  :: " string "


fun f_bin_rm_type_mnemonic_S_forwards_matches  :: \<open> f_bin_rm_op_S \<Rightarrow> bool \<close>  where 
     \<open> f_bin_rm_type_mnemonic_S_forwards_matches FADD_S = ( True )\<close>
|\<open> f_bin_rm_type_mnemonic_S_forwards_matches FSUB_S = ( True )\<close>
|\<open> f_bin_rm_type_mnemonic_S_forwards_matches FMUL_S = ( True )\<close>
|\<open> f_bin_rm_type_mnemonic_S_forwards_matches FDIV_S = ( True )\<close>


definition f_bin_rm_type_mnemonic_S_backwards_matches  :: \<open> string \<Rightarrow> bool \<close>  where 
     \<open> f_bin_rm_type_mnemonic_S_backwards_matches arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''fadd.s'')))) then True
   else if (((p00 = (''fsub.s'')))) then True
   else if (((p00 = (''fmul.s'')))) then True
   else if (((p00 = (''fdiv.s'')))) then True
   else False))\<close> 
  for  arg1  :: " string "


\<comment> \<open>\<open>val _s1130_ : string -> maybe string\<close>\<close>

definition s1130  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s1130 s11310 = (
   (let s11320 = s11310 in
   if ((string_startswith s11320 (''fdiv.s''))) then  
  (case  ((string_drop s11320 ((string_length (''fdiv.s''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s11310  :: " string "


\<comment> \<open>\<open>val _s1126_ : string -> maybe string\<close>\<close>

definition s1126  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s1126 s11270 = (
   (let s11280 = s11270 in
   if ((string_startswith s11280 (''fmul.s''))) then  
  (case  ((string_drop s11280 ((string_length (''fmul.s''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s11270  :: " string "


\<comment> \<open>\<open>val _s1122_ : string -> maybe string\<close>\<close>

definition s1122  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s1122 s11230 = (
   (let s11240 = s11230 in
   if ((string_startswith s11240 (''fsub.s''))) then  
  (case  ((string_drop s11240 ((string_length (''fsub.s''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s11230  :: " string "


\<comment> \<open>\<open>val _s1118_ : string -> maybe string\<close>\<close>

definition s1118  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s1118 s11190 = (
   (let s11200 = s11190 in
   if ((string_startswith s11200 (''fadd.s''))) then  
  (case  ((string_drop s11200 ((string_length (''fadd.s''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s11190  :: " string "


definition f_bin_rm_type_mnemonic_S_matches_prefix  :: \<open> string \<Rightarrow>(f_bin_rm_op_S*int)option \<close>  where 
     \<open> f_bin_rm_type_mnemonic_S_matches_prefix arg1 = (
   (let s11210 = arg1 in
   if ((case  ((s1118 s11210)) of   Some (s1) => True | _ => False )) then  
  (case  s1118 s11210 of
      (Some (s1)) =>
  Some (FADD_S, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s1122 s11210)) of   Some (s1) => True | _ => False )) then  
  (case  s1122 s11210 of
      (Some (s1)) =>
  Some (FSUB_S, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s1126 s11210)) of   Some (s1) => True | _ => False )) then  
  (case  s1126 s11210 of
      (Some (s1)) =>
  Some (FMUL_S, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s1130 s11210)) of   Some (s1) => True | _ => False )) then  
  (case  s1130 s11210 of
      (Some (s1)) =>
  Some (FDIV_S, ((string_length arg1)) - ((string_length s1)))
  )
   else None))\<close> 
  for  arg1  :: " string "


\<comment> \<open>\<open>val f_un_rm_type_mnemonic_S_forwards : f_un_rm_op_S -> string\<close>\<close>

\<comment> \<open>\<open>val f_un_rm_type_mnemonic_S_backwards : string -> M f_un_rm_op_S\<close>\<close>

\<comment> \<open>\<open>val f_un_rm_type_mnemonic_S_forwards_matches : f_un_rm_op_S -> bool\<close>\<close>

\<comment> \<open>\<open>val f_un_rm_type_mnemonic_S_backwards_matches : string -> bool\<close>\<close>

\<comment> \<open>\<open>val f_un_rm_type_mnemonic_S_matches_prefix : string -> maybe ((f_un_rm_op_S * ii))\<close>\<close>

fun f_un_rm_type_mnemonic_S_forwards  :: \<open> f_un_rm_op_S \<Rightarrow> string \<close>  where 
     \<open> f_un_rm_type_mnemonic_S_forwards FSQRT_S = ( (''fsqrt.s''))\<close>
|\<open> f_un_rm_type_mnemonic_S_forwards FCVT_W_S = ( (''fcvt.w.s''))\<close>
|\<open> f_un_rm_type_mnemonic_S_forwards FCVT_WU_S = ( (''fcvt.wu.s''))\<close>
|\<open> f_un_rm_type_mnemonic_S_forwards FCVT_S_W = ( (''fcvt.s.w''))\<close>
|\<open> f_un_rm_type_mnemonic_S_forwards FCVT_S_WU = ( (''fcvt.s.wu''))\<close>
|\<open> f_un_rm_type_mnemonic_S_forwards FCVT_L_S = ( (''fcvt.l.s''))\<close>
|\<open> f_un_rm_type_mnemonic_S_forwards FCVT_LU_S = ( (''fcvt.lu.s''))\<close>
|\<open> f_un_rm_type_mnemonic_S_forwards FCVT_S_L = ( (''fcvt.s.l''))\<close>
|\<open> f_un_rm_type_mnemonic_S_forwards FCVT_S_LU = ( (''fcvt.s.lu''))\<close>


definition f_un_rm_type_mnemonic_S_backwards  :: \<open> string \<Rightarrow>((register_value),(f_un_rm_op_S),(exception))monad \<close>  where 
     \<open> f_un_rm_type_mnemonic_S_backwards arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''fsqrt.s'')))) then return FSQRT_S
   else if (((p00 = (''fcvt.w.s'')))) then return FCVT_W_S
   else if (((p00 = (''fcvt.wu.s'')))) then return FCVT_WU_S
   else if (((p00 = (''fcvt.s.w'')))) then return FCVT_S_W
   else if (((p00 = (''fcvt.s.wu'')))) then return FCVT_S_WU
   else if (((p00 = (''fcvt.l.s'')))) then return FCVT_L_S
   else if (((p00 = (''fcvt.lu.s'')))) then return FCVT_LU_S
   else if (((p00 = (''fcvt.s.l'')))) then return FCVT_S_L
   else if (((p00 = (''fcvt.s.lu'')))) then return FCVT_S_LU
   else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))\<close> 
  for  arg1  :: " string "


fun f_un_rm_type_mnemonic_S_forwards_matches  :: \<open> f_un_rm_op_S \<Rightarrow> bool \<close>  where 
     \<open> f_un_rm_type_mnemonic_S_forwards_matches FSQRT_S = ( True )\<close>
|\<open> f_un_rm_type_mnemonic_S_forwards_matches FCVT_W_S = ( True )\<close>
|\<open> f_un_rm_type_mnemonic_S_forwards_matches FCVT_WU_S = ( True )\<close>
|\<open> f_un_rm_type_mnemonic_S_forwards_matches FCVT_S_W = ( True )\<close>
|\<open> f_un_rm_type_mnemonic_S_forwards_matches FCVT_S_WU = ( True )\<close>
|\<open> f_un_rm_type_mnemonic_S_forwards_matches FCVT_L_S = ( True )\<close>
|\<open> f_un_rm_type_mnemonic_S_forwards_matches FCVT_LU_S = ( True )\<close>
|\<open> f_un_rm_type_mnemonic_S_forwards_matches FCVT_S_L = ( True )\<close>
|\<open> f_un_rm_type_mnemonic_S_forwards_matches FCVT_S_LU = ( True )\<close>


definition f_un_rm_type_mnemonic_S_backwards_matches  :: \<open> string \<Rightarrow> bool \<close>  where 
     \<open> f_un_rm_type_mnemonic_S_backwards_matches arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''fsqrt.s'')))) then True
   else if (((p00 = (''fcvt.w.s'')))) then True
   else if (((p00 = (''fcvt.wu.s'')))) then True
   else if (((p00 = (''fcvt.s.w'')))) then True
   else if (((p00 = (''fcvt.s.wu'')))) then True
   else if (((p00 = (''fcvt.l.s'')))) then True
   else if (((p00 = (''fcvt.lu.s'')))) then True
   else if (((p00 = (''fcvt.s.l'')))) then True
   else if (((p00 = (''fcvt.s.lu'')))) then True
   else False))\<close> 
  for  arg1  :: " string "


\<comment> \<open>\<open>val _s1166_ : string -> maybe string\<close>\<close>

definition s1166  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s1166 s11670 = (
   (let s11680 = s11670 in
   if ((string_startswith s11680 (''fcvt.s.lu''))) then  
  (case  ((string_drop s11680 ((string_length (''fcvt.s.lu''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s11670  :: " string "


\<comment> \<open>\<open>val _s1162_ : string -> maybe string\<close>\<close>

definition s1162  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s1162 s11630 = (
   (let s11640 = s11630 in
   if ((string_startswith s11640 (''fcvt.s.l''))) then  
  (case  ((string_drop s11640 ((string_length (''fcvt.s.l''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s11630  :: " string "


\<comment> \<open>\<open>val _s1158_ : string -> maybe string\<close>\<close>

definition s1158  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s1158 s11590 = (
   (let s11600 = s11590 in
   if ((string_startswith s11600 (''fcvt.lu.s''))) then  
  (case  ((string_drop s11600 ((string_length (''fcvt.lu.s''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s11590  :: " string "


\<comment> \<open>\<open>val _s1154_ : string -> maybe string\<close>\<close>

definition s1154  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s1154 s11550 = (
   (let s11560 = s11550 in
   if ((string_startswith s11560 (''fcvt.l.s''))) then  
  (case  ((string_drop s11560 ((string_length (''fcvt.l.s''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s11550  :: " string "


\<comment> \<open>\<open>val _s1150_ : string -> maybe string\<close>\<close>

definition s1150  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s1150 s11510 = (
   (let s11520 = s11510 in
   if ((string_startswith s11520 (''fcvt.s.wu''))) then  
  (case  ((string_drop s11520 ((string_length (''fcvt.s.wu''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s11510  :: " string "


\<comment> \<open>\<open>val _s1146_ : string -> maybe string\<close>\<close>

definition s1146  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s1146 s11470 = (
   (let s11480 = s11470 in
   if ((string_startswith s11480 (''fcvt.s.w''))) then  
  (case  ((string_drop s11480 ((string_length (''fcvt.s.w''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s11470  :: " string "


\<comment> \<open>\<open>val _s1142_ : string -> maybe string\<close>\<close>

definition s1142  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s1142 s11430 = (
   (let s11440 = s11430 in
   if ((string_startswith s11440 (''fcvt.wu.s''))) then  
  (case  ((string_drop s11440 ((string_length (''fcvt.wu.s''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s11430  :: " string "


\<comment> \<open>\<open>val _s1138_ : string -> maybe string\<close>\<close>

definition s1138  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s1138 s11390 = (
   (let s11400 = s11390 in
   if ((string_startswith s11400 (''fcvt.w.s''))) then  
  (case  ((string_drop s11400 ((string_length (''fcvt.w.s''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s11390  :: " string "


\<comment> \<open>\<open>val _s1134_ : string -> maybe string\<close>\<close>

definition s1134  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s1134 s11350 = (
   (let s11360 = s11350 in
   if ((string_startswith s11360 (''fsqrt.s''))) then  
  (case  ((string_drop s11360 ((string_length (''fsqrt.s''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s11350  :: " string "


definition f_un_rm_type_mnemonic_S_matches_prefix  :: \<open> string \<Rightarrow>(f_un_rm_op_S*int)option \<close>  where 
     \<open> f_un_rm_type_mnemonic_S_matches_prefix arg1 = (
   (let s11370 = arg1 in
   if ((case  ((s1134 s11370)) of   Some (s1) => True | _ => False )) then  
  (case  s1134 s11370 of
      (Some (s1)) =>
  Some (FSQRT_S, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s1138 s11370)) of   Some (s1) => True | _ => False )) then  
  (case  s1138 s11370 of
      (Some (s1)) =>
  Some (FCVT_W_S, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s1142 s11370)) of   Some (s1) => True | _ => False )) then  
  (case  s1142 s11370 of
      (Some (s1)) =>
  Some (FCVT_WU_S, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s1146 s11370)) of   Some (s1) => True | _ => False )) then  
  (case  s1146 s11370 of
      (Some (s1)) =>
  Some (FCVT_S_W, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s1150 s11370)) of   Some (s1) => True | _ => False )) then  
  (case  s1150 s11370 of
      (Some (s1)) =>
  Some (FCVT_S_WU, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s1154 s11370)) of   Some (s1) => True | _ => False )) then  
  (case  s1154 s11370 of
      (Some (s1)) =>
  Some (FCVT_L_S, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s1158 s11370)) of   Some (s1) => True | _ => False )) then  
  (case  s1158 s11370 of
      (Some (s1)) =>
  Some (FCVT_LU_S, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s1162 s11370)) of   Some (s1) => True | _ => False )) then  
  (case  s1162 s11370 of
      (Some (s1)) =>
  Some (FCVT_S_L, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s1166 s11370)) of   Some (s1) => True | _ => False )) then  
  (case  s1166 s11370 of
      (Some (s1)) =>
  Some (FCVT_S_LU, ((string_length arg1)) - ((string_length s1)))
  )
   else None))\<close> 
  for  arg1  :: " string "


\<comment> \<open>\<open>val f_bin_type_mnemonic_S_forwards : f_bin_op_S -> string\<close>\<close>

\<comment> \<open>\<open>val f_bin_type_mnemonic_S_backwards : string -> M f_bin_op_S\<close>\<close>

\<comment> \<open>\<open>val f_bin_type_mnemonic_S_forwards_matches : f_bin_op_S -> bool\<close>\<close>

\<comment> \<open>\<open>val f_bin_type_mnemonic_S_backwards_matches : string -> bool\<close>\<close>

\<comment> \<open>\<open>val f_bin_type_mnemonic_S_matches_prefix : string -> maybe ((f_bin_op_S * ii))\<close>\<close>

fun f_bin_type_mnemonic_S_forwards  :: \<open> f_bin_op_S \<Rightarrow> string \<close>  where 
     \<open> f_bin_type_mnemonic_S_forwards FSGNJ_S = ( (''fsgnj.s''))\<close>
|\<open> f_bin_type_mnemonic_S_forwards FSGNJN_S = ( (''fsgnjn.s''))\<close>
|\<open> f_bin_type_mnemonic_S_forwards FSGNJX_S = ( (''fsgnjx.s''))\<close>
|\<open> f_bin_type_mnemonic_S_forwards FMIN_S = ( (''fmin.s''))\<close>
|\<open> f_bin_type_mnemonic_S_forwards FMAX_S = ( (''fmax.s''))\<close>
|\<open> f_bin_type_mnemonic_S_forwards FEQ_S = ( (''feq.s''))\<close>
|\<open> f_bin_type_mnemonic_S_forwards FLT_S = ( (''flt.s''))\<close>
|\<open> f_bin_type_mnemonic_S_forwards FLE_S = ( (''fle.s''))\<close>


definition f_bin_type_mnemonic_S_backwards  :: \<open> string \<Rightarrow>((register_value),(f_bin_op_S),(exception))monad \<close>  where 
     \<open> f_bin_type_mnemonic_S_backwards arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''fsgnj.s'')))) then return FSGNJ_S
   else if (((p00 = (''fsgnjn.s'')))) then return FSGNJN_S
   else if (((p00 = (''fsgnjx.s'')))) then return FSGNJX_S
   else if (((p00 = (''fmin.s'')))) then return FMIN_S
   else if (((p00 = (''fmax.s'')))) then return FMAX_S
   else if (((p00 = (''feq.s'')))) then return FEQ_S
   else if (((p00 = (''flt.s'')))) then return FLT_S
   else if (((p00 = (''fle.s'')))) then return FLE_S
   else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))\<close> 
  for  arg1  :: " string "


fun f_bin_type_mnemonic_S_forwards_matches  :: \<open> f_bin_op_S \<Rightarrow> bool \<close>  where 
     \<open> f_bin_type_mnemonic_S_forwards_matches FSGNJ_S = ( True )\<close>
|\<open> f_bin_type_mnemonic_S_forwards_matches FSGNJN_S = ( True )\<close>
|\<open> f_bin_type_mnemonic_S_forwards_matches FSGNJX_S = ( True )\<close>
|\<open> f_bin_type_mnemonic_S_forwards_matches FMIN_S = ( True )\<close>
|\<open> f_bin_type_mnemonic_S_forwards_matches FMAX_S = ( True )\<close>
|\<open> f_bin_type_mnemonic_S_forwards_matches FEQ_S = ( True )\<close>
|\<open> f_bin_type_mnemonic_S_forwards_matches FLT_S = ( True )\<close>
|\<open> f_bin_type_mnemonic_S_forwards_matches FLE_S = ( True )\<close>


definition f_bin_type_mnemonic_S_backwards_matches  :: \<open> string \<Rightarrow> bool \<close>  where 
     \<open> f_bin_type_mnemonic_S_backwards_matches arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''fsgnj.s'')))) then True
   else if (((p00 = (''fsgnjn.s'')))) then True
   else if (((p00 = (''fsgnjx.s'')))) then True
   else if (((p00 = (''fmin.s'')))) then True
   else if (((p00 = (''fmax.s'')))) then True
   else if (((p00 = (''feq.s'')))) then True
   else if (((p00 = (''flt.s'')))) then True
   else if (((p00 = (''fle.s'')))) then True
   else False))\<close> 
  for  arg1  :: " string "


\<comment> \<open>\<open>val _s1198_ : string -> maybe string\<close>\<close>

definition s1198  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s1198 s11990 = (
   (let s12000 = s11990 in
   if ((string_startswith s12000 (''fle.s''))) then  
  (case  ((string_drop s12000 ((string_length (''fle.s''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s11990  :: " string "


\<comment> \<open>\<open>val _s1194_ : string -> maybe string\<close>\<close>

definition s1194  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s1194 s11950 = (
   (let s11960 = s11950 in
   if ((string_startswith s11960 (''flt.s''))) then  
  (case  ((string_drop s11960 ((string_length (''flt.s''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s11950  :: " string "


\<comment> \<open>\<open>val _s1190_ : string -> maybe string\<close>\<close>

definition s1190  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s1190 s11910 = (
   (let s11920 = s11910 in
   if ((string_startswith s11920 (''feq.s''))) then  
  (case  ((string_drop s11920 ((string_length (''feq.s''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s11910  :: " string "


\<comment> \<open>\<open>val _s1186_ : string -> maybe string\<close>\<close>

definition s1186  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s1186 s11870 = (
   (let s11880 = s11870 in
   if ((string_startswith s11880 (''fmax.s''))) then  
  (case  ((string_drop s11880 ((string_length (''fmax.s''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s11870  :: " string "


\<comment> \<open>\<open>val _s1182_ : string -> maybe string\<close>\<close>

definition s1182  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s1182 s11830 = (
   (let s11840 = s11830 in
   if ((string_startswith s11840 (''fmin.s''))) then  
  (case  ((string_drop s11840 ((string_length (''fmin.s''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s11830  :: " string "


\<comment> \<open>\<open>val _s1178_ : string -> maybe string\<close>\<close>

definition s1178  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s1178 s11790 = (
   (let s11800 = s11790 in
   if ((string_startswith s11800 (''fsgnjx.s''))) then  
  (case  ((string_drop s11800 ((string_length (''fsgnjx.s''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s11790  :: " string "


\<comment> \<open>\<open>val _s1174_ : string -> maybe string\<close>\<close>

definition s1174  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s1174 s11750 = (
   (let s11760 = s11750 in
   if ((string_startswith s11760 (''fsgnjn.s''))) then  
  (case  ((string_drop s11760 ((string_length (''fsgnjn.s''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s11750  :: " string "


\<comment> \<open>\<open>val _s1170_ : string -> maybe string\<close>\<close>

definition s1170  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s1170 s11710 = (
   (let s11720 = s11710 in
   if ((string_startswith s11720 (''fsgnj.s''))) then  
  (case  ((string_drop s11720 ((string_length (''fsgnj.s''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s11710  :: " string "


definition f_bin_type_mnemonic_S_matches_prefix  :: \<open> string \<Rightarrow>(f_bin_op_S*int)option \<close>  where 
     \<open> f_bin_type_mnemonic_S_matches_prefix arg1 = (
   (let s11730 = arg1 in
   if ((case  ((s1170 s11730)) of   Some (s1) => True | _ => False )) then  
  (case  s1170 s11730 of
      (Some (s1)) =>
  Some (FSGNJ_S, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s1174 s11730)) of   Some (s1) => True | _ => False )) then  
  (case  s1174 s11730 of
      (Some (s1)) =>
  Some (FSGNJN_S, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s1178 s11730)) of   Some (s1) => True | _ => False )) then  
  (case  s1178 s11730 of
      (Some (s1)) =>
  Some (FSGNJX_S, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s1182 s11730)) of   Some (s1) => True | _ => False )) then  
  (case  s1182 s11730 of
      (Some (s1)) =>
  Some (FMIN_S, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s1186 s11730)) of   Some (s1) => True | _ => False )) then  
  (case  s1186 s11730 of
      (Some (s1)) =>
  Some (FMAX_S, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s1190 s11730)) of   Some (s1) => True | _ => False )) then  
  (case  s1190 s11730 of
      (Some (s1)) =>
  Some (FEQ_S, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s1194 s11730)) of   Some (s1) => True | _ => False )) then  
  (case  s1194 s11730 of
      (Some (s1)) =>
  Some (FLT_S, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s1198 s11730)) of   Some (s1) => True | _ => False )) then  
  (case  s1198 s11730 of
      (Some (s1)) =>
  Some (FLE_S, ((string_length arg1)) - ((string_length s1)))
  )
   else None))\<close> 
  for  arg1  :: " string "


\<comment> \<open>\<open>val f_un_type_mnemonic_S_forwards : f_un_op_S -> string\<close>\<close>

\<comment> \<open>\<open>val f_un_type_mnemonic_S_backwards : string -> M f_un_op_S\<close>\<close>

\<comment> \<open>\<open>val f_un_type_mnemonic_S_forwards_matches : f_un_op_S -> bool\<close>\<close>

\<comment> \<open>\<open>val f_un_type_mnemonic_S_backwards_matches : string -> bool\<close>\<close>

\<comment> \<open>\<open>val f_un_type_mnemonic_S_matches_prefix : string -> maybe ((f_un_op_S * ii))\<close>\<close>

fun f_un_type_mnemonic_S_forwards  :: \<open> f_un_op_S \<Rightarrow> string \<close>  where 
     \<open> f_un_type_mnemonic_S_forwards FMV_X_W = ( (''fmv.x.w''))\<close>
|\<open> f_un_type_mnemonic_S_forwards FCLASS_S = ( (''fclass.s''))\<close>
|\<open> f_un_type_mnemonic_S_forwards FMV_W_X = ( (''fmv.w.x''))\<close>


definition f_un_type_mnemonic_S_backwards  :: \<open> string \<Rightarrow>((register_value),(f_un_op_S),(exception))monad \<close>  where 
     \<open> f_un_type_mnemonic_S_backwards arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''fmv.x.w'')))) then return FMV_X_W
   else if (((p00 = (''fclass.s'')))) then return FCLASS_S
   else if (((p00 = (''fmv.w.x'')))) then return FMV_W_X
   else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))\<close> 
  for  arg1  :: " string "


fun f_un_type_mnemonic_S_forwards_matches  :: \<open> f_un_op_S \<Rightarrow> bool \<close>  where 
     \<open> f_un_type_mnemonic_S_forwards_matches FMV_X_W = ( True )\<close>
|\<open> f_un_type_mnemonic_S_forwards_matches FCLASS_S = ( True )\<close>
|\<open> f_un_type_mnemonic_S_forwards_matches FMV_W_X = ( True )\<close>


definition f_un_type_mnemonic_S_backwards_matches  :: \<open> string \<Rightarrow> bool \<close>  where 
     \<open> f_un_type_mnemonic_S_backwards_matches arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''fmv.x.w'')))) then True
   else if (((p00 = (''fclass.s'')))) then True
   else if (((p00 = (''fmv.w.x'')))) then True
   else False))\<close> 
  for  arg1  :: " string "


\<comment> \<open>\<open>val _s1210_ : string -> maybe string\<close>\<close>

definition s1210  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s1210 s12110 = (
   (let s12120 = s12110 in
   if ((string_startswith s12120 (''fmv.w.x''))) then  
  (case  ((string_drop s12120 ((string_length (''fmv.w.x''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s12110  :: " string "


\<comment> \<open>\<open>val _s1206_ : string -> maybe string\<close>\<close>

definition s1206  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s1206 s12070 = (
   (let s12080 = s12070 in
   if ((string_startswith s12080 (''fclass.s''))) then  
  (case  ((string_drop s12080 ((string_length (''fclass.s''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s12070  :: " string "


\<comment> \<open>\<open>val _s1202_ : string -> maybe string\<close>\<close>

definition s1202  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s1202 s12030 = (
   (let s12040 = s12030 in
   if ((string_startswith s12040 (''fmv.x.w''))) then  
  (case  ((string_drop s12040 ((string_length (''fmv.x.w''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s12030  :: " string "


definition f_un_type_mnemonic_S_matches_prefix  :: \<open> string \<Rightarrow>(f_un_op_S*int)option \<close>  where 
     \<open> f_un_type_mnemonic_S_matches_prefix arg1 = (
   (let s12050 = arg1 in
   if ((case  ((s1202 s12050)) of   Some (s1) => True | _ => False )) then  
  (case  s1202 s12050 of
      (Some (s1)) =>
  Some (FMV_X_W, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s1206 s12050)) of   Some (s1) => True | _ => False )) then  
  (case  s1206 s12050 of
      (Some (s1)) =>
  Some (FCLASS_S, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s1210 s12050)) of   Some (s1) => True | _ => False )) then  
  (case  s1210 s12050 of
      (Some (s1)) =>
  Some (FMV_W_X, ((string_length arg1)) - ((string_length s1)))
  )
   else None))\<close> 
  for  arg1  :: " string "


\<comment> \<open>\<open>val fsplit_D : mword ty64 -> (mword ty1 * mword ty11 * mword ty52)\<close>\<close>

definition fsplit_D  :: \<open>(64)Word.word \<Rightarrow>(1)Word.word*(11)Word.word*(52)Word.word \<close>  where 
     \<open> fsplit_D x64 = (
   ((subrange_vec_dec x64 (( 63 :: int)::ii) (( 63 :: int)::ii)  ::  1 Word.word),
    (subrange_vec_dec x64 (( 62 :: int)::ii) (( 52 :: int)::ii)  ::  11 Word.word),
    (subrange_vec_dec x64 (( 51 :: int)::ii) (( 0 :: int)::ii)  ::  52 Word.word)))\<close> 
  for  x64  :: "(64)Word.word "


\<comment> \<open>\<open>val fmake_D : mword ty1 -> mword ty11 -> mword ty52 -> mword ty64\<close>\<close>

definition fmake_D  :: \<open>(1)Word.word \<Rightarrow>(11)Word.word \<Rightarrow>(52)Word.word \<Rightarrow>(64)Word.word \<close>  where 
     \<open> fmake_D sign exp1 mant = ( (concat_vec sign ((concat_vec exp1 mant  ::  63 Word.word))  ::  64 Word.word))\<close> 
  for  sign  :: "(1)Word.word " 
  and  exp1  :: "(11)Word.word " 
  and  mant  :: "(52)Word.word "


\<comment> \<open>\<open>val canonical_NaN_D : unit -> mword ty64\<close>\<close>

definition canonical_NaN_D  :: \<open> unit \<Rightarrow>(64)Word.word \<close>  where 
     \<open> canonical_NaN_D _ = ( ( 0x7FF8000000000000 ::  64 Word.word))\<close>


\<comment> \<open>\<open>val f_is_neg_inf_D : mword ty64 -> bool\<close>\<close>

definition f_is_neg_inf_D  :: \<open>(64)Word.word \<Rightarrow> bool \<close>  where 
     \<open> f_is_neg_inf_D x64 = (
   (let (sign, exp1, mant) = ((fsplit_D x64  :: ( 1 Word.word *  11 Word.word *  52 Word.word))) in
   ((((sign = ( 0b1 ::  1 Word.word)))) \<and> ((((((exp1 = ((ones (( 11 :: int)::ii)  ::  11 Word.word))))) \<and> (((mant = ((zeros_implicit (( 52 :: int)::ii)  ::  52 Word.word)))))))))))\<close> 
  for  x64  :: "(64)Word.word "


\<comment> \<open>\<open>val f_is_neg_norm_D : mword ty64 -> bool\<close>\<close>

definition f_is_neg_norm_D  :: \<open>(64)Word.word \<Rightarrow> bool \<close>  where 
     \<open> f_is_neg_norm_D x64 = (
   (let (sign, exp1, mant) = ((fsplit_D x64  :: ( 1 Word.word *  11 Word.word *  52 Word.word))) in
   ((((sign = ( 0b1 ::  1 Word.word)))) \<and> ((((((exp1 \<noteq> ((zeros_implicit (( 11 :: int)::ii)  ::  11 Word.word))))) \<and> (((exp1 \<noteq> ((ones (( 11 :: int)::ii)  ::  11 Word.word)))))))))))\<close> 
  for  x64  :: "(64)Word.word "


\<comment> \<open>\<open>val f_is_neg_subnorm_D : mword ty64 -> bool\<close>\<close>

definition f_is_neg_subnorm_D  :: \<open>(64)Word.word \<Rightarrow> bool \<close>  where 
     \<open> f_is_neg_subnorm_D x64 = (
   (let (sign, exp1, mant) = ((fsplit_D x64  :: ( 1 Word.word *  11 Word.word *  52 Word.word))) in
   ((((sign = ( 0b1 ::  1 Word.word)))) \<and> ((((((exp1 = ((zeros_implicit (( 11 :: int)::ii)  ::  11 Word.word))))) \<and> (((mant \<noteq> ((zeros_implicit (( 52 :: int)::ii)  ::  52 Word.word)))))))))))\<close> 
  for  x64  :: "(64)Word.word "


\<comment> \<open>\<open>val f_is_neg_zero_D : mword ty64 -> bool\<close>\<close>

definition f_is_neg_zero_D  :: \<open>(64)Word.word \<Rightarrow> bool \<close>  where 
     \<open> f_is_neg_zero_D x64 = (
   (let (sign, exp1, mant) = ((fsplit_D x64  :: ( 1 Word.word *  11 Word.word *  52 Word.word))) in
   ((((sign = ((ones (( 1 :: int)::ii)  ::  1 Word.word))))) \<and> ((((((exp1 = ((zeros_implicit (( 11 :: int)::ii)  ::  11 Word.word))))) \<and> (((mant = ((zeros_implicit (( 52 :: int)::ii)  ::  52 Word.word)))))))))))\<close> 
  for  x64  :: "(64)Word.word "


\<comment> \<open>\<open>val f_is_pos_zero_D : mword ty64 -> bool\<close>\<close>

definition f_is_pos_zero_D  :: \<open>(64)Word.word \<Rightarrow> bool \<close>  where 
     \<open> f_is_pos_zero_D x64 = (
   (let (sign, exp1, mant) = ((fsplit_D x64  :: ( 1 Word.word *  11 Word.word *  52 Word.word))) in
   ((((sign = ((zeros_implicit (( 1 :: int)::ii)  ::  1 Word.word))))) \<and> ((((((exp1 = ((zeros_implicit (( 11 :: int)::ii)  ::  11 Word.word))))) \<and> (((mant = ((zeros_implicit (( 52 :: int)::ii)  ::  52 Word.word)))))))))))\<close> 
  for  x64  :: "(64)Word.word "


\<comment> \<open>\<open>val f_is_pos_subnorm_D : mword ty64 -> bool\<close>\<close>

definition f_is_pos_subnorm_D  :: \<open>(64)Word.word \<Rightarrow> bool \<close>  where 
     \<open> f_is_pos_subnorm_D x64 = (
   (let (sign, exp1, mant) = ((fsplit_D x64  :: ( 1 Word.word *  11 Word.word *  52 Word.word))) in
   ((((sign = ((zeros_implicit (( 1 :: int)::ii)  ::  1 Word.word))))) \<and> ((((((exp1 = ((zeros_implicit (( 11 :: int)::ii)  ::  11 Word.word))))) \<and> (((mant \<noteq> ((zeros_implicit (( 52 :: int)::ii)  ::  52 Word.word)))))))))))\<close> 
  for  x64  :: "(64)Word.word "


\<comment> \<open>\<open>val f_is_pos_norm_D : mword ty64 -> bool\<close>\<close>

definition f_is_pos_norm_D  :: \<open>(64)Word.word \<Rightarrow> bool \<close>  where 
     \<open> f_is_pos_norm_D x64 = (
   (let (sign, exp1, mant) = ((fsplit_D x64  :: ( 1 Word.word *  11 Word.word *  52 Word.word))) in
   ((((sign = ((zeros_implicit (( 1 :: int)::ii)  ::  1 Word.word))))) \<and> ((((((exp1 \<noteq> ((zeros_implicit (( 11 :: int)::ii)  ::  11 Word.word))))) \<and> (((exp1 \<noteq> ((ones (( 11 :: int)::ii)  ::  11 Word.word)))))))))))\<close> 
  for  x64  :: "(64)Word.word "


\<comment> \<open>\<open>val f_is_pos_inf_D : mword ty64 -> bool\<close>\<close>

definition f_is_pos_inf_D  :: \<open>(64)Word.word \<Rightarrow> bool \<close>  where 
     \<open> f_is_pos_inf_D x64 = (
   (let (sign, exp1, mant) = ((fsplit_D x64  :: ( 1 Word.word *  11 Word.word *  52 Word.word))) in
   ((((sign = ((zeros_implicit (( 1 :: int)::ii)  ::  1 Word.word))))) \<and> ((((((exp1 = ((ones (( 11 :: int)::ii)  ::  11 Word.word))))) \<and> (((mant = ((zeros_implicit (( 52 :: int)::ii)  ::  52 Word.word)))))))))))\<close> 
  for  x64  :: "(64)Word.word "


\<comment> \<open>\<open>val f_is_SNaN_D : mword ty64 -> bool\<close>\<close>

definition f_is_SNaN_D  :: \<open>(64)Word.word \<Rightarrow> bool \<close>  where 
     \<open> f_is_SNaN_D x64 = (
   (let (sign, exp1, mant) = ((fsplit_D x64  :: ( 1 Word.word *  11 Word.word *  52 Word.word))) in
   ((((exp1 = ((ones (( 11 :: int)::ii)  ::  11 Word.word))))) \<and> ((((((((access_vec_dec mant (( 51 :: int)::ii))) = B0))) \<and> (((mant \<noteq> ((zeros_implicit (( 52 :: int)::ii)  ::  52 Word.word)))))))))))\<close> 
  for  x64  :: "(64)Word.word "


\<comment> \<open>\<open>val f_is_QNaN_D : mword ty64 -> bool\<close>\<close>

definition f_is_QNaN_D  :: \<open>(64)Word.word \<Rightarrow> bool \<close>  where 
     \<open> f_is_QNaN_D x64 = (
   (let (sign, exp1, mant) = ((fsplit_D x64  :: ( 1 Word.word *  11 Word.word *  52 Word.word))) in
   ((((exp1 = ((ones (( 11 :: int)::ii)  ::  11 Word.word))))) \<and> (((((access_vec_dec mant (( 51 :: int)::ii))) = B1))))))\<close> 
  for  x64  :: "(64)Word.word "


\<comment> \<open>\<open>val f_is_NaN_D : mword ty64 -> bool\<close>\<close>

definition f_is_NaN_D  :: \<open>(64)Word.word \<Rightarrow> bool \<close>  where 
     \<open> f_is_NaN_D x64 = (
   (let (sign, exp1, mant) = ((fsplit_D x64  :: ( 1 Word.word *  11 Word.word *  52 Word.word))) in
   ((((exp1 = ((ones (( 11 :: int)::ii)  ::  11 Word.word))))) \<and> (((mant \<noteq> ((zeros_implicit (( 52 :: int)::ii)  ::  52 Word.word))))))))\<close> 
  for  x64  :: "(64)Word.word "


\<comment> \<open>\<open>val negate_D : mword ty64 -> mword ty64\<close>\<close>

definition negate_D  :: \<open>(64)Word.word \<Rightarrow>(64)Word.word \<close>  where 
     \<open> negate_D x64 = (
   (let (sign, exp1, mant) = ((fsplit_D x64  :: ( 1 Word.word *  11 Word.word *  52 Word.word))) in
   (let new_sign = (if (((sign = ( 0b0 ::  1 Word.word)))) then ( 0b1 ::  1 Word.word) else ( 0b0 ::  1 Word.word)) in
   (fmake_D new_sign exp1 mant  ::  64 Word.word))))\<close> 
  for  x64  :: "(64)Word.word "


\<comment> \<open>\<open>val feq_quiet_D : mword ty64 -> mword ty64 -> (bool * mword ty5)\<close>\<close>

definition feq_quiet_D  :: \<open>(64)Word.word \<Rightarrow>(64)Word.word \<Rightarrow> bool*(5)Word.word \<close>  where 
     \<open> feq_quiet_D v1 v2 = (
   (let (s1, e1, m1) = ((fsplit_D v1  :: ( 1 Word.word *  11 Word.word *  52 Word.word))) in
   (let (s2, e2, m2) = ((fsplit_D v2  :: ( 1 Word.word *  11 Word.word *  52 Word.word))) in
   (let v1Is0 = (((f_is_neg_zero_D v1)) \<or> ((f_is_pos_zero_D v1))) in
   (let v2Is0 = (((f_is_neg_zero_D v2)) \<or> ((f_is_pos_zero_D v2))) in
   (let result = ((((v1 = v2))) \<or> (((v1Is0 \<and> v2Is0)))) in
   (let fflags =
     (if (((((f_is_SNaN_D v1)) \<or> ((f_is_SNaN_D v2))))) then (nvFlag ()   ::  5 Word.word)
     else (zeros_implicit (( 5 :: int)::ii)  ::  5 Word.word)) in
   (result, fflags))))))))\<close> 
  for  v1  :: "(64)Word.word " 
  and  v2  :: "(64)Word.word "


\<comment> \<open>\<open>val flt_D : mword ty64 -> mword ty64 -> bool -> (bool * mword ty5)\<close>\<close>

definition flt_D  :: \<open>(64)Word.word \<Rightarrow>(64)Word.word \<Rightarrow> bool \<Rightarrow> bool*(5)Word.word \<close>  where 
     \<open> flt_D v1 v2 is_quiet = (
   (let (s1, e1, m1) = ((fsplit_D v1  :: ( 1 Word.word *  11 Word.word *  52 Word.word))) in
   (let (s2, e2, m2) = ((fsplit_D v2  :: ( 1 Word.word *  11 Word.word *  52 Word.word))) in
   (let (result :: bool) =
     (if ((((((s1 = ( 0b0 ::  1 Word.word)))) \<and> (((s2 = ( 0b0 ::  1 Word.word))))))) then
       if (((e1 = e2))) then ((Word.uint m1)) < ((Word.uint m2))
       else ((Word.uint e1)) < ((Word.uint e2))
     else if ((((((s1 = ( 0b0 ::  1 Word.word)))) \<and> (((s2 = ( 0b1 ::  1 Word.word))))))) then False
     else if ((((((s1 = ( 0b1 ::  1 Word.word)))) \<and> (((s2 = ( 0b0 ::  1 Word.word))))))) then True
     else if (((e1 = e2))) then ((Word.uint m1)) > ((Word.uint m2))
     else ((Word.uint e1)) > ((Word.uint e2))) in
   (let fflags =
     (if is_quiet then
       if (((((f_is_SNaN_D v1)) \<or> ((f_is_SNaN_D v2))))) then (nvFlag ()   ::  5 Word.word)
       else (zeros_implicit (( 5 :: int)::ii)  ::  5 Word.word)
     else if (((((f_is_NaN_D v1)) \<or> ((f_is_NaN_D v2))))) then (nvFlag ()   ::  5 Word.word)
     else (zeros_implicit (( 5 :: int)::ii)  ::  5 Word.word)) in
   (result, fflags))))))\<close> 
  for  v1  :: "(64)Word.word " 
  and  v2  :: "(64)Word.word " 
  and  is_quiet  :: " bool "


\<comment> \<open>\<open>val fle_D : mword ty64 -> mword ty64 -> bool -> (bool * mword ty5)\<close>\<close>

definition fle_D  :: \<open>(64)Word.word \<Rightarrow>(64)Word.word \<Rightarrow> bool \<Rightarrow> bool*(5)Word.word \<close>  where 
     \<open> fle_D v1 v2 is_quiet = (
   (let (s1, e1, m1) = ((fsplit_D v1  :: ( 1 Word.word *  11 Word.word *  52 Word.word))) in
   (let (s2, e2, m2) = ((fsplit_D v2  :: ( 1 Word.word *  11 Word.word *  52 Word.word))) in
   (let v1Is0 = (((f_is_neg_zero_D v1)) \<or> ((f_is_pos_zero_D v1))) in
   (let v2Is0 = (((f_is_neg_zero_D v2)) \<or> ((f_is_pos_zero_D v2))) in
   (let (result :: bool) =
     (if ((((((s1 = ( 0b0 ::  1 Word.word)))) \<and> (((s2 = ( 0b0 ::  1 Word.word))))))) then
       if (((e1 = e2))) then ((Word.uint m1)) \<le> ((Word.uint m2))
       else ((Word.uint e1)) < ((Word.uint e2))
     else if ((((((s1 = ( 0b0 ::  1 Word.word)))) \<and> (((s2 = ( 0b1 ::  1 Word.word))))))) then
       (v1Is0 \<and> v2Is0)
     else if ((((((s1 = ( 0b1 ::  1 Word.word)))) \<and> (((s2 = ( 0b0 ::  1 Word.word))))))) then True
     else if (((e1 = e2))) then ((Word.uint m1)) \<ge> ((Word.uint m2))
     else ((Word.uint e1)) > ((Word.uint e2))) in
   (let fflags =
     (if is_quiet then
       if (((((f_is_SNaN_D v1)) \<or> ((f_is_SNaN_D v2))))) then (nvFlag ()   ::  5 Word.word)
       else (zeros_implicit (( 5 :: int)::ii)  ::  5 Word.word)
     else if (((((f_is_NaN_D v1)) \<or> ((f_is_NaN_D v2))))) then (nvFlag ()   ::  5 Word.word)
     else (zeros_implicit (( 5 :: int)::ii)  ::  5 Word.word)) in
   (result, fflags))))))))\<close> 
  for  v1  :: "(64)Word.word " 
  and  v2  :: "(64)Word.word " 
  and  is_quiet  :: " bool "


\<comment> \<open>\<open>val f_madd_type_mnemonic_D_forwards : f_madd_op_D -> string\<close>\<close>

\<comment> \<open>\<open>val f_madd_type_mnemonic_D_backwards : string -> M f_madd_op_D\<close>\<close>

\<comment> \<open>\<open>val f_madd_type_mnemonic_D_forwards_matches : f_madd_op_D -> bool\<close>\<close>

\<comment> \<open>\<open>val f_madd_type_mnemonic_D_backwards_matches : string -> bool\<close>\<close>

\<comment> \<open>\<open>val f_madd_type_mnemonic_D_matches_prefix : string -> maybe ((f_madd_op_D * ii))\<close>\<close>

fun f_madd_type_mnemonic_D_forwards  :: \<open> f_madd_op_D \<Rightarrow> string \<close>  where 
     \<open> f_madd_type_mnemonic_D_forwards FMADD_D = ( (''fmadd.d''))\<close>
|\<open> f_madd_type_mnemonic_D_forwards FMSUB_D = ( (''fmsub.d''))\<close>
|\<open> f_madd_type_mnemonic_D_forwards FNMSUB_D = ( (''fnmsub.d''))\<close>
|\<open> f_madd_type_mnemonic_D_forwards FNMADD_D = ( (''fnmadd.d''))\<close>


definition f_madd_type_mnemonic_D_backwards  :: \<open> string \<Rightarrow>((register_value),(f_madd_op_D),(exception))monad \<close>  where 
     \<open> f_madd_type_mnemonic_D_backwards arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''fmadd.d'')))) then return FMADD_D
   else if (((p00 = (''fmsub.d'')))) then return FMSUB_D
   else if (((p00 = (''fnmsub.d'')))) then return FNMSUB_D
   else if (((p00 = (''fnmadd.d'')))) then return FNMADD_D
   else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))\<close> 
  for  arg1  :: " string "


fun f_madd_type_mnemonic_D_forwards_matches  :: \<open> f_madd_op_D \<Rightarrow> bool \<close>  where 
     \<open> f_madd_type_mnemonic_D_forwards_matches FMADD_D = ( True )\<close>
|\<open> f_madd_type_mnemonic_D_forwards_matches FMSUB_D = ( True )\<close>
|\<open> f_madd_type_mnemonic_D_forwards_matches FNMSUB_D = ( True )\<close>
|\<open> f_madd_type_mnemonic_D_forwards_matches FNMADD_D = ( True )\<close>


definition f_madd_type_mnemonic_D_backwards_matches  :: \<open> string \<Rightarrow> bool \<close>  where 
     \<open> f_madd_type_mnemonic_D_backwards_matches arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''fmadd.d'')))) then True
   else if (((p00 = (''fmsub.d'')))) then True
   else if (((p00 = (''fnmsub.d'')))) then True
   else if (((p00 = (''fnmadd.d'')))) then True
   else False))\<close> 
  for  arg1  :: " string "


\<comment> \<open>\<open>val _s1226_ : string -> maybe string\<close>\<close>

definition s1226  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s1226 s12270 = (
   (let s12280 = s12270 in
   if ((string_startswith s12280 (''fnmadd.d''))) then  
  (case  ((string_drop s12280 ((string_length (''fnmadd.d''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s12270  :: " string "


\<comment> \<open>\<open>val _s1222_ : string -> maybe string\<close>\<close>

definition s1222  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s1222 s12230 = (
   (let s12240 = s12230 in
   if ((string_startswith s12240 (''fnmsub.d''))) then  
  (case  ((string_drop s12240 ((string_length (''fnmsub.d''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s12230  :: " string "


\<comment> \<open>\<open>val _s1218_ : string -> maybe string\<close>\<close>

definition s1218  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s1218 s12190 = (
   (let s12200 = s12190 in
   if ((string_startswith s12200 (''fmsub.d''))) then  
  (case  ((string_drop s12200 ((string_length (''fmsub.d''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s12190  :: " string "


\<comment> \<open>\<open>val _s1214_ : string -> maybe string\<close>\<close>

definition s1214  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s1214 s12150 = (
   (let s12160 = s12150 in
   if ((string_startswith s12160 (''fmadd.d''))) then  
  (case  ((string_drop s12160 ((string_length (''fmadd.d''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s12150  :: " string "


definition f_madd_type_mnemonic_D_matches_prefix  :: \<open> string \<Rightarrow>(f_madd_op_D*int)option \<close>  where 
     \<open> f_madd_type_mnemonic_D_matches_prefix arg1 = (
   (let s12170 = arg1 in
   if ((case  ((s1214 s12170)) of   Some (s1) => True | _ => False )) then  
  (case  s1214 s12170 of
      (Some (s1)) =>
  Some (FMADD_D, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s1218 s12170)) of   Some (s1) => True | _ => False )) then  
  (case  s1218 s12170 of
      (Some (s1)) =>
  Some (FMSUB_D, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s1222 s12170)) of   Some (s1) => True | _ => False )) then  
  (case  s1222 s12170 of
      (Some (s1)) =>
  Some (FNMSUB_D, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s1226 s12170)) of   Some (s1) => True | _ => False )) then  
  (case  s1226 s12170 of
      (Some (s1)) =>
  Some (FNMADD_D, ((string_length arg1)) - ((string_length s1)))
  )
   else None))\<close> 
  for  arg1  :: " string "


\<comment> \<open>\<open>val f_bin_rm_type_mnemonic_D_forwards : f_bin_rm_op_D -> string\<close>\<close>

\<comment> \<open>\<open>val f_bin_rm_type_mnemonic_D_backwards : string -> M f_bin_rm_op_D\<close>\<close>

\<comment> \<open>\<open>val f_bin_rm_type_mnemonic_D_forwards_matches : f_bin_rm_op_D -> bool\<close>\<close>

\<comment> \<open>\<open>val f_bin_rm_type_mnemonic_D_backwards_matches : string -> bool\<close>\<close>

\<comment> \<open>\<open>val f_bin_rm_type_mnemonic_D_matches_prefix : string -> maybe ((f_bin_rm_op_D * ii))\<close>\<close>

fun f_bin_rm_type_mnemonic_D_forwards  :: \<open> f_bin_rm_op_D \<Rightarrow> string \<close>  where 
     \<open> f_bin_rm_type_mnemonic_D_forwards FADD_D = ( (''fadd.d''))\<close>
|\<open> f_bin_rm_type_mnemonic_D_forwards FSUB_D = ( (''fsub.d''))\<close>
|\<open> f_bin_rm_type_mnemonic_D_forwards FMUL_D = ( (''fmul.d''))\<close>
|\<open> f_bin_rm_type_mnemonic_D_forwards FDIV_D = ( (''fdiv.d''))\<close>


definition f_bin_rm_type_mnemonic_D_backwards  :: \<open> string \<Rightarrow>((register_value),(f_bin_rm_op_D),(exception))monad \<close>  where 
     \<open> f_bin_rm_type_mnemonic_D_backwards arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''fadd.d'')))) then return FADD_D
   else if (((p00 = (''fsub.d'')))) then return FSUB_D
   else if (((p00 = (''fmul.d'')))) then return FMUL_D
   else if (((p00 = (''fdiv.d'')))) then return FDIV_D
   else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))\<close> 
  for  arg1  :: " string "


fun f_bin_rm_type_mnemonic_D_forwards_matches  :: \<open> f_bin_rm_op_D \<Rightarrow> bool \<close>  where 
     \<open> f_bin_rm_type_mnemonic_D_forwards_matches FADD_D = ( True )\<close>
|\<open> f_bin_rm_type_mnemonic_D_forwards_matches FSUB_D = ( True )\<close>
|\<open> f_bin_rm_type_mnemonic_D_forwards_matches FMUL_D = ( True )\<close>
|\<open> f_bin_rm_type_mnemonic_D_forwards_matches FDIV_D = ( True )\<close>


definition f_bin_rm_type_mnemonic_D_backwards_matches  :: \<open> string \<Rightarrow> bool \<close>  where 
     \<open> f_bin_rm_type_mnemonic_D_backwards_matches arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''fadd.d'')))) then True
   else if (((p00 = (''fsub.d'')))) then True
   else if (((p00 = (''fmul.d'')))) then True
   else if (((p00 = (''fdiv.d'')))) then True
   else False))\<close> 
  for  arg1  :: " string "


\<comment> \<open>\<open>val _s1242_ : string -> maybe string\<close>\<close>

definition s1242  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s1242 s12430 = (
   (let s12440 = s12430 in
   if ((string_startswith s12440 (''fdiv.d''))) then  
  (case  ((string_drop s12440 ((string_length (''fdiv.d''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s12430  :: " string "


\<comment> \<open>\<open>val _s1238_ : string -> maybe string\<close>\<close>

definition s1238  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s1238 s12390 = (
   (let s12400 = s12390 in
   if ((string_startswith s12400 (''fmul.d''))) then  
  (case  ((string_drop s12400 ((string_length (''fmul.d''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s12390  :: " string "


\<comment> \<open>\<open>val _s1234_ : string -> maybe string\<close>\<close>

definition s1234  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s1234 s12350 = (
   (let s12360 = s12350 in
   if ((string_startswith s12360 (''fsub.d''))) then  
  (case  ((string_drop s12360 ((string_length (''fsub.d''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s12350  :: " string "


\<comment> \<open>\<open>val _s1230_ : string -> maybe string\<close>\<close>

definition s1230  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s1230 s12310 = (
   (let s12320 = s12310 in
   if ((string_startswith s12320 (''fadd.d''))) then  
  (case  ((string_drop s12320 ((string_length (''fadd.d''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s12310  :: " string "


definition f_bin_rm_type_mnemonic_D_matches_prefix  :: \<open> string \<Rightarrow>(f_bin_rm_op_D*int)option \<close>  where 
     \<open> f_bin_rm_type_mnemonic_D_matches_prefix arg1 = (
   (let s12330 = arg1 in
   if ((case  ((s1230 s12330)) of   Some (s1) => True | _ => False )) then  
  (case  s1230 s12330 of
      (Some (s1)) =>
  Some (FADD_D, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s1234 s12330)) of   Some (s1) => True | _ => False )) then  
  (case  s1234 s12330 of
      (Some (s1)) =>
  Some (FSUB_D, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s1238 s12330)) of   Some (s1) => True | _ => False )) then  
  (case  s1238 s12330 of
      (Some (s1)) =>
  Some (FMUL_D, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s1242 s12330)) of   Some (s1) => True | _ => False )) then  
  (case  s1242 s12330 of
      (Some (s1)) =>
  Some (FDIV_D, ((string_length arg1)) - ((string_length s1)))
  )
   else None))\<close> 
  for  arg1  :: " string "


\<comment> \<open>\<open>val f_un_rm_type_mnemonic_D_forwards : f_un_rm_op_D -> string\<close>\<close>

\<comment> \<open>\<open>val f_un_rm_type_mnemonic_D_backwards : string -> M f_un_rm_op_D\<close>\<close>

\<comment> \<open>\<open>val f_un_rm_type_mnemonic_D_forwards_matches : f_un_rm_op_D -> bool\<close>\<close>

\<comment> \<open>\<open>val f_un_rm_type_mnemonic_D_backwards_matches : string -> bool\<close>\<close>

\<comment> \<open>\<open>val f_un_rm_type_mnemonic_D_matches_prefix : string -> maybe ((f_un_rm_op_D * ii))\<close>\<close>

fun f_un_rm_type_mnemonic_D_forwards  :: \<open> f_un_rm_op_D \<Rightarrow> string \<close>  where 
     \<open> f_un_rm_type_mnemonic_D_forwards FSQRT_D = ( (''fsqrt.d''))\<close>
|\<open> f_un_rm_type_mnemonic_D_forwards FCVT_W_D = ( (''fcvt.w.d''))\<close>
|\<open> f_un_rm_type_mnemonic_D_forwards FCVT_WU_D = ( (''fcvt.wu.d''))\<close>
|\<open> f_un_rm_type_mnemonic_D_forwards FCVT_D_W = ( (''fcvt.d.w''))\<close>
|\<open> f_un_rm_type_mnemonic_D_forwards FCVT_D_WU = ( (''fcvt.d.wu''))\<close>
|\<open> f_un_rm_type_mnemonic_D_forwards FCVT_L_D = ( (''fcvt.l.d''))\<close>
|\<open> f_un_rm_type_mnemonic_D_forwards FCVT_LU_D = ( (''fcvt.lu.d''))\<close>
|\<open> f_un_rm_type_mnemonic_D_forwards FCVT_D_L = ( (''fcvt.d.l''))\<close>
|\<open> f_un_rm_type_mnemonic_D_forwards FCVT_D_LU = ( (''fcvt.d.lu''))\<close>
|\<open> f_un_rm_type_mnemonic_D_forwards FCVT_S_D = ( (''fcvt.s.d''))\<close>
|\<open> f_un_rm_type_mnemonic_D_forwards FCVT_D_S = ( (''fcvt.d.s''))\<close>


definition f_un_rm_type_mnemonic_D_backwards  :: \<open> string \<Rightarrow>((register_value),(f_un_rm_op_D),(exception))monad \<close>  where 
     \<open> f_un_rm_type_mnemonic_D_backwards arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''fsqrt.d'')))) then return FSQRT_D
   else if (((p00 = (''fcvt.w.d'')))) then return FCVT_W_D
   else if (((p00 = (''fcvt.wu.d'')))) then return FCVT_WU_D
   else if (((p00 = (''fcvt.d.w'')))) then return FCVT_D_W
   else if (((p00 = (''fcvt.d.wu'')))) then return FCVT_D_WU
   else if (((p00 = (''fcvt.l.d'')))) then return FCVT_L_D
   else if (((p00 = (''fcvt.lu.d'')))) then return FCVT_LU_D
   else if (((p00 = (''fcvt.d.l'')))) then return FCVT_D_L
   else if (((p00 = (''fcvt.d.lu'')))) then return FCVT_D_LU
   else if (((p00 = (''fcvt.s.d'')))) then return FCVT_S_D
   else if (((p00 = (''fcvt.d.s'')))) then return FCVT_D_S
   else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))\<close> 
  for  arg1  :: " string "


fun f_un_rm_type_mnemonic_D_forwards_matches  :: \<open> f_un_rm_op_D \<Rightarrow> bool \<close>  where 
     \<open> f_un_rm_type_mnemonic_D_forwards_matches FSQRT_D = ( True )\<close>
|\<open> f_un_rm_type_mnemonic_D_forwards_matches FCVT_W_D = ( True )\<close>
|\<open> f_un_rm_type_mnemonic_D_forwards_matches FCVT_WU_D = ( True )\<close>
|\<open> f_un_rm_type_mnemonic_D_forwards_matches FCVT_D_W = ( True )\<close>
|\<open> f_un_rm_type_mnemonic_D_forwards_matches FCVT_D_WU = ( True )\<close>
|\<open> f_un_rm_type_mnemonic_D_forwards_matches FCVT_L_D = ( True )\<close>
|\<open> f_un_rm_type_mnemonic_D_forwards_matches FCVT_LU_D = ( True )\<close>
|\<open> f_un_rm_type_mnemonic_D_forwards_matches FCVT_D_L = ( True )\<close>
|\<open> f_un_rm_type_mnemonic_D_forwards_matches FCVT_D_LU = ( True )\<close>
|\<open> f_un_rm_type_mnemonic_D_forwards_matches FCVT_S_D = ( True )\<close>
|\<open> f_un_rm_type_mnemonic_D_forwards_matches FCVT_D_S = ( True )\<close>


definition f_un_rm_type_mnemonic_D_backwards_matches  :: \<open> string \<Rightarrow> bool \<close>  where 
     \<open> f_un_rm_type_mnemonic_D_backwards_matches arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''fsqrt.d'')))) then True
   else if (((p00 = (''fcvt.w.d'')))) then True
   else if (((p00 = (''fcvt.wu.d'')))) then True
   else if (((p00 = (''fcvt.d.w'')))) then True
   else if (((p00 = (''fcvt.d.wu'')))) then True
   else if (((p00 = (''fcvt.l.d'')))) then True
   else if (((p00 = (''fcvt.lu.d'')))) then True
   else if (((p00 = (''fcvt.d.l'')))) then True
   else if (((p00 = (''fcvt.d.lu'')))) then True
   else if (((p00 = (''fcvt.s.d'')))) then True
   else if (((p00 = (''fcvt.d.s'')))) then True
   else False))\<close> 
  for  arg1  :: " string "


\<comment> \<open>\<open>val _s1286_ : string -> maybe string\<close>\<close>

definition s1286  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s1286 s12870 = (
   (let s12880 = s12870 in
   if ((string_startswith s12880 (''fcvt.d.s''))) then  
  (case  ((string_drop s12880 ((string_length (''fcvt.d.s''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s12870  :: " string "


\<comment> \<open>\<open>val _s1282_ : string -> maybe string\<close>\<close>

definition s1282  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s1282 s12830 = (
   (let s12840 = s12830 in
   if ((string_startswith s12840 (''fcvt.s.d''))) then  
  (case  ((string_drop s12840 ((string_length (''fcvt.s.d''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s12830  :: " string "


\<comment> \<open>\<open>val _s1278_ : string -> maybe string\<close>\<close>

definition s1278  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s1278 s12790 = (
   (let s12800 = s12790 in
   if ((string_startswith s12800 (''fcvt.d.lu''))) then  
  (case  ((string_drop s12800 ((string_length (''fcvt.d.lu''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s12790  :: " string "


\<comment> \<open>\<open>val _s1274_ : string -> maybe string\<close>\<close>

definition s1274  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s1274 s12750 = (
   (let s12760 = s12750 in
   if ((string_startswith s12760 (''fcvt.d.l''))) then  
  (case  ((string_drop s12760 ((string_length (''fcvt.d.l''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s12750  :: " string "


\<comment> \<open>\<open>val _s1270_ : string -> maybe string\<close>\<close>

definition s1270  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s1270 s12710 = (
   (let s12720 = s12710 in
   if ((string_startswith s12720 (''fcvt.lu.d''))) then  
  (case  ((string_drop s12720 ((string_length (''fcvt.lu.d''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s12710  :: " string "


\<comment> \<open>\<open>val _s1266_ : string -> maybe string\<close>\<close>

definition s1266  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s1266 s12670 = (
   (let s12680 = s12670 in
   if ((string_startswith s12680 (''fcvt.l.d''))) then  
  (case  ((string_drop s12680 ((string_length (''fcvt.l.d''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s12670  :: " string "


\<comment> \<open>\<open>val _s1262_ : string -> maybe string\<close>\<close>

definition s1262  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s1262 s12630 = (
   (let s12640 = s12630 in
   if ((string_startswith s12640 (''fcvt.d.wu''))) then  
  (case  ((string_drop s12640 ((string_length (''fcvt.d.wu''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s12630  :: " string "


\<comment> \<open>\<open>val _s1258_ : string -> maybe string\<close>\<close>

definition s1258  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s1258 s12590 = (
   (let s12600 = s12590 in
   if ((string_startswith s12600 (''fcvt.d.w''))) then  
  (case  ((string_drop s12600 ((string_length (''fcvt.d.w''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s12590  :: " string "


\<comment> \<open>\<open>val _s1254_ : string -> maybe string\<close>\<close>

definition s1254  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s1254 s12550 = (
   (let s12560 = s12550 in
   if ((string_startswith s12560 (''fcvt.wu.d''))) then  
  (case  ((string_drop s12560 ((string_length (''fcvt.wu.d''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s12550  :: " string "


\<comment> \<open>\<open>val _s1250_ : string -> maybe string\<close>\<close>

definition s1250  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s1250 s12510 = (
   (let s12520 = s12510 in
   if ((string_startswith s12520 (''fcvt.w.d''))) then  
  (case  ((string_drop s12520 ((string_length (''fcvt.w.d''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s12510  :: " string "


\<comment> \<open>\<open>val _s1246_ : string -> maybe string\<close>\<close>

definition s1246  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s1246 s12470 = (
   (let s12480 = s12470 in
   if ((string_startswith s12480 (''fsqrt.d''))) then  
  (case  ((string_drop s12480 ((string_length (''fsqrt.d''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s12470  :: " string "


definition f_un_rm_type_mnemonic_D_matches_prefix  :: \<open> string \<Rightarrow>(f_un_rm_op_D*int)option \<close>  where 
     \<open> f_un_rm_type_mnemonic_D_matches_prefix arg1 = (
   (let s12490 = arg1 in
   if ((case  ((s1246 s12490)) of   Some (s1) => True | _ => False )) then  
  (case  s1246 s12490 of
      (Some (s1)) =>
  Some (FSQRT_D, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s1250 s12490)) of   Some (s1) => True | _ => False )) then  
  (case  s1250 s12490 of
      (Some (s1)) =>
  Some (FCVT_W_D, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s1254 s12490)) of   Some (s1) => True | _ => False )) then  
  (case  s1254 s12490 of
      (Some (s1)) =>
  Some (FCVT_WU_D, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s1258 s12490)) of   Some (s1) => True | _ => False )) then  
  (case  s1258 s12490 of
      (Some (s1)) =>
  Some (FCVT_D_W, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s1262 s12490)) of   Some (s1) => True | _ => False )) then  
  (case  s1262 s12490 of
      (Some (s1)) =>
  Some (FCVT_D_WU, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s1266 s12490)) of   Some (s1) => True | _ => False )) then  
  (case  s1266 s12490 of
      (Some (s1)) =>
  Some (FCVT_L_D, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s1270 s12490)) of   Some (s1) => True | _ => False )) then  
  (case  s1270 s12490 of
      (Some (s1)) =>
  Some (FCVT_LU_D, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s1274 s12490)) of   Some (s1) => True | _ => False )) then  
  (case  s1274 s12490 of
      (Some (s1)) =>
  Some (FCVT_D_L, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s1278 s12490)) of   Some (s1) => True | _ => False )) then  
  (case  s1278 s12490 of
      (Some (s1)) =>
  Some (FCVT_D_LU, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s1282 s12490)) of   Some (s1) => True | _ => False )) then  
  (case  s1282 s12490 of
      (Some (s1)) =>
  Some (FCVT_S_D, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s1286 s12490)) of   Some (s1) => True | _ => False )) then  
  (case  s1286 s12490 of
      (Some (s1)) =>
  Some (FCVT_D_S, ((string_length arg1)) - ((string_length s1)))
  )
   else None))\<close> 
  for  arg1  :: " string "


\<comment> \<open>\<open>val f_bin_type_mnemonic_D_forwards : f_bin_op_D -> string\<close>\<close>

\<comment> \<open>\<open>val f_bin_type_mnemonic_D_backwards : string -> M f_bin_op_D\<close>\<close>

\<comment> \<open>\<open>val f_bin_type_mnemonic_D_forwards_matches : f_bin_op_D -> bool\<close>\<close>

\<comment> \<open>\<open>val f_bin_type_mnemonic_D_backwards_matches : string -> bool\<close>\<close>

\<comment> \<open>\<open>val f_bin_type_mnemonic_D_matches_prefix : string -> maybe ((f_bin_op_D * ii))\<close>\<close>

fun f_bin_type_mnemonic_D_forwards  :: \<open> f_bin_op_D \<Rightarrow> string \<close>  where 
     \<open> f_bin_type_mnemonic_D_forwards FSGNJ_D = ( (''fsgnj.d''))\<close>
|\<open> f_bin_type_mnemonic_D_forwards FSGNJN_D = ( (''fsgnjn.d''))\<close>
|\<open> f_bin_type_mnemonic_D_forwards FSGNJX_D = ( (''fsgnjx.d''))\<close>
|\<open> f_bin_type_mnemonic_D_forwards FMIN_D = ( (''fmin.d''))\<close>
|\<open> f_bin_type_mnemonic_D_forwards FMAX_D = ( (''fmax.d''))\<close>
|\<open> f_bin_type_mnemonic_D_forwards FEQ_D = ( (''feq.d''))\<close>
|\<open> f_bin_type_mnemonic_D_forwards FLT_D = ( (''flt.d''))\<close>
|\<open> f_bin_type_mnemonic_D_forwards FLE_D = ( (''fle.d''))\<close>


definition f_bin_type_mnemonic_D_backwards  :: \<open> string \<Rightarrow>((register_value),(f_bin_op_D),(exception))monad \<close>  where 
     \<open> f_bin_type_mnemonic_D_backwards arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''fsgnj.d'')))) then return FSGNJ_D
   else if (((p00 = (''fsgnjn.d'')))) then return FSGNJN_D
   else if (((p00 = (''fsgnjx.d'')))) then return FSGNJX_D
   else if (((p00 = (''fmin.d'')))) then return FMIN_D
   else if (((p00 = (''fmax.d'')))) then return FMAX_D
   else if (((p00 = (''feq.d'')))) then return FEQ_D
   else if (((p00 = (''flt.d'')))) then return FLT_D
   else if (((p00 = (''fle.d'')))) then return FLE_D
   else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))\<close> 
  for  arg1  :: " string "


fun f_bin_type_mnemonic_D_forwards_matches  :: \<open> f_bin_op_D \<Rightarrow> bool \<close>  where 
     \<open> f_bin_type_mnemonic_D_forwards_matches FSGNJ_D = ( True )\<close>
|\<open> f_bin_type_mnemonic_D_forwards_matches FSGNJN_D = ( True )\<close>
|\<open> f_bin_type_mnemonic_D_forwards_matches FSGNJX_D = ( True )\<close>
|\<open> f_bin_type_mnemonic_D_forwards_matches FMIN_D = ( True )\<close>
|\<open> f_bin_type_mnemonic_D_forwards_matches FMAX_D = ( True )\<close>
|\<open> f_bin_type_mnemonic_D_forwards_matches FEQ_D = ( True )\<close>
|\<open> f_bin_type_mnemonic_D_forwards_matches FLT_D = ( True )\<close>
|\<open> f_bin_type_mnemonic_D_forwards_matches FLE_D = ( True )\<close>


definition f_bin_type_mnemonic_D_backwards_matches  :: \<open> string \<Rightarrow> bool \<close>  where 
     \<open> f_bin_type_mnemonic_D_backwards_matches arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''fsgnj.d'')))) then True
   else if (((p00 = (''fsgnjn.d'')))) then True
   else if (((p00 = (''fsgnjx.d'')))) then True
   else if (((p00 = (''fmin.d'')))) then True
   else if (((p00 = (''fmax.d'')))) then True
   else if (((p00 = (''feq.d'')))) then True
   else if (((p00 = (''flt.d'')))) then True
   else if (((p00 = (''fle.d'')))) then True
   else False))\<close> 
  for  arg1  :: " string "


\<comment> \<open>\<open>val _s1318_ : string -> maybe string\<close>\<close>

definition s1318  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s1318 s13190 = (
   (let s13200 = s13190 in
   if ((string_startswith s13200 (''fle.d''))) then  
  (case  ((string_drop s13200 ((string_length (''fle.d''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s13190  :: " string "


\<comment> \<open>\<open>val _s1314_ : string -> maybe string\<close>\<close>

definition s1314  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s1314 s13150 = (
   (let s13160 = s13150 in
   if ((string_startswith s13160 (''flt.d''))) then  
  (case  ((string_drop s13160 ((string_length (''flt.d''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s13150  :: " string "


\<comment> \<open>\<open>val _s1310_ : string -> maybe string\<close>\<close>

definition s1310  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s1310 s13110 = (
   (let s13120 = s13110 in
   if ((string_startswith s13120 (''feq.d''))) then  
  (case  ((string_drop s13120 ((string_length (''feq.d''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s13110  :: " string "


\<comment> \<open>\<open>val _s1306_ : string -> maybe string\<close>\<close>

definition s1306  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s1306 s13070 = (
   (let s13080 = s13070 in
   if ((string_startswith s13080 (''fmax.d''))) then  
  (case  ((string_drop s13080 ((string_length (''fmax.d''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s13070  :: " string "


\<comment> \<open>\<open>val _s1302_ : string -> maybe string\<close>\<close>

definition s1302  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s1302 s13030 = (
   (let s13040 = s13030 in
   if ((string_startswith s13040 (''fmin.d''))) then  
  (case  ((string_drop s13040 ((string_length (''fmin.d''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s13030  :: " string "


\<comment> \<open>\<open>val _s1298_ : string -> maybe string\<close>\<close>

definition s1298  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s1298 s12990 = (
   (let s13000 = s12990 in
   if ((string_startswith s13000 (''fsgnjx.d''))) then  
  (case  ((string_drop s13000 ((string_length (''fsgnjx.d''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s12990  :: " string "


\<comment> \<open>\<open>val _s1294_ : string -> maybe string\<close>\<close>

definition s1294  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s1294 s12950 = (
   (let s12960 = s12950 in
   if ((string_startswith s12960 (''fsgnjn.d''))) then  
  (case  ((string_drop s12960 ((string_length (''fsgnjn.d''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s12950  :: " string "


\<comment> \<open>\<open>val _s1290_ : string -> maybe string\<close>\<close>

definition s1290  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s1290 s12910 = (
   (let s12920 = s12910 in
   if ((string_startswith s12920 (''fsgnj.d''))) then  
  (case  ((string_drop s12920 ((string_length (''fsgnj.d''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s12910  :: " string "


definition f_bin_type_mnemonic_D_matches_prefix  :: \<open> string \<Rightarrow>(f_bin_op_D*int)option \<close>  where 
     \<open> f_bin_type_mnemonic_D_matches_prefix arg1 = (
   (let s12930 = arg1 in
   if ((case  ((s1290 s12930)) of   Some (s1) => True | _ => False )) then  
  (case  s1290 s12930 of
      (Some (s1)) =>
  Some (FSGNJ_D, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s1294 s12930)) of   Some (s1) => True | _ => False )) then  
  (case  s1294 s12930 of
      (Some (s1)) =>
  Some (FSGNJN_D, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s1298 s12930)) of   Some (s1) => True | _ => False )) then  
  (case  s1298 s12930 of
      (Some (s1)) =>
  Some (FSGNJX_D, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s1302 s12930)) of   Some (s1) => True | _ => False )) then  
  (case  s1302 s12930 of
      (Some (s1)) =>
  Some (FMIN_D, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s1306 s12930)) of   Some (s1) => True | _ => False )) then  
  (case  s1306 s12930 of
      (Some (s1)) =>
  Some (FMAX_D, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s1310 s12930)) of   Some (s1) => True | _ => False )) then  
  (case  s1310 s12930 of
      (Some (s1)) =>
  Some (FEQ_D, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s1314 s12930)) of   Some (s1) => True | _ => False )) then  
  (case  s1314 s12930 of
      (Some (s1)) =>
  Some (FLT_D, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s1318 s12930)) of   Some (s1) => True | _ => False )) then  
  (case  s1318 s12930 of
      (Some (s1)) =>
  Some (FLE_D, ((string_length arg1)) - ((string_length s1)))
  )
   else None))\<close> 
  for  arg1  :: " string "


\<comment> \<open>\<open>val f_un_type_mnemonic_D_forwards : f_un_op_D -> string\<close>\<close>

\<comment> \<open>\<open>val f_un_type_mnemonic_D_backwards : string -> M f_un_op_D\<close>\<close>

\<comment> \<open>\<open>val f_un_type_mnemonic_D_forwards_matches : f_un_op_D -> bool\<close>\<close>

\<comment> \<open>\<open>val f_un_type_mnemonic_D_backwards_matches : string -> bool\<close>\<close>

\<comment> \<open>\<open>val f_un_type_mnemonic_D_matches_prefix : string -> maybe ((f_un_op_D * ii))\<close>\<close>

fun f_un_type_mnemonic_D_forwards  :: \<open> f_un_op_D \<Rightarrow> string \<close>  where 
     \<open> f_un_type_mnemonic_D_forwards FMV_X_D = ( (''fmv.x.d''))\<close>
|\<open> f_un_type_mnemonic_D_forwards FCLASS_D = ( (''fclass.d''))\<close>
|\<open> f_un_type_mnemonic_D_forwards FMV_D_X = ( (''fmv.d.x''))\<close>


definition f_un_type_mnemonic_D_backwards  :: \<open> string \<Rightarrow>((register_value),(f_un_op_D),(exception))monad \<close>  where 
     \<open> f_un_type_mnemonic_D_backwards arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''fmv.x.d'')))) then return FMV_X_D
   else if (((p00 = (''fclass.d'')))) then return FCLASS_D
   else if (((p00 = (''fmv.d.x'')))) then return FMV_D_X
   else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))\<close> 
  for  arg1  :: " string "


fun f_un_type_mnemonic_D_forwards_matches  :: \<open> f_un_op_D \<Rightarrow> bool \<close>  where 
     \<open> f_un_type_mnemonic_D_forwards_matches FMV_X_D = ( True )\<close>
|\<open> f_un_type_mnemonic_D_forwards_matches FCLASS_D = ( True )\<close>
|\<open> f_un_type_mnemonic_D_forwards_matches FMV_D_X = ( True )\<close>


definition f_un_type_mnemonic_D_backwards_matches  :: \<open> string \<Rightarrow> bool \<close>  where 
     \<open> f_un_type_mnemonic_D_backwards_matches arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''fmv.x.d'')))) then True
   else if (((p00 = (''fclass.d'')))) then True
   else if (((p00 = (''fmv.d.x'')))) then True
   else False))\<close> 
  for  arg1  :: " string "


\<comment> \<open>\<open>val _s1330_ : string -> maybe string\<close>\<close>

definition s1330  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s1330 s13310 = (
   (let s13320 = s13310 in
   if ((string_startswith s13320 (''fmv.d.x''))) then  
  (case  ((string_drop s13320 ((string_length (''fmv.d.x''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s13310  :: " string "


\<comment> \<open>\<open>val _s1326_ : string -> maybe string\<close>\<close>

definition s1326  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s1326 s13270 = (
   (let s13280 = s13270 in
   if ((string_startswith s13280 (''fclass.d''))) then  
  (case  ((string_drop s13280 ((string_length (''fclass.d''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s13270  :: " string "


\<comment> \<open>\<open>val _s1322_ : string -> maybe string\<close>\<close>

definition s1322  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s1322 s13230 = (
   (let s13240 = s13230 in
   if ((string_startswith s13240 (''fmv.x.d''))) then  
  (case  ((string_drop s13240 ((string_length (''fmv.x.d''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s13230  :: " string "


definition f_un_type_mnemonic_D_matches_prefix  :: \<open> string \<Rightarrow>(f_un_op_D*int)option \<close>  where 
     \<open> f_un_type_mnemonic_D_matches_prefix arg1 = (
   (let s13250 = arg1 in
   if ((case  ((s1322 s13250)) of   Some (s1) => True | _ => False )) then  
  (case  s1322 s13250 of
      (Some (s1)) =>
  Some (FMV_X_D, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s1326 s13250)) of   Some (s1) => True | _ => False )) then  
  (case  s1326 s13250 of
      (Some (s1)) =>
  Some (FCLASS_D, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s1330 s13250)) of   Some (s1) => True | _ => False )) then  
  (case  s1330 s13250 of
      (Some (s1)) =>
  Some (FMV_D_X, ((string_length arg1)) - ((string_length s1)))
  )
   else None))\<close> 
  for  arg1  :: " string "


definition encdec_forwards  :: \<open> ast \<Rightarrow>((register_value),((32)Word.word),(exception))monad \<close>  where 
     \<open> encdec_forwards ast = (
   (let arg1 = ast in
   (case  arg1 of
     UTYPE ((imm, rd, op1)) =>
      return ((concat_vec imm
                 ((concat_vec rd ((encdec_uop_forwards op1  ::  7 Word.word))  ::  12 Word.word))
                ::  32 Word.word))
   | RISCV_JAL ((v__2, rd)) =>
      if (((((subrange_vec_dec v__2 (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) = ( 0b0 ::  1 Word.word)))) then
        (let (imm_19 :: 1 bits) = ((subrange_vec_dec v__2 (( 20 :: int)::ii) (( 20 :: int)::ii)  ::  1 Word.word)) in
        (let (imm_8 :: 1 bits) = ((subrange_vec_dec v__2 (( 11 :: int)::ii) (( 11 :: int)::ii)  ::  1 Word.word)) in
        (let (imm_7_0 :: 8 bits) = ((subrange_vec_dec v__2 (( 19 :: int)::ii) (( 12 :: int)::ii)  ::  8 Word.word)) in
        (let (imm_19 :: 1 bits) = ((subrange_vec_dec v__2 (( 20 :: int)::ii) (( 20 :: int)::ii)  ::  1 Word.word)) in
        (let (imm_18_13 :: 6 bits) = ((subrange_vec_dec v__2 (( 10 :: int)::ii) (( 5 :: int)::ii)  ::  6 Word.word)) in
        (let (imm_12_9 :: 4 bits) = ((subrange_vec_dec v__2 (( 4 :: int)::ii) (( 1 :: int)::ii)  ::  4 Word.word)) in
        return ((concat_vec imm_19
                   ((concat_vec imm_18_13
                       ((concat_vec imm_12_9
                           ((concat_vec imm_8
                               ((concat_vec imm_7_0
                                   ((concat_vec rd ( 0b1101111 ::  7 Word.word)  ::  12 Word.word))
                                  ::  20 Word.word))
                              ::  21 Word.word))
                          ::  25 Word.word))
                      ::  31 Word.word))
                  ::  32 Word.word))))))))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () 
   | RISCV_JALR ((imm, rs1, rd)) =>
      return ((concat_vec imm
                 ((concat_vec rs1
                     ((concat_vec ( 0b000 ::  3 Word.word)
                         ((concat_vec rd ( 0b1100111 ::  7 Word.word)  ::  12 Word.word))
                        ::  15 Word.word))
                    ::  20 Word.word))
                ::  32 Word.word))
   | BTYPE ((v__4, rs2, rs1, op1)) =>
      if (((((subrange_vec_dec v__4 (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) = ( 0b0 ::  1 Word.word)))) then
        (let (imm7_6 :: 1 bits) = ((subrange_vec_dec v__4 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
        (let (imm7_6 :: 1 bits) = ((subrange_vec_dec v__4 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
        (let (imm7_5_0 :: 6 bits) = ((subrange_vec_dec v__4 (( 10 :: int)::ii) (( 5 :: int)::ii)  ::  6 Word.word)) in
        (let (imm5_4_1 :: 4 bits) = ((subrange_vec_dec v__4 (( 4 :: int)::ii) (( 1 :: int)::ii)  ::  4 Word.word)) in
        (let (imm5_0 :: 1 bits) = ((subrange_vec_dec v__4 (( 11 :: int)::ii) (( 11 :: int)::ii)  ::  1 Word.word)) in
        return ((concat_vec imm7_6
                   ((concat_vec imm7_5_0
                       ((concat_vec rs2
                           ((concat_vec rs1
                               ((concat_vec ((encdec_bop_forwards op1  ::  3 Word.word))
                                   ((concat_vec imm5_4_1
                                       ((concat_vec imm5_0 ( 0b1100011 ::  7 Word.word)  ::  8 Word.word))
                                      ::  12 Word.word))
                                  ::  15 Word.word))
                              ::  20 Word.word))
                          ::  25 Word.word))
                      ::  31 Word.word))
                  ::  32 Word.word)))))))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () 
   | ITYPE ((imm, rs1, rd, op1)) =>
      return ((concat_vec imm
                 ((concat_vec rs1
                     ((concat_vec ((encdec_iop_forwards op1  ::  3 Word.word))
                         ((concat_vec rd ( 0b0010011 ::  7 Word.word)  ::  12 Word.word))
                        ::  15 Word.word))
                    ::  20 Word.word))
                ::  32 Word.word))
   | SHIFTIOP ((shamt, rs1, rd, RISCV_SLLI)) =>
      return ((concat_vec ( 0b000000 ::  6 Word.word)
                 ((concat_vec shamt
                     ((concat_vec rs1
                         ((concat_vec ( 0b001 ::  3 Word.word)
                             ((concat_vec rd ( 0b0010011 ::  7 Word.word)  ::  12 Word.word))
                            ::  15 Word.word))
                        ::  20 Word.word))
                    ::  26 Word.word))
                ::  32 Word.word))
   | SHIFTIOP ((shamt, rs1, rd, RISCV_SRLI)) =>
      return ((concat_vec ( 0b000000 ::  6 Word.word)
                 ((concat_vec shamt
                     ((concat_vec rs1
                         ((concat_vec ( 0b101 ::  3 Word.word)
                             ((concat_vec rd ( 0b0010011 ::  7 Word.word)  ::  12 Word.word))
                            ::  15 Word.word))
                        ::  20 Word.word))
                    ::  26 Word.word))
                ::  32 Word.word))
   | SHIFTIOP ((shamt, rs1, rd, RISCV_SRAI)) =>
      return ((concat_vec ( 0b010000 ::  6 Word.word)
                 ((concat_vec shamt
                     ((concat_vec rs1
                         ((concat_vec ( 0b101 ::  3 Word.word)
                             ((concat_vec rd ( 0b0010011 ::  7 Word.word)  ::  12 Word.word))
                            ::  15 Word.word))
                        ::  20 Word.word))
                    ::  26 Word.word))
                ::  32 Word.word))
   | RTYPE ((rs2, rs1, rd, RISCV_ADD)) =>
      return ((concat_vec ( 0b0000000 ::  7 Word.word)
                 ((concat_vec rs2
                     ((concat_vec rs1
                         ((concat_vec ( 0b000 ::  3 Word.word)
                             ((concat_vec rd ( 0b0110011 ::  7 Word.word)  ::  12 Word.word))
                            ::  15 Word.word))
                        ::  20 Word.word))
                    ::  25 Word.word))
                ::  32 Word.word))
   | RTYPE ((rs2, rs1, rd, RISCV_SLT)) =>
      return ((concat_vec ( 0b0000000 ::  7 Word.word)
                 ((concat_vec rs2
                     ((concat_vec rs1
                         ((concat_vec ( 0b010 ::  3 Word.word)
                             ((concat_vec rd ( 0b0110011 ::  7 Word.word)  ::  12 Word.word))
                            ::  15 Word.word))
                        ::  20 Word.word))
                    ::  25 Word.word))
                ::  32 Word.word))
   | RTYPE ((rs2, rs1, rd, RISCV_SLTU)) =>
      return ((concat_vec ( 0b0000000 ::  7 Word.word)
                 ((concat_vec rs2
                     ((concat_vec rs1
                         ((concat_vec ( 0b011 ::  3 Word.word)
                             ((concat_vec rd ( 0b0110011 ::  7 Word.word)  ::  12 Word.word))
                            ::  15 Word.word))
                        ::  20 Word.word))
                    ::  25 Word.word))
                ::  32 Word.word))
   | RTYPE ((rs2, rs1, rd, RISCV_AND)) =>
      return ((concat_vec ( 0b0000000 ::  7 Word.word)
                 ((concat_vec rs2
                     ((concat_vec rs1
                         ((concat_vec ( 0b111 ::  3 Word.word)
                             ((concat_vec rd ( 0b0110011 ::  7 Word.word)  ::  12 Word.word))
                            ::  15 Word.word))
                        ::  20 Word.word))
                    ::  25 Word.word))
                ::  32 Word.word))
   | RTYPE ((rs2, rs1, rd, RISCV_OR)) =>
      return ((concat_vec ( 0b0000000 ::  7 Word.word)
                 ((concat_vec rs2
                     ((concat_vec rs1
                         ((concat_vec ( 0b110 ::  3 Word.word)
                             ((concat_vec rd ( 0b0110011 ::  7 Word.word)  ::  12 Word.word))
                            ::  15 Word.word))
                        ::  20 Word.word))
                    ::  25 Word.word))
                ::  32 Word.word))
   | RTYPE ((rs2, rs1, rd, RISCV_XOR)) =>
      return ((concat_vec ( 0b0000000 ::  7 Word.word)
                 ((concat_vec rs2
                     ((concat_vec rs1
                         ((concat_vec ( 0b100 ::  3 Word.word)
                             ((concat_vec rd ( 0b0110011 ::  7 Word.word)  ::  12 Word.word))
                            ::  15 Word.word))
                        ::  20 Word.word))
                    ::  25 Word.word))
                ::  32 Word.word))
   | RTYPE ((rs2, rs1, rd, RISCV_SLL)) =>
      return ((concat_vec ( 0b0000000 ::  7 Word.word)
                 ((concat_vec rs2
                     ((concat_vec rs1
                         ((concat_vec ( 0b001 ::  3 Word.word)
                             ((concat_vec rd ( 0b0110011 ::  7 Word.word)  ::  12 Word.word))
                            ::  15 Word.word))
                        ::  20 Word.word))
                    ::  25 Word.word))
                ::  32 Word.word))
   | RTYPE ((rs2, rs1, rd, RISCV_SRL)) =>
      return ((concat_vec ( 0b0000000 ::  7 Word.word)
                 ((concat_vec rs2
                     ((concat_vec rs1
                         ((concat_vec ( 0b101 ::  3 Word.word)
                             ((concat_vec rd ( 0b0110011 ::  7 Word.word)  ::  12 Word.word))
                            ::  15 Word.word))
                        ::  20 Word.word))
                    ::  25 Word.word))
                ::  32 Word.word))
   | RTYPE ((rs2, rs1, rd, RISCV_SUB)) =>
      return ((concat_vec ( 0b0100000 ::  7 Word.word)
                 ((concat_vec rs2
                     ((concat_vec rs1
                         ((concat_vec ( 0b000 ::  3 Word.word)
                             ((concat_vec rd ( 0b0110011 ::  7 Word.word)  ::  12 Word.word))
                            ::  15 Word.word))
                        ::  20 Word.word))
                    ::  25 Word.word))
                ::  32 Word.word))
   | RTYPE ((rs2, rs1, rd, RISCV_SRA)) =>
      return ((concat_vec ( 0b0100000 ::  7 Word.word)
                 ((concat_vec rs2
                     ((concat_vec rs1
                         ((concat_vec ( 0b101 ::  3 Word.word)
                             ((concat_vec rd ( 0b0110011 ::  7 Word.word)  ::  12 Word.word))
                            ::  15 Word.word))
                        ::  20 Word.word))
                    ::  25 Word.word))
                ::  32 Word.word))
   | LOAD ((imm, rs1, rd, is_unsigned, size1, False, False)) =>
      if (((((((word_width_bytes size1)) < (( 8 :: int)::ii))) \<or> (((((\<not> is_unsigned)) \<and> ((((word_width_bytes size1)) \<le> (( 8 :: int)::ii))))))))) then
        return ((concat_vec imm
                   ((concat_vec rs1
                       ((concat_vec ((bool_bits_forwards is_unsigned  ::  1 Word.word))
                           ((concat_vec ((size_bits_forwards size1  ::  2 Word.word))
                               ((concat_vec rd ( 0b0000011 ::  7 Word.word)  ::  12 Word.word))
                              ::  14 Word.word))
                          ::  15 Word.word))
                      ::  20 Word.word))
                  ::  32 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () 
   | STORE ((v__6, rs2, rs1, size1, False, False)) =>
      if ((((word_width_bytes size1)) \<le> (( 8 :: int)::ii))) then
        (let (imm7 :: 7 bits) = ((subrange_vec_dec v__6 (( 11 :: int)::ii) (( 5 :: int)::ii)  ::  7 Word.word)) in
        (let (imm7 :: 7 bits) = ((subrange_vec_dec v__6 (( 11 :: int)::ii) (( 5 :: int)::ii)  ::  7 Word.word)) in
        (let (imm5 :: 5 bits) = ((subrange_vec_dec v__6 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
        return ((concat_vec imm7
                   ((concat_vec rs2
                       ((concat_vec rs1
                           ((concat_vec ( 0b0 ::  1 Word.word)
                               ((concat_vec ((size_bits_forwards size1  ::  2 Word.word))
                                   ((concat_vec imm5 ( 0b0100011 ::  7 Word.word)  ::  12 Word.word))
                                  ::  14 Word.word))
                              ::  15 Word.word))
                          ::  20 Word.word))
                      ::  25 Word.word))
                  ::  32 Word.word)))))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () 
   | ADDIW ((imm, rs1, rd)) =>
      if ((((( 64 :: int)::ii) = (( 64 :: int)::ii)))) then
        return ((concat_vec imm
                   ((concat_vec rs1
                       ((concat_vec ( 0b000 ::  3 Word.word)
                           ((concat_vec rd ( 0b0011011 ::  7 Word.word)  ::  12 Word.word))
                          ::  15 Word.word))
                      ::  20 Word.word))
                  ::  32 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () 
   | SHIFTW ((shamt, rs1, rd, RISCV_SLLI)) =>
      if ((((( 64 :: int)::ii) = (( 64 :: int)::ii)))) then
        return ((concat_vec ( 0b0000000 ::  7 Word.word)
                   ((concat_vec shamt
                       ((concat_vec rs1
                           ((concat_vec ( 0b001 ::  3 Word.word)
                               ((concat_vec rd ( 0b0011011 ::  7 Word.word)  ::  12 Word.word))
                              ::  15 Word.word))
                          ::  20 Word.word))
                      ::  25 Word.word))
                  ::  32 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () 
   | SHIFTW ((shamt, rs1, rd, RISCV_SRLI)) =>
      if ((((( 64 :: int)::ii) = (( 64 :: int)::ii)))) then
        return ((concat_vec ( 0b0000000 ::  7 Word.word)
                   ((concat_vec shamt
                       ((concat_vec rs1
                           ((concat_vec ( 0b101 ::  3 Word.word)
                               ((concat_vec rd ( 0b0011011 ::  7 Word.word)  ::  12 Word.word))
                              ::  15 Word.word))
                          ::  20 Word.word))
                      ::  25 Word.word))
                  ::  32 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () 
   | SHIFTW ((shamt, rs1, rd, RISCV_SRAI)) =>
      if ((((( 64 :: int)::ii) = (( 64 :: int)::ii)))) then
        return ((concat_vec ( 0b0100000 ::  7 Word.word)
                   ((concat_vec shamt
                       ((concat_vec rs1
                           ((concat_vec ( 0b101 ::  3 Word.word)
                               ((concat_vec rd ( 0b0011011 ::  7 Word.word)  ::  12 Word.word))
                              ::  15 Word.word))
                          ::  20 Word.word))
                      ::  25 Word.word))
                  ::  32 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () 
   | RTYPEW ((rs2, rs1, rd, RISCV_ADDW)) =>
      if ((((( 64 :: int)::ii) = (( 64 :: int)::ii)))) then
        return ((concat_vec ( 0b0000000 ::  7 Word.word)
                   ((concat_vec rs2
                       ((concat_vec rs1
                           ((concat_vec ( 0b000 ::  3 Word.word)
                               ((concat_vec rd ( 0b0111011 ::  7 Word.word)  ::  12 Word.word))
                              ::  15 Word.word))
                          ::  20 Word.word))
                      ::  25 Word.word))
                  ::  32 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () 
   | RTYPEW ((rs2, rs1, rd, RISCV_SUBW)) =>
      if ((((( 64 :: int)::ii) = (( 64 :: int)::ii)))) then
        return ((concat_vec ( 0b0100000 ::  7 Word.word)
                   ((concat_vec rs2
                       ((concat_vec rs1
                           ((concat_vec ( 0b000 ::  3 Word.word)
                               ((concat_vec rd ( 0b0111011 ::  7 Word.word)  ::  12 Word.word))
                              ::  15 Word.word))
                          ::  20 Word.word))
                      ::  25 Word.word))
                  ::  32 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () 
   | RTYPEW ((rs2, rs1, rd, RISCV_SLLW)) =>
      if ((((( 64 :: int)::ii) = (( 64 :: int)::ii)))) then
        return ((concat_vec ( 0b0000000 ::  7 Word.word)
                   ((concat_vec rs2
                       ((concat_vec rs1
                           ((concat_vec ( 0b001 ::  3 Word.word)
                               ((concat_vec rd ( 0b0111011 ::  7 Word.word)  ::  12 Word.word))
                              ::  15 Word.word))
                          ::  20 Word.word))
                      ::  25 Word.word))
                  ::  32 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () 
   | RTYPEW ((rs2, rs1, rd, RISCV_SRLW)) =>
      if ((((( 64 :: int)::ii) = (( 64 :: int)::ii)))) then
        return ((concat_vec ( 0b0000000 ::  7 Word.word)
                   ((concat_vec rs2
                       ((concat_vec rs1
                           ((concat_vec ( 0b101 ::  3 Word.word)
                               ((concat_vec rd ( 0b0111011 ::  7 Word.word)  ::  12 Word.word))
                              ::  15 Word.word))
                          ::  20 Word.word))
                      ::  25 Word.word))
                  ::  32 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () 
   | RTYPEW ((rs2, rs1, rd, RISCV_SRAW)) =>
      if ((((( 64 :: int)::ii) = (( 64 :: int)::ii)))) then
        return ((concat_vec ( 0b0100000 ::  7 Word.word)
                   ((concat_vec rs2
                       ((concat_vec rs1
                           ((concat_vec ( 0b101 ::  3 Word.word)
                               ((concat_vec rd ( 0b0111011 ::  7 Word.word)  ::  12 Word.word))
                              ::  15 Word.word))
                          ::  20 Word.word))
                      ::  25 Word.word))
                  ::  32 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () 
   | SHIFTIWOP ((shamt, rs1, rd, RISCV_SLLIW)) =>
      if ((((( 64 :: int)::ii) = (( 64 :: int)::ii)))) then
        return ((concat_vec ( 0b0000000 ::  7 Word.word)
                   ((concat_vec shamt
                       ((concat_vec rs1
                           ((concat_vec ( 0b001 ::  3 Word.word)
                               ((concat_vec rd ( 0b0011011 ::  7 Word.word)  ::  12 Word.word))
                              ::  15 Word.word))
                          ::  20 Word.word))
                      ::  25 Word.word))
                  ::  32 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () 
   | SHIFTIWOP ((shamt, rs1, rd, RISCV_SRLIW)) =>
      if ((((( 64 :: int)::ii) = (( 64 :: int)::ii)))) then
        return ((concat_vec ( 0b0000000 ::  7 Word.word)
                   ((concat_vec shamt
                       ((concat_vec rs1
                           ((concat_vec ( 0b101 ::  3 Word.word)
                               ((concat_vec rd ( 0b0011011 ::  7 Word.word)  ::  12 Word.word))
                              ::  15 Word.word))
                          ::  20 Word.word))
                      ::  25 Word.word))
                  ::  32 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () 
   | SHIFTIWOP ((shamt, rs1, rd, RISCV_SRAIW)) =>
      if ((((( 64 :: int)::ii) = (( 64 :: int)::ii)))) then
        return ((concat_vec ( 0b0100000 ::  7 Word.word)
                   ((concat_vec shamt
                       ((concat_vec rs1
                           ((concat_vec ( 0b101 ::  3 Word.word)
                               ((concat_vec rd ( 0b0011011 ::  7 Word.word)  ::  12 Word.word))
                              ::  15 Word.word))
                          ::  20 Word.word))
                      ::  25 Word.word))
                  ::  32 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () 
   | FENCE ((pred, succ)) =>
      return ((concat_vec ( 0x0 ::  4 Word.word)
                 ((concat_vec pred
                     ((concat_vec succ
                         ((concat_vec ( 0b00000 ::  5 Word.word)
                             ((concat_vec ( 0b000 ::  3 Word.word)
                                 ((concat_vec ( 0b00000 ::  5 Word.word) ( 0b0001111 ::  7 Word.word)
                                    ::  12 Word.word))
                                ::  15 Word.word))
                            ::  20 Word.word))
                        ::  24 Word.word))
                    ::  28 Word.word))
                ::  32 Word.word))
   | FENCE_TSO ((pred, succ)) =>
      return ((concat_vec ( 0x8 ::  4 Word.word)
                 ((concat_vec pred
                     ((concat_vec succ
                         ((concat_vec ( 0b00000 ::  5 Word.word)
                             ((concat_vec ( 0b000 ::  3 Word.word)
                                 ((concat_vec ( 0b00000 ::  5 Word.word) ( 0b0001111 ::  7 Word.word)
                                    ::  12 Word.word))
                                ::  15 Word.word))
                            ::  20 Word.word))
                        ::  24 Word.word))
                    ::  28 Word.word))
                ::  32 Word.word))
   | FENCEI (_) =>
      return ((concat_vec ( 0x000 ::  12 Word.word)
                 ((concat_vec ( 0b00000 ::  5 Word.word)
                     ((concat_vec ( 0b001 ::  3 Word.word)
                         ((concat_vec ( 0b00000 ::  5 Word.word) ( 0b0001111 ::  7 Word.word)  ::  12 Word.word))
                        ::  15 Word.word))
                    ::  20 Word.word))
                ::  32 Word.word))
   | ECALL (_) =>
      return ((concat_vec ( 0x000 ::  12 Word.word)
                 ((concat_vec ( 0b00000 ::  5 Word.word)
                     ((concat_vec ( 0b000 ::  3 Word.word)
                         ((concat_vec ( 0b00000 ::  5 Word.word) ( 0b1110011 ::  7 Word.word)  ::  12 Word.word))
                        ::  15 Word.word))
                    ::  20 Word.word))
                ::  32 Word.word))
   | MRET (_) =>
      return ((concat_vec ( 0b0011000 ::  7 Word.word)
                 ((concat_vec ( 0b00010 ::  5 Word.word)
                     ((concat_vec ( 0b00000 ::  5 Word.word)
                         ((concat_vec ( 0b000 ::  3 Word.word)
                             ((concat_vec ( 0b00000 ::  5 Word.word) ( 0b1110011 ::  7 Word.word)
                                ::  12 Word.word))
                            ::  15 Word.word))
                        ::  20 Word.word))
                    ::  25 Word.word))
                ::  32 Word.word))
   | SRET (_) =>
      return ((concat_vec ( 0b0001000 ::  7 Word.word)
                 ((concat_vec ( 0b00010 ::  5 Word.word)
                     ((concat_vec ( 0b00000 ::  5 Word.word)
                         ((concat_vec ( 0b000 ::  3 Word.word)
                             ((concat_vec ( 0b00000 ::  5 Word.word) ( 0b1110011 ::  7 Word.word)
                                ::  12 Word.word))
                            ::  15 Word.word))
                        ::  20 Word.word))
                    ::  25 Word.word))
                ::  32 Word.word))
   | EBREAK (_) =>
      return ((concat_vec ( 0x001 ::  12 Word.word)
                 ((concat_vec ( 0b00000 ::  5 Word.word)
                     ((concat_vec ( 0b000 ::  3 Word.word)
                         ((concat_vec ( 0b00000 ::  5 Word.word) ( 0b1110011 ::  7 Word.word)  ::  12 Word.word))
                        ::  15 Word.word))
                    ::  20 Word.word))
                ::  32 Word.word))
   | WFI (_) =>
      return ((concat_vec ( 0x105 ::  12 Word.word)
                 ((concat_vec ( 0b00000 ::  5 Word.word)
                     ((concat_vec ( 0b000 ::  3 Word.word)
                         ((concat_vec ( 0b00000 ::  5 Word.word) ( 0b1110011 ::  7 Word.word)  ::  12 Word.word))
                        ::  15 Word.word))
                    ::  20 Word.word))
                ::  32 Word.word))
   | SFENCE_VMA ((rs1, rs2)) =>
      return ((concat_vec ( 0b0001001 ::  7 Word.word)
                 ((concat_vec rs2
                     ((concat_vec rs1
                         ((concat_vec ( 0b000 ::  3 Word.word)
                             ((concat_vec ( 0b00000 ::  5 Word.word) ( 0b1110011 ::  7 Word.word)
                                ::  12 Word.word))
                            ::  15 Word.word))
                        ::  20 Word.word))
                    ::  25 Word.word))
                ::  32 Word.word))
   | LOADRES ((aq, rl, rs1, size1, rd)) =>
      if ((amo_width_valid size1)) then
        return ((concat_vec ( 0b00010 ::  5 Word.word)
                   ((concat_vec ((bool_bits_forwards aq  ::  1 Word.word))
                       ((concat_vec ((bool_bits_forwards rl  ::  1 Word.word))
                           ((concat_vec ( 0b00000 ::  5 Word.word)
                               ((concat_vec rs1
                                   ((concat_vec ( 0b0 ::  1 Word.word)
                                       ((concat_vec ((size_bits_forwards size1  ::  2 Word.word))
                                           ((concat_vec rd ( 0b0101111 ::  7 Word.word)  ::  12 Word.word))
                                          ::  14 Word.word))
                                      ::  15 Word.word))
                                  ::  20 Word.word))
                              ::  25 Word.word))
                          ::  26 Word.word))
                      ::  27 Word.word))
                  ::  32 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () 
   | STORECON ((aq, rl, rs2, rs1, size1, rd)) =>
      if ((amo_width_valid size1)) then
        return ((concat_vec ( 0b00011 ::  5 Word.word)
                   ((concat_vec ((bool_bits_forwards aq  ::  1 Word.word))
                       ((concat_vec ((bool_bits_forwards rl  ::  1 Word.word))
                           ((concat_vec rs2
                               ((concat_vec rs1
                                   ((concat_vec ( 0b0 ::  1 Word.word)
                                       ((concat_vec ((size_bits_forwards size1  ::  2 Word.word))
                                           ((concat_vec rd ( 0b0101111 ::  7 Word.word)  ::  12 Word.word))
                                          ::  14 Word.word))
                                      ::  15 Word.word))
                                  ::  20 Word.word))
                              ::  25 Word.word))
                          ::  26 Word.word))
                      ::  27 Word.word))
                  ::  32 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () 
   | AMO ((op1, aq, rl, rs2, rs1, size1, rd)) =>
      if ((amo_width_valid size1)) then
        return ((concat_vec ((encdec_amoop_forwards op1  ::  5 Word.word))
                   ((concat_vec ((bool_bits_forwards aq  ::  1 Word.word))
                       ((concat_vec ((bool_bits_forwards rl  ::  1 Word.word))
                           ((concat_vec rs2
                               ((concat_vec rs1
                                   ((concat_vec ( 0b0 ::  1 Word.word)
                                       ((concat_vec ((size_bits_forwards size1  ::  2 Word.word))
                                           ((concat_vec rd ( 0b0101111 ::  7 Word.word)  ::  12 Word.word))
                                          ::  14 Word.word))
                                      ::  15 Word.word))
                                  ::  20 Word.word))
                              ::  25 Word.word))
                          ::  26 Word.word))
                      ::  27 Word.word))
                  ::  32 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () 
   | MUL ((rs2, rs1, rd, high, signed1, signed2)) =>
      return ((concat_vec ( 0b0000001 ::  7 Word.word)
                 ((concat_vec rs2
                     ((concat_vec rs1
                         ((concat_vec
                             ((encdec_mul_op_forwards (high, signed1, signed2)  ::  3 Word.word))
                             ((concat_vec rd ( 0b0110011 ::  7 Word.word)  ::  12 Word.word))
                            ::  15 Word.word))
                        ::  20 Word.word))
                    ::  25 Word.word))
                ::  32 Word.word))
   | DIV ((rs2, rs1, rd, s)) =>
      return ((concat_vec ( 0b0000001 ::  7 Word.word)
                 ((concat_vec rs2
                     ((concat_vec rs1
                         ((concat_vec ( 0b10 ::  2 Word.word)
                             ((concat_vec ((bool_not_bits_forwards s  ::  1 Word.word))
                                 ((concat_vec rd ( 0b0110011 ::  7 Word.word)  ::  12 Word.word))
                                ::  13 Word.word))
                            ::  15 Word.word))
                        ::  20 Word.word))
                    ::  25 Word.word))
                ::  32 Word.word))
   | REM ((rs2, rs1, rd, s)) =>
      return ((concat_vec ( 0b0000001 ::  7 Word.word)
                 ((concat_vec rs2
                     ((concat_vec rs1
                         ((concat_vec ( 0b11 ::  2 Word.word)
                             ((concat_vec ((bool_not_bits_forwards s  ::  1 Word.word))
                                 ((concat_vec rd ( 0b0110011 ::  7 Word.word)  ::  12 Word.word))
                                ::  13 Word.word))
                            ::  15 Word.word))
                        ::  20 Word.word))
                    ::  25 Word.word))
                ::  32 Word.word))
   | MULW ((rs2, rs1, rd)) =>
      if ((((( 64 :: int)::ii) = (( 64 :: int)::ii)))) then
        return ((concat_vec ( 0b0000001 ::  7 Word.word)
                   ((concat_vec rs2
                       ((concat_vec rs1
                           ((concat_vec ( 0b000 ::  3 Word.word)
                               ((concat_vec rd ( 0b0111011 ::  7 Word.word)  ::  12 Word.word))
                              ::  15 Word.word))
                          ::  20 Word.word))
                      ::  25 Word.word))
                  ::  32 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () 
   | DIVW ((rs2, rs1, rd, s)) =>
      if ((((( 64 :: int)::ii) = (( 64 :: int)::ii)))) then
        return ((concat_vec ( 0b0000001 ::  7 Word.word)
                   ((concat_vec rs2
                       ((concat_vec rs1
                           ((concat_vec ( 0b10 ::  2 Word.word)
                               ((concat_vec ((bool_not_bits_forwards s  ::  1 Word.word))
                                   ((concat_vec rd ( 0b0111011 ::  7 Word.word)  ::  12 Word.word))
                                  ::  13 Word.word))
                              ::  15 Word.word))
                          ::  20 Word.word))
                      ::  25 Word.word))
                  ::  32 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () 
   | REMW ((rs2, rs1, rd, s)) =>
      if ((((( 64 :: int)::ii) = (( 64 :: int)::ii)))) then
        return ((concat_vec ( 0b0000001 ::  7 Word.word)
                   ((concat_vec rs2
                       ((concat_vec rs1
                           ((concat_vec ( 0b11 ::  2 Word.word)
                               ((concat_vec ((bool_not_bits_forwards s  ::  1 Word.word))
                                   ((concat_vec rd ( 0b0111011 ::  7 Word.word)  ::  12 Word.word))
                                  ::  13 Word.word))
                              ::  15 Word.word))
                          ::  20 Word.word))
                      ::  25 Word.word))
                  ::  32 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () 
   | CSR ((csr, rs1, rd, is_imm, op1)) =>
      return ((concat_vec csr
                 ((concat_vec rs1
                     ((concat_vec ((bool_bits_forwards is_imm  ::  1 Word.word))
                         ((concat_vec ((encdec_csrop_forwards op1  ::  2 Word.word))
                             ((concat_vec rd ( 0b1110011 ::  7 Word.word)  ::  12 Word.word))
                            ::  14 Word.word))
                        ::  15 Word.word))
                    ::  20 Word.word))
                ::  32 Word.word))
   | URET (_) =>
      return ((concat_vec ( 0b0000000 ::  7 Word.word)
                 ((concat_vec ( 0b00010 ::  5 Word.word)
                     ((concat_vec ( 0b00000 ::  5 Word.word)
                         ((concat_vec ( 0b000 ::  3 Word.word)
                             ((concat_vec ( 0b00000 ::  5 Word.word) ( 0b1110011 ::  7 Word.word)
                                ::  12 Word.word))
                            ::  15 Word.word))
                        ::  20 Word.word))
                    ::  25 Word.word))
                ::  32 Word.word))
   | FENCE_RESERVED ((fm, pred, succ, rs, rd)) =>
      if (((((((((fm \<noteq> ( 0x0 ::  4 Word.word)))) \<and> (((fm \<noteq> ( 0x8 ::  4 Word.word))))))) \<or> ((((((rs \<noteq> ( 0b00000 ::  5 Word.word)))) \<or> (((rd \<noteq> ( 0b00000 ::  5 Word.word))))))))))
      then
        return ((concat_vec fm
                   ((concat_vec pred
                       ((concat_vec succ
                           ((concat_vec rs
                               ((concat_vec ( 0b000 ::  3 Word.word)
                                   ((concat_vec rd ( 0b0001111 ::  7 Word.word)  ::  12 Word.word))
                                  ::  15 Word.word))
                              ::  20 Word.word))
                          ::  24 Word.word))
                      ::  28 Word.word))
                  ::  32 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () 
   | FENCEI_RESERVED ((imm, rs, rd)) =>
      if ((((((imm \<noteq> ( 0x000 ::  12 Word.word)))) \<or> ((((((rs \<noteq> zreg))) \<or> (((rd \<noteq> zreg))))))))) then
        return ((concat_vec imm
                   ((concat_vec rs
                       ((concat_vec ( 0b001 ::  3 Word.word)
                           ((concat_vec rd ( 0b0001111 ::  7 Word.word)  ::  12 Word.word))
                          ::  15 Word.word))
                      ::  20 Word.word))
                  ::  32 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () 
   | LOAD_FP ((imm, rs1, rd, WORD)) =>
      is_RV32F_or_RV64F ()  \<bind> ((\<lambda> (w__48 :: bool) . 
      if w__48 then
        return ((concat_vec imm
                   ((concat_vec rs1
                       ((concat_vec ( 0b010 ::  3 Word.word)
                           ((concat_vec rd ( 0b0000111 ::  7 Word.word)  ::  12 Word.word))
                          ::  15 Word.word))
                      ::  20 Word.word))
                  ::  32 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))
   | LOAD_FP ((imm, rs1, rd, DOUBLE)) =>
      is_RV32D_or_RV64D ()  \<bind> ((\<lambda> (w__51 :: bool) . 
      if w__51 then
        return ((concat_vec imm
                   ((concat_vec rs1
                       ((concat_vec ( 0b011 ::  3 Word.word)
                           ((concat_vec rd ( 0b0000111 ::  7 Word.word)  ::  12 Word.word))
                          ::  15 Word.word))
                      ::  20 Word.word))
                  ::  32 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))
   | STORE_FP ((v__7, rs2, rs1, WORD)) =>
      is_RV32F_or_RV64F ()  \<bind> ((\<lambda> (w__54 :: bool) . 
      if w__54 then
        (let (imm7 :: 7 bits) = ((subrange_vec_dec v__7 (( 11 :: int)::ii) (( 5 :: int)::ii)  ::  7 Word.word)) in
        (let (imm7 :: 7 bits) = ((subrange_vec_dec v__7 (( 11 :: int)::ii) (( 5 :: int)::ii)  ::  7 Word.word)) in
        (let (imm5 :: 5 bits) = ((subrange_vec_dec v__7 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
        return ((concat_vec imm7
                   ((concat_vec rs2
                       ((concat_vec rs1
                           ((concat_vec ( 0b010 ::  3 Word.word)
                               ((concat_vec imm5 ( 0b0100111 ::  7 Word.word)  ::  12 Word.word))
                              ::  15 Word.word))
                          ::  20 Word.word))
                      ::  25 Word.word))
                  ::  32 Word.word)))))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))
   | STORE_FP ((v__8, rs2, rs1, DOUBLE)) =>
      is_RV32D_or_RV64D ()  \<bind> ((\<lambda> (w__57 :: bool) . 
      if w__57 then
        (let (imm7 :: 7 bits) = ((subrange_vec_dec v__8 (( 11 :: int)::ii) (( 5 :: int)::ii)  ::  7 Word.word)) in
        (let (imm7 :: 7 bits) = ((subrange_vec_dec v__8 (( 11 :: int)::ii) (( 5 :: int)::ii)  ::  7 Word.word)) in
        (let (imm5 :: 5 bits) = ((subrange_vec_dec v__8 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
        return ((concat_vec imm7
                   ((concat_vec rs2
                       ((concat_vec rs1
                           ((concat_vec ( 0b011 ::  3 Word.word)
                               ((concat_vec imm5 ( 0b0100111 ::  7 Word.word)  ::  12 Word.word))
                              ::  15 Word.word))
                          ::  20 Word.word))
                      ::  25 Word.word))
                  ::  32 Word.word)))))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))
   | F_MADD_TYPE_S ((rs3, rs2, rs1, rm, rd, FMADD_S)) =>
      is_RV32F_or_RV64F ()  \<bind> ((\<lambda> (w__60 :: bool) . 
      if w__60 then
        return ((concat_vec rs3
                   ((concat_vec ( 0b00 ::  2 Word.word)
                       ((concat_vec rs2
                           ((concat_vec rs1
                               ((concat_vec ((encdec_rounding_mode_forwards rm  ::  3 Word.word))
                                   ((concat_vec rd ( 0b1000011 ::  7 Word.word)  ::  12 Word.word))
                                  ::  15 Word.word))
                              ::  20 Word.word))
                          ::  25 Word.word))
                      ::  27 Word.word))
                  ::  32 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))
   | F_MADD_TYPE_S ((rs3, rs2, rs1, rm, rd, FMSUB_S)) =>
      is_RV32F_or_RV64F ()  \<bind> ((\<lambda> (w__63 :: bool) . 
      if w__63 then
        return ((concat_vec rs3
                   ((concat_vec ( 0b00 ::  2 Word.word)
                       ((concat_vec rs2
                           ((concat_vec rs1
                               ((concat_vec ((encdec_rounding_mode_forwards rm  ::  3 Word.word))
                                   ((concat_vec rd ( 0b1000111 ::  7 Word.word)  ::  12 Word.word))
                                  ::  15 Word.word))
                              ::  20 Word.word))
                          ::  25 Word.word))
                      ::  27 Word.word))
                  ::  32 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))
   | F_MADD_TYPE_S ((rs3, rs2, rs1, rm, rd, FNMSUB_S)) =>
      is_RV32F_or_RV64F ()  \<bind> ((\<lambda> (w__66 :: bool) . 
      if w__66 then
        return ((concat_vec rs3
                   ((concat_vec ( 0b00 ::  2 Word.word)
                       ((concat_vec rs2
                           ((concat_vec rs1
                               ((concat_vec ((encdec_rounding_mode_forwards rm  ::  3 Word.word))
                                   ((concat_vec rd ( 0b1001011 ::  7 Word.word)  ::  12 Word.word))
                                  ::  15 Word.word))
                              ::  20 Word.word))
                          ::  25 Word.word))
                      ::  27 Word.word))
                  ::  32 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))
   | F_MADD_TYPE_S ((rs3, rs2, rs1, rm, rd, FNMADD_S)) =>
      is_RV32F_or_RV64F ()  \<bind> ((\<lambda> (w__69 :: bool) . 
      if w__69 then
        return ((concat_vec rs3
                   ((concat_vec ( 0b00 ::  2 Word.word)
                       ((concat_vec rs2
                           ((concat_vec rs1
                               ((concat_vec ((encdec_rounding_mode_forwards rm  ::  3 Word.word))
                                   ((concat_vec rd ( 0b1001111 ::  7 Word.word)  ::  12 Word.word))
                                  ::  15 Word.word))
                              ::  20 Word.word))
                          ::  25 Word.word))
                      ::  27 Word.word))
                  ::  32 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))
   | F_BIN_RM_TYPE_S ((rs2, rs1, rm, rd, FADD_S)) =>
      is_RV32F_or_RV64F ()  \<bind> ((\<lambda> (w__72 :: bool) . 
      if w__72 then
        return ((concat_vec ( 0b0000000 ::  7 Word.word)
                   ((concat_vec rs2
                       ((concat_vec rs1
                           ((concat_vec ((encdec_rounding_mode_forwards rm  ::  3 Word.word))
                               ((concat_vec rd ( 0b1010011 ::  7 Word.word)  ::  12 Word.word))
                              ::  15 Word.word))
                          ::  20 Word.word))
                      ::  25 Word.word))
                  ::  32 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))
   | F_BIN_RM_TYPE_S ((rs2, rs1, rm, rd, FSUB_S)) =>
      is_RV32F_or_RV64F ()  \<bind> ((\<lambda> (w__75 :: bool) . 
      if w__75 then
        return ((concat_vec ( 0b0000100 ::  7 Word.word)
                   ((concat_vec rs2
                       ((concat_vec rs1
                           ((concat_vec ((encdec_rounding_mode_forwards rm  ::  3 Word.word))
                               ((concat_vec rd ( 0b1010011 ::  7 Word.word)  ::  12 Word.word))
                              ::  15 Word.word))
                          ::  20 Word.word))
                      ::  25 Word.word))
                  ::  32 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))
   | F_BIN_RM_TYPE_S ((rs2, rs1, rm, rd, FMUL_S)) =>
      is_RV32F_or_RV64F ()  \<bind> ((\<lambda> (w__78 :: bool) . 
      if w__78 then
        return ((concat_vec ( 0b0001000 ::  7 Word.word)
                   ((concat_vec rs2
                       ((concat_vec rs1
                           ((concat_vec ((encdec_rounding_mode_forwards rm  ::  3 Word.word))
                               ((concat_vec rd ( 0b1010011 ::  7 Word.word)  ::  12 Word.word))
                              ::  15 Word.word))
                          ::  20 Word.word))
                      ::  25 Word.word))
                  ::  32 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))
   | F_BIN_RM_TYPE_S ((rs2, rs1, rm, rd, FDIV_S)) =>
      is_RV32F_or_RV64F ()  \<bind> ((\<lambda> (w__81 :: bool) . 
      if w__81 then
        return ((concat_vec ( 0b0001100 ::  7 Word.word)
                   ((concat_vec rs2
                       ((concat_vec rs1
                           ((concat_vec ((encdec_rounding_mode_forwards rm  ::  3 Word.word))
                               ((concat_vec rd ( 0b1010011 ::  7 Word.word)  ::  12 Word.word))
                              ::  15 Word.word))
                          ::  20 Word.word))
                      ::  25 Word.word))
                  ::  32 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))
   | F_UN_RM_TYPE_S ((rs1, rm, rd, FSQRT_S)) =>
      is_RV32F_or_RV64F ()  \<bind> ((\<lambda> (w__84 :: bool) . 
      if w__84 then
        return ((concat_vec ( 0b0101100 ::  7 Word.word)
                   ((concat_vec ( 0b00000 ::  5 Word.word)
                       ((concat_vec rs1
                           ((concat_vec ((encdec_rounding_mode_forwards rm  ::  3 Word.word))
                               ((concat_vec rd ( 0b1010011 ::  7 Word.word)  ::  12 Word.word))
                              ::  15 Word.word))
                          ::  20 Word.word))
                      ::  25 Word.word))
                  ::  32 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))
   | F_UN_RM_TYPE_S ((rs1, rm, rd, FCVT_W_S)) =>
      is_RV32F_or_RV64F ()  \<bind> ((\<lambda> (w__87 :: bool) . 
      if w__87 then
        return ((concat_vec ( 0b1100000 ::  7 Word.word)
                   ((concat_vec ( 0b00000 ::  5 Word.word)
                       ((concat_vec rs1
                           ((concat_vec ((encdec_rounding_mode_forwards rm  ::  3 Word.word))
                               ((concat_vec rd ( 0b1010011 ::  7 Word.word)  ::  12 Word.word))
                              ::  15 Word.word))
                          ::  20 Word.word))
                      ::  25 Word.word))
                  ::  32 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))
   | F_UN_RM_TYPE_S ((rs1, rm, rd, FCVT_WU_S)) =>
      is_RV32F_or_RV64F ()  \<bind> ((\<lambda> (w__90 :: bool) . 
      if w__90 then
        return ((concat_vec ( 0b1100000 ::  7 Word.word)
                   ((concat_vec ( 0b00001 ::  5 Word.word)
                       ((concat_vec rs1
                           ((concat_vec ((encdec_rounding_mode_forwards rm  ::  3 Word.word))
                               ((concat_vec rd ( 0b1010011 ::  7 Word.word)  ::  12 Word.word))
                              ::  15 Word.word))
                          ::  20 Word.word))
                      ::  25 Word.word))
                  ::  32 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))
   | F_UN_RM_TYPE_S ((rs1, rm, rd, FCVT_S_W)) =>
      is_RV32F_or_RV64F ()  \<bind> ((\<lambda> (w__93 :: bool) . 
      if w__93 then
        return ((concat_vec ( 0b1101000 ::  7 Word.word)
                   ((concat_vec ( 0b00000 ::  5 Word.word)
                       ((concat_vec rs1
                           ((concat_vec ((encdec_rounding_mode_forwards rm  ::  3 Word.word))
                               ((concat_vec rd ( 0b1010011 ::  7 Word.word)  ::  12 Word.word))
                              ::  15 Word.word))
                          ::  20 Word.word))
                      ::  25 Word.word))
                  ::  32 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))
   | F_UN_RM_TYPE_S ((rs1, rm, rd, FCVT_S_WU)) =>
      is_RV32F_or_RV64F ()  \<bind> ((\<lambda> (w__96 :: bool) . 
      if w__96 then
        return ((concat_vec ( 0b1101000 ::  7 Word.word)
                   ((concat_vec ( 0b00001 ::  5 Word.word)
                       ((concat_vec rs1
                           ((concat_vec ((encdec_rounding_mode_forwards rm  ::  3 Word.word))
                               ((concat_vec rd ( 0b1010011 ::  7 Word.word)  ::  12 Word.word))
                              ::  15 Word.word))
                          ::  20 Word.word))
                      ::  25 Word.word))
                  ::  32 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))
   | F_UN_RM_TYPE_S ((rs1, rm, rd, FCVT_L_S)) =>
      is_RV64F ()  \<bind> ((\<lambda> (w__99 :: bool) . 
      if w__99 then
        return ((concat_vec ( 0b1100000 ::  7 Word.word)
                   ((concat_vec ( 0b00010 ::  5 Word.word)
                       ((concat_vec rs1
                           ((concat_vec ((encdec_rounding_mode_forwards rm  ::  3 Word.word))
                               ((concat_vec rd ( 0b1010011 ::  7 Word.word)  ::  12 Word.word))
                              ::  15 Word.word))
                          ::  20 Word.word))
                      ::  25 Word.word))
                  ::  32 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))
   | F_UN_RM_TYPE_S ((rs1, rm, rd, FCVT_LU_S)) =>
      is_RV64F ()  \<bind> ((\<lambda> (w__102 :: bool) . 
      if w__102 then
        return ((concat_vec ( 0b1100000 ::  7 Word.word)
                   ((concat_vec ( 0b00011 ::  5 Word.word)
                       ((concat_vec rs1
                           ((concat_vec ((encdec_rounding_mode_forwards rm  ::  3 Word.word))
                               ((concat_vec rd ( 0b1010011 ::  7 Word.word)  ::  12 Word.word))
                              ::  15 Word.word))
                          ::  20 Word.word))
                      ::  25 Word.word))
                  ::  32 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))
   | F_UN_RM_TYPE_S ((rs1, rm, rd, FCVT_S_L)) =>
      is_RV64F ()  \<bind> ((\<lambda> (w__105 :: bool) . 
      if w__105 then
        return ((concat_vec ( 0b1101000 ::  7 Word.word)
                   ((concat_vec ( 0b00010 ::  5 Word.word)
                       ((concat_vec rs1
                           ((concat_vec ((encdec_rounding_mode_forwards rm  ::  3 Word.word))
                               ((concat_vec rd ( 0b1010011 ::  7 Word.word)  ::  12 Word.word))
                              ::  15 Word.word))
                          ::  20 Word.word))
                      ::  25 Word.word))
                  ::  32 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))
   | F_UN_RM_TYPE_S ((rs1, rm, rd, FCVT_S_LU)) =>
      is_RV64F ()  \<bind> ((\<lambda> (w__108 :: bool) . 
      if w__108 then
        return ((concat_vec ( 0b1101000 ::  7 Word.word)
                   ((concat_vec ( 0b00011 ::  5 Word.word)
                       ((concat_vec rs1
                           ((concat_vec ((encdec_rounding_mode_forwards rm  ::  3 Word.word))
                               ((concat_vec rd ( 0b1010011 ::  7 Word.word)  ::  12 Word.word))
                              ::  15 Word.word))
                          ::  20 Word.word))
                      ::  25 Word.word))
                  ::  32 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))
   | F_BIN_TYPE_S ((rs2, rs1, rd, FSGNJ_S)) =>
      is_RV32F_or_RV64F ()  \<bind> ((\<lambda> (w__111 :: bool) . 
      if w__111 then
        return ((concat_vec ( 0b0010000 ::  7 Word.word)
                   ((concat_vec rs2
                       ((concat_vec rs1
                           ((concat_vec ( 0b000 ::  3 Word.word)
                               ((concat_vec rd ( 0b1010011 ::  7 Word.word)  ::  12 Word.word))
                              ::  15 Word.word))
                          ::  20 Word.word))
                      ::  25 Word.word))
                  ::  32 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))
   | F_BIN_TYPE_S ((rs2, rs1, rd, FSGNJN_S)) =>
      is_RV32F_or_RV64F ()  \<bind> ((\<lambda> (w__114 :: bool) . 
      if w__114 then
        return ((concat_vec ( 0b0010000 ::  7 Word.word)
                   ((concat_vec rs2
                       ((concat_vec rs1
                           ((concat_vec ( 0b001 ::  3 Word.word)
                               ((concat_vec rd ( 0b1010011 ::  7 Word.word)  ::  12 Word.word))
                              ::  15 Word.word))
                          ::  20 Word.word))
                      ::  25 Word.word))
                  ::  32 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))
   | F_BIN_TYPE_S ((rs2, rs1, rd, FSGNJX_S)) =>
      is_RV32F_or_RV64F ()  \<bind> ((\<lambda> (w__117 :: bool) . 
      if w__117 then
        return ((concat_vec ( 0b0010000 ::  7 Word.word)
                   ((concat_vec rs2
                       ((concat_vec rs1
                           ((concat_vec ( 0b010 ::  3 Word.word)
                               ((concat_vec rd ( 0b1010011 ::  7 Word.word)  ::  12 Word.word))
                              ::  15 Word.word))
                          ::  20 Word.word))
                      ::  25 Word.word))
                  ::  32 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))
   | F_BIN_TYPE_S ((rs2, rs1, rd, FMIN_S)) =>
      is_RV32F_or_RV64F ()  \<bind> ((\<lambda> (w__120 :: bool) . 
      if w__120 then
        return ((concat_vec ( 0b0010100 ::  7 Word.word)
                   ((concat_vec rs2
                       ((concat_vec rs1
                           ((concat_vec ( 0b000 ::  3 Word.word)
                               ((concat_vec rd ( 0b1010011 ::  7 Word.word)  ::  12 Word.word))
                              ::  15 Word.word))
                          ::  20 Word.word))
                      ::  25 Word.word))
                  ::  32 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))
   | F_BIN_TYPE_S ((rs2, rs1, rd, FMAX_S)) =>
      is_RV32F_or_RV64F ()  \<bind> ((\<lambda> (w__123 :: bool) . 
      if w__123 then
        return ((concat_vec ( 0b0010100 ::  7 Word.word)
                   ((concat_vec rs2
                       ((concat_vec rs1
                           ((concat_vec ( 0b001 ::  3 Word.word)
                               ((concat_vec rd ( 0b1010011 ::  7 Word.word)  ::  12 Word.word))
                              ::  15 Word.word))
                          ::  20 Word.word))
                      ::  25 Word.word))
                  ::  32 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))
   | F_BIN_TYPE_S ((rs2, rs1, rd, FEQ_S)) =>
      is_RV32F_or_RV64F ()  \<bind> ((\<lambda> (w__126 :: bool) . 
      if w__126 then
        return ((concat_vec ( 0b1010000 ::  7 Word.word)
                   ((concat_vec rs2
                       ((concat_vec rs1
                           ((concat_vec ( 0b010 ::  3 Word.word)
                               ((concat_vec rd ( 0b1010011 ::  7 Word.word)  ::  12 Word.word))
                              ::  15 Word.word))
                          ::  20 Word.word))
                      ::  25 Word.word))
                  ::  32 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))
   | F_BIN_TYPE_S ((rs2, rs1, rd, FLT_S)) =>
      is_RV32F_or_RV64F ()  \<bind> ((\<lambda> (w__129 :: bool) . 
      if w__129 then
        return ((concat_vec ( 0b1010000 ::  7 Word.word)
                   ((concat_vec rs2
                       ((concat_vec rs1
                           ((concat_vec ( 0b001 ::  3 Word.word)
                               ((concat_vec rd ( 0b1010011 ::  7 Word.word)  ::  12 Word.word))
                              ::  15 Word.word))
                          ::  20 Word.word))
                      ::  25 Word.word))
                  ::  32 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))
   | F_BIN_TYPE_S ((rs2, rs1, rd, FLE_S)) =>
      is_RV32F_or_RV64F ()  \<bind> ((\<lambda> (w__132 :: bool) . 
      if w__132 then
        return ((concat_vec ( 0b1010000 ::  7 Word.word)
                   ((concat_vec rs2
                       ((concat_vec rs1
                           ((concat_vec ( 0b000 ::  3 Word.word)
                               ((concat_vec rd ( 0b1010011 ::  7 Word.word)  ::  12 Word.word))
                              ::  15 Word.word))
                          ::  20 Word.word))
                      ::  25 Word.word))
                  ::  32 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))
   | F_UN_TYPE_S ((rs1, rd, FCLASS_S)) =>
      haveFExt ()  \<bind> ((\<lambda> (w__135 :: bool) . 
      if w__135 then
        return ((concat_vec ( 0b1110000 ::  7 Word.word)
                   ((concat_vec ( 0b00000 ::  5 Word.word)
                       ((concat_vec rs1
                           ((concat_vec ( 0b001 ::  3 Word.word)
                               ((concat_vec rd ( 0b1010011 ::  7 Word.word)  ::  12 Word.word))
                              ::  15 Word.word))
                          ::  20 Word.word))
                      ::  25 Word.word))
                  ::  32 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))
   | F_UN_TYPE_S ((rs1, rd, FMV_X_W)) =>
      haveFExt ()  \<bind> ((\<lambda> (w__138 :: bool) . 
      if w__138 then
        return ((concat_vec ( 0b1110000 ::  7 Word.word)
                   ((concat_vec ( 0b00000 ::  5 Word.word)
                       ((concat_vec rs1
                           ((concat_vec ( 0b000 ::  3 Word.word)
                               ((concat_vec rd ( 0b1010011 ::  7 Word.word)  ::  12 Word.word))
                              ::  15 Word.word))
                          ::  20 Word.word))
                      ::  25 Word.word))
                  ::  32 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))
   | F_UN_TYPE_S ((rs1, rd, FMV_W_X)) =>
      haveFExt ()  \<bind> ((\<lambda> (w__141 :: bool) . 
      if w__141 then
        return ((concat_vec ( 0b1111000 ::  7 Word.word)
                   ((concat_vec ( 0b00000 ::  5 Word.word)
                       ((concat_vec rs1
                           ((concat_vec ( 0b000 ::  3 Word.word)
                               ((concat_vec rd ( 0b1010011 ::  7 Word.word)  ::  12 Word.word))
                              ::  15 Word.word))
                          ::  20 Word.word))
                      ::  25 Word.word))
                  ::  32 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))
   | F_MADD_TYPE_D ((rs3, rs2, rs1, rm, rd, FMADD_D)) =>
      is_RV32D_or_RV64D ()  \<bind> ((\<lambda> (w__144 :: bool) . 
      if w__144 then
        return ((concat_vec rs3
                   ((concat_vec ( 0b01 ::  2 Word.word)
                       ((concat_vec rs2
                           ((concat_vec rs1
                               ((concat_vec ((encdec_rounding_mode_forwards rm  ::  3 Word.word))
                                   ((concat_vec rd ( 0b1000011 ::  7 Word.word)  ::  12 Word.word))
                                  ::  15 Word.word))
                              ::  20 Word.word))
                          ::  25 Word.word))
                      ::  27 Word.word))
                  ::  32 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))
   | F_MADD_TYPE_D ((rs3, rs2, rs1, rm, rd, FMSUB_D)) =>
      is_RV32D_or_RV64D ()  \<bind> ((\<lambda> (w__147 :: bool) . 
      if w__147 then
        return ((concat_vec rs3
                   ((concat_vec ( 0b01 ::  2 Word.word)
                       ((concat_vec rs2
                           ((concat_vec rs1
                               ((concat_vec ((encdec_rounding_mode_forwards rm  ::  3 Word.word))
                                   ((concat_vec rd ( 0b1000111 ::  7 Word.word)  ::  12 Word.word))
                                  ::  15 Word.word))
                              ::  20 Word.word))
                          ::  25 Word.word))
                      ::  27 Word.word))
                  ::  32 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))
   | F_MADD_TYPE_D ((rs3, rs2, rs1, rm, rd, FNMSUB_D)) =>
      is_RV32D_or_RV64D ()  \<bind> ((\<lambda> (w__150 :: bool) . 
      if w__150 then
        return ((concat_vec rs3
                   ((concat_vec ( 0b01 ::  2 Word.word)
                       ((concat_vec rs2
                           ((concat_vec rs1
                               ((concat_vec ((encdec_rounding_mode_forwards rm  ::  3 Word.word))
                                   ((concat_vec rd ( 0b1001011 ::  7 Word.word)  ::  12 Word.word))
                                  ::  15 Word.word))
                              ::  20 Word.word))
                          ::  25 Word.word))
                      ::  27 Word.word))
                  ::  32 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))
   | F_MADD_TYPE_D ((rs3, rs2, rs1, rm, rd, FNMADD_D)) =>
      is_RV32D_or_RV64D ()  \<bind> ((\<lambda> (w__153 :: bool) . 
      if w__153 then
        return ((concat_vec rs3
                   ((concat_vec ( 0b01 ::  2 Word.word)
                       ((concat_vec rs2
                           ((concat_vec rs1
                               ((concat_vec ((encdec_rounding_mode_forwards rm  ::  3 Word.word))
                                   ((concat_vec rd ( 0b1001111 ::  7 Word.word)  ::  12 Word.word))
                                  ::  15 Word.word))
                              ::  20 Word.word))
                          ::  25 Word.word))
                      ::  27 Word.word))
                  ::  32 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))
   | F_BIN_RM_TYPE_D ((rs2, rs1, rm, rd, FADD_D)) =>
      is_RV32D_or_RV64D ()  \<bind> ((\<lambda> (w__156 :: bool) . 
      if w__156 then
        return ((concat_vec ( 0b0000001 ::  7 Word.word)
                   ((concat_vec rs2
                       ((concat_vec rs1
                           ((concat_vec ((encdec_rounding_mode_forwards rm  ::  3 Word.word))
                               ((concat_vec rd ( 0b1010011 ::  7 Word.word)  ::  12 Word.word))
                              ::  15 Word.word))
                          ::  20 Word.word))
                      ::  25 Word.word))
                  ::  32 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))
   | F_BIN_RM_TYPE_D ((rs2, rs1, rm, rd, FSUB_D)) =>
      is_RV32D_or_RV64D ()  \<bind> ((\<lambda> (w__159 :: bool) . 
      if w__159 then
        return ((concat_vec ( 0b0000101 ::  7 Word.word)
                   ((concat_vec rs2
                       ((concat_vec rs1
                           ((concat_vec ((encdec_rounding_mode_forwards rm  ::  3 Word.word))
                               ((concat_vec rd ( 0b1010011 ::  7 Word.word)  ::  12 Word.word))
                              ::  15 Word.word))
                          ::  20 Word.word))
                      ::  25 Word.word))
                  ::  32 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))
   | F_BIN_RM_TYPE_D ((rs2, rs1, rm, rd, FMUL_D)) =>
      is_RV32D_or_RV64D ()  \<bind> ((\<lambda> (w__162 :: bool) . 
      if w__162 then
        return ((concat_vec ( 0b0001001 ::  7 Word.word)
                   ((concat_vec rs2
                       ((concat_vec rs1
                           ((concat_vec ((encdec_rounding_mode_forwards rm  ::  3 Word.word))
                               ((concat_vec rd ( 0b1010011 ::  7 Word.word)  ::  12 Word.word))
                              ::  15 Word.word))
                          ::  20 Word.word))
                      ::  25 Word.word))
                  ::  32 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))
   | F_BIN_RM_TYPE_D ((rs2, rs1, rm, rd, FDIV_D)) =>
      is_RV32D_or_RV64D ()  \<bind> ((\<lambda> (w__165 :: bool) . 
      if w__165 then
        return ((concat_vec ( 0b0001101 ::  7 Word.word)
                   ((concat_vec rs2
                       ((concat_vec rs1
                           ((concat_vec ((encdec_rounding_mode_forwards rm  ::  3 Word.word))
                               ((concat_vec rd ( 0b1010011 ::  7 Word.word)  ::  12 Word.word))
                              ::  15 Word.word))
                          ::  20 Word.word))
                      ::  25 Word.word))
                  ::  32 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))
   | F_UN_RM_TYPE_D ((rs1, rm, rd, FSQRT_D)) =>
      is_RV32D_or_RV64D ()  \<bind> ((\<lambda> (w__168 :: bool) . 
      if w__168 then
        return ((concat_vec ( 0b0101101 ::  7 Word.word)
                   ((concat_vec ( 0b00000 ::  5 Word.word)
                       ((concat_vec rs1
                           ((concat_vec ((encdec_rounding_mode_forwards rm  ::  3 Word.word))
                               ((concat_vec rd ( 0b1010011 ::  7 Word.word)  ::  12 Word.word))
                              ::  15 Word.word))
                          ::  20 Word.word))
                      ::  25 Word.word))
                  ::  32 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))
   | F_UN_RM_TYPE_D ((rs1, rm, rd, FCVT_W_D)) =>
      is_RV32D_or_RV64D ()  \<bind> ((\<lambda> (w__171 :: bool) . 
      if w__171 then
        return ((concat_vec ( 0b1100001 ::  7 Word.word)
                   ((concat_vec ( 0b00000 ::  5 Word.word)
                       ((concat_vec rs1
                           ((concat_vec ((encdec_rounding_mode_forwards rm  ::  3 Word.word))
                               ((concat_vec rd ( 0b1010011 ::  7 Word.word)  ::  12 Word.word))
                              ::  15 Word.word))
                          ::  20 Word.word))
                      ::  25 Word.word))
                  ::  32 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))
   | F_UN_RM_TYPE_D ((rs1, rm, rd, FCVT_WU_D)) =>
      is_RV32D_or_RV64D ()  \<bind> ((\<lambda> (w__174 :: bool) . 
      if w__174 then
        return ((concat_vec ( 0b1100001 ::  7 Word.word)
                   ((concat_vec ( 0b00001 ::  5 Word.word)
                       ((concat_vec rs1
                           ((concat_vec ((encdec_rounding_mode_forwards rm  ::  3 Word.word))
                               ((concat_vec rd ( 0b1010011 ::  7 Word.word)  ::  12 Word.word))
                              ::  15 Word.word))
                          ::  20 Word.word))
                      ::  25 Word.word))
                  ::  32 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))
   | F_UN_RM_TYPE_D ((rs1, rm, rd, FCVT_D_W)) =>
      is_RV32D_or_RV64D ()  \<bind> ((\<lambda> (w__177 :: bool) . 
      if w__177 then
        return ((concat_vec ( 0b1101001 ::  7 Word.word)
                   ((concat_vec ( 0b00000 ::  5 Word.word)
                       ((concat_vec rs1
                           ((concat_vec ((encdec_rounding_mode_forwards rm  ::  3 Word.word))
                               ((concat_vec rd ( 0b1010011 ::  7 Word.word)  ::  12 Word.word))
                              ::  15 Word.word))
                          ::  20 Word.word))
                      ::  25 Word.word))
                  ::  32 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))
   | F_UN_RM_TYPE_D ((rs1, rm, rd, FCVT_D_WU)) =>
      is_RV32D_or_RV64D ()  \<bind> ((\<lambda> (w__180 :: bool) . 
      if w__180 then
        return ((concat_vec ( 0b1101001 ::  7 Word.word)
                   ((concat_vec ( 0b00001 ::  5 Word.word)
                       ((concat_vec rs1
                           ((concat_vec ((encdec_rounding_mode_forwards rm  ::  3 Word.word))
                               ((concat_vec rd ( 0b1010011 ::  7 Word.word)  ::  12 Word.word))
                              ::  15 Word.word))
                          ::  20 Word.word))
                      ::  25 Word.word))
                  ::  32 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))
   | F_UN_RM_TYPE_D ((rs1, rm, rd, FCVT_S_D)) =>
      is_RV32D_or_RV64D ()  \<bind> ((\<lambda> (w__183 :: bool) . 
      if w__183 then
        return ((concat_vec ( 0b0100000 ::  7 Word.word)
                   ((concat_vec ( 0b00001 ::  5 Word.word)
                       ((concat_vec rs1
                           ((concat_vec ((encdec_rounding_mode_forwards rm  ::  3 Word.word))
                               ((concat_vec rd ( 0b1010011 ::  7 Word.word)  ::  12 Word.word))
                              ::  15 Word.word))
                          ::  20 Word.word))
                      ::  25 Word.word))
                  ::  32 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))
   | F_UN_RM_TYPE_D ((rs1, rm, rd, FCVT_D_S)) =>
      is_RV32D_or_RV64D ()  \<bind> ((\<lambda> (w__186 :: bool) . 
      if w__186 then
        return ((concat_vec ( 0b0100001 ::  7 Word.word)
                   ((concat_vec ( 0b00000 ::  5 Word.word)
                       ((concat_vec rs1
                           ((concat_vec ((encdec_rounding_mode_forwards rm  ::  3 Word.word))
                               ((concat_vec rd ( 0b1010011 ::  7 Word.word)  ::  12 Word.word))
                              ::  15 Word.word))
                          ::  20 Word.word))
                      ::  25 Word.word))
                  ::  32 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))
   | F_UN_RM_TYPE_D ((rs1, rm, rd, FCVT_L_D)) =>
      is_RV64D ()  \<bind> ((\<lambda> (w__189 :: bool) . 
      if w__189 then
        return ((concat_vec ( 0b1100001 ::  7 Word.word)
                   ((concat_vec ( 0b00010 ::  5 Word.word)
                       ((concat_vec rs1
                           ((concat_vec ((encdec_rounding_mode_forwards rm  ::  3 Word.word))
                               ((concat_vec rd ( 0b1010011 ::  7 Word.word)  ::  12 Word.word))
                              ::  15 Word.word))
                          ::  20 Word.word))
                      ::  25 Word.word))
                  ::  32 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))
   | F_UN_RM_TYPE_D ((rs1, rm, rd, FCVT_LU_D)) =>
      is_RV64D ()  \<bind> ((\<lambda> (w__192 :: bool) . 
      if w__192 then
        return ((concat_vec ( 0b1100001 ::  7 Word.word)
                   ((concat_vec ( 0b00011 ::  5 Word.word)
                       ((concat_vec rs1
                           ((concat_vec ((encdec_rounding_mode_forwards rm  ::  3 Word.word))
                               ((concat_vec rd ( 0b1010011 ::  7 Word.word)  ::  12 Word.word))
                              ::  15 Word.word))
                          ::  20 Word.word))
                      ::  25 Word.word))
                  ::  32 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))
   | F_UN_RM_TYPE_D ((rs1, rm, rd, FCVT_D_L)) =>
      is_RV64D ()  \<bind> ((\<lambda> (w__195 :: bool) . 
      if w__195 then
        return ((concat_vec ( 0b1101001 ::  7 Word.word)
                   ((concat_vec ( 0b00010 ::  5 Word.word)
                       ((concat_vec rs1
                           ((concat_vec ((encdec_rounding_mode_forwards rm  ::  3 Word.word))
                               ((concat_vec rd ( 0b1010011 ::  7 Word.word)  ::  12 Word.word))
                              ::  15 Word.word))
                          ::  20 Word.word))
                      ::  25 Word.word))
                  ::  32 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))
   | F_UN_RM_TYPE_D ((rs1, rm, rd, FCVT_D_LU)) =>
      is_RV64D ()  \<bind> ((\<lambda> (w__198 :: bool) . 
      if w__198 then
        return ((concat_vec ( 0b1101001 ::  7 Word.word)
                   ((concat_vec ( 0b00011 ::  5 Word.word)
                       ((concat_vec rs1
                           ((concat_vec ((encdec_rounding_mode_forwards rm  ::  3 Word.word))
                               ((concat_vec rd ( 0b1010011 ::  7 Word.word)  ::  12 Word.word))
                              ::  15 Word.word))
                          ::  20 Word.word))
                      ::  25 Word.word))
                  ::  32 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))
   | F_BIN_TYPE_D ((rs2, rs1, rd, FSGNJ_D)) =>
      is_RV32D_or_RV64D ()  \<bind> ((\<lambda> (w__201 :: bool) . 
      if w__201 then
        return ((concat_vec ( 0b0010001 ::  7 Word.word)
                   ((concat_vec rs2
                       ((concat_vec rs1
                           ((concat_vec ( 0b000 ::  3 Word.word)
                               ((concat_vec rd ( 0b1010011 ::  7 Word.word)  ::  12 Word.word))
                              ::  15 Word.word))
                          ::  20 Word.word))
                      ::  25 Word.word))
                  ::  32 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))
   | F_BIN_TYPE_D ((rs2, rs1, rd, FSGNJN_D)) =>
      is_RV32D_or_RV64D ()  \<bind> ((\<lambda> (w__204 :: bool) . 
      if w__204 then
        return ((concat_vec ( 0b0010001 ::  7 Word.word)
                   ((concat_vec rs2
                       ((concat_vec rs1
                           ((concat_vec ( 0b001 ::  3 Word.word)
                               ((concat_vec rd ( 0b1010011 ::  7 Word.word)  ::  12 Word.word))
                              ::  15 Word.word))
                          ::  20 Word.word))
                      ::  25 Word.word))
                  ::  32 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))
   | F_BIN_TYPE_D ((rs2, rs1, rd, FSGNJX_D)) =>
      is_RV32D_or_RV64D ()  \<bind> ((\<lambda> (w__207 :: bool) . 
      if w__207 then
        return ((concat_vec ( 0b0010001 ::  7 Word.word)
                   ((concat_vec rs2
                       ((concat_vec rs1
                           ((concat_vec ( 0b010 ::  3 Word.word)
                               ((concat_vec rd ( 0b1010011 ::  7 Word.word)  ::  12 Word.word))
                              ::  15 Word.word))
                          ::  20 Word.word))
                      ::  25 Word.word))
                  ::  32 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))
   | F_BIN_TYPE_D ((rs2, rs1, rd, FMIN_D)) =>
      is_RV32D_or_RV64D ()  \<bind> ((\<lambda> (w__210 :: bool) . 
      if w__210 then
        return ((concat_vec ( 0b0010101 ::  7 Word.word)
                   ((concat_vec rs2
                       ((concat_vec rs1
                           ((concat_vec ( 0b000 ::  3 Word.word)
                               ((concat_vec rd ( 0b1010011 ::  7 Word.word)  ::  12 Word.word))
                              ::  15 Word.word))
                          ::  20 Word.word))
                      ::  25 Word.word))
                  ::  32 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))
   | F_BIN_TYPE_D ((rs2, rs1, rd, FMAX_D)) =>
      is_RV32D_or_RV64D ()  \<bind> ((\<lambda> (w__213 :: bool) . 
      if w__213 then
        return ((concat_vec ( 0b0010101 ::  7 Word.word)
                   ((concat_vec rs2
                       ((concat_vec rs1
                           ((concat_vec ( 0b001 ::  3 Word.word)
                               ((concat_vec rd ( 0b1010011 ::  7 Word.word)  ::  12 Word.word))
                              ::  15 Word.word))
                          ::  20 Word.word))
                      ::  25 Word.word))
                  ::  32 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))
   | F_BIN_TYPE_D ((rs2, rs1, rd, FEQ_D)) =>
      is_RV32D_or_RV64D ()  \<bind> ((\<lambda> (w__216 :: bool) . 
      if w__216 then
        return ((concat_vec ( 0b1010001 ::  7 Word.word)
                   ((concat_vec rs2
                       ((concat_vec rs1
                           ((concat_vec ( 0b010 ::  3 Word.word)
                               ((concat_vec rd ( 0b1010011 ::  7 Word.word)  ::  12 Word.word))
                              ::  15 Word.word))
                          ::  20 Word.word))
                      ::  25 Word.word))
                  ::  32 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))
   | F_BIN_TYPE_D ((rs2, rs1, rd, FLT_D)) =>
      is_RV32D_or_RV64D ()  \<bind> ((\<lambda> (w__219 :: bool) . 
      if w__219 then
        return ((concat_vec ( 0b1010001 ::  7 Word.word)
                   ((concat_vec rs2
                       ((concat_vec rs1
                           ((concat_vec ( 0b001 ::  3 Word.word)
                               ((concat_vec rd ( 0b1010011 ::  7 Word.word)  ::  12 Word.word))
                              ::  15 Word.word))
                          ::  20 Word.word))
                      ::  25 Word.word))
                  ::  32 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))
   | F_BIN_TYPE_D ((rs2, rs1, rd, FLE_D)) =>
      is_RV32D_or_RV64D ()  \<bind> ((\<lambda> (w__222 :: bool) . 
      if w__222 then
        return ((concat_vec ( 0b1010001 ::  7 Word.word)
                   ((concat_vec rs2
                       ((concat_vec rs1
                           ((concat_vec ( 0b000 ::  3 Word.word)
                               ((concat_vec rd ( 0b1010011 ::  7 Word.word)  ::  12 Word.word))
                              ::  15 Word.word))
                          ::  20 Word.word))
                      ::  25 Word.word))
                  ::  32 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))
   | F_UN_TYPE_D ((rs1, rd, FCLASS_D)) =>
      haveDExt ()  \<bind> ((\<lambda> (w__225 :: bool) . 
      if w__225 then
        return ((concat_vec ( 0b1110001 ::  7 Word.word)
                   ((concat_vec ( 0b00000 ::  5 Word.word)
                       ((concat_vec rs1
                           ((concat_vec ( 0b001 ::  3 Word.word)
                               ((concat_vec rd ( 0b1010011 ::  7 Word.word)  ::  12 Word.word))
                              ::  15 Word.word))
                          ::  20 Word.word))
                      ::  25 Word.word))
                  ::  32 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))
   | F_UN_TYPE_D ((rs1, rd, FMV_X_D)) =>
      is_RV64D ()  \<bind> ((\<lambda> (w__228 :: bool) . 
      if w__228 then
        return ((concat_vec ( 0b1110001 ::  7 Word.word)
                   ((concat_vec ( 0b00000 ::  5 Word.word)
                       ((concat_vec rs1
                           ((concat_vec ( 0b000 ::  3 Word.word)
                               ((concat_vec rd ( 0b1010011 ::  7 Word.word)  ::  12 Word.word))
                              ::  15 Word.word))
                          ::  20 Word.word))
                      ::  25 Word.word))
                  ::  32 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))
   | F_UN_TYPE_D ((rs1, rd, FMV_D_X)) =>
      is_RV64D ()  \<bind> ((\<lambda> (w__231 :: bool) . 
      if w__231 then
        return ((concat_vec ( 0b1111001 ::  7 Word.word)
                   ((concat_vec ( 0b00000 ::  5 Word.word)
                       ((concat_vec rs1
                           ((concat_vec ( 0b000 ::  3 Word.word)
                               ((concat_vec rd ( 0b1010011 ::  7 Word.word)  ::  12 Word.word))
                              ::  15 Word.word))
                          ::  20 Word.word))
                      ::  25 Word.word))
                  ::  32 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))
   | ILLEGAL (s) => return s
   | _ => assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () 
   )))\<close> 
  for  ast  :: " ast "


definition encdec_backwards  :: \<open>(32)Word.word \<Rightarrow>((register_value),(ast),(exception))monad \<close>  where 
     \<open> encdec_backwards arg1 = (
   (let v__9 = arg1 in
   if ((let (mappingpatterns_590 ::  7 Word.word) = ((subrange_vec_dec v__9 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) in
     encdec_uop_backwards_matches mappingpatterns_590)) then
     (let (imm ::  20 Word.word) = ((subrange_vec_dec v__9 (( 31 :: int)::ii) (( 12 :: int)::ii)  ::  20 Word.word)) in
     (let (rd ::  5 Word.word) = ((subrange_vec_dec v__9 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     (let (imm ::  20 Word.word) = ((subrange_vec_dec v__9 (( 31 :: int)::ii) (( 12 :: int)::ii)  ::  20 Word.word)) in
     (let (mappingpatterns_590 ::  7 Word.word) = ((subrange_vec_dec v__9 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) in
     encdec_uop_backwards mappingpatterns_590 \<bind> ((\<lambda> op1 .  return (UTYPE (imm, rd, op1))))))))
   else if (((((subrange_vec_dec v__9 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b1101111 ::  7 Word.word))))
   then
     (let (imm_19 :: 1 bits) = ((subrange_vec_dec v__9 (( 31 :: int)::ii) (( 31 :: int)::ii)  ::  1 Word.word)) in
     (let (rd ::  5 Word.word) = ((subrange_vec_dec v__9 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     (let (imm_8 :: 1 bits) = ((subrange_vec_dec v__9 (( 20 :: int)::ii) (( 20 :: int)::ii)  ::  1 Word.word)) in
     (let (imm_7_0 :: 8 bits) = ((subrange_vec_dec v__9 (( 19 :: int)::ii) (( 12 :: int)::ii)  ::  8 Word.word)) in
     (let (imm_19 :: 1 bits) = ((subrange_vec_dec v__9 (( 31 :: int)::ii) (( 31 :: int)::ii)  ::  1 Word.word)) in
     (let (imm_18_13 :: 6 bits) = ((subrange_vec_dec v__9 (( 30 :: int)::ii) (( 25 :: int)::ii)  ::  6 Word.word)) in
     (let (imm_12_9 :: 4 bits) = ((subrange_vec_dec v__9 (( 24 :: int)::ii) (( 21 :: int)::ii)  ::  4 Word.word)) in
     return (RISCV_JAL ((concat_vec imm_19
                           ((concat_vec imm_7_0
                               ((concat_vec imm_8
                                   ((concat_vec imm_18_13
                                       ((concat_vec imm_12_9 ( 0b0 ::  1 Word.word)  ::  5 Word.word))
                                      ::  11 Word.word))
                                  ::  12 Word.word))
                              ::  20 Word.word))
                          ::  21 Word.word),
                        rd)))))))))
   else if ((((((((subrange_vec_dec v__9 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = ( 0b000 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__9 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b1100111 ::  7 Word.word)))))))
   then
     (let (imm ::  12 Word.word) = ((subrange_vec_dec v__9 (( 31 :: int)::ii) (( 20 :: int)::ii)  ::  12 Word.word)) in
     (let (rs1 ::  5 Word.word) = ((subrange_vec_dec v__9 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
     (let (rd ::  5 Word.word) = ((subrange_vec_dec v__9 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     (let (imm ::  12 Word.word) = ((subrange_vec_dec v__9 (( 31 :: int)::ii) (( 20 :: int)::ii)  ::  12 Word.word)) in
     return (RISCV_JALR (imm, rs1, rd))))))
   else if (((((let (mappingpatterns_600 ::  3 Word.word) =
                 ((subrange_vec_dec v__9 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) in
               encdec_bop_backwards_matches mappingpatterns_600)) \<and> (((((subrange_vec_dec v__9 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b1100011 ::  7 Word.word)))))))
   then
     (let (imm7_6 :: 1 bits) = ((subrange_vec_dec v__9 (( 31 :: int)::ii) (( 31 :: int)::ii)  ::  1 Word.word)) in
     (let (rs2 ::  5 Word.word) = ((subrange_vec_dec v__9 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
     (let (rs1 ::  5 Word.word) = ((subrange_vec_dec v__9 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
     (let (imm7_6 :: 1 bits) = ((subrange_vec_dec v__9 (( 31 :: int)::ii) (( 31 :: int)::ii)  ::  1 Word.word)) in
     (let (imm7_5_0 :: 6 bits) = ((subrange_vec_dec v__9 (( 30 :: int)::ii) (( 25 :: int)::ii)  ::  6 Word.word)) in
     (let (imm5_4_1 :: 4 bits) = ((subrange_vec_dec v__9 (( 11 :: int)::ii) (( 8 :: int)::ii)  ::  4 Word.word)) in
     (let (imm5_0 :: 1 bits) = ((subrange_vec_dec v__9 (( 7 :: int)::ii) (( 7 :: int)::ii)  ::  1 Word.word)) in
     (let (mappingpatterns_600 ::  3 Word.word) = ((subrange_vec_dec v__9 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) in
     encdec_bop_backwards mappingpatterns_600 \<bind> ((\<lambda> op1 . 
     return (BTYPE ((concat_vec imm7_6
                       ((concat_vec imm5_0
                           ((concat_vec imm7_5_0
                               ((concat_vec imm5_4_1 ( 0b0 ::  1 Word.word)  ::  5 Word.word))
                              ::  11 Word.word))
                          ::  12 Word.word))
                      ::  13 Word.word),
                    rs2,
                    rs1,
                    op1))))))))))))
   else if (((((let (mappingpatterns_610 ::  3 Word.word) =
                 ((subrange_vec_dec v__9 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) in
               encdec_iop_backwards_matches mappingpatterns_610)) \<and> (((((subrange_vec_dec v__9 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b0010011 ::  7 Word.word)))))))
   then
     (let (imm ::  12 Word.word) = ((subrange_vec_dec v__9 (( 31 :: int)::ii) (( 20 :: int)::ii)  ::  12 Word.word)) in
     (let (rs1 ::  5 Word.word) = ((subrange_vec_dec v__9 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
     (let (rd ::  5 Word.word) = ((subrange_vec_dec v__9 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     (let (imm ::  12 Word.word) = ((subrange_vec_dec v__9 (( 31 :: int)::ii) (( 20 :: int)::ii)  ::  12 Word.word)) in
     (let (mappingpatterns_610 ::  3 Word.word) = ((subrange_vec_dec v__9 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) in
     encdec_iop_backwards mappingpatterns_610 \<bind> ((\<lambda> op1 .  return (ITYPE (imm, rs1, rd, op1)))))))))
   else if (((((let (shamt ::  6 Word.word) = ((subrange_vec_dec v__9 (( 25 :: int)::ii) (( 20 :: int)::ii)  ::  6 Word.word)) in
               (((((( 64 :: int)::ii) = (( 64 :: int)::ii)))) \<or> (((((access_vec_dec shamt (( 5 :: int)::ii))) = B0)))))) \<and> ((((((((subrange_vec_dec v__9 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b000000 ::  6 Word.word)))) \<and> ((((((((subrange_vec_dec v__9 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = ( 0b001 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__9 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b0010011 ::  7 Word.word))))))))))))) then
     (let (shamt ::  6 Word.word) = ((subrange_vec_dec v__9 (( 25 :: int)::ii) (( 20 :: int)::ii)  ::  6 Word.word)) in
     (let (rs1 ::  5 Word.word) = ((subrange_vec_dec v__9 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
     (let (rd ::  5 Word.word) = ((subrange_vec_dec v__9 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     return (SHIFTIOP (shamt, rs1, rd, RISCV_SLLI)))))
   else if (((((let (shamt ::  6 Word.word) = ((subrange_vec_dec v__9 (( 25 :: int)::ii) (( 20 :: int)::ii)  ::  6 Word.word)) in
               (((((( 64 :: int)::ii) = (( 64 :: int)::ii)))) \<or> (((((access_vec_dec shamt (( 5 :: int)::ii))) = B0)))))) \<and> ((((((((subrange_vec_dec v__9 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b000000 ::  6 Word.word)))) \<and> ((((((((subrange_vec_dec v__9 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = ( 0b101 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__9 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b0010011 ::  7 Word.word))))))))))))) then
     (let (shamt ::  6 Word.word) = ((subrange_vec_dec v__9 (( 25 :: int)::ii) (( 20 :: int)::ii)  ::  6 Word.word)) in
     (let (rs1 ::  5 Word.word) = ((subrange_vec_dec v__9 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
     (let (rd ::  5 Word.word) = ((subrange_vec_dec v__9 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     return (SHIFTIOP (shamt, rs1, rd, RISCV_SRLI)))))
   else if (((((let (shamt ::  6 Word.word) = ((subrange_vec_dec v__9 (( 25 :: int)::ii) (( 20 :: int)::ii)  ::  6 Word.word)) in
               (((((( 64 :: int)::ii) = (( 64 :: int)::ii)))) \<or> (((((access_vec_dec shamt (( 5 :: int)::ii))) = B0)))))) \<and> ((((((((subrange_vec_dec v__9 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b010000 ::  6 Word.word)))) \<and> ((((((((subrange_vec_dec v__9 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = ( 0b101 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__9 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b0010011 ::  7 Word.word))))))))))))) then
     (let (shamt ::  6 Word.word) = ((subrange_vec_dec v__9 (( 25 :: int)::ii) (( 20 :: int)::ii)  ::  6 Word.word)) in
     (let (rs1 ::  5 Word.word) = ((subrange_vec_dec v__9 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
     (let (rd ::  5 Word.word) = ((subrange_vec_dec v__9 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     return (SHIFTIOP (shamt, rs1, rd, RISCV_SRAI)))))
   else if ((((((((subrange_vec_dec v__9 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = ( 0b0000000 ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__9 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = ( 0b000 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__9 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b0110011 ::  7 Word.word)))))))))) then
     (let (rs2 ::  5 Word.word) = ((subrange_vec_dec v__9 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
     (let (rs1 ::  5 Word.word) = ((subrange_vec_dec v__9 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
     (let (rd ::  5 Word.word) = ((subrange_vec_dec v__9 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     return (RTYPE (rs2, rs1, rd, RISCV_ADD)))))
   else if ((((((((subrange_vec_dec v__9 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = ( 0b0000000 ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__9 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = ( 0b010 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__9 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b0110011 ::  7 Word.word)))))))))) then
     (let (rs2 ::  5 Word.word) = ((subrange_vec_dec v__9 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
     (let (rs1 ::  5 Word.word) = ((subrange_vec_dec v__9 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
     (let (rd ::  5 Word.word) = ((subrange_vec_dec v__9 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     return (RTYPE (rs2, rs1, rd, RISCV_SLT)))))
   else if ((((((((subrange_vec_dec v__9 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = ( 0b0000000 ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__9 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = ( 0b011 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__9 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b0110011 ::  7 Word.word)))))))))) then
     (let (rs2 ::  5 Word.word) = ((subrange_vec_dec v__9 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
     (let (rs1 ::  5 Word.word) = ((subrange_vec_dec v__9 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
     (let (rd ::  5 Word.word) = ((subrange_vec_dec v__9 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     return (RTYPE (rs2, rs1, rd, RISCV_SLTU)))))
   else if ((((((((subrange_vec_dec v__9 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = ( 0b0000000 ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__9 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = ( 0b111 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__9 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b0110011 ::  7 Word.word)))))))))) then
     (let (rs2 ::  5 Word.word) = ((subrange_vec_dec v__9 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
     (let (rs1 ::  5 Word.word) = ((subrange_vec_dec v__9 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
     (let (rd ::  5 Word.word) = ((subrange_vec_dec v__9 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     return (RTYPE (rs2, rs1, rd, RISCV_AND)))))
   else if ((((((((subrange_vec_dec v__9 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = ( 0b0000000 ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__9 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = ( 0b110 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__9 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b0110011 ::  7 Word.word)))))))))) then
     (let (rs2 ::  5 Word.word) = ((subrange_vec_dec v__9 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
     (let (rs1 ::  5 Word.word) = ((subrange_vec_dec v__9 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
     (let (rd ::  5 Word.word) = ((subrange_vec_dec v__9 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     return (RTYPE (rs2, rs1, rd, RISCV_OR)))))
   else if ((((((((subrange_vec_dec v__9 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = ( 0b0000000 ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__9 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = ( 0b100 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__9 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b0110011 ::  7 Word.word)))))))))) then
     (let (rs2 ::  5 Word.word) = ((subrange_vec_dec v__9 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
     (let (rs1 ::  5 Word.word) = ((subrange_vec_dec v__9 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
     (let (rd ::  5 Word.word) = ((subrange_vec_dec v__9 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     return (RTYPE (rs2, rs1, rd, RISCV_XOR)))))
   else if ((((((((subrange_vec_dec v__9 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = ( 0b0000000 ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__9 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = ( 0b001 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__9 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b0110011 ::  7 Word.word)))))))))) then
     (let (rs2 ::  5 Word.word) = ((subrange_vec_dec v__9 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
     (let (rs1 ::  5 Word.word) = ((subrange_vec_dec v__9 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
     (let (rd ::  5 Word.word) = ((subrange_vec_dec v__9 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     return (RTYPE (rs2, rs1, rd, RISCV_SLL)))))
   else if ((((((((subrange_vec_dec v__9 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = ( 0b0000000 ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__9 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = ( 0b101 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__9 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b0110011 ::  7 Word.word)))))))))) then
     (let (rs2 ::  5 Word.word) = ((subrange_vec_dec v__9 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
     (let (rs1 ::  5 Word.word) = ((subrange_vec_dec v__9 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
     (let (rd ::  5 Word.word) = ((subrange_vec_dec v__9 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     return (RTYPE (rs2, rs1, rd, RISCV_SRL)))))
   else if ((((((((subrange_vec_dec v__9 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = ( 0b0100000 ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__9 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = ( 0b000 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__9 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b0110011 ::  7 Word.word)))))))))) then
     (let (rs2 ::  5 Word.word) = ((subrange_vec_dec v__9 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
     (let (rs1 ::  5 Word.word) = ((subrange_vec_dec v__9 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
     (let (rd ::  5 Word.word) = ((subrange_vec_dec v__9 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     return (RTYPE (rs2, rs1, rd, RISCV_SUB)))))
   else if ((((((((subrange_vec_dec v__9 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = ( 0b0100000 ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__9 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = ( 0b101 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__9 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b0110011 ::  7 Word.word)))))))))) then
     (let (rs2 ::  5 Word.word) = ((subrange_vec_dec v__9 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
     (let (rs1 ::  5 Word.word) = ((subrange_vec_dec v__9 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
     (let (rd ::  5 Word.word) = ((subrange_vec_dec v__9 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     return (RTYPE (rs2, rs1, rd, RISCV_SRA)))))
   else
     and_boolM
       ((let (mappingpatterns_630 ::  2 Word.word) =
         ((subrange_vec_dec v__9 (( 13 :: int)::ii) (( 12 :: int)::ii)  ::  2 Word.word)) in
       (let (mappingpatterns_620 ::  1 Word.word) = ((subrange_vec_dec v__9 (( 14 :: int)::ii) (( 14 :: int)::ii)  ::  1 Word.word)) in
       if ((size_bits_backwards_matches mappingpatterns_630)) then
         size_bits_backwards mappingpatterns_630 \<bind> ((\<lambda> size1 . 
         if ((bool_bits_backwards_matches mappingpatterns_620)) then
           bool_bits_backwards mappingpatterns_620 \<bind> ((\<lambda> is_unsigned . 
           return (((((((word_width_bytes size1)) < (( 8 :: int)::ii))) \<or> (((((\<not> is_unsigned)) \<and> ((((word_width_bytes size1)) \<le> (( 8 :: int)::ii)))))))))))
         else return False))
       else return False)))
       (return (((((subrange_vec_dec v__9 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b0000011 ::  7 Word.word))))) \<bind> ((\<lambda> (w__2 ::
       bool) . 
     if w__2 then
       (let (imm ::  12 Word.word) = ((subrange_vec_dec v__9 (( 31 :: int)::ii) (( 20 :: int)::ii)  ::  12 Word.word)) in
       (let (rs1 ::  5 Word.word) = ((subrange_vec_dec v__9 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
       (let (rd ::  5 Word.word) = ((subrange_vec_dec v__9 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
       (let (imm ::  12 Word.word) = ((subrange_vec_dec v__9 (( 31 :: int)::ii) (( 20 :: int)::ii)  ::  12 Word.word)) in
       (let (mappingpatterns_630 ::  2 Word.word) = ((subrange_vec_dec v__9 (( 13 :: int)::ii) (( 12 :: int)::ii)  ::  2 Word.word)) in
       (let (mappingpatterns_620 ::  1 Word.word) = ((subrange_vec_dec v__9 (( 14 :: int)::ii) (( 14 :: int)::ii)  ::  1 Word.word)) in
       size_bits_backwards mappingpatterns_630 \<bind> ((\<lambda> size1 . 
       bool_bits_backwards mappingpatterns_620 \<bind> ((\<lambda> is_unsigned . 
       return (LOAD (imm, rs1, rd, is_unsigned, size1, False, False))))))))))))
     else
       and_boolM
         ((let (mappingpatterns_640 ::  2 Word.word) =
           ((subrange_vec_dec v__9 (( 13 :: int)::ii) (( 12 :: int)::ii)  ::  2 Word.word)) in
         if ((size_bits_backwards_matches mappingpatterns_640)) then
           size_bits_backwards mappingpatterns_640 \<bind> ((\<lambda> size1 . 
           return ((((word_width_bytes size1)) \<le> (( 8 :: int)::ii)))))
         else return False))
         (return ((((((((subrange_vec_dec v__9 (( 14 :: int)::ii) (( 14 :: int)::ii)  ::  1 Word.word)) = ( 0b0 ::  1 Word.word)))) \<and> (((((subrange_vec_dec v__9 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b0100011 ::  7 Word.word)))))))) \<bind> ((\<lambda> (w__4 :: bool) . 
       if w__4 then
         (let (imm7 :: 7 bits) = ((subrange_vec_dec v__9 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) in
         (let (rs2 ::  5 Word.word) = ((subrange_vec_dec v__9 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
         (let (rs1 ::  5 Word.word) = ((subrange_vec_dec v__9 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
         (let (imm7 :: 7 bits) = ((subrange_vec_dec v__9 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) in
         (let (imm5 :: 5 bits) = ((subrange_vec_dec v__9 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
         (let (mappingpatterns_640 ::  2 Word.word) =
           ((subrange_vec_dec v__9 (( 13 :: int)::ii) (( 12 :: int)::ii)  ::  2 Word.word)) in
         size_bits_backwards mappingpatterns_640 \<bind> ((\<lambda> size1 . 
         return (STORE ((concat_vec imm7 imm5  ::  12 Word.word), rs2, rs1, size1, False, False))))))))))
       else if (((((((( 64 :: int)::ii) = (( 64 :: int)::ii)))) \<and> ((((((((subrange_vec_dec v__9 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = ( 0b000 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__9 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b0011011 ::  7 Word.word)))))))))) then
         (let (imm ::  12 Word.word) = ((subrange_vec_dec v__9 (( 31 :: int)::ii) (( 20 :: int)::ii)  ::  12 Word.word)) in
         (let (rs1 ::  5 Word.word) = ((subrange_vec_dec v__9 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
         (let (rd ::  5 Word.word) = ((subrange_vec_dec v__9 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
         (let (imm ::  12 Word.word) = ((subrange_vec_dec v__9 (( 31 :: int)::ii) (( 20 :: int)::ii)  ::  12 Word.word)) in
         return (ADDIW (imm, rs1, rd))))))
       else if (((((((( 64 :: int)::ii) = (( 64 :: int)::ii)))) \<and> ((((((((subrange_vec_dec v__9 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = ( 0b0000000 ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__9 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = ( 0b001 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__9 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b0011011 ::  7 Word.word))))))))))))) then
         (let (shamt ::  5 Word.word) = ((subrange_vec_dec v__9 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
         (let (rs1 ::  5 Word.word) = ((subrange_vec_dec v__9 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
         (let (rd ::  5 Word.word) = ((subrange_vec_dec v__9 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
         return (SHIFTW (shamt, rs1, rd, RISCV_SLLI)))))
       else if (((((((( 64 :: int)::ii) = (( 64 :: int)::ii)))) \<and> ((((((((subrange_vec_dec v__9 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = ( 0b0000000 ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__9 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = ( 0b101 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__9 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b0011011 ::  7 Word.word))))))))))))) then
         (let (shamt ::  5 Word.word) = ((subrange_vec_dec v__9 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
         (let (rs1 ::  5 Word.word) = ((subrange_vec_dec v__9 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
         (let (rd ::  5 Word.word) = ((subrange_vec_dec v__9 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
         return (SHIFTW (shamt, rs1, rd, RISCV_SRLI)))))
       else if (((((((( 64 :: int)::ii) = (( 64 :: int)::ii)))) \<and> ((((((((subrange_vec_dec v__9 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = ( 0b0100000 ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__9 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = ( 0b101 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__9 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b0011011 ::  7 Word.word))))))))))))) then
         (let (shamt ::  5 Word.word) = ((subrange_vec_dec v__9 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
         (let (rs1 ::  5 Word.word) = ((subrange_vec_dec v__9 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
         (let (rd ::  5 Word.word) = ((subrange_vec_dec v__9 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
         return (SHIFTW (shamt, rs1, rd, RISCV_SRAI)))))
       else if (((((((( 64 :: int)::ii) = (( 64 :: int)::ii)))) \<and> ((((((((subrange_vec_dec v__9 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = ( 0b0000000 ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__9 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = ( 0b000 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__9 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b0111011 ::  7 Word.word))))))))))))) then
         (let (rs2 ::  5 Word.word) = ((subrange_vec_dec v__9 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
         (let (rs1 ::  5 Word.word) = ((subrange_vec_dec v__9 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
         (let (rd ::  5 Word.word) = ((subrange_vec_dec v__9 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
         return (RTYPEW (rs2, rs1, rd, RISCV_ADDW)))))
       else if (((((((( 64 :: int)::ii) = (( 64 :: int)::ii)))) \<and> ((((((((subrange_vec_dec v__9 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = ( 0b0100000 ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__9 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = ( 0b000 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__9 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b0111011 ::  7 Word.word))))))))))))) then
         (let (rs2 ::  5 Word.word) = ((subrange_vec_dec v__9 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
         (let (rs1 ::  5 Word.word) = ((subrange_vec_dec v__9 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
         (let (rd ::  5 Word.word) = ((subrange_vec_dec v__9 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
         return (RTYPEW (rs2, rs1, rd, RISCV_SUBW)))))
       else if (((((((( 64 :: int)::ii) = (( 64 :: int)::ii)))) \<and> ((((((((subrange_vec_dec v__9 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = ( 0b0000000 ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__9 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = ( 0b001 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__9 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b0111011 ::  7 Word.word))))))))))))) then
         (let (rs2 ::  5 Word.word) = ((subrange_vec_dec v__9 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
         (let (rs1 ::  5 Word.word) = ((subrange_vec_dec v__9 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
         (let (rd ::  5 Word.word) = ((subrange_vec_dec v__9 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
         return (RTYPEW (rs2, rs1, rd, RISCV_SLLW)))))
       else if (((((((( 64 :: int)::ii) = (( 64 :: int)::ii)))) \<and> ((((((((subrange_vec_dec v__9 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = ( 0b0000000 ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__9 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = ( 0b101 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__9 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b0111011 ::  7 Word.word))))))))))))) then
         (let (rs2 ::  5 Word.word) = ((subrange_vec_dec v__9 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
         (let (rs1 ::  5 Word.word) = ((subrange_vec_dec v__9 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
         (let (rd ::  5 Word.word) = ((subrange_vec_dec v__9 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
         return (RTYPEW (rs2, rs1, rd, RISCV_SRLW)))))
       else if (((((((( 64 :: int)::ii) = (( 64 :: int)::ii)))) \<and> ((((((((subrange_vec_dec v__9 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = ( 0b0100000 ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__9 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = ( 0b101 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__9 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b0111011 ::  7 Word.word))))))))))))) then
         (let (rs2 ::  5 Word.word) = ((subrange_vec_dec v__9 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
         (let (rs1 ::  5 Word.word) = ((subrange_vec_dec v__9 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
         (let (rd ::  5 Word.word) = ((subrange_vec_dec v__9 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
         return (RTYPEW (rs2, rs1, rd, RISCV_SRAW)))))
       else if (((((((( 64 :: int)::ii) = (( 64 :: int)::ii)))) \<and> ((((((((subrange_vec_dec v__9 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = ( 0b0000000 ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__9 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = ( 0b001 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__9 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b0011011 ::  7 Word.word))))))))))))) then
         (let (shamt ::  5 Word.word) = ((subrange_vec_dec v__9 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
         (let (rs1 ::  5 Word.word) = ((subrange_vec_dec v__9 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
         (let (rd ::  5 Word.word) = ((subrange_vec_dec v__9 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
         return (SHIFTIWOP (shamt, rs1, rd, RISCV_SLLIW)))))
       else if (((((((( 64 :: int)::ii) = (( 64 :: int)::ii)))) \<and> ((((((((subrange_vec_dec v__9 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = ( 0b0000000 ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__9 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = ( 0b101 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__9 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b0011011 ::  7 Word.word))))))))))))) then
         (let (shamt ::  5 Word.word) = ((subrange_vec_dec v__9 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
         (let (rs1 ::  5 Word.word) = ((subrange_vec_dec v__9 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
         (let (rd ::  5 Word.word) = ((subrange_vec_dec v__9 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
         return (SHIFTIWOP (shamt, rs1, rd, RISCV_SRLIW)))))
       else if (((((((( 64 :: int)::ii) = (( 64 :: int)::ii)))) \<and> ((((((((subrange_vec_dec v__9 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = ( 0b0100000 ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__9 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = ( 0b101 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__9 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b0011011 ::  7 Word.word))))))))))))) then
         (let (shamt ::  5 Word.word) = ((subrange_vec_dec v__9 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
         (let (rs1 ::  5 Word.word) = ((subrange_vec_dec v__9 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
         (let (rd ::  5 Word.word) = ((subrange_vec_dec v__9 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
         return (SHIFTIWOP (shamt, rs1, rd, RISCV_SRAIW)))))
       else if ((((((((subrange_vec_dec v__9 (( 31 :: int)::ii) (( 28 :: int)::ii)  ::  4 Word.word)) = ( 0x0 ::  4 Word.word)))) \<and> (((((subrange_vec_dec v__9 (( 19 :: int)::ii) (( 0 :: int)::ii)  ::  20 Word.word)) = ( 0x0000F ::  20 Word.word))))))) then
         (let (succ ::  4 Word.word) = ((subrange_vec_dec v__9 (( 23 :: int)::ii) (( 20 :: int)::ii)  ::  4 Word.word)) in
         (let (pred ::  4 Word.word) = ((subrange_vec_dec v__9 (( 27 :: int)::ii) (( 24 :: int)::ii)  ::  4 Word.word)) in
         return (FENCE (pred, succ))))
       else if ((((((((subrange_vec_dec v__9 (( 31 :: int)::ii) (( 28 :: int)::ii)  ::  4 Word.word)) = ( 0x8 ::  4 Word.word)))) \<and> (((((subrange_vec_dec v__9 (( 19 :: int)::ii) (( 0 :: int)::ii)  ::  20 Word.word)) = ( 0x0000F ::  20 Word.word))))))) then
         (let (succ ::  4 Word.word) = ((subrange_vec_dec v__9 (( 23 :: int)::ii) (( 20 :: int)::ii)  ::  4 Word.word)) in
         (let (pred ::  4 Word.word) = ((subrange_vec_dec v__9 (( 27 :: int)::ii) (( 24 :: int)::ii)  ::  4 Word.word)) in
         return (FENCE_TSO (pred, succ))))
       else if (((v__9 = ( 0x0000100F ::  32 Word.word)))) then return (FENCEI () )
       else if (((v__9 = ( 0x00000073 ::  32 Word.word)))) then return (ECALL () )
       else if (((v__9 = ( 0x30200073 ::  32 Word.word)))) then return (MRET () )
       else if (((v__9 = ( 0x10200073 ::  32 Word.word)))) then return (SRET () )
       else if (((v__9 = ( 0x00100073 ::  32 Word.word)))) then return (EBREAK () )
       else if (((v__9 = ( 0x10500073 ::  32 Word.word)))) then return (WFI () )
       else if ((((((((subrange_vec_dec v__9 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = ( 0b0001001 ::  7 Word.word)))) \<and> (((((subrange_vec_dec v__9 (( 14 :: int)::ii) (( 0 :: int)::ii)  ::  15 Word.word)) = ( 0b000000001110011 ::  15 Word.word))))))) then
         (let (rs2 ::  5 Word.word) = ((subrange_vec_dec v__9 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
         (let (rs1 ::  5 Word.word) = ((subrange_vec_dec v__9 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
         return (SFENCE_VMA (rs1, rs2))))
       else
         and_boolM
           ((let (mappingpatterns_670 ::  2 Word.word) =
             ((subrange_vec_dec v__9 (( 13 :: int)::ii) (( 12 :: int)::ii)  ::  2 Word.word)) in
           (let (mappingpatterns_660 ::  1 Word.word) =
             ((subrange_vec_dec v__9 (( 25 :: int)::ii) (( 25 :: int)::ii)  ::  1 Word.word)) in
           (let (mappingpatterns_650 ::  1 Word.word) =
             ((subrange_vec_dec v__9 (( 26 :: int)::ii) (( 26 :: int)::ii)  ::  1 Word.word)) in
           if ((size_bits_backwards_matches mappingpatterns_670)) then
             size_bits_backwards mappingpatterns_670 \<bind> ((\<lambda> size1 . 
             if ((bool_bits_backwards_matches mappingpatterns_660)) then
               bool_bits_backwards mappingpatterns_660 \<bind> ((\<lambda> rl . 
               if ((bool_bits_backwards_matches mappingpatterns_650)) then
                 bool_bits_backwards mappingpatterns_650 \<bind> ((\<lambda> aq . 
                 return ((amo_width_valid size1))))
               else return False))
             else return False))
           else return False))))
           (return ((((((((subrange_vec_dec v__9 (( 31 :: int)::ii) (( 27 :: int)::ii)  ::  5 Word.word)) = ( 0b00010 ::  5 Word.word)))) \<and> ((((((((subrange_vec_dec v__9 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) = ( 0b00000 ::  5 Word.word)))) \<and> ((((((((subrange_vec_dec v__9 (( 14 :: int)::ii) (( 14 :: int)::ii)  ::  1 Word.word)) = ( 0b0 ::  1 Word.word)))) \<and> (((((subrange_vec_dec v__9 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b0101111 ::  7 Word.word)))))))))))))) \<bind> ((\<lambda> (w__8 :: bool) . 
         if w__8 then
           (let (rs1 ::  5 Word.word) = ((subrange_vec_dec v__9 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
           (let (rd ::  5 Word.word) = ((subrange_vec_dec v__9 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
           (let (mappingpatterns_670 ::  2 Word.word) =
             ((subrange_vec_dec v__9 (( 13 :: int)::ii) (( 12 :: int)::ii)  ::  2 Word.word)) in
           (let (mappingpatterns_660 ::  1 Word.word) =
             ((subrange_vec_dec v__9 (( 25 :: int)::ii) (( 25 :: int)::ii)  ::  1 Word.word)) in
           (let (mappingpatterns_650 ::  1 Word.word) =
             ((subrange_vec_dec v__9 (( 26 :: int)::ii) (( 26 :: int)::ii)  ::  1 Word.word)) in
           size_bits_backwards mappingpatterns_670 \<bind> ((\<lambda> size1 . 
           bool_bits_backwards mappingpatterns_660 \<bind> ((\<lambda> rl . 
           bool_bits_backwards mappingpatterns_650 \<bind> ((\<lambda> aq . 
           return (LOADRES (aq, rl, rs1, size1, rd)))))))))))))
         else
           and_boolM
             ((let (mappingpatterns_700 ::  2 Word.word) =
               ((subrange_vec_dec v__9 (( 13 :: int)::ii) (( 12 :: int)::ii)  ::  2 Word.word)) in
             (let (mappingpatterns_690 ::  1 Word.word) =
               ((subrange_vec_dec v__9 (( 25 :: int)::ii) (( 25 :: int)::ii)  ::  1 Word.word)) in
             (let (mappingpatterns_680 ::  1 Word.word) =
               ((subrange_vec_dec v__9 (( 26 :: int)::ii) (( 26 :: int)::ii)  ::  1 Word.word)) in
             if ((size_bits_backwards_matches mappingpatterns_700)) then
               size_bits_backwards mappingpatterns_700 \<bind> ((\<lambda> size1 . 
               if ((bool_bits_backwards_matches mappingpatterns_690)) then
                 bool_bits_backwards mappingpatterns_690 \<bind> ((\<lambda> rl . 
                 if ((bool_bits_backwards_matches mappingpatterns_680)) then
                   bool_bits_backwards mappingpatterns_680 \<bind> ((\<lambda> aq . 
                   return ((amo_width_valid size1))))
                 else return False))
               else return False))
             else return False))))
             (return ((((((((subrange_vec_dec v__9 (( 31 :: int)::ii) (( 27 :: int)::ii)  ::  5 Word.word)) = ( 0b00011 ::  5 Word.word)))) \<and> ((((((((subrange_vec_dec v__9 (( 14 :: int)::ii) (( 14 :: int)::ii)  ::  1 Word.word)) = ( 0b0 ::  1 Word.word)))) \<and> (((((subrange_vec_dec v__9 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b0101111 ::  7 Word.word))))))))))) \<bind> ((\<lambda> (w__12 :: bool) . 
           if w__12 then
             (let (rs2 ::  5 Word.word) = ((subrange_vec_dec v__9 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
             (let (rs1 ::  5 Word.word) = ((subrange_vec_dec v__9 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
             (let (rd ::  5 Word.word) = ((subrange_vec_dec v__9 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
             (let (mappingpatterns_700 ::  2 Word.word) =
               ((subrange_vec_dec v__9 (( 13 :: int)::ii) (( 12 :: int)::ii)  ::  2 Word.word)) in
             (let (mappingpatterns_690 ::  1 Word.word) =
               ((subrange_vec_dec v__9 (( 25 :: int)::ii) (( 25 :: int)::ii)  ::  1 Word.word)) in
             (let (mappingpatterns_680 ::  1 Word.word) =
               ((subrange_vec_dec v__9 (( 26 :: int)::ii) (( 26 :: int)::ii)  ::  1 Word.word)) in
             size_bits_backwards mappingpatterns_700 \<bind> ((\<lambda> size1 . 
             bool_bits_backwards mappingpatterns_690 \<bind> ((\<lambda> rl . 
             bool_bits_backwards mappingpatterns_680 \<bind> ((\<lambda> aq . 
             return (STORECON (aq, rl, rs2, rs1, size1, rd))))))))))))))
           else
             and_boolM
               ((let (mappingpatterns_710 ::  5 Word.word) =
                 ((subrange_vec_dec v__9 (( 31 :: int)::ii) (( 27 :: int)::ii)  ::  5 Word.word)) in
               (let (mappingpatterns_740 ::  2 Word.word) =
                 ((subrange_vec_dec v__9 (( 13 :: int)::ii) (( 12 :: int)::ii)  ::  2 Word.word)) in
               (let (mappingpatterns_730 ::  1 Word.word) =
                 ((subrange_vec_dec v__9 (( 25 :: int)::ii) (( 25 :: int)::ii)  ::  1 Word.word)) in
               (let (mappingpatterns_720 ::  1 Word.word) =
                 ((subrange_vec_dec v__9 (( 26 :: int)::ii) (( 26 :: int)::ii)  ::  1 Word.word)) in
               (let (mappingpatterns_710 ::  5 Word.word) =
                 ((subrange_vec_dec v__9 (( 31 :: int)::ii) (( 27 :: int)::ii)  ::  5 Word.word)) in
               if ((size_bits_backwards_matches mappingpatterns_740)) then
                 size_bits_backwards mappingpatterns_740 \<bind> ((\<lambda> size1 . 
                 if ((bool_bits_backwards_matches mappingpatterns_730)) then
                   bool_bits_backwards mappingpatterns_730 \<bind> ((\<lambda> rl . 
                   if ((bool_bits_backwards_matches mappingpatterns_720)) then
                     bool_bits_backwards mappingpatterns_720 \<bind> ((\<lambda> aq . 
                     if ((encdec_amoop_backwards_matches mappingpatterns_710)) then
                       encdec_amoop_backwards mappingpatterns_710 \<bind> ((\<lambda> op1 . 
                       return ((amo_width_valid size1))))
                     else return False))
                   else return False))
                 else return False))
               else return False))))))
               (return ((((((((subrange_vec_dec v__9 (( 14 :: int)::ii) (( 14 :: int)::ii)  ::  1 Word.word)) = ( 0b0 ::  1 Word.word)))) \<and> (((((subrange_vec_dec v__9 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b0101111 ::  7 Word.word)))))))) \<bind> ((\<lambda> (w__17 :: bool) . 
             if w__17 then
               (let (mappingpatterns_710 ::  5 Word.word) =
                 ((subrange_vec_dec v__9 (( 31 :: int)::ii) (( 27 :: int)::ii)  ::  5 Word.word)) in
               (let (rs2 ::  5 Word.word) = ((subrange_vec_dec v__9 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
               (let (rs1 ::  5 Word.word) = ((subrange_vec_dec v__9 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
               (let (rd ::  5 Word.word) = ((subrange_vec_dec v__9 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
               (let (mappingpatterns_740 ::  2 Word.word) =
                 ((subrange_vec_dec v__9 (( 13 :: int)::ii) (( 12 :: int)::ii)  ::  2 Word.word)) in
               (let (mappingpatterns_730 ::  1 Word.word) =
                 ((subrange_vec_dec v__9 (( 25 :: int)::ii) (( 25 :: int)::ii)  ::  1 Word.word)) in
               (let (mappingpatterns_720 ::  1 Word.word) =
                 ((subrange_vec_dec v__9 (( 26 :: int)::ii) (( 26 :: int)::ii)  ::  1 Word.word)) in
               (let (mappingpatterns_710 ::  5 Word.word) =
                 ((subrange_vec_dec v__9 (( 31 :: int)::ii) (( 27 :: int)::ii)  ::  5 Word.word)) in
               size_bits_backwards mappingpatterns_740 \<bind> ((\<lambda> size1 . 
               bool_bits_backwards mappingpatterns_730 \<bind> ((\<lambda> rl . 
               bool_bits_backwards mappingpatterns_720 \<bind> ((\<lambda> aq . 
               encdec_amoop_backwards mappingpatterns_710 \<bind> ((\<lambda> op1 . 
               return (AMO (op1, aq, rl, rs2, rs1, size1, rd))))))))))))))))))
             else if (((((let (mappingpatterns_750 ::  3 Word.word) =
                           ((subrange_vec_dec v__9 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) in
                         encdec_mul_op_backwards_matches mappingpatterns_750)) \<and> ((((((((subrange_vec_dec v__9 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = ( 0b0000001 ::  7 Word.word)))) \<and> (((((subrange_vec_dec v__9 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b0110011 ::  7 Word.word)))))))))) then
               (let (rs2 ::  5 Word.word) = ((subrange_vec_dec v__9 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
               (let (rs1 ::  5 Word.word) = ((subrange_vec_dec v__9 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
               (let (rd ::  5 Word.word) = ((subrange_vec_dec v__9 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
               (let (mappingpatterns_750 ::  3 Word.word) =
                 ((subrange_vec_dec v__9 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) in
               encdec_mul_op_backwards mappingpatterns_750 \<bind> ((\<lambda> varstup .  (let (high, signed1, signed2) = varstup in
               return (MUL (rs2, rs1, rd, high, signed1, signed2)))))))))
             else if (((((let (mappingpatterns_760 ::  1 Word.word) =
                           ((subrange_vec_dec v__9 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
                         bool_not_bits_backwards_matches mappingpatterns_760)) \<and> ((((((((subrange_vec_dec v__9 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = ( 0b0000001 ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__9 (( 14 :: int)::ii) (( 13 :: int)::ii)  ::  2 Word.word)) = ( 0b10 ::  2 Word.word)))) \<and> (((((subrange_vec_dec v__9 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b0110011 ::  7 Word.word))))))))))))) then
               (let (rs2 ::  5 Word.word) = ((subrange_vec_dec v__9 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
               (let (rs1 ::  5 Word.word) = ((subrange_vec_dec v__9 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
               (let (rd ::  5 Word.word) = ((subrange_vec_dec v__9 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
               (let (mappingpatterns_760 ::  1 Word.word) =
                 ((subrange_vec_dec v__9 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
               bool_not_bits_backwards mappingpatterns_760 \<bind> ((\<lambda> s . 
               return (DIV (rs2, rs1, rd, s))))))))
             else if (((((let (mappingpatterns_770 ::  1 Word.word) =
                           ((subrange_vec_dec v__9 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
                         bool_not_bits_backwards_matches mappingpatterns_770)) \<and> ((((((((subrange_vec_dec v__9 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = ( 0b0000001 ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__9 (( 14 :: int)::ii) (( 13 :: int)::ii)  ::  2 Word.word)) = ( 0b11 ::  2 Word.word)))) \<and> (((((subrange_vec_dec v__9 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b0110011 ::  7 Word.word))))))))))))) then
               (let (rs2 ::  5 Word.word) = ((subrange_vec_dec v__9 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
               (let (rs1 ::  5 Word.word) = ((subrange_vec_dec v__9 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
               (let (rd ::  5 Word.word) = ((subrange_vec_dec v__9 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
               (let (mappingpatterns_770 ::  1 Word.word) =
                 ((subrange_vec_dec v__9 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
               bool_not_bits_backwards mappingpatterns_770 \<bind> ((\<lambda> s . 
               return (REM (rs2, rs1, rd, s))))))))
             else if (((((((( 64 :: int)::ii) = (( 64 :: int)::ii)))) \<and> ((((((((subrange_vec_dec v__9 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = ( 0b0000001 ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__9 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = ( 0b000 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__9 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b0111011 ::  7 Word.word))))))))))))) then
               (let (rs2 ::  5 Word.word) = ((subrange_vec_dec v__9 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
               (let (rs1 ::  5 Word.word) = ((subrange_vec_dec v__9 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
               (let (rd ::  5 Word.word) = ((subrange_vec_dec v__9 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
               return (MULW (rs2, rs1, rd)))))
             else
               and_boolM
                 ((let (mappingpatterns_780 ::  1 Word.word) =
                   ((subrange_vec_dec v__9 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
                 if ((bool_not_bits_backwards_matches mappingpatterns_780)) then
                   bool_not_bits_backwards mappingpatterns_780 \<bind> ((\<lambda> s . 
                   return ((((( 64 :: int)::ii) = (( 64 :: int)::ii))))))
                 else return False))
                 (return ((((((((subrange_vec_dec v__9 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = ( 0b0000001 ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__9 (( 14 :: int)::ii) (( 13 :: int)::ii)  ::  2 Word.word)) = ( 0b10 ::  2 Word.word)))) \<and> (((((subrange_vec_dec v__9 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b0111011 ::  7 Word.word))))))))))) \<bind> ((\<lambda> (w__19 :: bool) . 
               if w__19 then
                 (let (rs2 ::  5 Word.word) = ((subrange_vec_dec v__9 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
                 (let (rs1 ::  5 Word.word) = ((subrange_vec_dec v__9 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
                 (let (rd ::  5 Word.word) = ((subrange_vec_dec v__9 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
                 (let (mappingpatterns_780 ::  1 Word.word) =
                   ((subrange_vec_dec v__9 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
                 bool_not_bits_backwards mappingpatterns_780 \<bind> ((\<lambda> s . 
                 return (DIVW (rs2, rs1, rd, s))))))))
               else
                 and_boolM
                   ((let (mappingpatterns_790 ::  1 Word.word) =
                     ((subrange_vec_dec v__9 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
                   if ((bool_not_bits_backwards_matches mappingpatterns_790)) then
                     bool_not_bits_backwards mappingpatterns_790 \<bind> ((\<lambda> s . 
                     return ((((( 64 :: int)::ii) = (( 64 :: int)::ii))))))
                   else return False))
                   (return ((((((((subrange_vec_dec v__9 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = ( 0b0000001 ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__9 (( 14 :: int)::ii) (( 13 :: int)::ii)  ::  2 Word.word)) = ( 0b11 ::  2 Word.word)))) \<and> (((((subrange_vec_dec v__9 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b0111011 ::  7 Word.word))))))))))) \<bind> ((\<lambda> (w__21 :: bool) . 
                 if w__21 then
                   (let (rs2 ::  5 Word.word) = ((subrange_vec_dec v__9 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
                   (let (rs1 ::  5 Word.word) = ((subrange_vec_dec v__9 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
                   (let (rd ::  5 Word.word) = ((subrange_vec_dec v__9 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
                   (let (mappingpatterns_790 ::  1 Word.word) =
                     ((subrange_vec_dec v__9 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
                   bool_not_bits_backwards mappingpatterns_790 \<bind> ((\<lambda> s . 
                   return (REMW (rs2, rs1, rd, s))))))))
                 else
                   and_boolM
                     ((let (mappingpatterns_810 ::  2 Word.word) =
                       ((subrange_vec_dec v__9 (( 13 :: int)::ii) (( 12 :: int)::ii)  ::  2 Word.word)) in
                     (let (mappingpatterns_800 ::  1 Word.word) =
                       ((subrange_vec_dec v__9 (( 14 :: int)::ii) (( 14 :: int)::ii)  ::  1 Word.word)) in
                     if ((encdec_csrop_backwards_matches mappingpatterns_810)) then
                       encdec_csrop_backwards mappingpatterns_810 \<bind> ((\<lambda> op1 . 
                       return ((bool_bits_backwards_matches mappingpatterns_800))))
                     else return False)))
                     (return (((((subrange_vec_dec v__9 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b1110011 ::  7 Word.word))))) \<bind> ((\<lambda> (w__23 :: bool) . 
                   if w__23 then
                     (let (csr ::  12 Word.word) = ((subrange_vec_dec v__9 (( 31 :: int)::ii) (( 20 :: int)::ii)  ::  12 Word.word)) in
                     (let (rs1 ::  5 Word.word) = ((subrange_vec_dec v__9 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
                     (let (rd ::  5 Word.word) = ((subrange_vec_dec v__9 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
                     (let (csr ::  12 Word.word) = ((subrange_vec_dec v__9 (( 31 :: int)::ii) (( 20 :: int)::ii)  ::  12 Word.word)) in
                     (let (mappingpatterns_810 ::  2 Word.word) =
                       ((subrange_vec_dec v__9 (( 13 :: int)::ii) (( 12 :: int)::ii)  ::  2 Word.word)) in
                     (let (mappingpatterns_800 ::  1 Word.word) =
                       ((subrange_vec_dec v__9 (( 14 :: int)::ii) (( 14 :: int)::ii)  ::  1 Word.word)) in
                     encdec_csrop_backwards mappingpatterns_810 \<bind> ((\<lambda> op1 . 
                     bool_bits_backwards mappingpatterns_800 \<bind> ((\<lambda> is_imm . 
                     return (CSR (csr, rs1, rd, is_imm, op1))))))))))))
                   else if (((v__9 = ( 0x00200073 ::  32 Word.word)))) then return (URET () )
                   else if (((((let (fm :: 4 bits) =
                                 ((subrange_vec_dec v__9 (( 31 :: int)::ii) (( 28 :: int)::ii)  ::  4 Word.word)) in
                               (let (rs :: regidx) =
                                 ((subrange_vec_dec v__9 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
                               (let (rd :: regidx) =
                                 ((subrange_vec_dec v__9 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
                               (let (fm :: 4 bits) =
                                 ((subrange_vec_dec v__9 (( 31 :: int)::ii) (( 28 :: int)::ii)  ::  4 Word.word)) in
                               (((((((fm \<noteq> ( 0x0 ::  4 Word.word)))) \<and> (((fm \<noteq> ( 0x8 ::  4 Word.word))))))) \<or> ((((((rs \<noteq> ( 0b00000 ::  5 Word.word)))) \<or> (((rd \<noteq> ( 0b00000 ::  5 Word.word))))))))))))) \<and> ((((((((subrange_vec_dec v__9 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = ( 0b000 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__9 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b0001111 ::  7 Word.word)))))))))) then
                     (let (fm :: 4 bits) = ((subrange_vec_dec v__9 (( 31 :: int)::ii) (( 28 :: int)::ii)  ::  4 Word.word)) in
                     (let (succ :: 4 bits) = ((subrange_vec_dec v__9 (( 23 :: int)::ii) (( 20 :: int)::ii)  ::  4 Word.word)) in
                     (let (rs :: regidx) = ((subrange_vec_dec v__9 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
                     (let (rd :: regidx) = ((subrange_vec_dec v__9 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
                     (let (pred :: 4 bits) = ((subrange_vec_dec v__9 (( 27 :: int)::ii) (( 24 :: int)::ii)  ::  4 Word.word)) in
                     (let (fm :: 4 bits) = ((subrange_vec_dec v__9 (( 31 :: int)::ii) (( 28 :: int)::ii)  ::  4 Word.word)) in
                     return (FENCE_RESERVED (fm, pred, succ, rs, rd))))))))
                   else if (((((let (imm :: 12 bits) =
                                 ((subrange_vec_dec v__9 (( 31 :: int)::ii) (( 20 :: int)::ii)  ::  12 Word.word)) in
                               (let (rs :: regidx) =
                                 ((subrange_vec_dec v__9 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
                               (let (rd :: regidx) =
                                 ((subrange_vec_dec v__9 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
                               (let (imm :: 12 bits) =
                                 ((subrange_vec_dec v__9 (( 31 :: int)::ii) (( 20 :: int)::ii)  ::  12 Word.word)) in
                               ((((imm \<noteq> ( 0x000 ::  12 Word.word)))) \<or> ((((((rs \<noteq> zreg))) \<or> (((rd \<noteq> zreg)))))))))))) \<and> ((((((((subrange_vec_dec v__9 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = ( 0b001 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__9 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b0001111 ::  7 Word.word)))))))))) then
                     (let (imm :: 12 bits) = ((subrange_vec_dec v__9 (( 31 :: int)::ii) (( 20 :: int)::ii)  ::  12 Word.word)) in
                     (let (rs :: regidx) = ((subrange_vec_dec v__9 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
                     (let (rd :: regidx) = ((subrange_vec_dec v__9 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
                     (let (imm :: 12 bits) = ((subrange_vec_dec v__9 (( 31 :: int)::ii) (( 20 :: int)::ii)  ::  12 Word.word)) in
                     return (FENCEI_RESERVED (imm, rs, rd))))))
                   else
                     and_boolM ((is_RV32F_or_RV64F () ))
                       (return ((((((((subrange_vec_dec v__9 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = ( 0b010 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__9 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b0000111 ::  7 Word.word)))))))) \<bind> ((\<lambda> (w__25 :: bool) . 
                     if w__25 then
                       (let (imm ::  12 Word.word) =
                         ((subrange_vec_dec v__9 (( 31 :: int)::ii) (( 20 :: int)::ii)  ::  12 Word.word)) in
                       (let (rs1 ::  5 Word.word) = ((subrange_vec_dec v__9 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
                       (let (rd ::  5 Word.word) = ((subrange_vec_dec v__9 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
                       (let (imm ::  12 Word.word) =
                         ((subrange_vec_dec v__9 (( 31 :: int)::ii) (( 20 :: int)::ii)  ::  12 Word.word)) in
                       return (LOAD_FP (imm, rs1, rd, WORD))))))
                     else
                       and_boolM ((is_RV32D_or_RV64D () ))
                         (return ((((((((subrange_vec_dec v__9 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = ( 0b011 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__9 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b0000111 ::  7 Word.word)))))))) \<bind> ((\<lambda> (w__27 :: bool) . 
                       if w__27 then
                         (let (imm ::  12 Word.word) =
                           ((subrange_vec_dec v__9 (( 31 :: int)::ii) (( 20 :: int)::ii)  ::  12 Word.word)) in
                         (let (rs1 ::  5 Word.word) =
                           ((subrange_vec_dec v__9 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
                         (let (rd ::  5 Word.word) = ((subrange_vec_dec v__9 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
                         (let (imm ::  12 Word.word) =
                           ((subrange_vec_dec v__9 (( 31 :: int)::ii) (( 20 :: int)::ii)  ::  12 Word.word)) in
                         return (LOAD_FP (imm, rs1, rd, DOUBLE))))))
                       else
                         and_boolM ((is_RV32F_or_RV64F () ))
                           (return ((((((((subrange_vec_dec v__9 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = ( 0b010 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__9 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b0100111 ::  7 Word.word)))))))) \<bind> ((\<lambda> (w__29 :: bool) . 
                         if w__29 then
                           (let (imm7 :: 7 bits) =
                             ((subrange_vec_dec v__9 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) in
                           (let (rs2 ::  5 Word.word) =
                             ((subrange_vec_dec v__9 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
                           (let (rs1 ::  5 Word.word) =
                             ((subrange_vec_dec v__9 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
                           (let (imm7 :: 7 bits) =
                             ((subrange_vec_dec v__9 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) in
                           (let (imm5 :: 5 bits) =
                             ((subrange_vec_dec v__9 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
                           return (STORE_FP ((concat_vec imm7 imm5  ::  12 Word.word), rs2, rs1, WORD)))))))
                         else
                           and_boolM ((is_RV32D_or_RV64D () ))
                             (return ((((((((subrange_vec_dec v__9 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = ( 0b011 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__9 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b0100111 ::  7 Word.word)))))))) \<bind> ((\<lambda> (w__31 :: bool) . 
                           if w__31 then
                             (let (imm7 :: 7 bits) =
                               ((subrange_vec_dec v__9 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) in
                             (let (rs2 ::  5 Word.word) =
                               ((subrange_vec_dec v__9 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
                             (let (rs1 ::  5 Word.word) =
                               ((subrange_vec_dec v__9 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
                             (let (imm7 :: 7 bits) =
                               ((subrange_vec_dec v__9 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) in
                             (let (imm5 :: 5 bits) =
                               ((subrange_vec_dec v__9 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
                             return (STORE_FP ((concat_vec imm7 imm5  ::  12 Word.word),
                                               rs2,
                                               rs1,
                                               DOUBLE)))))))
                           else
                             and_boolM
                               ((let (mappingpatterns_820 ::  3 Word.word) =
                                 ((subrange_vec_dec v__9 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) in
                               if ((encdec_rounding_mode_backwards_matches mappingpatterns_820))
                               then
                                 encdec_rounding_mode_backwards mappingpatterns_820 \<bind> ((\<lambda> rm . 
                                 is_RV32F_or_RV64F () ))
                               else return False))
                               (return ((((((((subrange_vec_dec v__9 (( 26 :: int)::ii) (( 25 :: int)::ii)  ::  2 Word.word)) = ( 0b00 ::  2 Word.word)))) \<and> (((((subrange_vec_dec v__9 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b1000011 ::  7 Word.word)))))))) \<bind> ((\<lambda> (w__34 :: bool) . 
                             if w__34 then
                               (let (rs3 ::  5 Word.word) =
                                 ((subrange_vec_dec v__9 (( 31 :: int)::ii) (( 27 :: int)::ii)  ::  5 Word.word)) in
                               (let (rs3 ::  5 Word.word) =
                                 ((subrange_vec_dec v__9 (( 31 :: int)::ii) (( 27 :: int)::ii)  ::  5 Word.word)) in
                               (let (rs2 ::  5 Word.word) =
                                 ((subrange_vec_dec v__9 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
                               (let (rs1 ::  5 Word.word) =
                                 ((subrange_vec_dec v__9 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
                               (let (rd ::  5 Word.word) =
                                 ((subrange_vec_dec v__9 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
                               (let (mappingpatterns_820 ::  3 Word.word) =
                                 ((subrange_vec_dec v__9 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) in
                               encdec_rounding_mode_backwards mappingpatterns_820 \<bind> ((\<lambda> rm . 
                               return (F_MADD_TYPE_S (rs3, rs2, rs1, rm, rd, FMADD_S))))))))))
                             else
                               and_boolM
                                 ((let (mappingpatterns_830 ::  3 Word.word) =
                                   ((subrange_vec_dec v__9 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) in
                                 if ((encdec_rounding_mode_backwards_matches mappingpatterns_830))
                                 then
                                   encdec_rounding_mode_backwards mappingpatterns_830 \<bind> ((\<lambda> rm . 
                                   is_RV32F_or_RV64F () ))
                                 else return False))
                                 (return ((((((((subrange_vec_dec v__9 (( 26 :: int)::ii) (( 25 :: int)::ii)
                                                    ::  2 Word.word)) = ( 0b00 ::  2 Word.word)))) \<and> (((((subrange_vec_dec v__9 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b1000111 ::  7 Word.word)))))))) \<bind> ((\<lambda> (w__37 :: bool) . 
                               if w__37 then
                                 (let (rs3 ::  5 Word.word) =
                                   ((subrange_vec_dec v__9 (( 31 :: int)::ii) (( 27 :: int)::ii)  ::  5 Word.word)) in
                                 (let (rs3 ::  5 Word.word) =
                                   ((subrange_vec_dec v__9 (( 31 :: int)::ii) (( 27 :: int)::ii)  ::  5 Word.word)) in
                                 (let (rs2 ::  5 Word.word) =
                                   ((subrange_vec_dec v__9 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
                                 (let (rs1 ::  5 Word.word) =
                                   ((subrange_vec_dec v__9 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
                                 (let (rd ::  5 Word.word) =
                                   ((subrange_vec_dec v__9 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
                                 (let (mappingpatterns_830 ::  3 Word.word) =
                                   ((subrange_vec_dec v__9 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) in
                                 encdec_rounding_mode_backwards mappingpatterns_830 \<bind> ((\<lambda> rm . 
                                 return (F_MADD_TYPE_S (rs3, rs2, rs1, rm, rd, FMSUB_S))))))))))
                               else
                                 and_boolM
                                   ((let (mappingpatterns_840 ::  3 Word.word) =
                                     ((subrange_vec_dec v__9 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) in
                                   if ((encdec_rounding_mode_backwards_matches mappingpatterns_840))
                                   then
                                     encdec_rounding_mode_backwards mappingpatterns_840 \<bind> ((\<lambda> rm . 
                                     is_RV32F_or_RV64F () ))
                                   else return False))
                                   (return ((((((((subrange_vec_dec v__9 (( 26 :: int)::ii) (( 25 :: int)::ii)
                                                      ::  2 Word.word)) = ( 0b00 ::  2 Word.word)))) \<and> (((((subrange_vec_dec v__9 (( 6 :: int)::ii) (( 0 :: int)::ii)
                                                      ::  7 Word.word)) = ( 0b1001011 ::  7 Word.word)))))))) \<bind> ((\<lambda> (w__40 ::
                                   bool) . 
                                 if w__40 then
                                   (let (rs3 ::  5 Word.word) =
                                     ((subrange_vec_dec v__9 (( 31 :: int)::ii) (( 27 :: int)::ii)  ::  5 Word.word)) in
                                   (let (rs3 ::  5 Word.word) =
                                     ((subrange_vec_dec v__9 (( 31 :: int)::ii) (( 27 :: int)::ii)  ::  5 Word.word)) in
                                   (let (rs2 ::  5 Word.word) =
                                     ((subrange_vec_dec v__9 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
                                   (let (rs1 ::  5 Word.word) =
                                     ((subrange_vec_dec v__9 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
                                   (let (rd ::  5 Word.word) =
                                     ((subrange_vec_dec v__9 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
                                   (let (mappingpatterns_840 ::  3 Word.word) =
                                     ((subrange_vec_dec v__9 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) in
                                   encdec_rounding_mode_backwards mappingpatterns_840 \<bind> ((\<lambda> rm . 
                                   return (F_MADD_TYPE_S (rs3, rs2, rs1, rm, rd, FNMSUB_S))))))))))
                                 else
                                   and_boolM
                                     ((let (mappingpatterns_850 ::  3 Word.word) =
                                       ((subrange_vec_dec v__9 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) in
                                     if ((encdec_rounding_mode_backwards_matches
                                            mappingpatterns_850)) then
                                       encdec_rounding_mode_backwards mappingpatterns_850 \<bind> ((\<lambda> rm . 
                                       is_RV32F_or_RV64F () ))
                                     else return False))
                                     (return ((((((((subrange_vec_dec v__9 (( 26 :: int)::ii) (( 25 :: int)::ii)
                                                        ::  2 Word.word)) = ( 0b00 ::  2 Word.word)))) \<and> (((((subrange_vec_dec v__9 (( 6 :: int)::ii) (( 0 :: int)::ii)
                                                        ::  7 Word.word)) = ( 0b1001111 ::  7 Word.word)))))))) \<bind> ((\<lambda> (w__43 ::
                                     bool) . 
                                   if w__43 then
                                     (let (rs3 ::  5 Word.word) =
                                       ((subrange_vec_dec v__9 (( 31 :: int)::ii) (( 27 :: int)::ii)  ::  5 Word.word)) in
                                     (let (rs3 ::  5 Word.word) =
                                       ((subrange_vec_dec v__9 (( 31 :: int)::ii) (( 27 :: int)::ii)  ::  5 Word.word)) in
                                     (let (rs2 ::  5 Word.word) =
                                       ((subrange_vec_dec v__9 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
                                     (let (rs1 ::  5 Word.word) =
                                       ((subrange_vec_dec v__9 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
                                     (let (rd ::  5 Word.word) =
                                       ((subrange_vec_dec v__9 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
                                     (let (mappingpatterns_850 ::  3 Word.word) =
                                       ((subrange_vec_dec v__9 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) in
                                     encdec_rounding_mode_backwards mappingpatterns_850 \<bind> ((\<lambda> rm . 
                                     return (F_MADD_TYPE_S (rs3, rs2, rs1, rm, rd, FNMADD_S))))))))))
                                   else
                                     and_boolM
                                       ((let (mappingpatterns_860 ::  3 Word.word) =
                                         ((subrange_vec_dec v__9 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) in
                                       if ((encdec_rounding_mode_backwards_matches
                                              mappingpatterns_860)) then
                                         encdec_rounding_mode_backwards mappingpatterns_860 \<bind> ((\<lambda> rm . 
                                         is_RV32F_or_RV64F () ))
                                       else return False))
                                       (return ((((((((subrange_vec_dec v__9 (( 31 :: int)::ii) (( 25 :: int)::ii)
                                                          ::  7 Word.word)) = ( 0b0000000 ::  7 Word.word)))) \<and> (((((subrange_vec_dec v__9 (( 6 :: int)::ii) (( 0 :: int)::ii)
                                                          ::  7 Word.word)) = ( 0b1010011 ::  7 Word.word)))))))) \<bind> ((\<lambda> (w__46 ::
                                       bool) . 
                                     if w__46 then
                                       (let (rs2 ::  5 Word.word) =
                                         ((subrange_vec_dec v__9 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
                                       (let (rs1 ::  5 Word.word) =
                                         ((subrange_vec_dec v__9 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
                                       (let (rd ::  5 Word.word) =
                                         ((subrange_vec_dec v__9 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
                                       (let (mappingpatterns_860 ::  3 Word.word) =
                                         ((subrange_vec_dec v__9 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) in
                                       encdec_rounding_mode_backwards mappingpatterns_860 \<bind> ((\<lambda> rm . 
                                       return (F_BIN_RM_TYPE_S (rs2, rs1, rm, rd, FADD_S))))))))
                                     else
                                       and_boolM
                                         ((let (mappingpatterns_870 ::  3 Word.word) =
                                           ((subrange_vec_dec v__9 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) in
                                         if ((encdec_rounding_mode_backwards_matches
                                                mappingpatterns_870)) then
                                           encdec_rounding_mode_backwards mappingpatterns_870 \<bind> ((\<lambda> rm . 
                                           is_RV32F_or_RV64F () ))
                                         else return False))
                                         (return ((((((((subrange_vec_dec v__9 (( 31 :: int)::ii) (( 25 :: int)::ii)
                                                            ::  7 Word.word)) = ( 0b0000100 ::  7 Word.word)))) \<and> (((((subrange_vec_dec v__9 (( 6 :: int)::ii) (( 0 :: int)::ii)
                                                            ::  7 Word.word)) = ( 0b1010011 ::  7 Word.word)))))))) \<bind> ((\<lambda> (w__49 ::
                                         bool) . 
                                       if w__49 then
                                         (let (rs2 ::  5 Word.word) =
                                           ((subrange_vec_dec v__9 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
                                         (let (rs1 ::  5 Word.word) =
                                           ((subrange_vec_dec v__9 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
                                         (let (rd ::  5 Word.word) =
                                           ((subrange_vec_dec v__9 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
                                         (let (mappingpatterns_870 ::  3 Word.word) =
                                           ((subrange_vec_dec v__9 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) in
                                         encdec_rounding_mode_backwards mappingpatterns_870 \<bind> ((\<lambda> rm . 
                                         return (F_BIN_RM_TYPE_S (rs2, rs1, rm, rd, FSUB_S))))))))
                                       else
                                         and_boolM
                                           ((let (mappingpatterns_880 ::  3 Word.word) =
                                             ((subrange_vec_dec v__9 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) in
                                           if ((encdec_rounding_mode_backwards_matches
                                                  mappingpatterns_880)) then
                                             encdec_rounding_mode_backwards mappingpatterns_880 \<bind> ((\<lambda> rm . 
                                             is_RV32F_or_RV64F () ))
                                           else return False))
                                           (return ((((((((subrange_vec_dec v__9 (( 31 :: int)::ii) (( 25 :: int)::ii)
                                                              ::  7 Word.word)) = ( 0b0001000 ::  7 Word.word)))) \<and> (((((subrange_vec_dec v__9 (( 6 :: int)::ii) (( 0 :: int)::ii)
                                                              ::  7 Word.word)) = ( 0b1010011 ::  7 Word.word)))))))) \<bind> ((\<lambda> (w__52 ::
                                           bool) . 
                                         if w__52 then
                                           (let (rs2 ::  5 Word.word) =
                                             ((subrange_vec_dec v__9 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
                                           (let (rs1 ::  5 Word.word) =
                                             ((subrange_vec_dec v__9 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
                                           (let (rd ::  5 Word.word) =
                                             ((subrange_vec_dec v__9 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
                                           (let (mappingpatterns_880 ::  3 Word.word) =
                                             ((subrange_vec_dec v__9 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) in
                                           encdec_rounding_mode_backwards mappingpatterns_880 \<bind> ((\<lambda> rm . 
                                           return (F_BIN_RM_TYPE_S (rs2, rs1, rm, rd, FMUL_S))))))))
                                         else
                                           and_boolM
                                             ((let (mappingpatterns_890 ::  3 Word.word) =
                                               ((subrange_vec_dec v__9 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) in
                                             if ((encdec_rounding_mode_backwards_matches
                                                    mappingpatterns_890)) then
                                               encdec_rounding_mode_backwards mappingpatterns_890 \<bind> ((\<lambda> rm . 
                                               is_RV32F_or_RV64F () ))
                                             else return False))
                                             (return ((((((((subrange_vec_dec v__9 (( 31 :: int)::ii) (( 25 :: int)::ii)
                                                                ::  7 Word.word)) = ( 0b0001100 ::  7 Word.word)))) \<and> (((((subrange_vec_dec v__9 (( 6 :: int)::ii) (( 0 :: int)::ii)
                                                                ::  7 Word.word)) = ( 0b1010011 ::  7 Word.word)))))))) \<bind> ((\<lambda> (w__55 ::
                                             bool) . 
                                           if w__55 then
                                             (let (rs2 ::  5 Word.word) =
                                               ((subrange_vec_dec v__9 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
                                             (let (rs1 ::  5 Word.word) =
                                               ((subrange_vec_dec v__9 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
                                             (let (rd ::  5 Word.word) =
                                               ((subrange_vec_dec v__9 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
                                             (let (mappingpatterns_890 ::  3 Word.word) =
                                               ((subrange_vec_dec v__9 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) in
                                             encdec_rounding_mode_backwards mappingpatterns_890 \<bind> ((\<lambda> rm . 
                                             return (F_BIN_RM_TYPE_S (rs2, rs1, rm, rd, FDIV_S))))))))
                                           else
                                             and_boolM
                                               ((let (mappingpatterns_900 ::  3 Word.word) =
                                                 ((subrange_vec_dec v__9 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) in
                                               if ((encdec_rounding_mode_backwards_matches
                                                      mappingpatterns_900)) then
                                                 encdec_rounding_mode_backwards mappingpatterns_900 \<bind> ((\<lambda> rm . 
                                                 is_RV32F_or_RV64F () ))
                                               else return False))
                                               (return ((((((((subrange_vec_dec v__9 (( 31 :: int)::ii)
                                                                   (( 20 :: int)::ii)
                                                                  ::  12 Word.word)) = ( 0x580 ::  12 Word.word)))) \<and> (((((subrange_vec_dec v__9 (( 6 :: int)::ii) (( 0 :: int)::ii)
                                                                  ::  7 Word.word)) = ( 0b1010011 ::  7 Word.word)))))))) \<bind> ((\<lambda> (w__58 ::
                                               bool) . 
                                             if w__58 then
                                               (let (rs1 ::  5 Word.word) =
                                                 ((subrange_vec_dec v__9 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
                                               (let (rd ::  5 Word.word) =
                                                 ((subrange_vec_dec v__9 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
                                               (let (mappingpatterns_900 ::  3 Word.word) =
                                                 ((subrange_vec_dec v__9 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) in
                                               encdec_rounding_mode_backwards mappingpatterns_900 \<bind> ((\<lambda> rm . 
                                               return (F_UN_RM_TYPE_S (rs1, rm, rd, FSQRT_S)))))))
                                             else
                                               and_boolM
                                                 ((let (mappingpatterns_910 ::  3 Word.word) =
                                                   ((subrange_vec_dec v__9 (( 14 :: int)::ii) (( 12 :: int)::ii)
                                                     ::  3 Word.word)) in
                                                 if ((encdec_rounding_mode_backwards_matches
                                                        mappingpatterns_910)) then
                                                   encdec_rounding_mode_backwards
                                                     mappingpatterns_910 \<bind> ((\<lambda> rm . 
                                                   is_RV32F_or_RV64F () ))
                                                 else return False))
                                                 (return ((((((((subrange_vec_dec v__9 (( 31 :: int)::ii)
                                                                     (( 20 :: int)::ii)
                                                                    ::  12 Word.word)) = ( 0xC00 ::  12 Word.word)))) \<and> (((((subrange_vec_dec v__9 (( 6 :: int)::ii)
                                                                     (( 0 :: int)::ii)
                                                                    ::  7 Word.word)) = ( 0b1010011 ::  7 Word.word)))))))) \<bind> ((\<lambda> (w__61 ::
                                                 bool) . 
                                               if w__61 then
                                                 (let (rs1 ::  5 Word.word) =
                                                   ((subrange_vec_dec v__9 (( 19 :: int)::ii) (( 15 :: int)::ii)
                                                     ::  5 Word.word)) in
                                                 (let (rd ::  5 Word.word) =
                                                   ((subrange_vec_dec v__9 (( 11 :: int)::ii) (( 7 :: int)::ii)
                                                     ::  5 Word.word)) in
                                                 (let (mappingpatterns_910 ::  3 Word.word) =
                                                   ((subrange_vec_dec v__9 (( 14 :: int)::ii) (( 12 :: int)::ii)
                                                     ::  3 Word.word)) in
                                                 encdec_rounding_mode_backwards mappingpatterns_910 \<bind> ((\<lambda> rm . 
                                                 return (F_UN_RM_TYPE_S (rs1, rm, rd, FCVT_W_S)))))))
                                               else
                                                 and_boolM
                                                   ((let (mappingpatterns_920 ::  3 Word.word) =
                                                     ((subrange_vec_dec v__9 (( 14 :: int)::ii) (( 12 :: int)::ii)
                                                       ::  3 Word.word)) in
                                                   if ((encdec_rounding_mode_backwards_matches
                                                          mappingpatterns_920)) then
                                                     encdec_rounding_mode_backwards
                                                       mappingpatterns_920 \<bind> ((\<lambda> rm . 
                                                     is_RV32F_or_RV64F () ))
                                                   else return False))
                                                   (return ((((((((subrange_vec_dec v__9 (( 31 :: int)::ii)
                                                                       (( 20 :: int)::ii)
                                                                      ::  12 Word.word)) = ( 0xC01 ::  12 Word.word)))) \<and> (((((subrange_vec_dec v__9 (( 6 :: int)::ii)
                                                                       (( 0 :: int)::ii)
                                                                      ::  7 Word.word)) = ( 0b1010011 ::  7 Word.word)))))))) \<bind> ((\<lambda> (w__64 ::
                                                   bool) . 
                                                 if w__64 then
                                                   (let (rs1 ::  5 Word.word) =
                                                     ((subrange_vec_dec v__9 (( 19 :: int)::ii) (( 15 :: int)::ii)
                                                       ::  5 Word.word)) in
                                                   (let (rd ::  5 Word.word) =
                                                     ((subrange_vec_dec v__9 (( 11 :: int)::ii) (( 7 :: int)::ii)
                                                       ::  5 Word.word)) in
                                                   (let (mappingpatterns_920 ::  3 Word.word) =
                                                     ((subrange_vec_dec v__9 (( 14 :: int)::ii) (( 12 :: int)::ii)
                                                       ::  3 Word.word)) in
                                                   encdec_rounding_mode_backwards
                                                     mappingpatterns_920 \<bind> ((\<lambda> rm . 
                                                   return (F_UN_RM_TYPE_S (rs1, rm, rd, FCVT_WU_S)))))))
                                                 else
                                                   and_boolM
                                                     ((let (mappingpatterns_930 ::  3 Word.word) =
                                                       ((subrange_vec_dec v__9 (( 14 :: int)::ii) (( 12 :: int)::ii)
                                                         ::  3 Word.word)) in
                                                     if ((encdec_rounding_mode_backwards_matches
                                                            mappingpatterns_930)) then
                                                       encdec_rounding_mode_backwards
                                                         mappingpatterns_930 \<bind> ((\<lambda> rm . 
                                                       is_RV32F_or_RV64F () ))
                                                     else return False))
                                                     (return ((((((((subrange_vec_dec v__9 (( 31 :: int)::ii)
                                                                         (( 20 :: int)::ii)
                                                                        ::  12 Word.word)) = ( 0xD00 ::  12 Word.word)))) \<and> (((((subrange_vec_dec v__9 (( 6 :: int)::ii)
                                                                         (( 0 :: int)::ii)
                                                                        ::  7 Word.word)) = ( 0b1010011 ::  7 Word.word)))))))) \<bind> ((\<lambda> (w__67 ::
                                                     bool) . 
                                                   if w__67 then
                                                     (let (rs1 ::  5 Word.word) =
                                                       ((subrange_vec_dec v__9 (( 19 :: int)::ii) (( 15 :: int)::ii)
                                                         ::  5 Word.word)) in
                                                     (let (rd ::  5 Word.word) =
                                                       ((subrange_vec_dec v__9 (( 11 :: int)::ii) (( 7 :: int)::ii)
                                                         ::  5 Word.word)) in
                                                     (let (mappingpatterns_930 ::  3 Word.word) =
                                                       ((subrange_vec_dec v__9 (( 14 :: int)::ii) (( 12 :: int)::ii)
                                                         ::  3 Word.word)) in
                                                     encdec_rounding_mode_backwards
                                                       mappingpatterns_930 \<bind> ((\<lambda> rm . 
                                                     return (F_UN_RM_TYPE_S (rs1, rm, rd, FCVT_S_W)))))))
                                                   else
                                                     and_boolM
                                                       ((let (mappingpatterns_940 ::  3 Word.word) =
                                                         ((subrange_vec_dec v__9 (( 14 :: int)::ii) (( 12 :: int)::ii)
                                                           ::  3 Word.word)) in
                                                       if ((encdec_rounding_mode_backwards_matches
                                                              mappingpatterns_940)) then
                                                         encdec_rounding_mode_backwards
                                                           mappingpatterns_940 \<bind> ((\<lambda> rm . 
                                                         is_RV32F_or_RV64F () ))
                                                       else return False))
                                                       (return ((((((((subrange_vec_dec v__9
                                                                           (( 31 :: int)::ii) (( 20 :: int)::ii)
                                                                          ::  12 Word.word)) = ( 0xD01 ::  12 Word.word)))) \<and> (((((subrange_vec_dec v__9
                                                                           (( 6 :: int)::ii) (( 0 :: int)::ii)
                                                                          ::  7 Word.word)) = ( 0b1010011 ::  7 Word.word)))))))) \<bind> ((\<lambda> (w__70 ::
                                                       bool) . 
                                                     if w__70 then
                                                       (let (rs1 ::  5 Word.word) =
                                                         ((subrange_vec_dec v__9 (( 19 :: int)::ii) (( 15 :: int)::ii)
                                                           ::  5 Word.word)) in
                                                       (let (rd ::  5 Word.word) =
                                                         ((subrange_vec_dec v__9 (( 11 :: int)::ii) (( 7 :: int)::ii)
                                                           ::  5 Word.word)) in
                                                       (let (mappingpatterns_940 ::  3 Word.word) =
                                                         ((subrange_vec_dec v__9 (( 14 :: int)::ii) (( 12 :: int)::ii)
                                                           ::  3 Word.word)) in
                                                       encdec_rounding_mode_backwards
                                                         mappingpatterns_940 \<bind> ((\<lambda> rm . 
                                                       return (F_UN_RM_TYPE_S (rs1,
                                                                               rm,
                                                                               rd,
                                                                               FCVT_S_WU)))))))
                                                     else
                                                       and_boolM
                                                         ((let (mappingpatterns_950 ::  3 Word.word) =
                                                           ((subrange_vec_dec v__9 (( 14 :: int)::ii) (( 12 :: int)::ii)
                                                             ::  3 Word.word)) in
                                                         if ((encdec_rounding_mode_backwards_matches
                                                                mappingpatterns_950)) then
                                                           encdec_rounding_mode_backwards
                                                             mappingpatterns_950 \<bind> ((\<lambda> rm . 
                                                           is_RV64F () ))
                                                         else return False))
                                                         (return ((((((((subrange_vec_dec v__9
                                                                             (( 31 :: int)::ii) (( 20 :: int)::ii)
                                                                            ::  12 Word.word)) = ( 0xC02 ::  12 Word.word)))) \<and> (((((subrange_vec_dec v__9
                                                                             (( 6 :: int)::ii) (( 0 :: int)::ii)
                                                                            ::  7 Word.word)) = ( 0b1010011 ::  7 Word.word)))))))) \<bind> ((\<lambda> (w__73 ::
                                                         bool) . 
                                                       if w__73 then
                                                         (let (rs1 ::  5 Word.word) =
                                                           ((subrange_vec_dec v__9 (( 19 :: int)::ii) (( 15 :: int)::ii)
                                                             ::  5 Word.word)) in
                                                         (let (rd ::  5 Word.word) =
                                                           ((subrange_vec_dec v__9 (( 11 :: int)::ii) (( 7 :: int)::ii)
                                                             ::  5 Word.word)) in
                                                         (let (mappingpatterns_950 ::  3 Word.word) =
                                                           ((subrange_vec_dec v__9 (( 14 :: int)::ii) (( 12 :: int)::ii)
                                                             ::  3 Word.word)) in
                                                         encdec_rounding_mode_backwards
                                                           mappingpatterns_950 \<bind> ((\<lambda> rm . 
                                                         return (F_UN_RM_TYPE_S (rs1,
                                                                                 rm,
                                                                                 rd,
                                                                                 FCVT_L_S)))))))
                                                       else
                                                         and_boolM
                                                           ((let (mappingpatterns_960 ::  3 Word.word) =
                                                             ((subrange_vec_dec v__9 (( 14 :: int)::ii) (( 12 :: int)::ii)
                                                               ::  3 Word.word)) in
                                                           if ((encdec_rounding_mode_backwards_matches
                                                                  mappingpatterns_960)) then
                                                             encdec_rounding_mode_backwards
                                                               mappingpatterns_960 \<bind> ((\<lambda> rm . 
                                                             is_RV64F () ))
                                                           else return False))
                                                           (return ((((((((subrange_vec_dec v__9
                                                                               (( 31 :: int)::ii) (( 20 :: int)::ii)
                                                                              ::  12 Word.word)) = ( 0xC03 ::  12 Word.word)))) \<and> (((((subrange_vec_dec v__9
                                                                               (( 6 :: int)::ii) (( 0 :: int)::ii)
                                                                              ::  7 Word.word)) = ( 0b1010011 ::  7 Word.word)))))))) \<bind> ((\<lambda> (w__76 ::
                                                           bool) . 
                                                         if w__76 then
                                                           (let (rs1 ::  5 Word.word) =
                                                             ((subrange_vec_dec v__9 (( 19 :: int)::ii) (( 15 :: int)::ii)
                                                               ::  5 Word.word)) in
                                                           (let (rd ::  5 Word.word) =
                                                             ((subrange_vec_dec v__9 (( 11 :: int)::ii) (( 7 :: int)::ii)
                                                               ::  5 Word.word)) in
                                                           (let (mappingpatterns_960 ::  3 Word.word) =
                                                             ((subrange_vec_dec v__9 (( 14 :: int)::ii) (( 12 :: int)::ii)
                                                               ::  3 Word.word)) in
                                                           encdec_rounding_mode_backwards
                                                             mappingpatterns_960 \<bind> ((\<lambda> rm . 
                                                           return (F_UN_RM_TYPE_S (rs1,
                                                                                   rm,
                                                                                   rd,
                                                                                   FCVT_LU_S)))))))
                                                         else
                                                           and_boolM
                                                             ((let (mappingpatterns_970 ::  3 Word.word) =
                                                               ((subrange_vec_dec v__9 (( 14 :: int)::ii)
                                                                  (( 12 :: int)::ii)
                                                                 ::  3 Word.word)) in
                                                             if ((encdec_rounding_mode_backwards_matches
                                                                    mappingpatterns_970)) then
                                                               encdec_rounding_mode_backwards
                                                                 mappingpatterns_970 \<bind> ((\<lambda> rm . 
                                                               is_RV64F () ))
                                                             else return False))
                                                             (return ((((((((subrange_vec_dec v__9
                                                                                 (( 31 :: int)::ii) (( 20 :: int)::ii)
                                                                                ::  12 Word.word)) = ( 0xD02 ::  12 Word.word)))) \<and> (((((subrange_vec_dec v__9
                                                                                 (( 6 :: int)::ii) (( 0 :: int)::ii)
                                                                                ::  7 Word.word)) = ( 0b1010011 ::  7 Word.word)))))))) \<bind> ((\<lambda> (w__79 ::
                                                             bool) . 
                                                           if w__79 then
                                                             (let (rs1 ::  5 Word.word) =
                                                               ((subrange_vec_dec v__9 (( 19 :: int)::ii)
                                                                  (( 15 :: int)::ii)
                                                                 ::  5 Word.word)) in
                                                             (let (rd ::  5 Word.word) =
                                                               ((subrange_vec_dec v__9 (( 11 :: int)::ii) (( 7 :: int)::ii)
                                                                 ::  5 Word.word)) in
                                                             (let (mappingpatterns_970 ::  3 Word.word) =
                                                               ((subrange_vec_dec v__9 (( 14 :: int)::ii)
                                                                  (( 12 :: int)::ii)
                                                                 ::  3 Word.word)) in
                                                             encdec_rounding_mode_backwards
                                                               mappingpatterns_970 \<bind> ((\<lambda> rm . 
                                                             return (F_UN_RM_TYPE_S (rs1,
                                                                                     rm,
                                                                                     rd,
                                                                                     FCVT_S_L)))))))
                                                           else
                                                             and_boolM
                                                               ((let (mappingpatterns_980 ::
                                                                  3 Word.word) =
                                                                 ((subrange_vec_dec v__9 (( 14 :: int)::ii)
                                                                    (( 12 :: int)::ii)
                                                                   ::  3 Word.word)) in
                                                               if ((encdec_rounding_mode_backwards_matches
                                                                      mappingpatterns_980)) then
                                                                 encdec_rounding_mode_backwards
                                                                   mappingpatterns_980 \<bind> ((\<lambda> rm . 
                                                                 is_RV64F () ))
                                                               else return False))
                                                               (return ((((((((subrange_vec_dec
                                                                                   v__9 (( 31 :: int)::ii)
                                                                                   (( 20 :: int)::ii)
                                                                                  ::  12 Word.word)) = ( 0xD03 ::  12 Word.word)))) \<and> (((((subrange_vec_dec
                                                                                   v__9 (( 6 :: int)::ii)
                                                                                   (( 0 :: int)::ii)
                                                                                  ::  7 Word.word)) = ( 0b1010011 ::  7 Word.word)))))))) \<bind> ((\<lambda> (w__82 ::
                                                               bool) . 
                                                             if w__82 then
                                                               (let (rs1 ::  5 Word.word) =
                                                                 ((subrange_vec_dec v__9 (( 19 :: int)::ii)
                                                                    (( 15 :: int)::ii)
                                                                   ::  5 Word.word)) in
                                                               (let (rd ::  5 Word.word) =
                                                                 ((subrange_vec_dec v__9 (( 11 :: int)::ii)
                                                                    (( 7 :: int)::ii)
                                                                   ::  5 Word.word)) in
                                                               (let (mappingpatterns_980 ::  3 Word.word) =
                                                                 ((subrange_vec_dec v__9 (( 14 :: int)::ii)
                                                                    (( 12 :: int)::ii)
                                                                   ::  3 Word.word)) in
                                                               encdec_rounding_mode_backwards
                                                                 mappingpatterns_980 \<bind> ((\<lambda> rm . 
                                                               return (F_UN_RM_TYPE_S (rs1,
                                                                                       rm,
                                                                                       rd,
                                                                                       FCVT_S_LU)))))))
                                                             else
                                                               and_boolM ((is_RV32F_or_RV64F () ))
                                                                 (return ((((((((subrange_vec_dec
                                                                                     v__9 (( 31 :: int)::ii)
                                                                                     (( 25 :: int)::ii)
                                                                                    ::  7 Word.word)) = ( 0b0010000 ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec
                                                                                         v__9
                                                                                         (( 14 :: int)::ii)
                                                                                         (( 12 :: int)::ii)
                                                                                        ::  3 Word.word)) = ( 0b000 ::  3 Word.word)))) \<and> (((((subrange_vec_dec
                                                                                         v__9 (( 6 :: int)::ii)
                                                                                         (( 0 :: int)::ii)
                                                                                        ::  7 Word.word)) = ( 0b1010011 ::  7 Word.word))))))))))) \<bind> ((\<lambda> (w__84 ::
                                                                 bool) . 
                                                               if w__84 then
                                                                 (let (rs2 ::  5 Word.word) =
                                                                   ((subrange_vec_dec v__9 (( 24 :: int)::ii)
                                                                      (( 20 :: int)::ii)
                                                                     ::  5 Word.word)) in
                                                                 (let (rs1 ::  5 Word.word) =
                                                                   ((subrange_vec_dec v__9 (( 19 :: int)::ii)
                                                                      (( 15 :: int)::ii)
                                                                     ::  5 Word.word)) in
                                                                 (let (rd ::  5 Word.word) =
                                                                   ((subrange_vec_dec v__9 (( 11 :: int)::ii)
                                                                      (( 7 :: int)::ii)
                                                                     ::  5 Word.word)) in
                                                                 return (F_BIN_TYPE_S (rs2,
                                                                                       rs1,
                                                                                       rd,
                                                                                       FSGNJ_S)))))
                                                               else
                                                                 and_boolM ((is_RV32F_or_RV64F () ))
                                                                   (return ((((((((subrange_vec_dec
                                                                                       v__9 (( 31 :: int)::ii)
                                                                                       (( 25 :: int)::ii)
                                                                                      ::  7 Word.word)) = ( 0b0010000 ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec
                                                                                           v__9
                                                                                           (( 14 :: int)::ii)
                                                                                           (( 12 :: int)::ii)
                                                                                          ::  3 Word.word)) = ( 0b001 ::  3 Word.word)))) \<and> (((((subrange_vec_dec
                                                                                           v__9
                                                                                           (( 6 :: int)::ii)
                                                                                           (( 0 :: int)::ii)
                                                                                          ::  7 Word.word)) = ( 0b1010011 ::  7 Word.word))))))))))) \<bind> ((\<lambda> (w__86 ::
                                                                   bool) . 
                                                                 if w__86 then
                                                                   (let (rs2 ::  5 Word.word) =
                                                                     ((subrange_vec_dec v__9 (( 24 :: int)::ii)
                                                                        (( 20 :: int)::ii)
                                                                       ::  5 Word.word)) in
                                                                   (let (rs1 ::  5 Word.word) =
                                                                     ((subrange_vec_dec v__9 (( 19 :: int)::ii)
                                                                        (( 15 :: int)::ii)
                                                                       ::  5 Word.word)) in
                                                                   (let (rd ::  5 Word.word) =
                                                                     ((subrange_vec_dec v__9 (( 11 :: int)::ii)
                                                                        (( 7 :: int)::ii)
                                                                       ::  5 Word.word)) in
                                                                   return (F_BIN_TYPE_S (rs2,
                                                                                         rs1,
                                                                                         rd,
                                                                                         FSGNJN_S)))))
                                                                 else
                                                                   and_boolM
                                                                     ((is_RV32F_or_RV64F () ))
                                                                     (return ((((((((subrange_vec_dec
                                                                                         v__9
                                                                                         (( 31 :: int)::ii)
                                                                                         (( 25 :: int)::ii)
                                                                                        ::  7 Word.word)) = ( 0b0010000 ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec
                                                                                             v__9
                                                                                             (( 14 :: int)::ii)
                                                                                             (( 12 :: int)::ii)
                                                                                            ::  3 Word.word)) = ( 0b010 ::  3 Word.word)))) \<and> (((((subrange_vec_dec
                                                                                             v__9
                                                                                             (( 6 :: int)::ii)
                                                                                             (( 0 :: int)::ii)
                                                                                            ::  7 Word.word)) = ( 0b1010011 ::  7 Word.word))))))))))) \<bind> ((\<lambda> (w__88 ::
                                                                     bool) . 
                                                                   if w__88 then
                                                                     (let (rs2 ::  5 Word.word) =
                                                                       ((subrange_vec_dec v__9
                                                                          (( 24 :: int)::ii) (( 20 :: int)::ii)
                                                                         ::  5 Word.word)) in
                                                                     (let (rs1 ::  5 Word.word) =
                                                                       ((subrange_vec_dec v__9
                                                                          (( 19 :: int)::ii) (( 15 :: int)::ii)
                                                                         ::  5 Word.word)) in
                                                                     (let (rd ::  5 Word.word) =
                                                                       ((subrange_vec_dec v__9
                                                                          (( 11 :: int)::ii) (( 7 :: int)::ii)
                                                                         ::  5 Word.word)) in
                                                                     return (F_BIN_TYPE_S (rs2,
                                                                                           rs1,
                                                                                           rd,
                                                                                           FSGNJX_S)))))
                                                                   else
                                                                     and_boolM
                                                                       ((is_RV32F_or_RV64F () ))
                                                                       (return ((((((((subrange_vec_dec
                                                                                           v__9
                                                                                           (( 31 :: int)::ii)
                                                                                           (( 25 :: int)::ii)
                                                                                          ::  7 Word.word)) = ( 0b0010100 ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec
                                                                                               v__9
                                                                                               (( 14 :: int)::ii)
                                                                                               (( 12 :: int)::ii)
                                                                                              ::  3 Word.word)) = ( 0b000 ::  3 Word.word)))) \<and> (((((subrange_vec_dec
                                                                                               v__9
                                                                                               (( 6 :: int)::ii)
                                                                                               (( 0 :: int)::ii)
                                                                                              ::  7 Word.word)) = ( 0b1010011 ::  7 Word.word))))))))))) \<bind> ((\<lambda> (w__90 ::
                                                                       bool) . 
                                                                     if w__90 then
                                                                       (let (rs2 ::  5 Word.word) =
                                                                         ((subrange_vec_dec v__9
                                                                            (( 24 :: int)::ii) (( 20 :: int)::ii)
                                                                           ::  5 Word.word)) in
                                                                       (let (rs1 ::  5 Word.word) =
                                                                         ((subrange_vec_dec v__9
                                                                            (( 19 :: int)::ii) (( 15 :: int)::ii)
                                                                           ::  5 Word.word)) in
                                                                       (let (rd ::  5 Word.word) =
                                                                         ((subrange_vec_dec v__9
                                                                            (( 11 :: int)::ii) (( 7 :: int)::ii)
                                                                           ::  5 Word.word)) in
                                                                       return (F_BIN_TYPE_S (rs2,
                                                                                             rs1,
                                                                                             rd,
                                                                                             FMIN_S)))))
                                                                     else
                                                                       and_boolM
                                                                         ((is_RV32F_or_RV64F () ))
                                                                         (return ((((((((subrange_vec_dec
                                                                                             v__9
                                                                                             (( 31 :: int)::ii)
                                                                                             (( 25 :: int)::ii)
                                                                                            ::  7 Word.word)) = ( 0b0010100 ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec
                                                                                                 v__9
                                                                                                 (( 14 :: int)::ii)
                                                                                                 (( 12 :: int)::ii)
                                                                                                ::  3 Word.word)) = ( 0b001 ::  3 Word.word)))) \<and> (((((subrange_vec_dec
                                                                                                 v__9
                                                                                                 (( 6 :: int)::ii)
                                                                                                 (( 0 :: int)::ii)
                                                                                                ::  7 Word.word)) = ( 0b1010011 ::  7 Word.word))))))))))) \<bind> ((\<lambda> (w__92 ::
                                                                         bool) . 
                                                                       if w__92 then
                                                                         (let (rs2 ::  5 Word.word) =
                                                                           ((subrange_vec_dec v__9
                                                                              (( 24 :: int)::ii) (( 20 :: int)::ii)
                                                                             ::  5 Word.word)) in
                                                                         (let (rs1 ::  5 Word.word) =
                                                                           ((subrange_vec_dec v__9
                                                                              (( 19 :: int)::ii) (( 15 :: int)::ii)
                                                                             ::  5 Word.word)) in
                                                                         (let (rd ::  5 Word.word) =
                                                                           ((subrange_vec_dec v__9
                                                                              (( 11 :: int)::ii) (( 7 :: int)::ii)
                                                                             ::  5 Word.word)) in
                                                                         return (F_BIN_TYPE_S (rs2,
                                                                                               rs1,
                                                                                               rd,
                                                                                               FMAX_S)))))
                                                                       else
                                                                         and_boolM
                                                                           ((is_RV32F_or_RV64F () ))
                                                                           (return ((((((((subrange_vec_dec
                                                                                               v__9
                                                                                               (( 31 :: int)::ii)
                                                                                               (( 25 :: int)::ii)
                                                                                              ::  7 Word.word)) = ( 0b1010000 ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec
                                                                                                   v__9
                                                                                                   (( 14 :: int)::ii)
                                                                                                   (( 12 :: int)::ii)
                                                                                                  ::  3 Word.word)) = ( 0b010 ::  3 Word.word)))) \<and> (((((subrange_vec_dec
                                                                                                   v__9
                                                                                                   (( 6 :: int)::ii)
                                                                                                   (( 0 :: int)::ii)
                                                                                                  ::  7 Word.word)) = ( 0b1010011 ::  7 Word.word))))))))))) \<bind> ((\<lambda> (w__94 ::
                                                                           bool) . 
                                                                         if w__94 then
                                                                           (let (rs2 ::  5 Word.word) =
                                                                             ((subrange_vec_dec v__9
                                                                                (( 24 :: int)::ii) (( 20 :: int)::ii)
                                                                               ::  5 Word.word)) in
                                                                           (let (rs1 ::  5 Word.word) =
                                                                             ((subrange_vec_dec v__9
                                                                                (( 19 :: int)::ii) (( 15 :: int)::ii)
                                                                               ::  5 Word.word)) in
                                                                           (let (rd ::  5 Word.word) =
                                                                             ((subrange_vec_dec v__9
                                                                                (( 11 :: int)::ii) (( 7 :: int)::ii)
                                                                               ::  5 Word.word)) in
                                                                           return (F_BIN_TYPE_S (rs2,
                                                                                                 rs1,
                                                                                                 rd,
                                                                                                 FEQ_S)))))
                                                                         else
                                                                           and_boolM
                                                                             ((is_RV32F_or_RV64F () ))
                                                                             (return ((((((((subrange_vec_dec
                                                                                                 v__9
                                                                                                 (( 31 :: int)::ii)
                                                                                                 (( 25 :: int)::ii)
                                                                                                ::  7 Word.word)) = ( 0b1010000 ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec
                                                                                                     v__9
                                                                                                     (( 14 :: int)::ii)
                                                                                                     (( 12 :: int)::ii)
                                                                                                    ::  3 Word.word)) = ( 0b001 ::  3 Word.word)))) \<and> (((((subrange_vec_dec
                                                                                                     v__9
                                                                                                     (( 6 :: int)::ii)
                                                                                                     (( 0 :: int)::ii)
                                                                                                    ::  7 Word.word)) = ( 0b1010011 ::  7 Word.word))))))))))) \<bind> ((\<lambda> (w__96 ::
                                                                             bool) . 
                                                                           if w__96 then
                                                                             (let (rs2 ::  5 Word.word) =
                                                                               ((subrange_vec_dec
                                                                                  v__9 (( 24 :: int)::ii)
                                                                                  (( 20 :: int)::ii)
                                                                                 ::  5 Word.word)) in
                                                                             (let (rs1 ::  5 Word.word) =
                                                                               ((subrange_vec_dec
                                                                                  v__9 (( 19 :: int)::ii)
                                                                                  (( 15 :: int)::ii)
                                                                                 ::  5 Word.word)) in
                                                                             (let (rd ::  5 Word.word) =
                                                                               ((subrange_vec_dec
                                                                                  v__9 (( 11 :: int)::ii)
                                                                                  (( 7 :: int)::ii)
                                                                                 ::  5 Word.word)) in
                                                                             return (F_BIN_TYPE_S (rs2,
                                                                                                   rs1,
                                                                                                   rd,
                                                                                                   FLT_S)))))
                                                                           else
                                                                             and_boolM
                                                                               ((is_RV32F_or_RV64F
                                                                                   () ))
                                                                               (return ((((((((subrange_vec_dec
                                                                                                   v__9
                                                                                                   (( 31 :: int)::ii)
                                                                                                   (( 25 :: int)::ii)
                                                                                                  ::  7 Word.word)) = ( 0b1010000 ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec
                                                                                                       v__9
                                                                                                       (( 14 :: int)::ii)
                                                                                                       (( 12 :: int)::ii)
                                                                                                      ::  3 Word.word)) = ( 0b000 ::  3 Word.word)))) \<and> (((((subrange_vec_dec
                                                                                                       v__9
                                                                                                       (( 6 :: int)::ii)
                                                                                                       (( 0 :: int)::ii)
                                                                                                      ::  7 Word.word)) = ( 0b1010011 ::  7 Word.word))))))))))) \<bind> ((\<lambda> (w__98 ::
                                                                               bool) . 
                                                                             if w__98 then
                                                                               (let (rs2 ::  5 Word.word) =
                                                                                 ((subrange_vec_dec
                                                                                    v__9 (( 24 :: int)::ii)
                                                                                    (( 20 :: int)::ii)
                                                                                   ::  5 Word.word)) in
                                                                               (let (rs1 ::  5 Word.word) =
                                                                                 ((subrange_vec_dec
                                                                                    v__9 (( 19 :: int)::ii)
                                                                                    (( 15 :: int)::ii)
                                                                                   ::  5 Word.word)) in
                                                                               (let (rd ::  5 Word.word) =
                                                                                 ((subrange_vec_dec
                                                                                    v__9 (( 11 :: int)::ii)
                                                                                    (( 7 :: int)::ii)
                                                                                   ::  5 Word.word)) in
                                                                               return (F_BIN_TYPE_S (rs2,
                                                                                                     rs1,
                                                                                                     rd,
                                                                                                     FLE_S)))))
                                                                             else
                                                                               and_boolM
                                                                                 ((haveFExt () ))
                                                                                 (return ((((((((subrange_vec_dec
                                                                                                     v__9
                                                                                                     (( 31 :: int)::ii)
                                                                                                     (( 20 :: int)::ii)
                                                                                                    ::  12 Word.word)) = ( 0xE00 ::  12 Word.word)))) \<and> ((((((((subrange_vec_dec
                                                                                                         v__9
                                                                                                         (( 14 :: int)::ii)
                                                                                                         (( 12 :: int)::ii)
                                                                                                        ::  3 Word.word)) = ( 0b001 ::  3 Word.word)))) \<and> (((((subrange_vec_dec
                                                                                                         v__9
                                                                                                         (( 6 :: int)::ii)
                                                                                                         (( 0 :: int)::ii)
                                                                                                        ::  7 Word.word)) = ( 0b1010011 ::  7 Word.word))))))))))) \<bind> ((\<lambda> (w__100 ::
                                                                                 bool) . 
                                                                               if w__100 then
                                                                                 (let (rs1 ::
                                                                                    5 Word.word) =
                                                                                   ((subrange_vec_dec
                                                                                      v__9 (( 19 :: int)::ii)
                                                                                      (( 15 :: int)::ii)
                                                                                     ::  5 Word.word)) in
                                                                                 (let (rd ::  5 Word.word) =
                                                                                   ((subrange_vec_dec
                                                                                      v__9 (( 11 :: int)::ii)
                                                                                      (( 7 :: int)::ii)
                                                                                     ::  5 Word.word)) in
                                                                                 return (F_UN_TYPE_S (rs1,
                                                                                                      rd,
                                                                                                      FCLASS_S))))
                                                                               else
                                                                                 and_boolM
                                                                                   ((haveFExt () ))
                                                                                   (return ((((((((subrange_vec_dec
                                                                                                       v__9
                                                                                                       (( 31 :: int)::ii)
                                                                                                       (( 20 :: int)::ii)
                                                                                                      ::  12 Word.word)) = ( 0xE00 ::  12 Word.word)))) \<and> ((((((((subrange_vec_dec
                                                                                                           v__9
                                                                                                           (( 14 :: int)::ii)
                                                                                                           (( 12 :: int)::ii)
                                                                                                          ::  3 Word.word)) = ( 0b000 ::  3 Word.word)))) \<and> (((((subrange_vec_dec
                                                                                                           v__9
                                                                                                           (( 6 :: int)::ii)
                                                                                                           (( 0 :: int)::ii)
                                                                                                          ::  7 Word.word)) = ( 0b1010011 ::  7 Word.word))))))))))) \<bind> ((\<lambda> (w__102 ::
                                                                                   bool) . 
                                                                                 if w__102 then
                                                                                   (let (rs1 ::
                                                                                      5 Word.word) =
                                                                                     ((subrange_vec_dec
                                                                                        v__9 (( 19 :: int)::ii)
                                                                                        (( 15 :: int)::ii)
                                                                                       ::  5 Word.word)) in
                                                                                   (let (rd ::
                                                                                      5 Word.word) =
                                                                                     ((subrange_vec_dec
                                                                                        v__9 (( 11 :: int)::ii)
                                                                                        (( 7 :: int)::ii)
                                                                                       ::  5 Word.word)) in
                                                                                   return (F_UN_TYPE_S (rs1,
                                                                                                        rd,
                                                                                                        FMV_X_W))))
                                                                                 else
                                                                                   and_boolM
                                                                                     ((haveFExt () ))
                                                                                     (return ((((((((subrange_vec_dec
                                                                                                         v__9
                                                                                                         (( 31 :: int)::ii)
                                                                                                         (( 20 :: int)::ii)
                                                                                                        ::  12 Word.word)) = ( 0xF00 ::  12 Word.word)))) \<and> ((((((((subrange_vec_dec
                                                                                                             v__9
                                                                                                             (( 14 :: int)::ii)
                                                                                                             (( 12 :: int)::ii)
                                                                                                            ::  3 Word.word)) = ( 0b000 ::  3 Word.word)))) \<and> (((((subrange_vec_dec
                                                                                                             v__9
                                                                                                             (( 6 :: int)::ii)
                                                                                                             (( 0 :: int)::ii)
                                                                                                            ::  7 Word.word)) = ( 0b1010011 ::  7 Word.word))))))))))) \<bind> ((\<lambda> (w__104 ::
                                                                                     bool) . 
                                                                                   if w__104 then
                                                                                     (let (rs1 ::
                                                                                        5 Word.word) =
                                                                                       ((subrange_vec_dec
                                                                                          v__9
                                                                                          (( 19 :: int)::ii)
                                                                                          (( 15 :: int)::ii)
                                                                                         ::  5 Word.word)) in
                                                                                     (let (rd ::
                                                                                        5 Word.word) =
                                                                                       ((subrange_vec_dec
                                                                                          v__9
                                                                                          (( 11 :: int)::ii)
                                                                                          (( 7 :: int)::ii)
                                                                                         ::  5 Word.word)) in
                                                                                     return (F_UN_TYPE_S (rs1,
                                                                                                          rd,
                                                                                                          FMV_W_X))))
                                                                                   else
                                                                                     and_boolM
                                                                                       ((let (mappingpatterns_990 ::
                                                                                          3 Word.word) =
                                                                                         ((subrange_vec_dec
                                                                                            v__9
                                                                                            (( 14 :: int)::ii)
                                                                                            (( 12 :: int)::ii)
                                                                                           ::  3 Word.word)) in
                                                                                       if ((encdec_rounding_mode_backwards_matches
                                                                                              mappingpatterns_990))
                                                                                       then
                                                                                         encdec_rounding_mode_backwards
                                                                                           mappingpatterns_990 \<bind> ((\<lambda> rm . 
                                                                                         is_RV32D_or_RV64D
                                                                                           () ))
                                                                                       else
                                                                                         return False))
                                                                                       (return ((((((((subrange_vec_dec
                                                                                                           v__9
                                                                                                           (( 26 :: int)::ii)
                                                                                                           (( 25 :: int)::ii)
                                                                                                          ::  2 Word.word)) = ( 0b01 ::  2 Word.word)))) \<and> (((((subrange_vec_dec
                                                                                                           v__9
                                                                                                           (( 6 :: int)::ii)
                                                                                                           (( 0 :: int)::ii)
                                                                                                          ::  7 Word.word)) = ( 0b1000011 ::  7 Word.word)))))))) \<bind> ((\<lambda> (w__107 ::
                                                                                       bool) . 
                                                                                     if w__107 then
                                                                                       (let (rs3 ::
                                                                                          5 Word.word) =
                                                                                         ((subrange_vec_dec
                                                                                            v__9
                                                                                            (( 31 :: int)::ii)
                                                                                            (( 27 :: int)::ii)
                                                                                           ::  5 Word.word)) in
                                                                                       (let (rs3 ::
                                                                                          5 Word.word) =
                                                                                         ((subrange_vec_dec
                                                                                            v__9
                                                                                            (( 31 :: int)::ii)
                                                                                            (( 27 :: int)::ii)
                                                                                           ::  5 Word.word)) in
                                                                                       (let (rs2 ::
                                                                                          5 Word.word) =
                                                                                         ((subrange_vec_dec
                                                                                            v__9
                                                                                            (( 24 :: int)::ii)
                                                                                            (( 20 :: int)::ii)
                                                                                           ::  5 Word.word)) in
                                                                                       (let (rs1 ::
                                                                                          5 Word.word) =
                                                                                         ((subrange_vec_dec
                                                                                            v__9
                                                                                            (( 19 :: int)::ii)
                                                                                            (( 15 :: int)::ii)
                                                                                           ::  5 Word.word)) in
                                                                                       (let (rd ::
                                                                                          5 Word.word) =
                                                                                         ((subrange_vec_dec
                                                                                            v__9
                                                                                            (( 11 :: int)::ii)
                                                                                            (( 7 :: int)::ii)
                                                                                           ::  5 Word.word)) in
                                                                                       (let (mappingpatterns_990 ::
                                                                                          3 Word.word) =
                                                                                         ((subrange_vec_dec
                                                                                            v__9
                                                                                            (( 14 :: int)::ii)
                                                                                            (( 12 :: int)::ii)
                                                                                           ::  3 Word.word)) in
                                                                                       encdec_rounding_mode_backwards
                                                                                         mappingpatterns_990 \<bind> ((\<lambda> rm . 
                                                                                       return (F_MADD_TYPE_D (rs3,
                                                                                                              rs2,
                                                                                                              rs1,
                                                                                                              rm,
                                                                                                              rd,
                                                                                                              FMADD_D))))))))))
                                                                                     else
                                                                                       and_boolM
                                                                                         ((let (mappingpatterns_1000 ::
                                                                                            3 Word.word) =
                                                                                           ((subrange_vec_dec
                                                                                              v__9
                                                                                              (( 14 :: int)::ii)
                                                                                              (( 12 :: int)::ii)
                                                                                             ::  3 Word.word)) in
                                                                                         if ((encdec_rounding_mode_backwards_matches
                                                                                                mappingpatterns_1000))
                                                                                         then
                                                                                           encdec_rounding_mode_backwards
                                                                                             mappingpatterns_1000 \<bind> ((\<lambda> rm . 
                                                                                           is_RV32D_or_RV64D
                                                                                             () ))
                                                                                         else
                                                                                           return False))
                                                                                         (return ((((((((subrange_vec_dec
                                                                                                             v__9
                                                                                                             (( 26 :: int)::ii)
                                                                                                             (( 25 :: int)::ii)
                                                                                                            ::  2 Word.word)) = ( 0b01 ::  2 Word.word)))) \<and> (((((subrange_vec_dec
                                                                                                             v__9
                                                                                                             (( 6 :: int)::ii)
                                                                                                             (( 0 :: int)::ii)
                                                                                                            ::  7 Word.word)) = ( 0b1000111 ::  7 Word.word)))))))) \<bind> ((\<lambda> (w__110 ::
                                                                                         bool) . 
                                                                                       if w__110
                                                                                       then
                                                                                         (let (rs3 ::
                                                                                            5 Word.word) =
                                                                                           ((subrange_vec_dec
                                                                                              v__9
                                                                                              (( 31 :: int)::ii)
                                                                                              (( 27 :: int)::ii)
                                                                                             ::  5 Word.word)) in
                                                                                         (let (rs3 ::
                                                                                            5 Word.word) =
                                                                                           ((subrange_vec_dec
                                                                                              v__9
                                                                                              (( 31 :: int)::ii)
                                                                                              (( 27 :: int)::ii)
                                                                                             ::  5 Word.word)) in
                                                                                         (let (rs2 ::
                                                                                            5 Word.word) =
                                                                                           ((subrange_vec_dec
                                                                                              v__9
                                                                                              (( 24 :: int)::ii)
                                                                                              (( 20 :: int)::ii)
                                                                                             ::  5 Word.word)) in
                                                                                         (let (rs1 ::
                                                                                            5 Word.word) =
                                                                                           ((subrange_vec_dec
                                                                                              v__9
                                                                                              (( 19 :: int)::ii)
                                                                                              (( 15 :: int)::ii)
                                                                                             ::  5 Word.word)) in
                                                                                         (let (rd ::
                                                                                            5 Word.word) =
                                                                                           ((subrange_vec_dec
                                                                                              v__9
                                                                                              (( 11 :: int)::ii)
                                                                                              (( 7 :: int)::ii)
                                                                                             ::  5 Word.word)) in
                                                                                         (let (mappingpatterns_1000 ::
                                                                                            3 Word.word) =
                                                                                           ((subrange_vec_dec
                                                                                              v__9
                                                                                              (( 14 :: int)::ii)
                                                                                              (( 12 :: int)::ii)
                                                                                             ::  3 Word.word)) in
                                                                                         encdec_rounding_mode_backwards
                                                                                           mappingpatterns_1000 \<bind> ((\<lambda> rm . 
                                                                                         return (F_MADD_TYPE_D (rs3,
                                                                                                                rs2,
                                                                                                                rs1,
                                                                                                                rm,
                                                                                                                rd,
                                                                                                                FMSUB_D))))))))))
                                                                                       else
                                                                                         and_boolM
                                                                                           ((let (mappingpatterns_1010 ::
                                                                                              3 Word.word) =
                                                                                             ((subrange_vec_dec
                                                                                                v__9
                                                                                                (( 14 :: int)::ii)
                                                                                                (( 12 :: int)::ii)
                                                                                               ::  3 Word.word)) in
                                                                                           if ((encdec_rounding_mode_backwards_matches
                                                                                                  mappingpatterns_1010))
                                                                                           then
                                                                                             encdec_rounding_mode_backwards
                                                                                               mappingpatterns_1010 \<bind> ((\<lambda> rm . 
                                                                                             is_RV32D_or_RV64D
                                                                                               () ))
                                                                                           else
                                                                                             return False))
                                                                                           (return ((((((((subrange_vec_dec
                                                                                                               v__9
                                                                                                               (( 26 :: int)::ii)
                                                                                                               (( 25 :: int)::ii)
                                                                                                              ::  2 Word.word)) = ( 0b01 ::  2 Word.word)))) \<and> (((((subrange_vec_dec
                                                                                                               v__9
                                                                                                               (( 6 :: int)::ii)
                                                                                                               (( 0 :: int)::ii)
                                                                                                              ::  7 Word.word)) = ( 0b1001011 ::  7 Word.word)))))))) \<bind> ((\<lambda> (w__113 ::
                                                                                           bool) . 
                                                                                         if w__113
                                                                                         then
                                                                                           (let (rs3 ::
                                                                                              5 Word.word) =
                                                                                             ((subrange_vec_dec
                                                                                                v__9
                                                                                                (( 31 :: int)::ii)
                                                                                                (( 27 :: int)::ii)
                                                                                               ::  5 Word.word)) in
                                                                                           (let (rs3 ::
                                                                                              5 Word.word) =
                                                                                             ((subrange_vec_dec
                                                                                                v__9
                                                                                                (( 31 :: int)::ii)
                                                                                                (( 27 :: int)::ii)
                                                                                               ::  5 Word.word)) in
                                                                                           (let (rs2 ::
                                                                                              5 Word.word) =
                                                                                             ((subrange_vec_dec
                                                                                                v__9
                                                                                                (( 24 :: int)::ii)
                                                                                                (( 20 :: int)::ii)
                                                                                               ::  5 Word.word)) in
                                                                                           (let (rs1 ::
                                                                                              5 Word.word) =
                                                                                             ((subrange_vec_dec
                                                                                                v__9
                                                                                                (( 19 :: int)::ii)
                                                                                                (( 15 :: int)::ii)
                                                                                               ::  5 Word.word)) in
                                                                                           (let (rd ::
                                                                                              5 Word.word) =
                                                                                             ((subrange_vec_dec
                                                                                                v__9
                                                                                                (( 11 :: int)::ii)
                                                                                                (( 7 :: int)::ii)
                                                                                               ::  5 Word.word)) in
                                                                                           (let (mappingpatterns_1010 ::
                                                                                              3 Word.word) =
                                                                                             ((subrange_vec_dec
                                                                                                v__9
                                                                                                (( 14 :: int)::ii)
                                                                                                (( 12 :: int)::ii)
                                                                                               ::  3 Word.word)) in
                                                                                           encdec_rounding_mode_backwards
                                                                                             mappingpatterns_1010 \<bind> ((\<lambda> rm . 
                                                                                           return (F_MADD_TYPE_D (rs3,
                                                                                                                  rs2,
                                                                                                                  rs1,
                                                                                                                  rm,
                                                                                                                  rd,
                                                                                                                  FNMSUB_D))))))))))
                                                                                         else
                                                                                           and_boolM
                                                                                             ((let (mappingpatterns_1020 ::
                                                                                                3 Word.word) =
                                                                                               ((subrange_vec_dec
                                                                                                  v__9
                                                                                                  (( 14 :: int)::ii)
                                                                                                  (( 12 :: int)::ii)
                                                                                                 ::  3 Word.word)) in
                                                                                             if ((encdec_rounding_mode_backwards_matches
                                                                                                    mappingpatterns_1020))
                                                                                             then
                                                                                               encdec_rounding_mode_backwards
                                                                                                 mappingpatterns_1020 \<bind> ((\<lambda> rm . 
                                                                                               is_RV32D_or_RV64D
                                                                                                 () ))
                                                                                             else
                                                                                               return False))
                                                                                             (return ((((((((subrange_vec_dec
                                                                                                                 v__9
                                                                                                                 (( 26 :: int)::ii)
                                                                                                                 (( 25 :: int)::ii)
                                                                                                                ::  2 Word.word)) = ( 0b01 ::  2 Word.word)))) \<and> (((((subrange_vec_dec
                                                                                                                 v__9
                                                                                                                 (( 6 :: int)::ii)
                                                                                                                 (( 0 :: int)::ii)
                                                                                                                ::  7 Word.word)) = ( 0b1001111 ::  7 Word.word)))))))) \<bind> ((\<lambda> (w__116 ::
                                                                                             bool) . 
                                                                                           if w__116
                                                                                           then
                                                                                             (let (rs3 ::
                                                                                                5 Word.word) =
                                                                                               ((subrange_vec_dec
                                                                                                  v__9
                                                                                                  (( 31 :: int)::ii)
                                                                                                  (( 27 :: int)::ii)
                                                                                                 ::  5 Word.word)) in
                                                                                             (let (rs3 ::
                                                                                                5 Word.word) =
                                                                                               ((subrange_vec_dec
                                                                                                  v__9
                                                                                                  (( 31 :: int)::ii)
                                                                                                  (( 27 :: int)::ii)
                                                                                                 ::  5 Word.word)) in
                                                                                             (let (rs2 ::
                                                                                                5 Word.word) =
                                                                                               ((subrange_vec_dec
                                                                                                  v__9
                                                                                                  (( 24 :: int)::ii)
                                                                                                  (( 20 :: int)::ii)
                                                                                                 ::  5 Word.word)) in
                                                                                             (let (rs1 ::
                                                                                                5 Word.word) =
                                                                                               ((subrange_vec_dec
                                                                                                  v__9
                                                                                                  (( 19 :: int)::ii)
                                                                                                  (( 15 :: int)::ii)
                                                                                                 ::  5 Word.word)) in
                                                                                             (let (rd ::
                                                                                                5 Word.word) =
                                                                                               ((subrange_vec_dec
                                                                                                  v__9
                                                                                                  (( 11 :: int)::ii)
                                                                                                  (( 7 :: int)::ii)
                                                                                                 ::  5 Word.word)) in
                                                                                             (let (mappingpatterns_1020 ::
                                                                                                3 Word.word) =
                                                                                               ((subrange_vec_dec
                                                                                                  v__9
                                                                                                  (( 14 :: int)::ii)
                                                                                                  (( 12 :: int)::ii)
                                                                                                 ::  3 Word.word)) in
                                                                                             encdec_rounding_mode_backwards
                                                                                               mappingpatterns_1020 \<bind> ((\<lambda> rm . 
                                                                                             return (F_MADD_TYPE_D (rs3,
                                                                                                                    rs2,
                                                                                                                    rs1,
                                                                                                                    rm,
                                                                                                                    rd,
                                                                                                                    FNMADD_D))))))))))
                                                                                           else
                                                                                             and_boolM
                                                                                               ((let (mappingpatterns_1030 ::
                                                                                                  3 Word.word) =
                                                                                                 ((subrange_vec_dec
                                                                                                    v__9
                                                                                                    (( 14 :: int)::ii)
                                                                                                    (( 12 :: int)::ii)
                                                                                                   ::  3 Word.word)) in
                                                                                               if ((encdec_rounding_mode_backwards_matches
                                                                                                      mappingpatterns_1030))
                                                                                               then
                                                                                                 encdec_rounding_mode_backwards
                                                                                                   mappingpatterns_1030 \<bind> ((\<lambda> rm . 
                                                                                                 is_RV32D_or_RV64D
                                                                                                   () ))
                                                                                               else
                                                                                                 return False))
                                                                                               (return ((((((((subrange_vec_dec
                                                                                                                   v__9
                                                                                                                   (( 31 :: int)::ii)
                                                                                                                   (( 25 :: int)::ii)
                                                                                                                  ::  7 Word.word)) = ( 0b0000001 ::  7 Word.word)))) \<and> (((((subrange_vec_dec
                                                                                                                   v__9
                                                                                                                   (( 6 :: int)::ii)
                                                                                                                   (( 0 :: int)::ii)
                                                                                                                  ::  7 Word.word)) = ( 0b1010011 ::  7 Word.word)))))))) \<bind> ((\<lambda> (w__119 ::
                                                                                               bool) . 
                                                                                             if w__119
                                                                                             then
                                                                                               (let (rs2 ::
                                                                                                  5 Word.word) =
                                                                                                 ((subrange_vec_dec
                                                                                                    v__9
                                                                                                    (( 24 :: int)::ii)
                                                                                                    (( 20 :: int)::ii)
                                                                                                   ::  5 Word.word)) in
                                                                                               (let (rs1 ::
                                                                                                  5 Word.word) =
                                                                                                 ((subrange_vec_dec
                                                                                                    v__9
                                                                                                    (( 19 :: int)::ii)
                                                                                                    (( 15 :: int)::ii)
                                                                                                   ::  5 Word.word)) in
                                                                                               (let (rd ::
                                                                                                  5 Word.word) =
                                                                                                 ((subrange_vec_dec
                                                                                                    v__9
                                                                                                    (( 11 :: int)::ii)
                                                                                                    (( 7 :: int)::ii)
                                                                                                   ::  5 Word.word)) in
                                                                                               (let (mappingpatterns_1030 ::
                                                                                                  3 Word.word) =
                                                                                                 ((subrange_vec_dec
                                                                                                    v__9
                                                                                                    (( 14 :: int)::ii)
                                                                                                    (( 12 :: int)::ii)
                                                                                                   ::  3 Word.word)) in
                                                                                               encdec_rounding_mode_backwards
                                                                                                 mappingpatterns_1030 \<bind> ((\<lambda> rm . 
                                                                                               return (F_BIN_RM_TYPE_D (rs2,
                                                                                                                        rs1,
                                                                                                                        rm,
                                                                                                                        rd,
                                                                                                                        FADD_D))))))))
                                                                                             else
                                                                                               and_boolM
                                                                                                 ((let (mappingpatterns_1040 ::
                                                                                                    3 Word.word) =
                                                                                                   ((subrange_vec_dec
                                                                                                      v__9
                                                                                                      (( 14 :: int)::ii)
                                                                                                      (( 12 :: int)::ii)
                                                                                                     ::  3 Word.word)) in
                                                                                                 if ((encdec_rounding_mode_backwards_matches
                                                                                                        mappingpatterns_1040))
                                                                                                 then
                                                                                                   encdec_rounding_mode_backwards
                                                                                                     mappingpatterns_1040 \<bind> ((\<lambda> rm . 
                                                                                                   is_RV32D_or_RV64D
                                                                                                     () ))
                                                                                                 else
                                                                                                   return False))
                                                                                                 (return ((((((((subrange_vec_dec
                                                                                                                     v__9
                                                                                                                     (( 31 :: int)::ii)
                                                                                                                     (( 25 :: int)::ii)
                                                                                                                    ::  7 Word.word)) = ( 0b0000101 ::  7 Word.word)))) \<and> (((((subrange_vec_dec
                                                                                                                     v__9
                                                                                                                     (( 6 :: int)::ii)
                                                                                                                     (( 0 :: int)::ii)
                                                                                                                    ::  7 Word.word)) = ( 0b1010011 ::  7 Word.word)))))))) \<bind> ((\<lambda> (w__122 ::
                                                                                                 bool) . 
                                                                                               if w__122
                                                                                               then
                                                                                                 (let (rs2 ::
                                                                                                    5 Word.word) =
                                                                                                   ((subrange_vec_dec
                                                                                                      v__9
                                                                                                      (( 24 :: int)::ii)
                                                                                                      (( 20 :: int)::ii)
                                                                                                     ::  5 Word.word)) in
                                                                                                 (let (rs1 ::
                                                                                                    5 Word.word) =
                                                                                                   ((subrange_vec_dec
                                                                                                      v__9
                                                                                                      (( 19 :: int)::ii)
                                                                                                      (( 15 :: int)::ii)
                                                                                                     ::  5 Word.word)) in
                                                                                                 (let (rd ::
                                                                                                    5 Word.word) =
                                                                                                   ((subrange_vec_dec
                                                                                                      v__9
                                                                                                      (( 11 :: int)::ii)
                                                                                                      (( 7 :: int)::ii)
                                                                                                     ::  5 Word.word)) in
                                                                                                 (let (mappingpatterns_1040 ::
                                                                                                    3 Word.word) =
                                                                                                   ((subrange_vec_dec
                                                                                                      v__9
                                                                                                      (( 14 :: int)::ii)
                                                                                                      (( 12 :: int)::ii)
                                                                                                     ::  3 Word.word)) in
                                                                                                 encdec_rounding_mode_backwards
                                                                                                   mappingpatterns_1040 \<bind> ((\<lambda> rm . 
                                                                                                 return (F_BIN_RM_TYPE_D (rs2,
                                                                                                                          rs1,
                                                                                                                          rm,
                                                                                                                          rd,
                                                                                                                          FSUB_D))))))))
                                                                                               else
                                                                                                 and_boolM
                                                                                                   ((let (mappingpatterns_1050 ::
                                                                                                      3 Word.word) =
                                                                                                     ((subrange_vec_dec
                                                                                                        v__9
                                                                                                        (( 14 :: int)::ii)
                                                                                                        (( 12 :: int)::ii)
                                                                                                       ::  3 Word.word)) in
                                                                                                   if
                                                                                                     ((encdec_rounding_mode_backwards_matches
                                                                                                         mappingpatterns_1050))
                                                                                                   then
                                                                                                     encdec_rounding_mode_backwards
                                                                                                       mappingpatterns_1050 \<bind> ((\<lambda> rm . 
                                                                                                     is_RV32D_or_RV64D
                                                                                                       () ))
                                                                                                   else
                                                                                                     return False))
                                                                                                   (return ((((((((subrange_vec_dec
                                                                                                                       v__9
                                                                                                                       (( 31 :: int)::ii)
                                                                                                                       (( 25 :: int)::ii)
                                                                                                                      ::  7 Word.word)) = ( 0b0001001 ::  7 Word.word)))) \<and> (((((subrange_vec_dec
                                                                                                                       v__9
                                                                                                                       (( 6 :: int)::ii)
                                                                                                                       (( 0 :: int)::ii)
                                                                                                                      ::  7 Word.word)) = ( 0b1010011 ::  7 Word.word)))))))) \<bind> ((\<lambda> (w__125 ::
                                                                                                   bool) . 
                                                                                                 if w__125
                                                                                                 then
                                                                                                   (let (rs2 ::
                                                                                                      5 Word.word) =
                                                                                                     ((subrange_vec_dec
                                                                                                        v__9
                                                                                                        (( 24 :: int)::ii)
                                                                                                        (( 20 :: int)::ii)
                                                                                                       ::  5 Word.word)) in
                                                                                                   (let (rs1 ::
                                                                                                      5 Word.word) =
                                                                                                     ((subrange_vec_dec
                                                                                                        v__9
                                                                                                        (( 19 :: int)::ii)
                                                                                                        (( 15 :: int)::ii)
                                                                                                       ::  5 Word.word)) in
                                                                                                   (let (rd ::
                                                                                                      5 Word.word) =
                                                                                                     ((subrange_vec_dec
                                                                                                        v__9
                                                                                                        (( 11 :: int)::ii)
                                                                                                        (( 7 :: int)::ii)
                                                                                                       ::  5 Word.word)) in
                                                                                                   (let (mappingpatterns_1050 ::
                                                                                                      3 Word.word) =
                                                                                                     ((subrange_vec_dec
                                                                                                        v__9
                                                                                                        (( 14 :: int)::ii)
                                                                                                        (( 12 :: int)::ii)
                                                                                                       ::  3 Word.word)) in
                                                                                                   encdec_rounding_mode_backwards
                                                                                                     mappingpatterns_1050 \<bind> ((\<lambda> rm . 
                                                                                                   return (F_BIN_RM_TYPE_D (rs2,
                                                                                                                            rs1,
                                                                                                                            rm,
                                                                                                                            rd,
                                                                                                                            FMUL_D))))))))
                                                                                                 else
                                                                                                   and_boolM
                                                                                                     ((let (mappingpatterns_1060 ::
                                                                                                        3 Word.word) =
                                                                                                       ((subrange_vec_dec
                                                                                                          v__9
                                                                                                          (( 14 :: int)::ii)
                                                                                                          (( 12 :: int)::ii)
                                                                                                         ::  3 Word.word)) in
                                                                                                     if
                                                                                                       ((encdec_rounding_mode_backwards_matches
                                                                                                           mappingpatterns_1060))
                                                                                                     then
                                                                                                       encdec_rounding_mode_backwards
                                                                                                         mappingpatterns_1060 \<bind> ((\<lambda> rm . 
                                                                                                       is_RV32D_or_RV64D
                                                                                                         () ))
                                                                                                     else
                                                                                                       return False))
                                                                                                     (return ((((((((subrange_vec_dec
                                                                                                                         v__9
                                                                                                                         (( 31 :: int)::ii)
                                                                                                                         (( 25 :: int)::ii)
                                                                                                                        ::  7 Word.word)) = ( 0b0001101 ::  7 Word.word)))) \<and> (((((subrange_vec_dec
                                                                                                                         v__9
                                                                                                                         (( 6 :: int)::ii)
                                                                                                                         (( 0 :: int)::ii)
                                                                                                                        ::  7 Word.word)) = ( 0b1010011 ::  7 Word.word)))))))) \<bind> ((\<lambda> (w__128 ::
                                                                                                     bool) . 
                                                                                                   if
                                                                                                     w__128
                                                                                                   then
                                                                                                     (let (rs2 ::
                                                                                                        5 Word.word) =
                                                                                                       ((subrange_vec_dec
                                                                                                          v__9
                                                                                                          (( 24 :: int)::ii)
                                                                                                          (( 20 :: int)::ii)
                                                                                                         ::  5 Word.word)) in
                                                                                                     (let (rs1 ::
                                                                                                        5 Word.word) =
                                                                                                       ((subrange_vec_dec
                                                                                                          v__9
                                                                                                          (( 19 :: int)::ii)
                                                                                                          (( 15 :: int)::ii)
                                                                                                         ::  5 Word.word)) in
                                                                                                     (let (rd ::
                                                                                                        5 Word.word) =
                                                                                                       ((subrange_vec_dec
                                                                                                          v__9
                                                                                                          (( 11 :: int)::ii)
                                                                                                          (( 7 :: int)::ii)
                                                                                                         ::  5 Word.word)) in
                                                                                                     (let (mappingpatterns_1060 ::
                                                                                                        3 Word.word) =
                                                                                                       ((subrange_vec_dec
                                                                                                          v__9
                                                                                                          (( 14 :: int)::ii)
                                                                                                          (( 12 :: int)::ii)
                                                                                                         ::  3 Word.word)) in
                                                                                                     encdec_rounding_mode_backwards
                                                                                                       mappingpatterns_1060 \<bind> ((\<lambda> rm . 
                                                                                                     return (F_BIN_RM_TYPE_D (rs2,
                                                                                                                              rs1,
                                                                                                                              rm,
                                                                                                                              rd,
                                                                                                                              FDIV_D))))))))
                                                                                                   else
                                                                                                     and_boolM
                                                                                                       ((let (mappingpatterns_1070 ::
                                                                                                          3 Word.word) =
                                                                                                         ((subrange_vec_dec
                                                                                                            v__9
                                                                                                            (( 14 :: int)::ii)
                                                                                                            (( 12 :: int)::ii)
                                                                                                           ::  3 Word.word)) in
                                                                                                       if
                                                                                                         ((encdec_rounding_mode_backwards_matches
                                                                                                             mappingpatterns_1070))
                                                                                                       then
                                                                                                         encdec_rounding_mode_backwards
                                                                                                           mappingpatterns_1070 \<bind> ((\<lambda> rm . 
                                                                                                         is_RV32D_or_RV64D
                                                                                                           () ))
                                                                                                       else
                                                                                                         return False))
                                                                                                       (return ((((((((subrange_vec_dec
                                                                                                                           v__9
                                                                                                                           (( 31 :: int)::ii)
                                                                                                                           (( 20 :: int)::ii)
                                                                                                                          ::  12 Word.word)) = ( 0x5A0 ::  12 Word.word)))) \<and> (((((subrange_vec_dec
                                                                                                                           v__9
                                                                                                                           (( 6 :: int)::ii)
                                                                                                                           (( 0 :: int)::ii)
                                                                                                                          ::  7 Word.word)) = ( 0b1010011 ::  7 Word.word)))))))) \<bind> ((\<lambda> (w__131 ::
                                                                                                       bool) . 
                                                                                                     if
                                                                                                       w__131
                                                                                                     then
                                                                                                       (let (rs1 ::
                                                                                                          5 Word.word) =
                                                                                                         ((subrange_vec_dec
                                                                                                            v__9
                                                                                                            (( 19 :: int)::ii)
                                                                                                            (( 15 :: int)::ii)
                                                                                                           ::  5 Word.word)) in
                                                                                                       (let (rd ::
                                                                                                          5 Word.word) =
                                                                                                         ((subrange_vec_dec
                                                                                                            v__9
                                                                                                            (( 11 :: int)::ii)
                                                                                                            (( 7 :: int)::ii)
                                                                                                           ::  5 Word.word)) in
                                                                                                       (let (mappingpatterns_1070 ::
                                                                                                          3 Word.word) =
                                                                                                         ((subrange_vec_dec
                                                                                                            v__9
                                                                                                            (( 14 :: int)::ii)
                                                                                                            (( 12 :: int)::ii)
                                                                                                           ::  3 Word.word)) in
                                                                                                       encdec_rounding_mode_backwards
                                                                                                         mappingpatterns_1070 \<bind> ((\<lambda> rm . 
                                                                                                       return (F_UN_RM_TYPE_D (rs1,
                                                                                                                               rm,
                                                                                                                               rd,
                                                                                                                               FSQRT_D)))))))
                                                                                                     else
                                                                                                       and_boolM
                                                                                                         ((let (mappingpatterns_1080 ::
                                                                                                            3 Word.word) =
                                                                                                           ((subrange_vec_dec
                                                                                                              v__9
                                                                                                              (( 14 :: int)::ii)
                                                                                                              (( 12 :: int)::ii)
                                                                                                             ::  3 Word.word)) in
                                                                                                         if
                                                                                                           ((encdec_rounding_mode_backwards_matches
                                                                                                               mappingpatterns_1080))
                                                                                                         then
                                                                                                           encdec_rounding_mode_backwards
                                                                                                             mappingpatterns_1080 \<bind> ((\<lambda> rm . 
                                                                                                           is_RV32D_or_RV64D
                                                                                                             () ))
                                                                                                         else
                                                                                                           return False))
                                                                                                         (return ((((((((subrange_vec_dec
                                                                                                                             v__9
                                                                                                                             (( 31 :: int)::ii)
                                                                                                                             (( 20 :: int)::ii)
                                                                                                                            ::  12 Word.word)) = ( 0xC20 ::  12 Word.word)))) \<and> (((((subrange_vec_dec
                                                                                                                             v__9
                                                                                                                             (( 6 :: int)::ii)
                                                                                                                             (( 0 :: int)::ii)
                                                                                                                            ::  7 Word.word)) = ( 0b1010011 ::  7 Word.word)))))))) \<bind> ((\<lambda> (w__134 ::
                                                                                                         bool) . 
                                                                                                       if
                                                                                                         w__134
                                                                                                       then
                                                                                                         (let (rs1 ::
                                                                                                            5 Word.word) =
                                                                                                           ((subrange_vec_dec
                                                                                                              v__9
                                                                                                              (( 19 :: int)::ii)
                                                                                                              (( 15 :: int)::ii)
                                                                                                             ::  5 Word.word)) in
                                                                                                         (let (rd ::
                                                                                                            5 Word.word) =
                                                                                                           ((subrange_vec_dec
                                                                                                              v__9
                                                                                                              (( 11 :: int)::ii)
                                                                                                              (( 7 :: int)::ii)
                                                                                                             ::  5 Word.word)) in
                                                                                                         (let (mappingpatterns_1080 ::
                                                                                                            3 Word.word) =
                                                                                                           ((subrange_vec_dec
                                                                                                              v__9
                                                                                                              (( 14 :: int)::ii)
                                                                                                              (( 12 :: int)::ii)
                                                                                                             ::  3 Word.word)) in
                                                                                                         encdec_rounding_mode_backwards
                                                                                                           mappingpatterns_1080 \<bind> ((\<lambda> rm . 
                                                                                                         return (F_UN_RM_TYPE_D (rs1,
                                                                                                                                 rm,
                                                                                                                                 rd,
                                                                                                                                 FCVT_W_D)))))))
                                                                                                       else
                                                                                                         and_boolM
                                                                                                           ((let (mappingpatterns_1090 ::
                                                                                                              3 Word.word) =
                                                                                                             ((subrange_vec_dec
                                                                                                                v__9
                                                                                                                (( 14 :: int)::ii)
                                                                                                                (( 12 :: int)::ii)
                                                                                                               ::  3 Word.word)) in
                                                                                                           if
                                                                                                             ((encdec_rounding_mode_backwards_matches
                                                                                                                 mappingpatterns_1090))
                                                                                                           then
                                                                                                             encdec_rounding_mode_backwards
                                                                                                               mappingpatterns_1090 \<bind> ((\<lambda> rm . 
                                                                                                             is_RV32D_or_RV64D
                                                                                                               () ))
                                                                                                           else
                                                                                                             return False))
                                                                                                           (return ((((((((subrange_vec_dec
                                                                                                                               v__9
                                                                                                                               (( 31 :: int)::ii)
                                                                                                                               (( 20 :: int)::ii)
                                                                                                                              ::  12 Word.word)) = ( 0xC21 ::  12 Word.word)))) \<and> (((((subrange_vec_dec
                                                                                                                               v__9
                                                                                                                               (( 6 :: int)::ii)
                                                                                                                               (( 0 :: int)::ii)
                                                                                                                              ::  7 Word.word)) = ( 0b1010011 ::  7 Word.word)))))))) \<bind> ((\<lambda> (w__137 ::
                                                                                                           bool) . 
                                                                                                         if
                                                                                                           w__137
                                                                                                         then
                                                                                                           (let (rs1 ::
                                                                                                              5 Word.word) =
                                                                                                             ((subrange_vec_dec
                                                                                                                v__9
                                                                                                                (( 19 :: int)::ii)
                                                                                                                (( 15 :: int)::ii)
                                                                                                               ::  5 Word.word)) in
                                                                                                           (let (rd ::
                                                                                                              5 Word.word) =
                                                                                                             ((subrange_vec_dec
                                                                                                                v__9
                                                                                                                (( 11 :: int)::ii)
                                                                                                                (( 7 :: int)::ii)
                                                                                                               ::  5 Word.word)) in
                                                                                                           (let (mappingpatterns_1090 ::
                                                                                                              3 Word.word) =
                                                                                                             ((subrange_vec_dec
                                                                                                                v__9
                                                                                                                (( 14 :: int)::ii)
                                                                                                                (( 12 :: int)::ii)
                                                                                                               ::  3 Word.word)) in
                                                                                                           encdec_rounding_mode_backwards
                                                                                                             mappingpatterns_1090 \<bind> ((\<lambda> rm . 
                                                                                                           return (F_UN_RM_TYPE_D (rs1,
                                                                                                                                   rm,
                                                                                                                                   rd,
                                                                                                                                   FCVT_WU_D)))))))
                                                                                                         else
                                                                                                           and_boolM
                                                                                                             ((let (mappingpatterns_1100 ::
                                                                                                                3 Word.word) =
                                                                                                               ((subrange_vec_dec
                                                                                                                  v__9
                                                                                                                  (( 14 :: int)::ii)
                                                                                                                  (( 12 :: int)::ii)
                                                                                                                 ::  3 Word.word)) in
                                                                                                             if
                                                                                                               ((encdec_rounding_mode_backwards_matches
                                                                                                                   mappingpatterns_1100))
                                                                                                             then
                                                                                                               encdec_rounding_mode_backwards
                                                                                                                 mappingpatterns_1100 \<bind> ((\<lambda> rm . 
                                                                                                               is_RV32D_or_RV64D
                                                                                                                 () ))
                                                                                                             else
                                                                                                               return False))
                                                                                                             (return ((((((((subrange_vec_dec
                                                                                                                                 v__9
                                                                                                                                 (( 31 :: int)::ii)
                                                                                                                                 (( 20 :: int)::ii)
                                                                                                                                ::  12 Word.word)) = ( 0xD20 ::  12 Word.word)))) \<and> (((((subrange_vec_dec
                                                                                                                                 v__9
                                                                                                                                 (( 6 :: int)::ii)
                                                                                                                                 (( 0 :: int)::ii)
                                                                                                                                ::  7 Word.word)) = ( 0b1010011 ::  7 Word.word)))))))) \<bind> ((\<lambda> (w__140 ::
                                                                                                             bool) . 
                                                                                                           if
                                                                                                             w__140
                                                                                                           then
                                                                                                             (let (rs1 ::
                                                                                                                5 Word.word) =
                                                                                                               ((subrange_vec_dec
                                                                                                                  v__9
                                                                                                                  (( 19 :: int)::ii)
                                                                                                                  (( 15 :: int)::ii)
                                                                                                                 ::  5 Word.word)) in
                                                                                                             (let (rd ::
                                                                                                                5 Word.word) =
                                                                                                               ((subrange_vec_dec
                                                                                                                  v__9
                                                                                                                  (( 11 :: int)::ii)
                                                                                                                  (( 7 :: int)::ii)
                                                                                                                 ::  5 Word.word)) in
                                                                                                             (let (mappingpatterns_1100 ::
                                                                                                                3 Word.word) =
                                                                                                               ((subrange_vec_dec
                                                                                                                  v__9
                                                                                                                  (( 14 :: int)::ii)
                                                                                                                  (( 12 :: int)::ii)
                                                                                                                 ::  3 Word.word)) in
                                                                                                             encdec_rounding_mode_backwards
                                                                                                               mappingpatterns_1100 \<bind> ((\<lambda> rm . 
                                                                                                             return (F_UN_RM_TYPE_D (rs1,
                                                                                                                                     rm,
                                                                                                                                     rd,
                                                                                                                                     FCVT_D_W)))))))
                                                                                                           else
                                                                                                             and_boolM
                                                                                                               ((let (mappingpatterns_1110 ::
                                                                                                                  3 Word.word) =
                                                                                                                 ((subrange_vec_dec
                                                                                                                    v__9
                                                                                                                    (( 14 :: int)::ii)
                                                                                                                    (( 12 :: int)::ii)
                                                                                                                   ::  3 Word.word)) in
                                                                                                               if
                                                                                                                 ((encdec_rounding_mode_backwards_matches
                                                                                                                     mappingpatterns_1110))
                                                                                                               then
                                                                                                                 encdec_rounding_mode_backwards
                                                                                                                   mappingpatterns_1110 \<bind> ((\<lambda> rm . 
                                                                                                                 is_RV32D_or_RV64D
                                                                                                                   () ))
                                                                                                               else
                                                                                                                 return False))
                                                                                                               (return ((((((((subrange_vec_dec
                                                                                                                                   v__9
                                                                                                                                   (( 31 :: int)::ii)
                                                                                                                                   (( 20 :: int)::ii)
                                                                                                                                  ::  12 Word.word)) = ( 0xD21 ::  12 Word.word)))) \<and> (((((subrange_vec_dec
                                                                                                                                   v__9
                                                                                                                                   (( 6 :: int)::ii)
                                                                                                                                   (( 0 :: int)::ii)
                                                                                                                                  ::  7 Word.word)) = ( 0b1010011 ::  7 Word.word)))))))) \<bind> ((\<lambda> (w__143 ::
                                                                                                               bool) . 
                                                                                                             if
                                                                                                               w__143
                                                                                                             then
                                                                                                               (let (rs1 ::
                                                                                                                  5 Word.word) =
                                                                                                                 ((subrange_vec_dec
                                                                                                                    v__9
                                                                                                                    (( 19 :: int)::ii)
                                                                                                                    (( 15 :: int)::ii)
                                                                                                                   ::  5 Word.word)) in
                                                                                                               (let (rd ::
                                                                                                                  5 Word.word) =
                                                                                                                 ((subrange_vec_dec
                                                                                                                    v__9
                                                                                                                    (( 11 :: int)::ii)
                                                                                                                    (( 7 :: int)::ii)
                                                                                                                   ::  5 Word.word)) in
                                                                                                               (let (mappingpatterns_1110 ::
                                                                                                                  3 Word.word) =
                                                                                                                 ((subrange_vec_dec
                                                                                                                    v__9
                                                                                                                    (( 14 :: int)::ii)
                                                                                                                    (( 12 :: int)::ii)
                                                                                                                   ::  3 Word.word)) in
                                                                                                               encdec_rounding_mode_backwards
                                                                                                                 mappingpatterns_1110 \<bind> ((\<lambda> rm . 
                                                                                                               return (F_UN_RM_TYPE_D (rs1,
                                                                                                                                       rm,
                                                                                                                                       rd,
                                                                                                                                       FCVT_D_WU)))))))
                                                                                                             else
                                                                                                               and_boolM
                                                                                                                 ((let (mappingpatterns_1120 ::
                                                                                                                    3 Word.word) =
                                                                                                                   ((subrange_vec_dec
                                                                                                                      v__9
                                                                                                                      (( 14 :: int)::ii)
                                                                                                                      (( 12 :: int)::ii)
                                                                                                                     ::  3 Word.word)) in
                                                                                                                 if
                                                                                                                   ((encdec_rounding_mode_backwards_matches
                                                                                                                       mappingpatterns_1120))
                                                                                                                 then
                                                                                                                   encdec_rounding_mode_backwards
                                                                                                                     mappingpatterns_1120 \<bind> ((\<lambda> rm . 
                                                                                                                   is_RV32D_or_RV64D
                                                                                                                     () ))
                                                                                                                 else
                                                                                                                   return False))
                                                                                                                 (return ((((((((subrange_vec_dec
                                                                                                                                     v__9
                                                                                                                                     (( 31 :: int)::ii)
                                                                                                                                     (( 20 :: int)::ii)
                                                                                                                                    ::  12 Word.word)) = ( 0x401 ::  12 Word.word)))) \<and> (((((subrange_vec_dec
                                                                                                                                     v__9
                                                                                                                                     (( 6 :: int)::ii)
                                                                                                                                     (( 0 :: int)::ii)
                                                                                                                                    ::  7 Word.word)) = ( 0b1010011 ::  7 Word.word)))))))) \<bind> ((\<lambda> (w__146 ::
                                                                                                                 bool) . 
                                                                                                               if
                                                                                                                 w__146
                                                                                                               then
                                                                                                                 (let (rs1 ::
                                                                                                                    5 Word.word) =
                                                                                                                   ((subrange_vec_dec
                                                                                                                      v__9
                                                                                                                      (( 19 :: int)::ii)
                                                                                                                      (( 15 :: int)::ii)
                                                                                                                     ::  5 Word.word)) in
                                                                                                                 (let (rd ::
                                                                                                                    5 Word.word) =
                                                                                                                   ((subrange_vec_dec
                                                                                                                      v__9
                                                                                                                      (( 11 :: int)::ii)
                                                                                                                      (( 7 :: int)::ii)
                                                                                                                     ::  5 Word.word)) in
                                                                                                                 (let (mappingpatterns_1120 ::
                                                                                                                    3 Word.word) =
                                                                                                                   ((subrange_vec_dec
                                                                                                                      v__9
                                                                                                                      (( 14 :: int)::ii)
                                                                                                                      (( 12 :: int)::ii)
                                                                                                                     ::  3 Word.word)) in
                                                                                                                 encdec_rounding_mode_backwards
                                                                                                                   mappingpatterns_1120 \<bind> ((\<lambda> rm . 
                                                                                                                 return (F_UN_RM_TYPE_D (rs1,
                                                                                                                                         rm,
                                                                                                                                         rd,
                                                                                                                                         FCVT_S_D)))))))
                                                                                                               else
                                                                                                                 and_boolM
                                                                                                                   ((let (mappingpatterns_1130 ::
                                                                                                                      3 Word.word) =
                                                                                                                     ((subrange_vec_dec
                                                                                                                        v__9
                                                                                                                        (( 14 :: int)::ii)
                                                                                                                        (( 12 :: int)::ii)
                                                                                                                       ::  3 Word.word)) in
                                                                                                                   if
                                                                                                                     ((encdec_rounding_mode_backwards_matches
                                                                                                                         mappingpatterns_1130))
                                                                                                                   then
                                                                                                                     encdec_rounding_mode_backwards
                                                                                                                       mappingpatterns_1130 \<bind> ((\<lambda> rm . 
                                                                                                                     is_RV32D_or_RV64D
                                                                                                                       () ))
                                                                                                                   else
                                                                                                                     return False))
                                                                                                                   (return ((((((((subrange_vec_dec
                                                                                                                                       v__9
                                                                                                                                       (( 31 :: int)::ii)
                                                                                                                                       (( 20 :: int)::ii)
                                                                                                                                      ::  12 Word.word)) = ( 0x420 ::  12 Word.word)))) \<and> (((((subrange_vec_dec
                                                                                                                                       v__9
                                                                                                                                       (( 6 :: int)::ii)
                                                                                                                                       (( 0 :: int)::ii)
                                                                                                                                      ::  7 Word.word)) = ( 0b1010011 ::  7 Word.word)))))))) \<bind> ((\<lambda> (w__149 ::
                                                                                                                   bool) . 
                                                                                                                 if
                                                                                                                   w__149
                                                                                                                 then
                                                                                                                   (let (rs1 ::
                                                                                                                      5 Word.word) =
                                                                                                                     ((subrange_vec_dec
                                                                                                                        v__9
                                                                                                                        (( 19 :: int)::ii)
                                                                                                                        (( 15 :: int)::ii)
                                                                                                                       ::  5 Word.word)) in
                                                                                                                   (let (rd ::
                                                                                                                      5 Word.word) =
                                                                                                                     ((subrange_vec_dec
                                                                                                                        v__9
                                                                                                                        (( 11 :: int)::ii)
                                                                                                                        (( 7 :: int)::ii)
                                                                                                                       ::  5 Word.word)) in
                                                                                                                   (let (mappingpatterns_1130 ::
                                                                                                                      3 Word.word) =
                                                                                                                     ((subrange_vec_dec
                                                                                                                        v__9
                                                                                                                        (( 14 :: int)::ii)
                                                                                                                        (( 12 :: int)::ii)
                                                                                                                       ::  3 Word.word)) in
                                                                                                                   encdec_rounding_mode_backwards
                                                                                                                     mappingpatterns_1130 \<bind> ((\<lambda> rm . 
                                                                                                                   return (F_UN_RM_TYPE_D (rs1,
                                                                                                                                           rm,
                                                                                                                                           rd,
                                                                                                                                           FCVT_D_S)))))))
                                                                                                                 else
                                                                                                                   and_boolM
                                                                                                                     ((let (mappingpatterns_1140 ::
                                                                                                                        3 Word.word) =
                                                                                                                       ((subrange_vec_dec
                                                                                                                          v__9
                                                                                                                          (( 14 :: int)::ii)
                                                                                                                          (( 12 :: int)::ii)
                                                                                                                         ::  3 Word.word)) in
                                                                                                                     if
                                                                                                                       ((encdec_rounding_mode_backwards_matches
                                                                                                                           mappingpatterns_1140))
                                                                                                                     then
                                                                                                                       encdec_rounding_mode_backwards
                                                                                                                         mappingpatterns_1140 \<bind> ((\<lambda> rm . 
                                                                                                                       is_RV64D
                                                                                                                         () ))
                                                                                                                     else
                                                                                                                       return False))
                                                                                                                     (return ((((((((subrange_vec_dec
                                                                                                                                         v__9
                                                                                                                                         (( 31 :: int)::ii)
                                                                                                                                         (( 20 :: int)::ii)
                                                                                                                                        ::  12 Word.word)) = ( 0xC22 ::  12 Word.word)))) \<and> (((((subrange_vec_dec
                                                                                                                                         v__9
                                                                                                                                         (( 6 :: int)::ii)
                                                                                                                                         (( 0 :: int)::ii)
                                                                                                                                        ::  7 Word.word)) = ( 0b1010011 ::  7 Word.word)))))))) \<bind> ((\<lambda> (w__152 ::
                                                                                                                     bool) . 
                                                                                                                   if
                                                                                                                     w__152
                                                                                                                   then
                                                                                                                     (let (rs1 ::
                                                                                                                        5 Word.word) =
                                                                                                                       ((subrange_vec_dec
                                                                                                                          v__9
                                                                                                                          (( 19 :: int)::ii)
                                                                                                                          (( 15 :: int)::ii)
                                                                                                                         ::  5 Word.word)) in
                                                                                                                     (let (rd ::
                                                                                                                        5 Word.word) =
                                                                                                                       ((subrange_vec_dec
                                                                                                                          v__9
                                                                                                                          (( 11 :: int)::ii)
                                                                                                                          (( 7 :: int)::ii)
                                                                                                                         ::  5 Word.word)) in
                                                                                                                     (let (mappingpatterns_1140 ::
                                                                                                                        3 Word.word) =
                                                                                                                       ((subrange_vec_dec
                                                                                                                          v__9
                                                                                                                          (( 14 :: int)::ii)
                                                                                                                          (( 12 :: int)::ii)
                                                                                                                         ::  3 Word.word)) in
                                                                                                                     encdec_rounding_mode_backwards
                                                                                                                       mappingpatterns_1140 \<bind> ((\<lambda> rm . 
                                                                                                                     return (F_UN_RM_TYPE_D (rs1,
                                                                                                                                             rm,
                                                                                                                                             rd,
                                                                                                                                             FCVT_L_D)))))))
                                                                                                                   else
                                                                                                                     and_boolM
                                                                                                                       ((let (mappingpatterns_1150 ::
                                                                                                                          3 Word.word) =
                                                                                                                         ((subrange_vec_dec
                                                                                                                            v__9
                                                                                                                            (( 14 :: int)::ii)
                                                                                                                            (( 12 :: int)::ii)
                                                                                                                           ::  3 Word.word)) in
                                                                                                                       if
                                                                                                                         ((encdec_rounding_mode_backwards_matches
                                                                                                                             mappingpatterns_1150))
                                                                                                                       then
                                                                                                                         encdec_rounding_mode_backwards
                                                                                                                           mappingpatterns_1150 \<bind> ((\<lambda> rm . 
                                                                                                                         is_RV64D
                                                                                                                           () ))
                                                                                                                       else
                                                                                                                         return False))
                                                                                                                       (return ((((((((subrange_vec_dec
                                                                                                                                           v__9
                                                                                                                                           (( 31 :: int)::ii)
                                                                                                                                           (( 20 :: int)::ii)
                                                                                                                                          ::  12 Word.word)) = ( 0xC23 ::  12 Word.word)))) \<and> (((((subrange_vec_dec
                                                                                                                                           v__9
                                                                                                                                           (( 6 :: int)::ii)
                                                                                                                                           (( 0 :: int)::ii)
                                                                                                                                          ::  7 Word.word)) = ( 0b1010011 ::  7 Word.word)))))))) \<bind> ((\<lambda> (w__155 ::
                                                                                                                       bool) . 
                                                                                                                     if
                                                                                                                       w__155
                                                                                                                     then
                                                                                                                       (let (rs1 ::
                                                                                                                          5 Word.word) =
                                                                                                                         ((subrange_vec_dec
                                                                                                                            v__9
                                                                                                                            (( 19 :: int)::ii)
                                                                                                                            (( 15 :: int)::ii)
                                                                                                                           ::  5 Word.word)) in
                                                                                                                       (let (rd ::
                                                                                                                          5 Word.word) =
                                                                                                                         ((subrange_vec_dec
                                                                                                                            v__9
                                                                                                                            (( 11 :: int)::ii)
                                                                                                                            (( 7 :: int)::ii)
                                                                                                                           ::  5 Word.word)) in
                                                                                                                       (let (mappingpatterns_1150 ::
                                                                                                                          3 Word.word) =
                                                                                                                         ((subrange_vec_dec
                                                                                                                            v__9
                                                                                                                            (( 14 :: int)::ii)
                                                                                                                            (( 12 :: int)::ii)
                                                                                                                           ::  3 Word.word)) in
                                                                                                                       encdec_rounding_mode_backwards
                                                                                                                         mappingpatterns_1150 \<bind> ((\<lambda> rm . 
                                                                                                                       return (F_UN_RM_TYPE_D (rs1,
                                                                                                                                               rm,
                                                                                                                                               rd,
                                                                                                                                               FCVT_LU_D)))))))
                                                                                                                     else
                                                                                                                       and_boolM
                                                                                                                         ((let (mappingpatterns_1160 ::
                                                                                                                            3 Word.word) =
                                                                                                                           ((subrange_vec_dec
                                                                                                                              v__9
                                                                                                                              (( 14 :: int)::ii)
                                                                                                                              (( 12 :: int)::ii)
                                                                                                                             ::  3 Word.word)) in
                                                                                                                         if
                                                                                                                           ((encdec_rounding_mode_backwards_matches
                                                                                                                               mappingpatterns_1160))
                                                                                                                         then
                                                                                                                           encdec_rounding_mode_backwards
                                                                                                                             mappingpatterns_1160 \<bind> ((\<lambda> rm . 
                                                                                                                           is_RV64D
                                                                                                                             () ))
                                                                                                                         else
                                                                                                                           return False))
                                                                                                                         (return ((((((((subrange_vec_dec
                                                                                                                                             v__9
                                                                                                                                             (( 31 :: int)::ii)
                                                                                                                                             (( 20 :: int)::ii)
                                                                                                                                            ::  12 Word.word)) = ( 0xD22 ::  12 Word.word)))) \<and> (((((subrange_vec_dec
                                                                                                                                             v__9
                                                                                                                                             (( 6 :: int)::ii)
                                                                                                                                             (( 0 :: int)::ii)
                                                                                                                                            ::  7 Word.word)) = ( 0b1010011 ::  7 Word.word)))))))) \<bind> ((\<lambda> (w__158 ::
                                                                                                                         bool) . 
                                                                                                                       if
                                                                                                                         w__158
                                                                                                                       then
                                                                                                                         (let (rs1 ::
                                                                                                                            5 Word.word) =
                                                                                                                           ((subrange_vec_dec
                                                                                                                              v__9
                                                                                                                              (( 19 :: int)::ii)
                                                                                                                              (( 15 :: int)::ii)
                                                                                                                             ::  5 Word.word)) in
                                                                                                                         (let (rd ::
                                                                                                                            5 Word.word) =
                                                                                                                           ((subrange_vec_dec
                                                                                                                              v__9
                                                                                                                              (( 11 :: int)::ii)
                                                                                                                              (( 7 :: int)::ii)
                                                                                                                             ::  5 Word.word)) in
                                                                                                                         (let (mappingpatterns_1160 ::
                                                                                                                            3 Word.word) =
                                                                                                                           ((subrange_vec_dec
                                                                                                                              v__9
                                                                                                                              (( 14 :: int)::ii)
                                                                                                                              (( 12 :: int)::ii)
                                                                                                                             ::  3 Word.word)) in
                                                                                                                         encdec_rounding_mode_backwards
                                                                                                                           mappingpatterns_1160 \<bind> ((\<lambda> rm . 
                                                                                                                         return (F_UN_RM_TYPE_D (rs1,
                                                                                                                                                 rm,
                                                                                                                                                 rd,
                                                                                                                                                 FCVT_D_L)))))))
                                                                                                                       else
                                                                                                                         and_boolM
                                                                                                                           ((let (mappingpatterns_1170 ::
                                                                                                                              3 Word.word) =
                                                                                                                             ((subrange_vec_dec
                                                                                                                                v__9
                                                                                                                                (( 14 :: int)::ii)
                                                                                                                                (( 12 :: int)::ii)
                                                                                                                               ::  3 Word.word)) in
                                                                                                                           if
                                                                                                                             ((encdec_rounding_mode_backwards_matches
                                                                                                                                 mappingpatterns_1170))
                                                                                                                           then
                                                                                                                             encdec_rounding_mode_backwards
                                                                                                                               mappingpatterns_1170 \<bind> ((\<lambda> rm . 
                                                                                                                             is_RV64D
                                                                                                                               () ))
                                                                                                                           else
                                                                                                                             return False))
                                                                                                                           (return ((((((((subrange_vec_dec
                                                                                                                                               v__9
                                                                                                                                               (( 31 :: int)::ii)
                                                                                                                                               (( 20 :: int)::ii)
                                                                                                                                              ::  12 Word.word)) = ( 0xD23 ::  12 Word.word)))) \<and> (((((subrange_vec_dec
                                                                                                                                               v__9
                                                                                                                                               (( 6 :: int)::ii)
                                                                                                                                               (( 0 :: int)::ii)
                                                                                                                                              ::  7 Word.word)) = ( 0b1010011 ::  7 Word.word)))))))) \<bind> ((\<lambda> (w__161 ::
                                                                                                                           bool) . 
                                                                                                                         if
                                                                                                                           w__161
                                                                                                                         then
                                                                                                                           (let (rs1 ::
                                                                                                                              5 Word.word) =
                                                                                                                             ((subrange_vec_dec
                                                                                                                                v__9
                                                                                                                                (( 19 :: int)::ii)
                                                                                                                                (( 15 :: int)::ii)
                                                                                                                               ::  5 Word.word)) in
                                                                                                                           (let (rd ::
                                                                                                                              5 Word.word) =
                                                                                                                             ((subrange_vec_dec
                                                                                                                                v__9
                                                                                                                                (( 11 :: int)::ii)
                                                                                                                                (( 7 :: int)::ii)
                                                                                                                               ::  5 Word.word)) in
                                                                                                                           (let (mappingpatterns_1170 ::
                                                                                                                              3 Word.word) =
                                                                                                                             ((subrange_vec_dec
                                                                                                                                v__9
                                                                                                                                (( 14 :: int)::ii)
                                                                                                                                (( 12 :: int)::ii)
                                                                                                                               ::  3 Word.word)) in
                                                                                                                           encdec_rounding_mode_backwards
                                                                                                                             mappingpatterns_1170 \<bind> ((\<lambda> rm . 
                                                                                                                           return (F_UN_RM_TYPE_D (rs1,
                                                                                                                                                   rm,
                                                                                                                                                   rd,
                                                                                                                                                   FCVT_D_LU)))))))
                                                                                                                         else
                                                                                                                           and_boolM
                                                                                                                             ((is_RV32D_or_RV64D
                                                                                                                                 () ))
                                                                                                                             (return ((((((((subrange_vec_dec
                                                                                                                                                 v__9
                                                                                                                                                 (( 31 :: int)::ii)
                                                                                                                                                 (( 25 :: int)::ii)
                                                                                                                                                ::  7 Word.word)) = ( 0b0010001 ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec
                                                                                                                                                     v__9
                                                                                                                                                     (( 14 :: int)::ii)
                                                                                                                                                     (( 12 :: int)::ii)
                                                                                                                                                    ::  3 Word.word)) = ( 0b000 ::  3 Word.word)))) \<and> (((((subrange_vec_dec
                                                                                                                                                     v__9
                                                                                                                                                     (( 6 :: int)::ii)
                                                                                                                                                     (( 0 :: int)::ii)
                                                                                                                                                    ::  7 Word.word)) = ( 0b1010011 ::  7 Word.word))))))))))) \<bind> ((\<lambda> (w__163 ::
                                                                                                                             bool) . 
                                                                                                                           if
                                                                                                                             w__163
                                                                                                                           then
                                                                                                                             (let (rs2 ::
                                                                                                                                5 Word.word) =
                                                                                                                               ((subrange_vec_dec
                                                                                                                                  v__9
                                                                                                                                  (( 24 :: int)::ii)
                                                                                                                                  (( 20 :: int)::ii)
                                                                                                                                 ::  5 Word.word)) in
                                                                                                                             (let (rs1 ::
                                                                                                                                5 Word.word) =
                                                                                                                               ((subrange_vec_dec
                                                                                                                                  v__9
                                                                                                                                  (( 19 :: int)::ii)
                                                                                                                                  (( 15 :: int)::ii)
                                                                                                                                 ::  5 Word.word)) in
                                                                                                                             (let (rd ::
                                                                                                                                5 Word.word) =
                                                                                                                               ((subrange_vec_dec
                                                                                                                                  v__9
                                                                                                                                  (( 11 :: int)::ii)
                                                                                                                                  (( 7 :: int)::ii)
                                                                                                                                 ::  5 Word.word)) in
                                                                                                                             return (F_BIN_TYPE_D (rs2,
                                                                                                                                                   rs1,
                                                                                                                                                   rd,
                                                                                                                                                   FSGNJ_D)))))
                                                                                                                           else
                                                                                                                             and_boolM
                                                                                                                               ((is_RV32D_or_RV64D
                                                                                                                                   () ))
                                                                                                                               (return ((((((((subrange_vec_dec
                                                                                                                                                   v__9
                                                                                                                                                   (( 31 :: int)::ii)
                                                                                                                                                   (( 25 :: int)::ii)
                                                                                                                                                  ::  7 Word.word)) = ( 0b0010001 ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec
                                                                                                                                                       v__9
                                                                                                                                                       (( 14 :: int)::ii)
                                                                                                                                                       (( 12 :: int)::ii)
                                                                                                                                                      ::  3 Word.word)) = ( 0b001 ::  3 Word.word)))) \<and> (((((subrange_vec_dec
                                                                                                                                                       v__9
                                                                                                                                                       (( 6 :: int)::ii)
                                                                                                                                                       (( 0 :: int)::ii)
                                                                                                                                                      ::  7 Word.word)) = ( 0b1010011 ::  7 Word.word))))))))))) \<bind> ((\<lambda> (w__165 ::
                                                                                                                               bool) . 
                                                                                                                             if
                                                                                                                               w__165
                                                                                                                             then
                                                                                                                               (let (rs2 ::
                                                                                                                                  5 Word.word) =
                                                                                                                                 ((subrange_vec_dec
                                                                                                                                    v__9
                                                                                                                                    (( 24 :: int)::ii)
                                                                                                                                    (( 20 :: int)::ii)
                                                                                                                                   ::  5 Word.word)) in
                                                                                                                               (let (rs1 ::
                                                                                                                                  5 Word.word) =
                                                                                                                                 ((subrange_vec_dec
                                                                                                                                    v__9
                                                                                                                                    (( 19 :: int)::ii)
                                                                                                                                    (( 15 :: int)::ii)
                                                                                                                                   ::  5 Word.word)) in
                                                                                                                               (let (rd ::
                                                                                                                                  5 Word.word) =
                                                                                                                                 ((subrange_vec_dec
                                                                                                                                    v__9
                                                                                                                                    (( 11 :: int)::ii)
                                                                                                                                    (( 7 :: int)::ii)
                                                                                                                                   ::  5 Word.word)) in
                                                                                                                               return (F_BIN_TYPE_D (rs2,
                                                                                                                                                     rs1,
                                                                                                                                                     rd,
                                                                                                                                                     FSGNJN_D)))))
                                                                                                                             else
                                                                                                                               and_boolM
                                                                                                                                 ((is_RV32D_or_RV64D
                                                                                                                                     () ))
                                                                                                                                 (return ((((((((subrange_vec_dec
                                                                                                                                                     v__9
                                                                                                                                                     (( 31 :: int)::ii)
                                                                                                                                                     (( 25 :: int)::ii)
                                                                                                                                                    ::  7 Word.word)) = ( 0b0010001 ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec
                                                                                                                                                         v__9
                                                                                                                                                         (( 14 :: int)::ii)
                                                                                                                                                         (( 12 :: int)::ii)
                                                                                                                                                        ::  3 Word.word)) = ( 0b010 ::  3 Word.word)))) \<and> (((((subrange_vec_dec
                                                                                                                                                         v__9
                                                                                                                                                         (( 6 :: int)::ii)
                                                                                                                                                         (( 0 :: int)::ii)
                                                                                                                                                        ::  7 Word.word)) = ( 0b1010011 ::  7 Word.word))))))))))) \<bind> ((\<lambda> (w__167 ::
                                                                                                                                 bool) . 
                                                                                                                               if
                                                                                                                                 w__167
                                                                                                                               then
                                                                                                                                 (let (rs2 ::
                                                                                                                                    5 Word.word) =
                                                                                                                                   ((subrange_vec_dec
                                                                                                                                      v__9
                                                                                                                                      (( 24 :: int)::ii)
                                                                                                                                      (( 20 :: int)::ii)
                                                                                                                                     ::  5 Word.word)) in
                                                                                                                                 (let (rs1 ::
                                                                                                                                    5 Word.word) =
                                                                                                                                   ((subrange_vec_dec
                                                                                                                                      v__9
                                                                                                                                      (( 19 :: int)::ii)
                                                                                                                                      (( 15 :: int)::ii)
                                                                                                                                     ::  5 Word.word)) in
                                                                                                                                 (let (rd ::
                                                                                                                                    5 Word.word) =
                                                                                                                                   ((subrange_vec_dec
                                                                                                                                      v__9
                                                                                                                                      (( 11 :: int)::ii)
                                                                                                                                      (( 7 :: int)::ii)
                                                                                                                                     ::  5 Word.word)) in
                                                                                                                                 return (F_BIN_TYPE_D (rs2,
                                                                                                                                                       rs1,
                                                                                                                                                       rd,
                                                                                                                                                       FSGNJX_D)))))
                                                                                                                               else
                                                                                                                                 and_boolM
                                                                                                                                   ((is_RV32D_or_RV64D
                                                                                                                                       () ))
                                                                                                                                   (return ((((((((subrange_vec_dec
                                                                                                                                                       v__9
                                                                                                                                                       (( 31 :: int)::ii)
                                                                                                                                                       (( 25 :: int)::ii)
                                                                                                                                                      ::  7 Word.word)) = ( 0b0010101 ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec
                                                                                                                                                           v__9
                                                                                                                                                           (( 14 :: int)::ii)
                                                                                                                                                           (( 12 :: int)::ii)
                                                                                                                                                          ::  3 Word.word)) = ( 0b000 ::  3 Word.word)))) \<and> (((((subrange_vec_dec
                                                                                                                                                           v__9
                                                                                                                                                           (( 6 :: int)::ii)
                                                                                                                                                           (( 0 :: int)::ii)
                                                                                                                                                          ::  7 Word.word)) = ( 0b1010011 ::  7 Word.word))))))))))) \<bind> ((\<lambda> (w__169 ::
                                                                                                                                   bool) . 
                                                                                                                                 if
                                                                                                                                   w__169
                                                                                                                                 then
                                                                                                                                   (let (rs2 ::
                                                                                                                                      5 Word.word) =
                                                                                                                                     ((subrange_vec_dec
                                                                                                                                        v__9
                                                                                                                                        (( 24 :: int)::ii)
                                                                                                                                        (( 20 :: int)::ii)
                                                                                                                                       ::  5 Word.word)) in
                                                                                                                                   (let (rs1 ::
                                                                                                                                      5 Word.word) =
                                                                                                                                     ((subrange_vec_dec
                                                                                                                                        v__9
                                                                                                                                        (( 19 :: int)::ii)
                                                                                                                                        (( 15 :: int)::ii)
                                                                                                                                       ::  5 Word.word)) in
                                                                                                                                   (let (rd ::
                                                                                                                                      5 Word.word) =
                                                                                                                                     ((subrange_vec_dec
                                                                                                                                        v__9
                                                                                                                                        (( 11 :: int)::ii)
                                                                                                                                        (( 7 :: int)::ii)
                                                                                                                                       ::  5 Word.word)) in
                                                                                                                                   return (F_BIN_TYPE_D (rs2,
                                                                                                                                                         rs1,
                                                                                                                                                         rd,
                                                                                                                                                         FMIN_D)))))
                                                                                                                                 else
                                                                                                                                   and_boolM
                                                                                                                                     ((is_RV32D_or_RV64D
                                                                                                                                         () ))
                                                                                                                                     (return ((((((((subrange_vec_dec
                                                                                                                                                         v__9
                                                                                                                                                         (( 31 :: int)::ii)
                                                                                                                                                         (( 25 :: int)::ii)
                                                                                                                                                        ::  7 Word.word)) = ( 0b0010101 ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec
                                                                                                                                                             v__9
                                                                                                                                                             (( 14 :: int)::ii)
                                                                                                                                                             (( 12 :: int)::ii)
                                                                                                                                                            ::  3 Word.word)) = ( 0b001 ::  3 Word.word)))) \<and> (((((subrange_vec_dec
                                                                                                                                                             v__9
                                                                                                                                                             (( 6 :: int)::ii)
                                                                                                                                                             (( 0 :: int)::ii)
                                                                                                                                                            ::  7 Word.word)) = ( 0b1010011 ::  7 Word.word))))))))))) \<bind> ((\<lambda> (w__171 ::
                                                                                                                                     bool) . 
                                                                                                                                   if
                                                                                                                                     w__171
                                                                                                                                   then
                                                                                                                                     (let (rs2 ::
                                                                                                                                        5 Word.word) =
                                                                                                                                       ((subrange_vec_dec
                                                                                                                                          v__9
                                                                                                                                          (( 24 :: int)::ii)
                                                                                                                                          (( 20 :: int)::ii)
                                                                                                                                         ::  5 Word.word)) in
                                                                                                                                     (let (rs1 ::
                                                                                                                                        5 Word.word) =
                                                                                                                                       ((subrange_vec_dec
                                                                                                                                          v__9
                                                                                                                                          (( 19 :: int)::ii)
                                                                                                                                          (( 15 :: int)::ii)
                                                                                                                                         ::  5 Word.word)) in
                                                                                                                                     (let (rd ::
                                                                                                                                        5 Word.word) =
                                                                                                                                       ((subrange_vec_dec
                                                                                                                                          v__9
                                                                                                                                          (( 11 :: int)::ii)
                                                                                                                                          (( 7 :: int)::ii)
                                                                                                                                         ::  5 Word.word)) in
                                                                                                                                     return (F_BIN_TYPE_D (rs2,
                                                                                                                                                           rs1,
                                                                                                                                                           rd,
                                                                                                                                                           FMAX_D)))))
                                                                                                                                   else
                                                                                                                                     and_boolM
                                                                                                                                       ((is_RV32D_or_RV64D
                                                                                                                                           () ))
                                                                                                                                       (return ((((((((subrange_vec_dec
                                                                                                                                                           v__9
                                                                                                                                                           (( 31 :: int)::ii)
                                                                                                                                                           (( 25 :: int)::ii)
                                                                                                                                                          ::  7 Word.word)) = ( 0b1010001 ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec
                                                                                                                                                               v__9
                                                                                                                                                               (( 14 :: int)::ii)
                                                                                                                                                               (( 12 :: int)::ii)
                                                                                                                                                              ::  3 Word.word)) = ( 0b010 ::  3 Word.word)))) \<and> (((((subrange_vec_dec
                                                                                                                                                               v__9
                                                                                                                                                               (( 6 :: int)::ii)
                                                                                                                                                               (( 0 :: int)::ii)
                                                                                                                                                              ::  7 Word.word)) = ( 0b1010011 ::  7 Word.word))))))))))) \<bind> ((\<lambda> (w__173 ::
                                                                                                                                       bool) . 
                                                                                                                                     if
                                                                                                                                       w__173
                                                                                                                                     then
                                                                                                                                       (let (rs2 ::
                                                                                                                                          5 Word.word) =
                                                                                                                                         ((subrange_vec_dec
                                                                                                                                            v__9
                                                                                                                                            (( 24 :: int)::ii)
                                                                                                                                            (( 20 :: int)::ii)
                                                                                                                                           ::  5 Word.word)) in
                                                                                                                                       (let (rs1 ::
                                                                                                                                          5 Word.word) =
                                                                                                                                         ((subrange_vec_dec
                                                                                                                                            v__9
                                                                                                                                            (( 19 :: int)::ii)
                                                                                                                                            (( 15 :: int)::ii)
                                                                                                                                           ::  5 Word.word)) in
                                                                                                                                       (let (rd ::
                                                                                                                                          5 Word.word) =
                                                                                                                                         ((subrange_vec_dec
                                                                                                                                            v__9
                                                                                                                                            (( 11 :: int)::ii)
                                                                                                                                            (( 7 :: int)::ii)
                                                                                                                                           ::  5 Word.word)) in
                                                                                                                                       return (F_BIN_TYPE_D (rs2,
                                                                                                                                                             rs1,
                                                                                                                                                             rd,
                                                                                                                                                             FEQ_D)))))
                                                                                                                                     else
                                                                                                                                       and_boolM
                                                                                                                                         ((is_RV32D_or_RV64D
                                                                                                                                             () ))
                                                                                                                                         (return ((((((((subrange_vec_dec
                                                                                                                                                             v__9
                                                                                                                                                             (( 31 :: int)::ii)
                                                                                                                                                             (( 25 :: int)::ii)
                                                                                                                                                            ::  7 Word.word)) = ( 0b1010001 ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec
                                                                                                                                                                 v__9
                                                                                                                                                                 (( 14 :: int)::ii)
                                                                                                                                                                 (( 12 :: int)::ii)
                                                                                                                                                                ::  3 Word.word)) = ( 0b001 ::  3 Word.word)))) \<and> (((((subrange_vec_dec
                                                                                                                                                                 v__9
                                                                                                                                                                 (( 6 :: int)::ii)
                                                                                                                                                                 (( 0 :: int)::ii)
                                                                                                                                                                ::  7 Word.word)) = ( 0b1010011 ::  7 Word.word))))))))))) \<bind> ((\<lambda> (w__175 ::
                                                                                                                                         bool) . 
                                                                                                                                       if
                                                                                                                                         w__175
                                                                                                                                       then
                                                                                                                                         (let (rs2 ::
                                                                                                                                            5 Word.word) =
                                                                                                                                           ((subrange_vec_dec
                                                                                                                                              v__9
                                                                                                                                              (( 24 :: int)::ii)
                                                                                                                                              (( 20 :: int)::ii)
                                                                                                                                             ::  5 Word.word)) in
                                                                                                                                         (let (rs1 ::
                                                                                                                                            5 Word.word) =
                                                                                                                                           ((subrange_vec_dec
                                                                                                                                              v__9
                                                                                                                                              (( 19 :: int)::ii)
                                                                                                                                              (( 15 :: int)::ii)
                                                                                                                                             ::  5 Word.word)) in
                                                                                                                                         (let (rd ::
                                                                                                                                            5 Word.word) =
                                                                                                                                           ((subrange_vec_dec
                                                                                                                                              v__9
                                                                                                                                              (( 11 :: int)::ii)
                                                                                                                                              (( 7 :: int)::ii)
                                                                                                                                             ::  5 Word.word)) in
                                                                                                                                         return (F_BIN_TYPE_D (rs2,
                                                                                                                                                               rs1,
                                                                                                                                                               rd,
                                                                                                                                                               FLT_D)))))
                                                                                                                                       else
                                                                                                                                         and_boolM
                                                                                                                                           ((is_RV32D_or_RV64D
                                                                                                                                               () ))
                                                                                                                                           (return ((((((((subrange_vec_dec
                                                                                                                                                               v__9
                                                                                                                                                               (( 31 :: int)::ii)
                                                                                                                                                               (( 25 :: int)::ii)
                                                                                                                                                              ::  7 Word.word)) = ( 0b1010001 ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec
                                                                                                                                                                   v__9
                                                                                                                                                                   (( 14 :: int)::ii)
                                                                                                                                                                   (( 12 :: int)::ii)
                                                                                                                                                                  ::  3 Word.word)) = ( 0b000 ::  3 Word.word)))) \<and> (((((subrange_vec_dec
                                                                                                                                                                   v__9
                                                                                                                                                                   (( 6 :: int)::ii)
                                                                                                                                                                   (( 0 :: int)::ii)
                                                                                                                                                                  ::  7 Word.word)) = ( 0b1010011 ::  7 Word.word))))))))))) \<bind> ((\<lambda> (w__177 ::
                                                                                                                                           bool) . 
                                                                                                                                         if
                                                                                                                                           w__177
                                                                                                                                         then
                                                                                                                                           (let (rs2 ::
                                                                                                                                              5 Word.word) =
                                                                                                                                             ((subrange_vec_dec
                                                                                                                                                v__9
                                                                                                                                                (( 24 :: int)::ii)
                                                                                                                                                (( 20 :: int)::ii)
                                                                                                                                               ::  5 Word.word)) in
                                                                                                                                           (let (rs1 ::
                                                                                                                                              5 Word.word) =
                                                                                                                                             ((subrange_vec_dec
                                                                                                                                                v__9
                                                                                                                                                (( 19 :: int)::ii)
                                                                                                                                                (( 15 :: int)::ii)
                                                                                                                                               ::  5 Word.word)) in
                                                                                                                                           (let (rd ::
                                                                                                                                              5 Word.word) =
                                                                                                                                             ((subrange_vec_dec
                                                                                                                                                v__9
                                                                                                                                                (( 11 :: int)::ii)
                                                                                                                                                (( 7 :: int)::ii)
                                                                                                                                               ::  5 Word.word)) in
                                                                                                                                           return (F_BIN_TYPE_D (rs2,
                                                                                                                                                                 rs1,
                                                                                                                                                                 rd,
                                                                                                                                                                 FLE_D)))))
                                                                                                                                         else
                                                                                                                                           and_boolM
                                                                                                                                             ((haveDExt
                                                                                                                                                 () ))
                                                                                                                                             (return ((((((((subrange_vec_dec
                                                                                                                                                                 v__9
                                                                                                                                                                 (( 31 :: int)::ii)
                                                                                                                                                                 (( 20 :: int)::ii)
                                                                                                                                                                ::  12 Word.word)) = ( 0xE20 ::  12 Word.word)))) \<and> ((((((((subrange_vec_dec
                                                                                                                                                                     v__9
                                                                                                                                                                     (( 14 :: int)::ii)
                                                                                                                                                                     (( 12 :: int)::ii)
                                                                                                                                                                    ::  3 Word.word)) = ( 0b001 ::  3 Word.word)))) \<and> (((((subrange_vec_dec
                                                                                                                                                                     v__9
                                                                                                                                                                     (( 6 :: int)::ii)
                                                                                                                                                                     (( 0 :: int)::ii)
                                                                                                                                                                    ::  7 Word.word)) = ( 0b1010011 ::  7 Word.word))))))))))) \<bind> ((\<lambda> (w__179 ::
                                                                                                                                             bool) . 
                                                                                                                                           if
                                                                                                                                             w__179
                                                                                                                                           then
                                                                                                                                             (let (rs1 ::
                                                                                                                                                5 Word.word) =
                                                                                                                                               ((subrange_vec_dec
                                                                                                                                                  v__9
                                                                                                                                                  (( 19 :: int)::ii)
                                                                                                                                                  (( 15 :: int)::ii)
                                                                                                                                                 ::  5 Word.word)) in
                                                                                                                                             (let (rd ::
                                                                                                                                                5 Word.word) =
                                                                                                                                               ((subrange_vec_dec
                                                                                                                                                  v__9
                                                                                                                                                  (( 11 :: int)::ii)
                                                                                                                                                  (( 7 :: int)::ii)
                                                                                                                                                 ::  5 Word.word)) in
                                                                                                                                             return (F_UN_TYPE_D (rs1,
                                                                                                                                                                  rd,
                                                                                                                                                                  FCLASS_D))))
                                                                                                                                           else
                                                                                                                                             and_boolM
                                                                                                                                               ((is_RV64D
                                                                                                                                                   () ))
                                                                                                                                               (return ((((((((subrange_vec_dec
                                                                                                                                                                   v__9
                                                                                                                                                                   (( 31 :: int)::ii)
                                                                                                                                                                   (( 20 :: int)::ii)
                                                                                                                                                                  ::  12 Word.word)) = ( 0xE20 ::  12 Word.word)))) \<and> ((((((((subrange_vec_dec
                                                                                                                                                                       v__9
                                                                                                                                                                       (( 14 :: int)::ii)
                                                                                                                                                                       (( 12 :: int)::ii)
                                                                                                                                                                      ::  3 Word.word)) = ( 0b000 ::  3 Word.word)))) \<and> (((((subrange_vec_dec
                                                                                                                                                                       v__9
                                                                                                                                                                       (( 6 :: int)::ii)
                                                                                                                                                                       (( 0 :: int)::ii)
                                                                                                                                                                      ::  7 Word.word)) = ( 0b1010011 ::  7 Word.word))))))))))) \<bind> ((\<lambda> (w__181 ::
                                                                                                                                               bool) . 
                                                                                                                                             if
                                                                                                                                               w__181
                                                                                                                                             then
                                                                                                                                               (let (rs1 ::
                                                                                                                                                  5 Word.word) =
                                                                                                                                                 ((subrange_vec_dec
                                                                                                                                                    v__9
                                                                                                                                                    (( 19 :: int)::ii)
                                                                                                                                                    (( 15 :: int)::ii)
                                                                                                                                                   ::  5 Word.word)) in
                                                                                                                                               (let (rd ::
                                                                                                                                                  5 Word.word) =
                                                                                                                                                 ((subrange_vec_dec
                                                                                                                                                    v__9
                                                                                                                                                    (( 11 :: int)::ii)
                                                                                                                                                    (( 7 :: int)::ii)
                                                                                                                                                   ::  5 Word.word)) in
                                                                                                                                               return (F_UN_TYPE_D (rs1,
                                                                                                                                                                    rd,
                                                                                                                                                                    FMV_X_D))))
                                                                                                                                             else
                                                                                                                                               and_boolM
                                                                                                                                                 ((is_RV64D
                                                                                                                                                     () ))
                                                                                                                                                 (return ((((((((subrange_vec_dec
                                                                                                                                                                     v__9
                                                                                                                                                                     (( 31 :: int)::ii)
                                                                                                                                                                     (( 20 :: int)::ii)
                                                                                                                                                                    ::  12 Word.word)) = ( 0xF20 ::  12 Word.word)))) \<and> ((((((((subrange_vec_dec
                                                                                                                                                                         v__9
                                                                                                                                                                         (( 14 :: int)::ii)
                                                                                                                                                                         (( 12 :: int)::ii)
                                                                                                                                                                        ::  3 Word.word)) = ( 0b000 ::  3 Word.word)))) \<and> (((((subrange_vec_dec
                                                                                                                                                                         v__9
                                                                                                                                                                         (( 6 :: int)::ii)
                                                                                                                                                                         (( 0 :: int)::ii)
                                                                                                                                                                        ::  7 Word.word)) = ( 0b1010011 ::  7 Word.word))))))))))) \<bind> ((\<lambda> (w__183 ::
                                                                                                                                                 bool) . 
                                                                                                                                               return (if
                                                                                                                                                         w__183
                                                                                                                                                       then
                                                                                                                                                         (let (rs1 ::
                                                                                                                                                            5 Word.word) =
                                                                                                                                                           ((subrange_vec_dec
                                                                                                                                                              v__9
                                                                                                                                                              (( 19 :: int)::ii)
                                                                                                                                                              (( 15 :: int)::ii)
                                                                                                                                                             ::  5 Word.word)) in
                                                                                                                                                         (let (rd ::
                                                                                                                                                            5 Word.word) =
                                                                                                                                                           ((subrange_vec_dec
                                                                                                                                                              v__9
                                                                                                                                                              (( 11 :: int)::ii)
                                                                                                                                                              (( 7 :: int)::ii)
                                                                                                                                                             ::  5 Word.word)) in
                                                                                                                                                         F_UN_TYPE_D (rs1,
                                                                                                                                                                      rd,
                                                                                                                                                                      FMV_D_X)))
                                                                                                                                                       else
                                                                                                                                                         ILLEGAL v__9)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))\<close> 
  for  arg1  :: "(32)Word.word "


definition encdec_forwards_matches  :: \<open> ast \<Rightarrow>((register_value),(bool),(exception))monad \<close>  where 
     \<open> encdec_forwards_matches ast = (
   (let arg1 = ast in
   (case  arg1 of
     UTYPE ((imm, rd, op1)) => return True
   | RISCV_JAL ((v__462, rd)) =>
      return (if (((((subrange_vec_dec v__462 (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) = ( 0b0 ::  1 Word.word))))
              then
                True
              else False)
   | RISCV_JALR ((imm, rs1, rd)) => return True
   | BTYPE ((v__464, rs2, rs1, op1)) =>
      return (if (((((subrange_vec_dec v__464 (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) = ( 0b0 ::  1 Word.word))))
              then
                True
              else False)
   | ITYPE ((imm, rs1, rd, op1)) => return True
   | SHIFTIOP ((shamt, rs1, rd, RISCV_SLLI)) => return True
   | SHIFTIOP ((shamt, rs1, rd, RISCV_SRLI)) => return True
   | SHIFTIOP ((shamt, rs1, rd, RISCV_SRAI)) => return True
   | RTYPE ((rs2, rs1, rd, RISCV_ADD)) => return True
   | RTYPE ((rs2, rs1, rd, RISCV_SLT)) => return True
   | RTYPE ((rs2, rs1, rd, RISCV_SLTU)) => return True
   | RTYPE ((rs2, rs1, rd, RISCV_AND)) => return True
   | RTYPE ((rs2, rs1, rd, RISCV_OR)) => return True
   | RTYPE ((rs2, rs1, rd, RISCV_XOR)) => return True
   | RTYPE ((rs2, rs1, rd, RISCV_SLL)) => return True
   | RTYPE ((rs2, rs1, rd, RISCV_SRL)) => return True
   | RTYPE ((rs2, rs1, rd, RISCV_SUB)) => return True
   | RTYPE ((rs2, rs1, rd, RISCV_SRA)) => return True
   | LOAD ((imm, rs1, rd, is_unsigned, size1, False, False)) =>
      return (if (((((((word_width_bytes size1)) < (( 8 :: int)::ii))) \<or> (((((\<not> is_unsigned)) \<and> ((((word_width_bytes size1)) \<le> (( 8 :: int)::ii)))))))))
              then
                True
              else False)
   | STORE ((v__466, rs2, rs1, size1, False, False)) =>
      return (if ((((word_width_bytes size1)) \<le> (( 8 :: int)::ii))) then True else False)
   | ADDIW ((imm, rs1, rd)) => return (if ((((( 64 :: int)::ii) = (( 64 :: int)::ii)))) then True else False)
   | SHIFTW ((shamt, rs1, rd, RISCV_SLLI)) =>
      return (if ((((( 64 :: int)::ii) = (( 64 :: int)::ii)))) then True else False)
   | SHIFTW ((shamt, rs1, rd, RISCV_SRLI)) =>
      return (if ((((( 64 :: int)::ii) = (( 64 :: int)::ii)))) then True else False)
   | SHIFTW ((shamt, rs1, rd, RISCV_SRAI)) =>
      return (if ((((( 64 :: int)::ii) = (( 64 :: int)::ii)))) then True else False)
   | RTYPEW ((rs2, rs1, rd, RISCV_ADDW)) => return (if ((((( 64 :: int)::ii) = (( 64 :: int)::ii)))) then True else False)
   | RTYPEW ((rs2, rs1, rd, RISCV_SUBW)) => return (if ((((( 64 :: int)::ii) = (( 64 :: int)::ii)))) then True else False)
   | RTYPEW ((rs2, rs1, rd, RISCV_SLLW)) => return (if ((((( 64 :: int)::ii) = (( 64 :: int)::ii)))) then True else False)
   | RTYPEW ((rs2, rs1, rd, RISCV_SRLW)) => return (if ((((( 64 :: int)::ii) = (( 64 :: int)::ii)))) then True else False)
   | RTYPEW ((rs2, rs1, rd, RISCV_SRAW)) => return (if ((((( 64 :: int)::ii) = (( 64 :: int)::ii)))) then True else False)
   | SHIFTIWOP ((shamt, rs1, rd, RISCV_SLLIW)) =>
      return (if ((((( 64 :: int)::ii) = (( 64 :: int)::ii)))) then True else False)
   | SHIFTIWOP ((shamt, rs1, rd, RISCV_SRLIW)) =>
      return (if ((((( 64 :: int)::ii) = (( 64 :: int)::ii)))) then True else False)
   | SHIFTIWOP ((shamt, rs1, rd, RISCV_SRAIW)) =>
      return (if ((((( 64 :: int)::ii) = (( 64 :: int)::ii)))) then True else False)
   | FENCE ((pred, succ)) => return True
   | FENCE_TSO ((pred, succ)) => return True
   | FENCEI (_) => return True
   | ECALL (_) => return True
   | MRET (_) => return True
   | SRET (_) => return True
   | EBREAK (_) => return True
   | WFI (_) => return True
   | SFENCE_VMA ((rs1, rs2)) => return True
   | LOADRES ((aq, rl, rs1, size1, rd)) => return (if ((amo_width_valid size1)) then True else False)
   | STORECON ((aq, rl, rs2, rs1, size1, rd)) =>
      return (if ((amo_width_valid size1)) then True else False)
   | AMO ((op1, aq, rl, rs2, rs1, size1, rd)) =>
      return (if ((amo_width_valid size1)) then True else False)
   | MUL ((rs2, rs1, rd, high, signed1, signed2)) => return True
   | DIV ((rs2, rs1, rd, s)) => return True
   | REM ((rs2, rs1, rd, s)) => return True
   | MULW ((rs2, rs1, rd)) => return (if ((((( 64 :: int)::ii) = (( 64 :: int)::ii)))) then True else False)
   | DIVW ((rs2, rs1, rd, s)) => return (if ((((( 64 :: int)::ii) = (( 64 :: int)::ii)))) then True else False)
   | REMW ((rs2, rs1, rd, s)) => return (if ((((( 64 :: int)::ii) = (( 64 :: int)::ii)))) then True else False)
   | CSR ((csr, rs1, rd, is_imm, op1)) => return True
   | URET (_) => return True
   | FENCE_RESERVED ((fm, pred, succ, rs, rd)) =>
      return (if (((((((((fm \<noteq> ( 0x0 ::  4 Word.word)))) \<and> (((fm \<noteq> ( 0x8 ::  4 Word.word))))))) \<or> ((((((rs \<noteq> ( 0b00000 ::  5 Word.word)))) \<or> (((rd \<noteq> ( 0b00000 ::  5 Word.word)))))))))) then
                True
              else False)
   | FENCEI_RESERVED ((imm, rs, rd)) =>
      return (if ((((((imm \<noteq> ( 0x000 ::  12 Word.word)))) \<or> ((((((rs \<noteq> zreg))) \<or> (((rd \<noteq> zreg))))))))) then
                True
              else False)
   | LOAD_FP ((imm, rs1, rd, WORD)) =>
      is_RV32F_or_RV64F ()  \<bind> ((\<lambda> (w__0 :: bool) .  return (if w__0 then True else False)))
   | LOAD_FP ((imm, rs1, rd, DOUBLE)) =>
      is_RV32D_or_RV64D ()  \<bind> ((\<lambda> (w__1 :: bool) .  return (if w__1 then True else False)))
   | STORE_FP ((v__467, rs2, rs1, WORD)) =>
      is_RV32F_or_RV64F ()  \<bind> ((\<lambda> (w__2 :: bool) .  return (if w__2 then True else False)))
   | STORE_FP ((v__468, rs2, rs1, DOUBLE)) =>
      is_RV32D_or_RV64D ()  \<bind> ((\<lambda> (w__3 :: bool) .  return (if w__3 then True else False)))
   | F_MADD_TYPE_S ((rs3, rs2, rs1, rm, rd, FMADD_S)) =>
      is_RV32F_or_RV64F ()  \<bind> ((\<lambda> (w__4 :: bool) .  return (if w__4 then True else False)))
   | F_MADD_TYPE_S ((rs3, rs2, rs1, rm, rd, FMSUB_S)) =>
      is_RV32F_or_RV64F ()  \<bind> ((\<lambda> (w__5 :: bool) .  return (if w__5 then True else False)))
   | F_MADD_TYPE_S ((rs3, rs2, rs1, rm, rd, FNMSUB_S)) =>
      is_RV32F_or_RV64F ()  \<bind> ((\<lambda> (w__6 :: bool) .  return (if w__6 then True else False)))
   | F_MADD_TYPE_S ((rs3, rs2, rs1, rm, rd, FNMADD_S)) =>
      is_RV32F_or_RV64F ()  \<bind> ((\<lambda> (w__7 :: bool) .  return (if w__7 then True else False)))
   | F_BIN_RM_TYPE_S ((rs2, rs1, rm, rd, FADD_S)) =>
      is_RV32F_or_RV64F ()  \<bind> ((\<lambda> (w__8 :: bool) .  return (if w__8 then True else False)))
   | F_BIN_RM_TYPE_S ((rs2, rs1, rm, rd, FSUB_S)) =>
      is_RV32F_or_RV64F ()  \<bind> ((\<lambda> (w__9 :: bool) .  return (if w__9 then True else False)))
   | F_BIN_RM_TYPE_S ((rs2, rs1, rm, rd, FMUL_S)) =>
      is_RV32F_or_RV64F ()  \<bind> ((\<lambda> (w__10 :: bool) .  return (if w__10 then True else False)))
   | F_BIN_RM_TYPE_S ((rs2, rs1, rm, rd, FDIV_S)) =>
      is_RV32F_or_RV64F ()  \<bind> ((\<lambda> (w__11 :: bool) .  return (if w__11 then True else False)))
   | F_UN_RM_TYPE_S ((rs1, rm, rd, FSQRT_S)) =>
      is_RV32F_or_RV64F ()  \<bind> ((\<lambda> (w__12 :: bool) .  return (if w__12 then True else False)))
   | F_UN_RM_TYPE_S ((rs1, rm, rd, FCVT_W_S)) =>
      is_RV32F_or_RV64F ()  \<bind> ((\<lambda> (w__13 :: bool) .  return (if w__13 then True else False)))
   | F_UN_RM_TYPE_S ((rs1, rm, rd, FCVT_WU_S)) =>
      is_RV32F_or_RV64F ()  \<bind> ((\<lambda> (w__14 :: bool) .  return (if w__14 then True else False)))
   | F_UN_RM_TYPE_S ((rs1, rm, rd, FCVT_S_W)) =>
      is_RV32F_or_RV64F ()  \<bind> ((\<lambda> (w__15 :: bool) .  return (if w__15 then True else False)))
   | F_UN_RM_TYPE_S ((rs1, rm, rd, FCVT_S_WU)) =>
      is_RV32F_or_RV64F ()  \<bind> ((\<lambda> (w__16 :: bool) .  return (if w__16 then True else False)))
   | F_UN_RM_TYPE_S ((rs1, rm, rd, FCVT_L_S)) =>
      is_RV64F ()  \<bind> ((\<lambda> (w__17 :: bool) .  return (if w__17 then True else False)))
   | F_UN_RM_TYPE_S ((rs1, rm, rd, FCVT_LU_S)) =>
      is_RV64F ()  \<bind> ((\<lambda> (w__18 :: bool) .  return (if w__18 then True else False)))
   | F_UN_RM_TYPE_S ((rs1, rm, rd, FCVT_S_L)) =>
      is_RV64F ()  \<bind> ((\<lambda> (w__19 :: bool) .  return (if w__19 then True else False)))
   | F_UN_RM_TYPE_S ((rs1, rm, rd, FCVT_S_LU)) =>
      is_RV64F ()  \<bind> ((\<lambda> (w__20 :: bool) .  return (if w__20 then True else False)))
   | F_BIN_TYPE_S ((rs2, rs1, rd, FSGNJ_S)) =>
      is_RV32F_or_RV64F ()  \<bind> ((\<lambda> (w__21 :: bool) .  return (if w__21 then True else False)))
   | F_BIN_TYPE_S ((rs2, rs1, rd, FSGNJN_S)) =>
      is_RV32F_or_RV64F ()  \<bind> ((\<lambda> (w__22 :: bool) .  return (if w__22 then True else False)))
   | F_BIN_TYPE_S ((rs2, rs1, rd, FSGNJX_S)) =>
      is_RV32F_or_RV64F ()  \<bind> ((\<lambda> (w__23 :: bool) .  return (if w__23 then True else False)))
   | F_BIN_TYPE_S ((rs2, rs1, rd, FMIN_S)) =>
      is_RV32F_or_RV64F ()  \<bind> ((\<lambda> (w__24 :: bool) .  return (if w__24 then True else False)))
   | F_BIN_TYPE_S ((rs2, rs1, rd, FMAX_S)) =>
      is_RV32F_or_RV64F ()  \<bind> ((\<lambda> (w__25 :: bool) .  return (if w__25 then True else False)))
   | F_BIN_TYPE_S ((rs2, rs1, rd, FEQ_S)) =>
      is_RV32F_or_RV64F ()  \<bind> ((\<lambda> (w__26 :: bool) .  return (if w__26 then True else False)))
   | F_BIN_TYPE_S ((rs2, rs1, rd, FLT_S)) =>
      is_RV32F_or_RV64F ()  \<bind> ((\<lambda> (w__27 :: bool) .  return (if w__27 then True else False)))
   | F_BIN_TYPE_S ((rs2, rs1, rd, FLE_S)) =>
      is_RV32F_or_RV64F ()  \<bind> ((\<lambda> (w__28 :: bool) .  return (if w__28 then True else False)))
   | F_UN_TYPE_S ((rs1, rd, FCLASS_S)) =>
      haveFExt ()  \<bind> ((\<lambda> (w__29 :: bool) .  return (if w__29 then True else False)))
   | F_UN_TYPE_S ((rs1, rd, FMV_X_W)) =>
      haveFExt ()  \<bind> ((\<lambda> (w__30 :: bool) .  return (if w__30 then True else False)))
   | F_UN_TYPE_S ((rs1, rd, FMV_W_X)) =>
      haveFExt ()  \<bind> ((\<lambda> (w__31 :: bool) .  return (if w__31 then True else False)))
   | F_MADD_TYPE_D ((rs3, rs2, rs1, rm, rd, FMADD_D)) =>
      is_RV32D_or_RV64D ()  \<bind> ((\<lambda> (w__32 :: bool) .  return (if w__32 then True else False)))
   | F_MADD_TYPE_D ((rs3, rs2, rs1, rm, rd, FMSUB_D)) =>
      is_RV32D_or_RV64D ()  \<bind> ((\<lambda> (w__33 :: bool) .  return (if w__33 then True else False)))
   | F_MADD_TYPE_D ((rs3, rs2, rs1, rm, rd, FNMSUB_D)) =>
      is_RV32D_or_RV64D ()  \<bind> ((\<lambda> (w__34 :: bool) .  return (if w__34 then True else False)))
   | F_MADD_TYPE_D ((rs3, rs2, rs1, rm, rd, FNMADD_D)) =>
      is_RV32D_or_RV64D ()  \<bind> ((\<lambda> (w__35 :: bool) .  return (if w__35 then True else False)))
   | F_BIN_RM_TYPE_D ((rs2, rs1, rm, rd, FADD_D)) =>
      is_RV32D_or_RV64D ()  \<bind> ((\<lambda> (w__36 :: bool) .  return (if w__36 then True else False)))
   | F_BIN_RM_TYPE_D ((rs2, rs1, rm, rd, FSUB_D)) =>
      is_RV32D_or_RV64D ()  \<bind> ((\<lambda> (w__37 :: bool) .  return (if w__37 then True else False)))
   | F_BIN_RM_TYPE_D ((rs2, rs1, rm, rd, FMUL_D)) =>
      is_RV32D_or_RV64D ()  \<bind> ((\<lambda> (w__38 :: bool) .  return (if w__38 then True else False)))
   | F_BIN_RM_TYPE_D ((rs2, rs1, rm, rd, FDIV_D)) =>
      is_RV32D_or_RV64D ()  \<bind> ((\<lambda> (w__39 :: bool) .  return (if w__39 then True else False)))
   | F_UN_RM_TYPE_D ((rs1, rm, rd, FSQRT_D)) =>
      is_RV32D_or_RV64D ()  \<bind> ((\<lambda> (w__40 :: bool) .  return (if w__40 then True else False)))
   | F_UN_RM_TYPE_D ((rs1, rm, rd, FCVT_W_D)) =>
      is_RV32D_or_RV64D ()  \<bind> ((\<lambda> (w__41 :: bool) .  return (if w__41 then True else False)))
   | F_UN_RM_TYPE_D ((rs1, rm, rd, FCVT_WU_D)) =>
      is_RV32D_or_RV64D ()  \<bind> ((\<lambda> (w__42 :: bool) .  return (if w__42 then True else False)))
   | F_UN_RM_TYPE_D ((rs1, rm, rd, FCVT_D_W)) =>
      is_RV32D_or_RV64D ()  \<bind> ((\<lambda> (w__43 :: bool) .  return (if w__43 then True else False)))
   | F_UN_RM_TYPE_D ((rs1, rm, rd, FCVT_D_WU)) =>
      is_RV32D_or_RV64D ()  \<bind> ((\<lambda> (w__44 :: bool) .  return (if w__44 then True else False)))
   | F_UN_RM_TYPE_D ((rs1, rm, rd, FCVT_S_D)) =>
      is_RV32D_or_RV64D ()  \<bind> ((\<lambda> (w__45 :: bool) .  return (if w__45 then True else False)))
   | F_UN_RM_TYPE_D ((rs1, rm, rd, FCVT_D_S)) =>
      is_RV32D_or_RV64D ()  \<bind> ((\<lambda> (w__46 :: bool) .  return (if w__46 then True else False)))
   | F_UN_RM_TYPE_D ((rs1, rm, rd, FCVT_L_D)) =>
      is_RV64D ()  \<bind> ((\<lambda> (w__47 :: bool) .  return (if w__47 then True else False)))
   | F_UN_RM_TYPE_D ((rs1, rm, rd, FCVT_LU_D)) =>
      is_RV64D ()  \<bind> ((\<lambda> (w__48 :: bool) .  return (if w__48 then True else False)))
   | F_UN_RM_TYPE_D ((rs1, rm, rd, FCVT_D_L)) =>
      is_RV64D ()  \<bind> ((\<lambda> (w__49 :: bool) .  return (if w__49 then True else False)))
   | F_UN_RM_TYPE_D ((rs1, rm, rd, FCVT_D_LU)) =>
      is_RV64D ()  \<bind> ((\<lambda> (w__50 :: bool) .  return (if w__50 then True else False)))
   | F_BIN_TYPE_D ((rs2, rs1, rd, FSGNJ_D)) =>
      is_RV32D_or_RV64D ()  \<bind> ((\<lambda> (w__51 :: bool) .  return (if w__51 then True else False)))
   | F_BIN_TYPE_D ((rs2, rs1, rd, FSGNJN_D)) =>
      is_RV32D_or_RV64D ()  \<bind> ((\<lambda> (w__52 :: bool) .  return (if w__52 then True else False)))
   | F_BIN_TYPE_D ((rs2, rs1, rd, FSGNJX_D)) =>
      is_RV32D_or_RV64D ()  \<bind> ((\<lambda> (w__53 :: bool) .  return (if w__53 then True else False)))
   | F_BIN_TYPE_D ((rs2, rs1, rd, FMIN_D)) =>
      is_RV32D_or_RV64D ()  \<bind> ((\<lambda> (w__54 :: bool) .  return (if w__54 then True else False)))
   | F_BIN_TYPE_D ((rs2, rs1, rd, FMAX_D)) =>
      is_RV32D_or_RV64D ()  \<bind> ((\<lambda> (w__55 :: bool) .  return (if w__55 then True else False)))
   | F_BIN_TYPE_D ((rs2, rs1, rd, FEQ_D)) =>
      is_RV32D_or_RV64D ()  \<bind> ((\<lambda> (w__56 :: bool) .  return (if w__56 then True else False)))
   | F_BIN_TYPE_D ((rs2, rs1, rd, FLT_D)) =>
      is_RV32D_or_RV64D ()  \<bind> ((\<lambda> (w__57 :: bool) .  return (if w__57 then True else False)))
   | F_BIN_TYPE_D ((rs2, rs1, rd, FLE_D)) =>
      is_RV32D_or_RV64D ()  \<bind> ((\<lambda> (w__58 :: bool) .  return (if w__58 then True else False)))
   | F_UN_TYPE_D ((rs1, rd, FCLASS_D)) =>
      haveDExt ()  \<bind> ((\<lambda> (w__59 :: bool) .  return (if w__59 then True else False)))
   | F_UN_TYPE_D ((rs1, rd, FMV_X_D)) =>
      is_RV64D ()  \<bind> ((\<lambda> (w__60 :: bool) .  return (if w__60 then True else False)))
   | F_UN_TYPE_D ((rs1, rd, FMV_D_X)) =>
      is_RV64D ()  \<bind> ((\<lambda> (w__61 :: bool) .  return (if w__61 then True else False)))
   | ILLEGAL (s) => return True
   | _ => return False
   )))\<close> 
  for  ast  :: " ast "


definition encdec_backwards_matches  :: \<open>(32)Word.word \<Rightarrow>((register_value),(bool),(exception))monad \<close>  where 
     \<open> encdec_backwards_matches arg1 = (
   (let v__469 = arg1 in
   if ((let (mappingpatterns_00 ::  7 Word.word) = ((subrange_vec_dec v__469 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) in
     encdec_uop_backwards_matches mappingpatterns_00)) then
     (let (mappingpatterns_00 ::  7 Word.word) = ((subrange_vec_dec v__469 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) in
     encdec_uop_backwards mappingpatterns_00 \<bind> ((\<lambda> op1 .  return True)))
   else if (((((subrange_vec_dec v__469 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b1101111 ::  7 Word.word))))
   then
     return True
   else if ((((((((subrange_vec_dec v__469 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = ( 0b000 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__469 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b1100111 ::  7 Word.word))))))) then
     return True
   else if (((((let (mappingpatterns_10 ::  3 Word.word) =
                 ((subrange_vec_dec v__469 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) in
               encdec_bop_backwards_matches mappingpatterns_10)) \<and> (((((subrange_vec_dec v__469 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b1100011 ::  7 Word.word))))))) then
     (let (mappingpatterns_10 ::  3 Word.word) = ((subrange_vec_dec v__469 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) in
     encdec_bop_backwards mappingpatterns_10 \<bind> ((\<lambda> op1 .  return True)))
   else if (((((let (mappingpatterns_20 ::  3 Word.word) =
                 ((subrange_vec_dec v__469 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) in
               encdec_iop_backwards_matches mappingpatterns_20)) \<and> (((((subrange_vec_dec v__469 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b0010011 ::  7 Word.word))))))) then
     (let (mappingpatterns_20 ::  3 Word.word) = ((subrange_vec_dec v__469 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) in
     encdec_iop_backwards mappingpatterns_20 \<bind> ((\<lambda> op1 .  return True)))
   else if (((((let (shamt ::  6 Word.word) = ((subrange_vec_dec v__469 (( 25 :: int)::ii) (( 20 :: int)::ii)  ::  6 Word.word)) in
               (((((( 64 :: int)::ii) = (( 64 :: int)::ii)))) \<or> (((((access_vec_dec shamt (( 5 :: int)::ii))) = B0)))))) \<and> ((((((((subrange_vec_dec v__469 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b000000 ::  6 Word.word)))) \<and> ((((((((subrange_vec_dec v__469 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = ( 0b001 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__469 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b0010011 ::  7 Word.word))))))))))))) then
     return True
   else if (((((let (shamt ::  6 Word.word) = ((subrange_vec_dec v__469 (( 25 :: int)::ii) (( 20 :: int)::ii)  ::  6 Word.word)) in
               (((((( 64 :: int)::ii) = (( 64 :: int)::ii)))) \<or> (((((access_vec_dec shamt (( 5 :: int)::ii))) = B0)))))) \<and> ((((((((subrange_vec_dec v__469 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b000000 ::  6 Word.word)))) \<and> ((((((((subrange_vec_dec v__469 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = ( 0b101 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__469 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b0010011 ::  7 Word.word))))))))))))) then
     return True
   else if (((((let (shamt ::  6 Word.word) = ((subrange_vec_dec v__469 (( 25 :: int)::ii) (( 20 :: int)::ii)  ::  6 Word.word)) in
               (((((( 64 :: int)::ii) = (( 64 :: int)::ii)))) \<or> (((((access_vec_dec shamt (( 5 :: int)::ii))) = B0)))))) \<and> ((((((((subrange_vec_dec v__469 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = ( 0b010000 ::  6 Word.word)))) \<and> ((((((((subrange_vec_dec v__469 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = ( 0b101 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__469 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b0010011 ::  7 Word.word))))))))))))) then
     return True
   else if ((((((((subrange_vec_dec v__469 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = ( 0b0000000 ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__469 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = ( 0b000 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__469 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b0110011 ::  7 Word.word)))))))))) then
     return True
   else if ((((((((subrange_vec_dec v__469 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = ( 0b0000000 ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__469 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = ( 0b010 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__469 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b0110011 ::  7 Word.word)))))))))) then
     return True
   else if ((((((((subrange_vec_dec v__469 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = ( 0b0000000 ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__469 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = ( 0b011 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__469 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b0110011 ::  7 Word.word)))))))))) then
     return True
   else if ((((((((subrange_vec_dec v__469 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = ( 0b0000000 ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__469 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = ( 0b111 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__469 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b0110011 ::  7 Word.word)))))))))) then
     return True
   else if ((((((((subrange_vec_dec v__469 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = ( 0b0000000 ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__469 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = ( 0b110 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__469 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b0110011 ::  7 Word.word)))))))))) then
     return True
   else if ((((((((subrange_vec_dec v__469 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = ( 0b0000000 ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__469 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = ( 0b100 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__469 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b0110011 ::  7 Word.word)))))))))) then
     return True
   else if ((((((((subrange_vec_dec v__469 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = ( 0b0000000 ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__469 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = ( 0b001 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__469 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b0110011 ::  7 Word.word)))))))))) then
     return True
   else if ((((((((subrange_vec_dec v__469 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = ( 0b0000000 ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__469 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = ( 0b101 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__469 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b0110011 ::  7 Word.word)))))))))) then
     return True
   else if ((((((((subrange_vec_dec v__469 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = ( 0b0100000 ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__469 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = ( 0b000 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__469 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b0110011 ::  7 Word.word)))))))))) then
     return True
   else if ((((((((subrange_vec_dec v__469 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = ( 0b0100000 ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__469 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = ( 0b101 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__469 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b0110011 ::  7 Word.word)))))))))) then
     return True
   else
     and_boolM
       ((let (mappingpatterns_40 ::  2 Word.word) =
         ((subrange_vec_dec v__469 (( 13 :: int)::ii) (( 12 :: int)::ii)  ::  2 Word.word)) in
       (let (mappingpatterns_30 ::  1 Word.word) =
         ((subrange_vec_dec v__469 (( 14 :: int)::ii) (( 14 :: int)::ii)  ::  1 Word.word)) in
       if ((size_bits_backwards_matches mappingpatterns_40)) then
         size_bits_backwards mappingpatterns_40 \<bind> ((\<lambda> size1 . 
         if ((bool_bits_backwards_matches mappingpatterns_30)) then
           bool_bits_backwards mappingpatterns_30 \<bind> ((\<lambda> is_unsigned . 
           return (((((((word_width_bytes size1)) < (( 8 :: int)::ii))) \<or> (((((\<not> is_unsigned)) \<and> ((((word_width_bytes size1)) \<le> (( 8 :: int)::ii)))))))))))
         else return False))
       else return False)))
       (return (((((subrange_vec_dec v__469 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b0000011 ::  7 Word.word))))) \<bind> ((\<lambda> (w__2 :: bool) . 
     if w__2 then
       (let (mappingpatterns_40 ::  2 Word.word) =
         ((subrange_vec_dec v__469 (( 13 :: int)::ii) (( 12 :: int)::ii)  ::  2 Word.word)) in
       (let (mappingpatterns_30 ::  1 Word.word) =
         ((subrange_vec_dec v__469 (( 14 :: int)::ii) (( 14 :: int)::ii)  ::  1 Word.word)) in
       size_bits_backwards mappingpatterns_40 \<bind> ((\<lambda> size1 . 
       bool_bits_backwards mappingpatterns_30 \<bind> ((\<lambda> is_unsigned .  return True))))))
     else
       and_boolM
         ((let (mappingpatterns_50 ::  2 Word.word) =
           ((subrange_vec_dec v__469 (( 13 :: int)::ii) (( 12 :: int)::ii)  ::  2 Word.word)) in
         if ((size_bits_backwards_matches mappingpatterns_50)) then
           size_bits_backwards mappingpatterns_50 \<bind> ((\<lambda> size1 . 
           return ((((word_width_bytes size1)) \<le> (( 8 :: int)::ii)))))
         else return False))
         (return ((((((((subrange_vec_dec v__469 (( 14 :: int)::ii) (( 14 :: int)::ii)  ::  1 Word.word)) = ( 0b0 ::  1 Word.word)))) \<and> (((((subrange_vec_dec v__469 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b0100011 ::  7 Word.word)))))))) \<bind> ((\<lambda> (w__4 :: bool) . 
       if w__4 then
         (let (mappingpatterns_50 ::  2 Word.word) =
           ((subrange_vec_dec v__469 (( 13 :: int)::ii) (( 12 :: int)::ii)  ::  2 Word.word)) in
         size_bits_backwards mappingpatterns_50 \<bind> ((\<lambda> size1 .  return True)))
       else if (((((((( 64 :: int)::ii) = (( 64 :: int)::ii)))) \<and> ((((((((subrange_vec_dec v__469 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = ( 0b000 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__469 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b0011011 ::  7 Word.word)))))))))) then
         return True
       else if (((((((( 64 :: int)::ii) = (( 64 :: int)::ii)))) \<and> ((((((((subrange_vec_dec v__469 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = ( 0b0000000 ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__469 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = ( 0b001 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__469 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b0011011 ::  7 Word.word))))))))))))) then
         return True
       else if (((((((( 64 :: int)::ii) = (( 64 :: int)::ii)))) \<and> ((((((((subrange_vec_dec v__469 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = ( 0b0000000 ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__469 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = ( 0b101 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__469 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b0011011 ::  7 Word.word))))))))))))) then
         return True
       else if (((((((( 64 :: int)::ii) = (( 64 :: int)::ii)))) \<and> ((((((((subrange_vec_dec v__469 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = ( 0b0100000 ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__469 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = ( 0b101 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__469 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b0011011 ::  7 Word.word))))))))))))) then
         return True
       else if (((((((( 64 :: int)::ii) = (( 64 :: int)::ii)))) \<and> ((((((((subrange_vec_dec v__469 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = ( 0b0000000 ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__469 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = ( 0b000 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__469 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b0111011 ::  7 Word.word))))))))))))) then
         return True
       else if (((((((( 64 :: int)::ii) = (( 64 :: int)::ii)))) \<and> ((((((((subrange_vec_dec v__469 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = ( 0b0100000 ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__469 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = ( 0b000 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__469 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b0111011 ::  7 Word.word))))))))))))) then
         return True
       else if (((((((( 64 :: int)::ii) = (( 64 :: int)::ii)))) \<and> ((((((((subrange_vec_dec v__469 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = ( 0b0000000 ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__469 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = ( 0b001 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__469 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b0111011 ::  7 Word.word))))))))))))) then
         return True
       else if (((((((( 64 :: int)::ii) = (( 64 :: int)::ii)))) \<and> ((((((((subrange_vec_dec v__469 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = ( 0b0000000 ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__469 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = ( 0b101 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__469 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b0111011 ::  7 Word.word))))))))))))) then
         return True
       else if (((((((( 64 :: int)::ii) = (( 64 :: int)::ii)))) \<and> ((((((((subrange_vec_dec v__469 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = ( 0b0100000 ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__469 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = ( 0b101 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__469 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b0111011 ::  7 Word.word))))))))))))) then
         return True
       else if (((((((( 64 :: int)::ii) = (( 64 :: int)::ii)))) \<and> ((((((((subrange_vec_dec v__469 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = ( 0b0000000 ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__469 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = ( 0b001 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__469 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b0011011 ::  7 Word.word))))))))))))) then
         return True
       else if (((((((( 64 :: int)::ii) = (( 64 :: int)::ii)))) \<and> ((((((((subrange_vec_dec v__469 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = ( 0b0000000 ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__469 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = ( 0b101 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__469 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b0011011 ::  7 Word.word))))))))))))) then
         return True
       else if (((((((( 64 :: int)::ii) = (( 64 :: int)::ii)))) \<and> ((((((((subrange_vec_dec v__469 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = ( 0b0100000 ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__469 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = ( 0b101 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__469 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b0011011 ::  7 Word.word))))))))))))) then
         return True
       else if ((((((((subrange_vec_dec v__469 (( 31 :: int)::ii) (( 28 :: int)::ii)  ::  4 Word.word)) = ( 0x0 ::  4 Word.word)))) \<and> (((((subrange_vec_dec v__469 (( 19 :: int)::ii) (( 0 :: int)::ii)  ::  20 Word.word)) = ( 0x0000F ::  20 Word.word))))))) then
         return True
       else if ((((((((subrange_vec_dec v__469 (( 31 :: int)::ii) (( 28 :: int)::ii)  ::  4 Word.word)) = ( 0x8 ::  4 Word.word)))) \<and> (((((subrange_vec_dec v__469 (( 19 :: int)::ii) (( 0 :: int)::ii)  ::  20 Word.word)) = ( 0x0000F ::  20 Word.word))))))) then
         return True
       else if (((v__469 = ( 0x0000100F ::  32 Word.word)))) then return True
       else if (((v__469 = ( 0x00000073 ::  32 Word.word)))) then return True
       else if (((v__469 = ( 0x30200073 ::  32 Word.word)))) then return True
       else if (((v__469 = ( 0x10200073 ::  32 Word.word)))) then return True
       else if (((v__469 = ( 0x00100073 ::  32 Word.word)))) then return True
       else if (((v__469 = ( 0x10500073 ::  32 Word.word)))) then return True
       else if ((((((((subrange_vec_dec v__469 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = ( 0b0001001 ::  7 Word.word)))) \<and> (((((subrange_vec_dec v__469 (( 14 :: int)::ii) (( 0 :: int)::ii)  ::  15 Word.word)) = ( 0b000000001110011 ::  15 Word.word))))))) then
         return True
       else
         and_boolM
           ((let (mappingpatterns_80 ::  2 Word.word) =
             ((subrange_vec_dec v__469 (( 13 :: int)::ii) (( 12 :: int)::ii)  ::  2 Word.word)) in
           (let (mappingpatterns_70 ::  1 Word.word) =
             ((subrange_vec_dec v__469 (( 25 :: int)::ii) (( 25 :: int)::ii)  ::  1 Word.word)) in
           (let (mappingpatterns_60 ::  1 Word.word) =
             ((subrange_vec_dec v__469 (( 26 :: int)::ii) (( 26 :: int)::ii)  ::  1 Word.word)) in
           if ((size_bits_backwards_matches mappingpatterns_80)) then
             size_bits_backwards mappingpatterns_80 \<bind> ((\<lambda> size1 . 
             if ((bool_bits_backwards_matches mappingpatterns_70)) then
               bool_bits_backwards mappingpatterns_70 \<bind> ((\<lambda> rl . 
               if ((bool_bits_backwards_matches mappingpatterns_60)) then
                 bool_bits_backwards mappingpatterns_60 \<bind> ((\<lambda> aq . 
                 return ((amo_width_valid size1))))
               else return False))
             else return False))
           else return False))))
           (return ((((((((subrange_vec_dec v__469 (( 31 :: int)::ii) (( 27 :: int)::ii)  ::  5 Word.word)) = ( 0b00010 ::  5 Word.word)))) \<and> ((((((((subrange_vec_dec v__469 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) = ( 0b00000 ::  5 Word.word)))) \<and> ((((((((subrange_vec_dec v__469 (( 14 :: int)::ii) (( 14 :: int)::ii)  ::  1 Word.word)) = ( 0b0 ::  1 Word.word)))) \<and> (((((subrange_vec_dec v__469 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b0101111 ::  7 Word.word)))))))))))))) \<bind> ((\<lambda> (w__8 :: bool) . 
         if w__8 then
           (let (mappingpatterns_80 ::  2 Word.word) =
             ((subrange_vec_dec v__469 (( 13 :: int)::ii) (( 12 :: int)::ii)  ::  2 Word.word)) in
           (let (mappingpatterns_70 ::  1 Word.word) =
             ((subrange_vec_dec v__469 (( 25 :: int)::ii) (( 25 :: int)::ii)  ::  1 Word.word)) in
           (let (mappingpatterns_60 ::  1 Word.word) =
             ((subrange_vec_dec v__469 (( 26 :: int)::ii) (( 26 :: int)::ii)  ::  1 Word.word)) in
           size_bits_backwards mappingpatterns_80 \<bind> ((\<lambda> size1 . 
           bool_bits_backwards mappingpatterns_70 \<bind> ((\<lambda> rl . 
           bool_bits_backwards mappingpatterns_60 \<bind> ((\<lambda> aq .  return True)))))))))
         else
           and_boolM
             ((let (mappingpatterns_90 ::  1 Word.word) =
               ((subrange_vec_dec v__469 (( 26 :: int)::ii) (( 26 :: int)::ii)  ::  1 Word.word)) in
             (let (mappingpatterns_110 ::  2 Word.word) =
               ((subrange_vec_dec v__469 (( 13 :: int)::ii) (( 12 :: int)::ii)  ::  2 Word.word)) in
             (let (mappingpatterns_100 ::  1 Word.word) =
               ((subrange_vec_dec v__469 (( 25 :: int)::ii) (( 25 :: int)::ii)  ::  1 Word.word)) in
             if ((size_bits_backwards_matches mappingpatterns_110)) then
               size_bits_backwards mappingpatterns_110 \<bind> ((\<lambda> size1 . 
               if ((bool_bits_backwards_matches mappingpatterns_100)) then
                 bool_bits_backwards mappingpatterns_100 \<bind> ((\<lambda> rl . 
                 if ((bool_bits_backwards_matches mappingpatterns_90)) then
                   bool_bits_backwards mappingpatterns_90 \<bind> ((\<lambda> aq . 
                   return ((amo_width_valid size1))))
                 else return False))
               else return False))
             else return False))))
             (return ((((((((subrange_vec_dec v__469 (( 31 :: int)::ii) (( 27 :: int)::ii)  ::  5 Word.word)) = ( 0b00011 ::  5 Word.word)))) \<and> ((((((((subrange_vec_dec v__469 (( 14 :: int)::ii) (( 14 :: int)::ii)  ::  1 Word.word)) = ( 0b0 ::  1 Word.word)))) \<and> (((((subrange_vec_dec v__469 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b0101111 ::  7 Word.word))))))))))) \<bind> ((\<lambda> (w__12 :: bool) . 
           if w__12 then
             (let (mappingpatterns_90 ::  1 Word.word) =
               ((subrange_vec_dec v__469 (( 26 :: int)::ii) (( 26 :: int)::ii)  ::  1 Word.word)) in
             (let (mappingpatterns_110 ::  2 Word.word) =
               ((subrange_vec_dec v__469 (( 13 :: int)::ii) (( 12 :: int)::ii)  ::  2 Word.word)) in
             (let (mappingpatterns_100 ::  1 Word.word) =
               ((subrange_vec_dec v__469 (( 25 :: int)::ii) (( 25 :: int)::ii)  ::  1 Word.word)) in
             size_bits_backwards mappingpatterns_110 \<bind> ((\<lambda> size1 . 
             bool_bits_backwards mappingpatterns_100 \<bind> ((\<lambda> rl . 
             bool_bits_backwards mappingpatterns_90 \<bind> ((\<lambda> aq .  return True)))))))))
           else
             and_boolM
               ((let (mappingpatterns_120 ::  5 Word.word) =
                 ((subrange_vec_dec v__469 (( 31 :: int)::ii) (( 27 :: int)::ii)  ::  5 Word.word)) in
               (let (mappingpatterns_150 ::  2 Word.word) =
                 ((subrange_vec_dec v__469 (( 13 :: int)::ii) (( 12 :: int)::ii)  ::  2 Word.word)) in
               (let (mappingpatterns_140 ::  1 Word.word) =
                 ((subrange_vec_dec v__469 (( 25 :: int)::ii) (( 25 :: int)::ii)  ::  1 Word.word)) in
               (let (mappingpatterns_130 ::  1 Word.word) =
                 ((subrange_vec_dec v__469 (( 26 :: int)::ii) (( 26 :: int)::ii)  ::  1 Word.word)) in
               (let (mappingpatterns_120 ::  5 Word.word) =
                 ((subrange_vec_dec v__469 (( 31 :: int)::ii) (( 27 :: int)::ii)  ::  5 Word.word)) in
               if ((size_bits_backwards_matches mappingpatterns_150)) then
                 size_bits_backwards mappingpatterns_150 \<bind> ((\<lambda> size1 . 
                 if ((bool_bits_backwards_matches mappingpatterns_140)) then
                   bool_bits_backwards mappingpatterns_140 \<bind> ((\<lambda> rl . 
                   if ((bool_bits_backwards_matches mappingpatterns_130)) then
                     bool_bits_backwards mappingpatterns_130 \<bind> ((\<lambda> aq . 
                     if ((encdec_amoop_backwards_matches mappingpatterns_120)) then
                       encdec_amoop_backwards mappingpatterns_120 \<bind> ((\<lambda> op1 . 
                       return ((amo_width_valid size1))))
                     else return False))
                   else return False))
                 else return False))
               else return False))))))
               (return ((((((((subrange_vec_dec v__469 (( 14 :: int)::ii) (( 14 :: int)::ii)  ::  1 Word.word)) = ( 0b0 ::  1 Word.word)))) \<and> (((((subrange_vec_dec v__469 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b0101111 ::  7 Word.word)))))))) \<bind> ((\<lambda> (w__17 :: bool) . 
             if w__17 then
               (let (mappingpatterns_120 ::  5 Word.word) =
                 ((subrange_vec_dec v__469 (( 31 :: int)::ii) (( 27 :: int)::ii)  ::  5 Word.word)) in
               (let (mappingpatterns_150 ::  2 Word.word) =
                 ((subrange_vec_dec v__469 (( 13 :: int)::ii) (( 12 :: int)::ii)  ::  2 Word.word)) in
               (let (mappingpatterns_140 ::  1 Word.word) =
                 ((subrange_vec_dec v__469 (( 25 :: int)::ii) (( 25 :: int)::ii)  ::  1 Word.word)) in
               (let (mappingpatterns_130 ::  1 Word.word) =
                 ((subrange_vec_dec v__469 (( 26 :: int)::ii) (( 26 :: int)::ii)  ::  1 Word.word)) in
               (let (mappingpatterns_120 ::  5 Word.word) =
                 ((subrange_vec_dec v__469 (( 31 :: int)::ii) (( 27 :: int)::ii)  ::  5 Word.word)) in
               size_bits_backwards mappingpatterns_150 \<bind> ((\<lambda> size1 . 
               bool_bits_backwards mappingpatterns_140 \<bind> ((\<lambda> rl . 
               bool_bits_backwards mappingpatterns_130 \<bind> ((\<lambda> aq . 
               encdec_amoop_backwards mappingpatterns_120 \<bind> ((\<lambda> op1 .  return True)))))))))))))
             else if (((((let (mappingpatterns_160 ::  3 Word.word) =
                           ((subrange_vec_dec v__469 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) in
                         encdec_mul_op_backwards_matches mappingpatterns_160)) \<and> ((((((((subrange_vec_dec v__469 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = ( 0b0000001 ::  7 Word.word)))) \<and> (((((subrange_vec_dec v__469 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b0110011 ::  7 Word.word)))))))))) then
               (let (mappingpatterns_160 ::  3 Word.word) =
                 ((subrange_vec_dec v__469 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) in
               encdec_mul_op_backwards mappingpatterns_160 \<bind> ((\<lambda> varstup .  (let (high, signed1, signed2) = varstup in
               return True))))
             else if (((((let (mappingpatterns_170 ::  1 Word.word) =
                           ((subrange_vec_dec v__469 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
                         bool_not_bits_backwards_matches mappingpatterns_170)) \<and> ((((((((subrange_vec_dec v__469 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = ( 0b0000001 ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__469 (( 14 :: int)::ii) (( 13 :: int)::ii)  ::  2 Word.word)) = ( 0b10 ::  2 Word.word)))) \<and> (((((subrange_vec_dec v__469 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b0110011 ::  7 Word.word))))))))))))) then
               (let (mappingpatterns_170 ::  1 Word.word) =
                 ((subrange_vec_dec v__469 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
               bool_not_bits_backwards mappingpatterns_170 \<bind> ((\<lambda> s .  return True)))
             else if (((((let (mappingpatterns_180 ::  1 Word.word) =
                           ((subrange_vec_dec v__469 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
                         bool_not_bits_backwards_matches mappingpatterns_180)) \<and> ((((((((subrange_vec_dec v__469 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = ( 0b0000001 ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__469 (( 14 :: int)::ii) (( 13 :: int)::ii)  ::  2 Word.word)) = ( 0b11 ::  2 Word.word)))) \<and> (((((subrange_vec_dec v__469 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b0110011 ::  7 Word.word))))))))))))) then
               (let (mappingpatterns_180 ::  1 Word.word) =
                 ((subrange_vec_dec v__469 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
               bool_not_bits_backwards mappingpatterns_180 \<bind> ((\<lambda> s .  return True)))
             else if (((((((( 64 :: int)::ii) = (( 64 :: int)::ii)))) \<and> ((((((((subrange_vec_dec v__469 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = ( 0b0000001 ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__469 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = ( 0b000 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__469 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b0111011 ::  7 Word.word))))))))))))) then
               return True
             else
               and_boolM
                 ((let (mappingpatterns_190 ::  1 Word.word) =
                   ((subrange_vec_dec v__469 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
                 if ((bool_not_bits_backwards_matches mappingpatterns_190)) then
                   bool_not_bits_backwards mappingpatterns_190 \<bind> ((\<lambda> s . 
                   return ((((( 64 :: int)::ii) = (( 64 :: int)::ii))))))
                 else return False))
                 (return ((((((((subrange_vec_dec v__469 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = ( 0b0000001 ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__469 (( 14 :: int)::ii) (( 13 :: int)::ii)  ::  2 Word.word)) = ( 0b10 ::  2 Word.word)))) \<and> (((((subrange_vec_dec v__469 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b0111011 ::  7 Word.word))))))))))) \<bind> ((\<lambda> (w__19 :: bool) . 
               if w__19 then
                 (let (mappingpatterns_190 ::  1 Word.word) =
                   ((subrange_vec_dec v__469 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
                 bool_not_bits_backwards mappingpatterns_190 \<bind> ((\<lambda> s .  return True)))
               else
                 and_boolM
                   ((let (mappingpatterns_200 ::  1 Word.word) =
                     ((subrange_vec_dec v__469 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
                   if ((bool_not_bits_backwards_matches mappingpatterns_200)) then
                     bool_not_bits_backwards mappingpatterns_200 \<bind> ((\<lambda> s . 
                     return ((((( 64 :: int)::ii) = (( 64 :: int)::ii))))))
                   else return False))
                   (return ((((((((subrange_vec_dec v__469 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = ( 0b0000001 ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__469 (( 14 :: int)::ii) (( 13 :: int)::ii)  ::  2 Word.word)) = ( 0b11 ::  2 Word.word)))) \<and> (((((subrange_vec_dec v__469 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b0111011 ::  7 Word.word))))))))))) \<bind> ((\<lambda> (w__21 :: bool) . 
                 if w__21 then
                   (let (mappingpatterns_200 ::  1 Word.word) =
                     ((subrange_vec_dec v__469 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
                   bool_not_bits_backwards mappingpatterns_200 \<bind> ((\<lambda> s .  return True)))
                 else
                   and_boolM
                     ((let (mappingpatterns_220 ::  2 Word.word) =
                       ((subrange_vec_dec v__469 (( 13 :: int)::ii) (( 12 :: int)::ii)  ::  2 Word.word)) in
                     (let (mappingpatterns_210 ::  1 Word.word) =
                       ((subrange_vec_dec v__469 (( 14 :: int)::ii) (( 14 :: int)::ii)  ::  1 Word.word)) in
                     if ((encdec_csrop_backwards_matches mappingpatterns_220)) then
                       encdec_csrop_backwards mappingpatterns_220 \<bind> ((\<lambda> op1 . 
                       return ((bool_bits_backwards_matches mappingpatterns_210))))
                     else return False)))
                     (return (((((subrange_vec_dec v__469 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b1110011 ::  7 Word.word))))) \<bind> ((\<lambda> (w__23 :: bool) . 
                   if w__23 then
                     (let (mappingpatterns_220 ::  2 Word.word) =
                       ((subrange_vec_dec v__469 (( 13 :: int)::ii) (( 12 :: int)::ii)  ::  2 Word.word)) in
                     (let (mappingpatterns_210 ::  1 Word.word) =
                       ((subrange_vec_dec v__469 (( 14 :: int)::ii) (( 14 :: int)::ii)  ::  1 Word.word)) in
                     encdec_csrop_backwards mappingpatterns_220 \<bind> ((\<lambda> op1 . 
                     bool_bits_backwards mappingpatterns_210 \<bind> ((\<lambda> is_imm .  return True))))))
                   else if (((v__469 = ( 0x00200073 ::  32 Word.word)))) then return True
                   else if (((((let (fm :: 4 bits) =
                                 ((subrange_vec_dec v__469 (( 31 :: int)::ii) (( 28 :: int)::ii)  ::  4 Word.word)) in
                               (let (rs :: regidx) =
                                 ((subrange_vec_dec v__469 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
                               (let (rd :: regidx) =
                                 ((subrange_vec_dec v__469 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
                               (let (fm :: 4 bits) =
                                 ((subrange_vec_dec v__469 (( 31 :: int)::ii) (( 28 :: int)::ii)  ::  4 Word.word)) in
                               (((((((fm \<noteq> ( 0x0 ::  4 Word.word)))) \<and> (((fm \<noteq> ( 0x8 ::  4 Word.word))))))) \<or> ((((((rs \<noteq> ( 0b00000 ::  5 Word.word)))) \<or> (((rd \<noteq> ( 0b00000 ::  5 Word.word))))))))))))) \<and> ((((((((subrange_vec_dec v__469 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = ( 0b000 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__469 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b0001111 ::  7 Word.word)))))))))) then
                     return True
                   else if (((((let (imm :: 12 bits) =
                                 ((subrange_vec_dec v__469 (( 31 :: int)::ii) (( 20 :: int)::ii)  ::  12 Word.word)) in
                               (let (rs :: regidx) =
                                 ((subrange_vec_dec v__469 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
                               (let (rd :: regidx) =
                                 ((subrange_vec_dec v__469 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
                               (let (imm :: 12 bits) =
                                 ((subrange_vec_dec v__469 (( 31 :: int)::ii) (( 20 :: int)::ii)  ::  12 Word.word)) in
                               ((((imm \<noteq> ( 0x000 ::  12 Word.word)))) \<or> ((((((rs \<noteq> zreg))) \<or> (((rd \<noteq> zreg)))))))))))) \<and> ((((((((subrange_vec_dec v__469 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = ( 0b001 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__469 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b0001111 ::  7 Word.word)))))))))) then
                     return True
                   else
                     and_boolM ((is_RV32F_or_RV64F () ))
                       (return ((((((((subrange_vec_dec v__469 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = ( 0b010 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__469 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b0000111 ::  7 Word.word)))))))) \<bind> ((\<lambda> (w__25 :: bool) . 
                     if w__25 then return True
                     else
                       and_boolM ((is_RV32D_or_RV64D () ))
                         (return ((((((((subrange_vec_dec v__469 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = ( 0b011 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__469 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b0000111 ::  7 Word.word)))))))) \<bind> ((\<lambda> (w__27 :: bool) . 
                       if w__27 then return True
                       else
                         and_boolM ((is_RV32F_or_RV64F () ))
                           (return ((((((((subrange_vec_dec v__469 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = ( 0b010 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__469 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b0100111 ::  7 Word.word)))))))) \<bind> ((\<lambda> (w__29 :: bool) . 
                         if w__29 then return True
                         else
                           and_boolM ((is_RV32D_or_RV64D () ))
                             (return ((((((((subrange_vec_dec v__469 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = ( 0b011 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__469 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b0100111 ::  7 Word.word)))))))) \<bind> ((\<lambda> (w__31 :: bool) . 
                           if w__31 then return True
                           else
                             and_boolM
                               ((let (mappingpatterns_230 ::  3 Word.word) =
                                 ((subrange_vec_dec v__469 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) in
                               if ((encdec_rounding_mode_backwards_matches mappingpatterns_230))
                               then
                                 encdec_rounding_mode_backwards mappingpatterns_230 \<bind> ((\<lambda> rm . 
                                 is_RV32F_or_RV64F () ))
                               else return False))
                               (return ((((((((subrange_vec_dec v__469 (( 26 :: int)::ii) (( 25 :: int)::ii)
                                                  ::  2 Word.word)) = ( 0b00 ::  2 Word.word)))) \<and> (((((subrange_vec_dec v__469 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b1000011 ::  7 Word.word)))))))) \<bind> ((\<lambda> (w__34 :: bool) . 
                             if w__34 then
                               (let (mappingpatterns_230 ::  3 Word.word) =
                                 ((subrange_vec_dec v__469 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) in
                               encdec_rounding_mode_backwards mappingpatterns_230 \<bind> ((\<lambda> rm . 
                               return True)))
                             else
                               and_boolM
                                 ((let (mappingpatterns_240 ::  3 Word.word) =
                                   ((subrange_vec_dec v__469 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) in
                                 if ((encdec_rounding_mode_backwards_matches mappingpatterns_240))
                                 then
                                   encdec_rounding_mode_backwards mappingpatterns_240 \<bind> ((\<lambda> rm . 
                                   is_RV32F_or_RV64F () ))
                                 else return False))
                                 (return ((((((((subrange_vec_dec v__469 (( 26 :: int)::ii) (( 25 :: int)::ii)
                                                    ::  2 Word.word)) = ( 0b00 ::  2 Word.word)))) \<and> (((((subrange_vec_dec v__469 (( 6 :: int)::ii) (( 0 :: int)::ii)
                                                    ::  7 Word.word)) = ( 0b1000111 ::  7 Word.word)))))))) \<bind> ((\<lambda> (w__37 ::
                                 bool) . 
                               if w__37 then
                                 (let (mappingpatterns_240 ::  3 Word.word) =
                                   ((subrange_vec_dec v__469 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) in
                                 encdec_rounding_mode_backwards mappingpatterns_240 \<bind> ((\<lambda> rm . 
                                 return True)))
                               else
                                 and_boolM
                                   ((let (mappingpatterns_250 ::  3 Word.word) =
                                     ((subrange_vec_dec v__469 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) in
                                   if ((encdec_rounding_mode_backwards_matches mappingpatterns_250))
                                   then
                                     encdec_rounding_mode_backwards mappingpatterns_250 \<bind> ((\<lambda> rm . 
                                     is_RV32F_or_RV64F () ))
                                   else return False))
                                   (return ((((((((subrange_vec_dec v__469 (( 26 :: int)::ii) (( 25 :: int)::ii)
                                                      ::  2 Word.word)) = ( 0b00 ::  2 Word.word)))) \<and> (((((subrange_vec_dec v__469 (( 6 :: int)::ii) (( 0 :: int)::ii)
                                                      ::  7 Word.word)) = ( 0b1001011 ::  7 Word.word)))))))) \<bind> ((\<lambda> (w__40 ::
                                   bool) . 
                                 if w__40 then
                                   (let (mappingpatterns_250 ::  3 Word.word) =
                                     ((subrange_vec_dec v__469 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) in
                                   encdec_rounding_mode_backwards mappingpatterns_250 \<bind> ((\<lambda> rm . 
                                   return True)))
                                 else
                                   and_boolM
                                     ((let (mappingpatterns_260 ::  3 Word.word) =
                                       ((subrange_vec_dec v__469 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) in
                                     if ((encdec_rounding_mode_backwards_matches
                                            mappingpatterns_260)) then
                                       encdec_rounding_mode_backwards mappingpatterns_260 \<bind> ((\<lambda> rm . 
                                       is_RV32F_or_RV64F () ))
                                     else return False))
                                     (return ((((((((subrange_vec_dec v__469 (( 26 :: int)::ii) (( 25 :: int)::ii)
                                                        ::  2 Word.word)) = ( 0b00 ::  2 Word.word)))) \<and> (((((subrange_vec_dec v__469 (( 6 :: int)::ii) (( 0 :: int)::ii)
                                                        ::  7 Word.word)) = ( 0b1001111 ::  7 Word.word)))))))) \<bind> ((\<lambda> (w__43 ::
                                     bool) . 
                                   if w__43 then
                                     (let (mappingpatterns_260 ::  3 Word.word) =
                                       ((subrange_vec_dec v__469 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) in
                                     encdec_rounding_mode_backwards mappingpatterns_260 \<bind> ((\<lambda> rm . 
                                     return True)))
                                   else
                                     and_boolM
                                       ((let (mappingpatterns_270 ::  3 Word.word) =
                                         ((subrange_vec_dec v__469 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) in
                                       if ((encdec_rounding_mode_backwards_matches
                                              mappingpatterns_270)) then
                                         encdec_rounding_mode_backwards mappingpatterns_270 \<bind> ((\<lambda> rm . 
                                         is_RV32F_or_RV64F () ))
                                       else return False))
                                       (return ((((((((subrange_vec_dec v__469 (( 31 :: int)::ii) (( 25 :: int)::ii)
                                                          ::  7 Word.word)) = ( 0b0000000 ::  7 Word.word)))) \<and> (((((subrange_vec_dec v__469 (( 6 :: int)::ii) (( 0 :: int)::ii)
                                                          ::  7 Word.word)) = ( 0b1010011 ::  7 Word.word)))))))) \<bind> ((\<lambda> (w__46 ::
                                       bool) . 
                                     if w__46 then
                                       (let (mappingpatterns_270 ::  3 Word.word) =
                                         ((subrange_vec_dec v__469 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) in
                                       encdec_rounding_mode_backwards mappingpatterns_270 \<bind> ((\<lambda> rm . 
                                       return True)))
                                     else
                                       and_boolM
                                         ((let (mappingpatterns_280 ::  3 Word.word) =
                                           ((subrange_vec_dec v__469 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) in
                                         if ((encdec_rounding_mode_backwards_matches
                                                mappingpatterns_280)) then
                                           encdec_rounding_mode_backwards mappingpatterns_280 \<bind> ((\<lambda> rm . 
                                           is_RV32F_or_RV64F () ))
                                         else return False))
                                         (return ((((((((subrange_vec_dec v__469 (( 31 :: int)::ii) (( 25 :: int)::ii)
                                                            ::  7 Word.word)) = ( 0b0000100 ::  7 Word.word)))) \<and> (((((subrange_vec_dec v__469 (( 6 :: int)::ii) (( 0 :: int)::ii)
                                                            ::  7 Word.word)) = ( 0b1010011 ::  7 Word.word)))))))) \<bind> ((\<lambda> (w__49 ::
                                         bool) . 
                                       if w__49 then
                                         (let (mappingpatterns_280 ::  3 Word.word) =
                                           ((subrange_vec_dec v__469 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) in
                                         encdec_rounding_mode_backwards mappingpatterns_280 \<bind> ((\<lambda> rm . 
                                         return True)))
                                       else
                                         and_boolM
                                           ((let (mappingpatterns_290 ::  3 Word.word) =
                                             ((subrange_vec_dec v__469 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) in
                                           if ((encdec_rounding_mode_backwards_matches
                                                  mappingpatterns_290)) then
                                             encdec_rounding_mode_backwards mappingpatterns_290 \<bind> ((\<lambda> rm . 
                                             is_RV32F_or_RV64F () ))
                                           else return False))
                                           (return ((((((((subrange_vec_dec v__469 (( 31 :: int)::ii) (( 25 :: int)::ii)
                                                              ::  7 Word.word)) = ( 0b0001000 ::  7 Word.word)))) \<and> (((((subrange_vec_dec v__469 (( 6 :: int)::ii) (( 0 :: int)::ii)
                                                              ::  7 Word.word)) = ( 0b1010011 ::  7 Word.word)))))))) \<bind> ((\<lambda> (w__52 ::
                                           bool) . 
                                         if w__52 then
                                           (let (mappingpatterns_290 ::  3 Word.word) =
                                             ((subrange_vec_dec v__469 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) in
                                           encdec_rounding_mode_backwards mappingpatterns_290 \<bind> ((\<lambda> rm . 
                                           return True)))
                                         else
                                           and_boolM
                                             ((let (mappingpatterns_300 ::  3 Word.word) =
                                               ((subrange_vec_dec v__469 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) in
                                             if ((encdec_rounding_mode_backwards_matches
                                                    mappingpatterns_300)) then
                                               encdec_rounding_mode_backwards mappingpatterns_300 \<bind> ((\<lambda> rm . 
                                               is_RV32F_or_RV64F () ))
                                             else return False))
                                             (return ((((((((subrange_vec_dec v__469 (( 31 :: int)::ii)
                                                                 (( 25 :: int)::ii)
                                                                ::  7 Word.word)) = ( 0b0001100 ::  7 Word.word)))) \<and> (((((subrange_vec_dec v__469 (( 6 :: int)::ii) (( 0 :: int)::ii)
                                                                ::  7 Word.word)) = ( 0b1010011 ::  7 Word.word)))))))) \<bind> ((\<lambda> (w__55 ::
                                             bool) . 
                                           if w__55 then
                                             (let (mappingpatterns_300 ::  3 Word.word) =
                                               ((subrange_vec_dec v__469 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) in
                                             encdec_rounding_mode_backwards mappingpatterns_300 \<bind> ((\<lambda> rm . 
                                             return True)))
                                           else
                                             and_boolM
                                               ((let (mappingpatterns_310 ::  3 Word.word) =
                                                 ((subrange_vec_dec v__469 (( 14 :: int)::ii) (( 12 :: int)::ii)
                                                   ::  3 Word.word)) in
                                               if ((encdec_rounding_mode_backwards_matches
                                                      mappingpatterns_310)) then
                                                 encdec_rounding_mode_backwards mappingpatterns_310 \<bind> ((\<lambda> rm . 
                                                 is_RV32F_or_RV64F () ))
                                               else return False))
                                               (return ((((((((subrange_vec_dec v__469 (( 31 :: int)::ii)
                                                                   (( 20 :: int)::ii)
                                                                  ::  12 Word.word)) = ( 0x580 ::  12 Word.word)))) \<and> (((((subrange_vec_dec v__469 (( 6 :: int)::ii)
                                                                   (( 0 :: int)::ii)
                                                                  ::  7 Word.word)) = ( 0b1010011 ::  7 Word.word)))))))) \<bind> ((\<lambda> (w__58 ::
                                               bool) . 
                                             if w__58 then
                                               (let (mappingpatterns_310 ::  3 Word.word) =
                                                 ((subrange_vec_dec v__469 (( 14 :: int)::ii) (( 12 :: int)::ii)
                                                   ::  3 Word.word)) in
                                               encdec_rounding_mode_backwards mappingpatterns_310 \<bind> ((\<lambda> rm . 
                                               return True)))
                                             else
                                               and_boolM
                                                 ((let (mappingpatterns_320 ::  3 Word.word) =
                                                   ((subrange_vec_dec v__469 (( 14 :: int)::ii) (( 12 :: int)::ii)
                                                     ::  3 Word.word)) in
                                                 if ((encdec_rounding_mode_backwards_matches
                                                        mappingpatterns_320)) then
                                                   encdec_rounding_mode_backwards
                                                     mappingpatterns_320 \<bind> ((\<lambda> rm . 
                                                   is_RV32F_or_RV64F () ))
                                                 else return False))
                                                 (return ((((((((subrange_vec_dec v__469 (( 31 :: int)::ii)
                                                                     (( 20 :: int)::ii)
                                                                    ::  12 Word.word)) = ( 0xC00 ::  12 Word.word)))) \<and> (((((subrange_vec_dec v__469 (( 6 :: int)::ii)
                                                                     (( 0 :: int)::ii)
                                                                    ::  7 Word.word)) = ( 0b1010011 ::  7 Word.word)))))))) \<bind> ((\<lambda> (w__61 ::
                                                 bool) . 
                                               if w__61 then
                                                 (let (mappingpatterns_320 ::  3 Word.word) =
                                                   ((subrange_vec_dec v__469 (( 14 :: int)::ii) (( 12 :: int)::ii)
                                                     ::  3 Word.word)) in
                                                 encdec_rounding_mode_backwards mappingpatterns_320 \<bind> ((\<lambda> rm . 
                                                 return True)))
                                               else
                                                 and_boolM
                                                   ((let (mappingpatterns_330 ::  3 Word.word) =
                                                     ((subrange_vec_dec v__469 (( 14 :: int)::ii) (( 12 :: int)::ii)
                                                       ::  3 Word.word)) in
                                                   if ((encdec_rounding_mode_backwards_matches
                                                          mappingpatterns_330)) then
                                                     encdec_rounding_mode_backwards
                                                       mappingpatterns_330 \<bind> ((\<lambda> rm . 
                                                     is_RV32F_or_RV64F () ))
                                                   else return False))
                                                   (return ((((((((subrange_vec_dec v__469 (( 31 :: int)::ii)
                                                                       (( 20 :: int)::ii)
                                                                      ::  12 Word.word)) = ( 0xC01 ::  12 Word.word)))) \<and> (((((subrange_vec_dec v__469 (( 6 :: int)::ii)
                                                                       (( 0 :: int)::ii)
                                                                      ::  7 Word.word)) = ( 0b1010011 ::  7 Word.word)))))))) \<bind> ((\<lambda> (w__64 ::
                                                   bool) . 
                                                 if w__64 then
                                                   (let (mappingpatterns_330 ::  3 Word.word) =
                                                     ((subrange_vec_dec v__469 (( 14 :: int)::ii) (( 12 :: int)::ii)
                                                       ::  3 Word.word)) in
                                                   encdec_rounding_mode_backwards
                                                     mappingpatterns_330 \<bind> ((\<lambda> rm . 
                                                   return True)))
                                                 else
                                                   and_boolM
                                                     ((let (mappingpatterns_340 ::  3 Word.word) =
                                                       ((subrange_vec_dec v__469 (( 14 :: int)::ii) (( 12 :: int)::ii)
                                                         ::  3 Word.word)) in
                                                     if ((encdec_rounding_mode_backwards_matches
                                                            mappingpatterns_340)) then
                                                       encdec_rounding_mode_backwards
                                                         mappingpatterns_340 \<bind> ((\<lambda> rm . 
                                                       is_RV32F_or_RV64F () ))
                                                     else return False))
                                                     (return ((((((((subrange_vec_dec v__469
                                                                         (( 31 :: int)::ii) (( 20 :: int)::ii)
                                                                        ::  12 Word.word)) = ( 0xD00 ::  12 Word.word)))) \<and> (((((subrange_vec_dec v__469
                                                                         (( 6 :: int)::ii) (( 0 :: int)::ii)
                                                                        ::  7 Word.word)) = ( 0b1010011 ::  7 Word.word)))))))) \<bind> ((\<lambda> (w__67 ::
                                                     bool) . 
                                                   if w__67 then
                                                     (let (mappingpatterns_340 ::  3 Word.word) =
                                                       ((subrange_vec_dec v__469 (( 14 :: int)::ii) (( 12 :: int)::ii)
                                                         ::  3 Word.word)) in
                                                     encdec_rounding_mode_backwards
                                                       mappingpatterns_340 \<bind> ((\<lambda> rm . 
                                                     return True)))
                                                   else
                                                     and_boolM
                                                       ((let (mappingpatterns_350 ::  3 Word.word) =
                                                         ((subrange_vec_dec v__469 (( 14 :: int)::ii) (( 12 :: int)::ii)
                                                           ::  3 Word.word)) in
                                                       if ((encdec_rounding_mode_backwards_matches
                                                              mappingpatterns_350)) then
                                                         encdec_rounding_mode_backwards
                                                           mappingpatterns_350 \<bind> ((\<lambda> rm . 
                                                         is_RV32F_or_RV64F () ))
                                                       else return False))
                                                       (return ((((((((subrange_vec_dec v__469
                                                                           (( 31 :: int)::ii) (( 20 :: int)::ii)
                                                                          ::  12 Word.word)) = ( 0xD01 ::  12 Word.word)))) \<and> (((((subrange_vec_dec v__469
                                                                           (( 6 :: int)::ii) (( 0 :: int)::ii)
                                                                          ::  7 Word.word)) = ( 0b1010011 ::  7 Word.word)))))))) \<bind> ((\<lambda> (w__70 ::
                                                       bool) . 
                                                     if w__70 then
                                                       (let (mappingpatterns_350 ::  3 Word.word) =
                                                         ((subrange_vec_dec v__469 (( 14 :: int)::ii) (( 12 :: int)::ii)
                                                           ::  3 Word.word)) in
                                                       encdec_rounding_mode_backwards
                                                         mappingpatterns_350 \<bind> ((\<lambda> rm . 
                                                       return True)))
                                                     else
                                                       and_boolM
                                                         ((let (mappingpatterns_360 ::  3 Word.word) =
                                                           ((subrange_vec_dec v__469 (( 14 :: int)::ii) (( 12 :: int)::ii)
                                                             ::  3 Word.word)) in
                                                         if ((encdec_rounding_mode_backwards_matches
                                                                mappingpatterns_360)) then
                                                           encdec_rounding_mode_backwards
                                                             mappingpatterns_360 \<bind> ((\<lambda> rm . 
                                                           is_RV64F () ))
                                                         else return False))
                                                         (return ((((((((subrange_vec_dec v__469
                                                                             (( 31 :: int)::ii) (( 20 :: int)::ii)
                                                                            ::  12 Word.word)) = ( 0xC02 ::  12 Word.word)))) \<and> (((((subrange_vec_dec v__469
                                                                             (( 6 :: int)::ii) (( 0 :: int)::ii)
                                                                            ::  7 Word.word)) = ( 0b1010011 ::  7 Word.word)))))))) \<bind> ((\<lambda> (w__73 ::
                                                         bool) . 
                                                       if w__73 then
                                                         (let (mappingpatterns_360 ::  3 Word.word) =
                                                           ((subrange_vec_dec v__469 (( 14 :: int)::ii) (( 12 :: int)::ii)
                                                             ::  3 Word.word)) in
                                                         encdec_rounding_mode_backwards
                                                           mappingpatterns_360 \<bind> ((\<lambda> rm . 
                                                         return True)))
                                                       else
                                                         and_boolM
                                                           ((let (mappingpatterns_370 ::  3 Word.word) =
                                                             ((subrange_vec_dec v__469 (( 14 :: int)::ii)
                                                                (( 12 :: int)::ii)
                                                               ::  3 Word.word)) in
                                                           if ((encdec_rounding_mode_backwards_matches
                                                                  mappingpatterns_370)) then
                                                             encdec_rounding_mode_backwards
                                                               mappingpatterns_370 \<bind> ((\<lambda> rm . 
                                                             is_RV64F () ))
                                                           else return False))
                                                           (return ((((((((subrange_vec_dec v__469
                                                                               (( 31 :: int)::ii) (( 20 :: int)::ii)
                                                                              ::  12 Word.word)) = ( 0xC03 ::  12 Word.word)))) \<and> (((((subrange_vec_dec v__469
                                                                               (( 6 :: int)::ii) (( 0 :: int)::ii)
                                                                              ::  7 Word.word)) = ( 0b1010011 ::  7 Word.word)))))))) \<bind> ((\<lambda> (w__76 ::
                                                           bool) . 
                                                         if w__76 then
                                                           (let (mappingpatterns_370 ::  3 Word.word) =
                                                             ((subrange_vec_dec v__469 (( 14 :: int)::ii)
                                                                (( 12 :: int)::ii)
                                                               ::  3 Word.word)) in
                                                           encdec_rounding_mode_backwards
                                                             mappingpatterns_370 \<bind> ((\<lambda> rm . 
                                                           return True)))
                                                         else
                                                           and_boolM
                                                             ((let (mappingpatterns_380 ::  3 Word.word) =
                                                               ((subrange_vec_dec v__469 (( 14 :: int)::ii)
                                                                  (( 12 :: int)::ii)
                                                                 ::  3 Word.word)) in
                                                             if ((encdec_rounding_mode_backwards_matches
                                                                    mappingpatterns_380)) then
                                                               encdec_rounding_mode_backwards
                                                                 mappingpatterns_380 \<bind> ((\<lambda> rm . 
                                                               is_RV64F () ))
                                                             else return False))
                                                             (return ((((((((subrange_vec_dec
                                                                                 v__469 (( 31 :: int)::ii)
                                                                                 (( 20 :: int)::ii)
                                                                                ::  12 Word.word)) = ( 0xD02 ::  12 Word.word)))) \<and> (((((subrange_vec_dec
                                                                                 v__469 (( 6 :: int)::ii)
                                                                                 (( 0 :: int)::ii)
                                                                                ::  7 Word.word)) = ( 0b1010011 ::  7 Word.word)))))))) \<bind> ((\<lambda> (w__79 ::
                                                             bool) . 
                                                           if w__79 then
                                                             (let (mappingpatterns_380 ::  3 Word.word) =
                                                               ((subrange_vec_dec v__469 (( 14 :: int)::ii)
                                                                  (( 12 :: int)::ii)
                                                                 ::  3 Word.word)) in
                                                             encdec_rounding_mode_backwards
                                                               mappingpatterns_380 \<bind> ((\<lambda> rm . 
                                                             return True)))
                                                           else
                                                             and_boolM
                                                               ((let (mappingpatterns_390 ::
                                                                  3 Word.word) =
                                                                 ((subrange_vec_dec v__469 (( 14 :: int)::ii)
                                                                    (( 12 :: int)::ii)
                                                                   ::  3 Word.word)) in
                                                               if ((encdec_rounding_mode_backwards_matches
                                                                      mappingpatterns_390)) then
                                                                 encdec_rounding_mode_backwards
                                                                   mappingpatterns_390 \<bind> ((\<lambda> rm . 
                                                                 is_RV64F () ))
                                                               else return False))
                                                               (return ((((((((subrange_vec_dec
                                                                                   v__469 (( 31 :: int)::ii)
                                                                                   (( 20 :: int)::ii)
                                                                                  ::  12 Word.word)) = ( 0xD03 ::  12 Word.word)))) \<and> (((((subrange_vec_dec
                                                                                   v__469 (( 6 :: int)::ii)
                                                                                   (( 0 :: int)::ii)
                                                                                  ::  7 Word.word)) = ( 0b1010011 ::  7 Word.word)))))))) \<bind> ((\<lambda> (w__82 ::
                                                               bool) . 
                                                             if w__82 then
                                                               (let (mappingpatterns_390 ::  3 Word.word) =
                                                                 ((subrange_vec_dec v__469 (( 14 :: int)::ii)
                                                                    (( 12 :: int)::ii)
                                                                   ::  3 Word.word)) in
                                                               encdec_rounding_mode_backwards
                                                                 mappingpatterns_390 \<bind> ((\<lambda> rm . 
                                                               return True)))
                                                             else
                                                               and_boolM ((is_RV32F_or_RV64F () ))
                                                                 (return ((((((((subrange_vec_dec
                                                                                     v__469 (( 31 :: int)::ii)
                                                                                     (( 25 :: int)::ii)
                                                                                    ::  7 Word.word)) = ( 0b0010000 ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec
                                                                                         v__469
                                                                                         (( 14 :: int)::ii)
                                                                                         (( 12 :: int)::ii)
                                                                                        ::  3 Word.word)) = ( 0b000 ::  3 Word.word)))) \<and> (((((subrange_vec_dec
                                                                                         v__469
                                                                                         (( 6 :: int)::ii)
                                                                                         (( 0 :: int)::ii)
                                                                                        ::  7 Word.word)) = ( 0b1010011 ::  7 Word.word))))))))))) \<bind> ((\<lambda> (w__84 ::
                                                                 bool) . 
                                                               if w__84 then return True
                                                               else
                                                                 and_boolM ((is_RV32F_or_RV64F () ))
                                                                   (return ((((((((subrange_vec_dec
                                                                                       v__469
                                                                                       (( 31 :: int)::ii)
                                                                                       (( 25 :: int)::ii)
                                                                                      ::  7 Word.word)) = ( 0b0010000 ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec
                                                                                           v__469
                                                                                           (( 14 :: int)::ii)
                                                                                           (( 12 :: int)::ii)
                                                                                          ::  3 Word.word)) = ( 0b001 ::  3 Word.word)))) \<and> (((((subrange_vec_dec
                                                                                           v__469
                                                                                           (( 6 :: int)::ii)
                                                                                           (( 0 :: int)::ii)
                                                                                          ::  7 Word.word)) = ( 0b1010011 ::  7 Word.word))))))))))) \<bind> ((\<lambda> (w__86 ::
                                                                   bool) . 
                                                                 if w__86 then return True
                                                                 else
                                                                   and_boolM
                                                                     ((is_RV32F_or_RV64F () ))
                                                                     (return ((((((((subrange_vec_dec
                                                                                         v__469
                                                                                         (( 31 :: int)::ii)
                                                                                         (( 25 :: int)::ii)
                                                                                        ::  7 Word.word)) = ( 0b0010000 ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec
                                                                                             v__469
                                                                                             (( 14 :: int)::ii)
                                                                                             (( 12 :: int)::ii)
                                                                                            ::  3 Word.word)) = ( 0b010 ::  3 Word.word)))) \<and> (((((subrange_vec_dec
                                                                                             v__469
                                                                                             (( 6 :: int)::ii)
                                                                                             (( 0 :: int)::ii)
                                                                                            ::  7 Word.word)) = ( 0b1010011 ::  7 Word.word))))))))))) \<bind> ((\<lambda> (w__88 ::
                                                                     bool) . 
                                                                   if w__88 then return True
                                                                   else
                                                                     and_boolM
                                                                       ((is_RV32F_or_RV64F () ))
                                                                       (return ((((((((subrange_vec_dec
                                                                                           v__469
                                                                                           (( 31 :: int)::ii)
                                                                                           (( 25 :: int)::ii)
                                                                                          ::  7 Word.word)) = ( 0b0010100 ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec
                                                                                               v__469
                                                                                               (( 14 :: int)::ii)
                                                                                               (( 12 :: int)::ii)
                                                                                              ::  3 Word.word)) = ( 0b000 ::  3 Word.word)))) \<and> (((((subrange_vec_dec
                                                                                               v__469
                                                                                               (( 6 :: int)::ii)
                                                                                               (( 0 :: int)::ii)
                                                                                              ::  7 Word.word)) = ( 0b1010011 ::  7 Word.word))))))))))) \<bind> ((\<lambda> (w__90 ::
                                                                       bool) . 
                                                                     if w__90 then return True
                                                                     else
                                                                       and_boolM
                                                                         ((is_RV32F_or_RV64F () ))
                                                                         (return ((((((((subrange_vec_dec
                                                                                             v__469
                                                                                             (( 31 :: int)::ii)
                                                                                             (( 25 :: int)::ii)
                                                                                            ::  7 Word.word)) = ( 0b0010100 ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec
                                                                                                 v__469
                                                                                                 (( 14 :: int)::ii)
                                                                                                 (( 12 :: int)::ii)
                                                                                                ::  3 Word.word)) = ( 0b001 ::  3 Word.word)))) \<and> (((((subrange_vec_dec
                                                                                                 v__469
                                                                                                 (( 6 :: int)::ii)
                                                                                                 (( 0 :: int)::ii)
                                                                                                ::  7 Word.word)) = ( 0b1010011 ::  7 Word.word))))))))))) \<bind> ((\<lambda> (w__92 ::
                                                                         bool) . 
                                                                       if w__92 then return True
                                                                       else
                                                                         and_boolM
                                                                           ((is_RV32F_or_RV64F () ))
                                                                           (return ((((((((subrange_vec_dec
                                                                                               v__469
                                                                                               (( 31 :: int)::ii)
                                                                                               (( 25 :: int)::ii)
                                                                                              ::  7 Word.word)) = ( 0b1010000 ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec
                                                                                                   v__469
                                                                                                   (( 14 :: int)::ii)
                                                                                                   (( 12 :: int)::ii)
                                                                                                  ::  3 Word.word)) = ( 0b010 ::  3 Word.word)))) \<and> (((((subrange_vec_dec
                                                                                                   v__469
                                                                                                   (( 6 :: int)::ii)
                                                                                                   (( 0 :: int)::ii)
                                                                                                  ::  7 Word.word)) = ( 0b1010011 ::  7 Word.word))))))))))) \<bind> ((\<lambda> (w__94 ::
                                                                           bool) . 
                                                                         if w__94 then return True
                                                                         else
                                                                           and_boolM
                                                                             ((is_RV32F_or_RV64F () ))
                                                                             (return ((((((((subrange_vec_dec
                                                                                                 v__469
                                                                                                 (( 31 :: int)::ii)
                                                                                                 (( 25 :: int)::ii)
                                                                                                ::  7 Word.word)) = ( 0b1010000 ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec
                                                                                                     v__469
                                                                                                     (( 14 :: int)::ii)
                                                                                                     (( 12 :: int)::ii)
                                                                                                    ::  3 Word.word)) = ( 0b001 ::  3 Word.word)))) \<and> (((((subrange_vec_dec
                                                                                                     v__469
                                                                                                     (( 6 :: int)::ii)
                                                                                                     (( 0 :: int)::ii)
                                                                                                    ::  7 Word.word)) = ( 0b1010011 ::  7 Word.word))))))))))) \<bind> ((\<lambda> (w__96 ::
                                                                             bool) . 
                                                                           if w__96 then return True
                                                                           else
                                                                             and_boolM
                                                                               ((is_RV32F_or_RV64F
                                                                                   () ))
                                                                               (return ((((((((subrange_vec_dec
                                                                                                   v__469
                                                                                                   (( 31 :: int)::ii)
                                                                                                   (( 25 :: int)::ii)
                                                                                                  ::  7 Word.word)) = ( 0b1010000 ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec
                                                                                                       v__469
                                                                                                       (( 14 :: int)::ii)
                                                                                                       (( 12 :: int)::ii)
                                                                                                      ::  3 Word.word)) = ( 0b000 ::  3 Word.word)))) \<and> (((((subrange_vec_dec
                                                                                                       v__469
                                                                                                       (( 6 :: int)::ii)
                                                                                                       (( 0 :: int)::ii)
                                                                                                      ::  7 Word.word)) = ( 0b1010011 ::  7 Word.word))))))))))) \<bind> ((\<lambda> (w__98 ::
                                                                               bool) . 
                                                                             if w__98 then
                                                                               return True
                                                                             else
                                                                               and_boolM
                                                                                 ((haveFExt () ))
                                                                                 (return ((((((((subrange_vec_dec
                                                                                                     v__469
                                                                                                     (( 31 :: int)::ii)
                                                                                                     (( 20 :: int)::ii)
                                                                                                    ::  12 Word.word)) = ( 0xE00 ::  12 Word.word)))) \<and> ((((((((subrange_vec_dec
                                                                                                         v__469
                                                                                                         (( 14 :: int)::ii)
                                                                                                         (( 12 :: int)::ii)
                                                                                                        ::  3 Word.word)) = ( 0b001 ::  3 Word.word)))) \<and> (((((subrange_vec_dec
                                                                                                         v__469
                                                                                                         (( 6 :: int)::ii)
                                                                                                         (( 0 :: int)::ii)
                                                                                                        ::  7 Word.word)) = ( 0b1010011 ::  7 Word.word))))))))))) \<bind> ((\<lambda> (w__100 ::
                                                                                 bool) . 
                                                                               if w__100 then
                                                                                 return True
                                                                               else
                                                                                 and_boolM
                                                                                   ((haveFExt () ))
                                                                                   (return ((((((((subrange_vec_dec
                                                                                                       v__469
                                                                                                       (( 31 :: int)::ii)
                                                                                                       (( 20 :: int)::ii)
                                                                                                      ::  12 Word.word)) = ( 0xE00 ::  12 Word.word)))) \<and> ((((((((subrange_vec_dec
                                                                                                           v__469
                                                                                                           (( 14 :: int)::ii)
                                                                                                           (( 12 :: int)::ii)
                                                                                                          ::  3 Word.word)) = ( 0b000 ::  3 Word.word)))) \<and> (((((subrange_vec_dec
                                                                                                           v__469
                                                                                                           (( 6 :: int)::ii)
                                                                                                           (( 0 :: int)::ii)
                                                                                                          ::  7 Word.word)) = ( 0b1010011 ::  7 Word.word))))))))))) \<bind> ((\<lambda> (w__102 ::
                                                                                   bool) . 
                                                                                 if w__102 then
                                                                                   return True
                                                                                 else
                                                                                   and_boolM
                                                                                     ((haveFExt () ))
                                                                                     (return ((((((((subrange_vec_dec
                                                                                                         v__469
                                                                                                         (( 31 :: int)::ii)
                                                                                                         (( 20 :: int)::ii)
                                                                                                        ::  12 Word.word)) = ( 0xF00 ::  12 Word.word)))) \<and> ((((((((subrange_vec_dec
                                                                                                             v__469
                                                                                                             (( 14 :: int)::ii)
                                                                                                             (( 12 :: int)::ii)
                                                                                                            ::  3 Word.word)) = ( 0b000 ::  3 Word.word)))) \<and> (((((subrange_vec_dec
                                                                                                             v__469
                                                                                                             (( 6 :: int)::ii)
                                                                                                             (( 0 :: int)::ii)
                                                                                                            ::  7 Word.word)) = ( 0b1010011 ::  7 Word.word))))))))))) \<bind> ((\<lambda> (w__104 ::
                                                                                     bool) . 
                                                                                   if w__104 then
                                                                                     return True
                                                                                   else
                                                                                     and_boolM
                                                                                       ((let (mappingpatterns_400 ::
                                                                                          3 Word.word) =
                                                                                         ((subrange_vec_dec
                                                                                            v__469
                                                                                            (( 14 :: int)::ii)
                                                                                            (( 12 :: int)::ii)
                                                                                           ::  3 Word.word)) in
                                                                                       if ((encdec_rounding_mode_backwards_matches
                                                                                              mappingpatterns_400))
                                                                                       then
                                                                                         encdec_rounding_mode_backwards
                                                                                           mappingpatterns_400 \<bind> ((\<lambda> rm . 
                                                                                         is_RV32D_or_RV64D
                                                                                           () ))
                                                                                       else
                                                                                         return False))
                                                                                       (return ((((((((subrange_vec_dec
                                                                                                           v__469
                                                                                                           (( 26 :: int)::ii)
                                                                                                           (( 25 :: int)::ii)
                                                                                                          ::  2 Word.word)) = ( 0b01 ::  2 Word.word)))) \<and> (((((subrange_vec_dec
                                                                                                           v__469
                                                                                                           (( 6 :: int)::ii)
                                                                                                           (( 0 :: int)::ii)
                                                                                                          ::  7 Word.word)) = ( 0b1000011 ::  7 Word.word)))))))) \<bind> ((\<lambda> (w__107 ::
                                                                                       bool) . 
                                                                                     if w__107 then
                                                                                       (let (mappingpatterns_400 ::
                                                                                          3 Word.word) =
                                                                                         ((subrange_vec_dec
                                                                                            v__469
                                                                                            (( 14 :: int)::ii)
                                                                                            (( 12 :: int)::ii)
                                                                                           ::  3 Word.word)) in
                                                                                       encdec_rounding_mode_backwards
                                                                                         mappingpatterns_400 \<bind> ((\<lambda> rm . 
                                                                                       return True)))
                                                                                     else
                                                                                       and_boolM
                                                                                         ((let (mappingpatterns_410 ::
                                                                                            3 Word.word) =
                                                                                           ((subrange_vec_dec
                                                                                              v__469
                                                                                              (( 14 :: int)::ii)
                                                                                              (( 12 :: int)::ii)
                                                                                             ::  3 Word.word)) in
                                                                                         if ((encdec_rounding_mode_backwards_matches
                                                                                                mappingpatterns_410))
                                                                                         then
                                                                                           encdec_rounding_mode_backwards
                                                                                             mappingpatterns_410 \<bind> ((\<lambda> rm . 
                                                                                           is_RV32D_or_RV64D
                                                                                             () ))
                                                                                         else
                                                                                           return False))
                                                                                         (return ((((((((subrange_vec_dec
                                                                                                             v__469
                                                                                                             (( 26 :: int)::ii)
                                                                                                             (( 25 :: int)::ii)
                                                                                                            ::  2 Word.word)) = ( 0b01 ::  2 Word.word)))) \<and> (((((subrange_vec_dec
                                                                                                             v__469
                                                                                                             (( 6 :: int)::ii)
                                                                                                             (( 0 :: int)::ii)
                                                                                                            ::  7 Word.word)) = ( 0b1000111 ::  7 Word.word)))))))) \<bind> ((\<lambda> (w__110 ::
                                                                                         bool) . 
                                                                                       if w__110
                                                                                       then
                                                                                         (let (mappingpatterns_410 ::
                                                                                            3 Word.word) =
                                                                                           ((subrange_vec_dec
                                                                                              v__469
                                                                                              (( 14 :: int)::ii)
                                                                                              (( 12 :: int)::ii)
                                                                                             ::  3 Word.word)) in
                                                                                         encdec_rounding_mode_backwards
                                                                                           mappingpatterns_410 \<bind> ((\<lambda> rm . 
                                                                                         return True)))
                                                                                       else
                                                                                         and_boolM
                                                                                           ((let (mappingpatterns_420 ::
                                                                                              3 Word.word) =
                                                                                             ((subrange_vec_dec
                                                                                                v__469
                                                                                                (( 14 :: int)::ii)
                                                                                                (( 12 :: int)::ii)
                                                                                               ::  3 Word.word)) in
                                                                                           if ((encdec_rounding_mode_backwards_matches
                                                                                                  mappingpatterns_420))
                                                                                           then
                                                                                             encdec_rounding_mode_backwards
                                                                                               mappingpatterns_420 \<bind> ((\<lambda> rm . 
                                                                                             is_RV32D_or_RV64D
                                                                                               () ))
                                                                                           else
                                                                                             return False))
                                                                                           (return ((((((((subrange_vec_dec
                                                                                                               v__469
                                                                                                               (( 26 :: int)::ii)
                                                                                                               (( 25 :: int)::ii)
                                                                                                              ::  2 Word.word)) = ( 0b01 ::  2 Word.word)))) \<and> (((((subrange_vec_dec
                                                                                                               v__469
                                                                                                               (( 6 :: int)::ii)
                                                                                                               (( 0 :: int)::ii)
                                                                                                              ::  7 Word.word)) = ( 0b1001011 ::  7 Word.word)))))))) \<bind> ((\<lambda> (w__113 ::
                                                                                           bool) . 
                                                                                         if w__113
                                                                                         then
                                                                                           (let (mappingpatterns_420 ::
                                                                                              3 Word.word) =
                                                                                             ((subrange_vec_dec
                                                                                                v__469
                                                                                                (( 14 :: int)::ii)
                                                                                                (( 12 :: int)::ii)
                                                                                               ::  3 Word.word)) in
                                                                                           encdec_rounding_mode_backwards
                                                                                             mappingpatterns_420 \<bind> ((\<lambda> rm . 
                                                                                           return True)))
                                                                                         else
                                                                                           and_boolM
                                                                                             ((let (mappingpatterns_430 ::
                                                                                                3 Word.word) =
                                                                                               ((subrange_vec_dec
                                                                                                  v__469
                                                                                                  (( 14 :: int)::ii)
                                                                                                  (( 12 :: int)::ii)
                                                                                                 ::  3 Word.word)) in
                                                                                             if ((encdec_rounding_mode_backwards_matches
                                                                                                    mappingpatterns_430))
                                                                                             then
                                                                                               encdec_rounding_mode_backwards
                                                                                                 mappingpatterns_430 \<bind> ((\<lambda> rm . 
                                                                                               is_RV32D_or_RV64D
                                                                                                 () ))
                                                                                             else
                                                                                               return False))
                                                                                             (return ((((((((subrange_vec_dec
                                                                                                                 v__469
                                                                                                                 (( 26 :: int)::ii)
                                                                                                                 (( 25 :: int)::ii)
                                                                                                                ::  2 Word.word)) = ( 0b01 ::  2 Word.word)))) \<and> (((((subrange_vec_dec
                                                                                                                 v__469
                                                                                                                 (( 6 :: int)::ii)
                                                                                                                 (( 0 :: int)::ii)
                                                                                                                ::  7 Word.word)) = ( 0b1001111 ::  7 Word.word)))))))) \<bind> ((\<lambda> (w__116 ::
                                                                                             bool) . 
                                                                                           if w__116
                                                                                           then
                                                                                             (let (mappingpatterns_430 ::
                                                                                                3 Word.word) =
                                                                                               ((subrange_vec_dec
                                                                                                  v__469
                                                                                                  (( 14 :: int)::ii)
                                                                                                  (( 12 :: int)::ii)
                                                                                                 ::  3 Word.word)) in
                                                                                             encdec_rounding_mode_backwards
                                                                                               mappingpatterns_430 \<bind> ((\<lambda> rm . 
                                                                                             return True)))
                                                                                           else
                                                                                             and_boolM
                                                                                               ((let (mappingpatterns_440 ::
                                                                                                  3 Word.word) =
                                                                                                 ((subrange_vec_dec
                                                                                                    v__469
                                                                                                    (( 14 :: int)::ii)
                                                                                                    (( 12 :: int)::ii)
                                                                                                   ::  3 Word.word)) in
                                                                                               if ((encdec_rounding_mode_backwards_matches
                                                                                                      mappingpatterns_440))
                                                                                               then
                                                                                                 encdec_rounding_mode_backwards
                                                                                                   mappingpatterns_440 \<bind> ((\<lambda> rm . 
                                                                                                 is_RV32D_or_RV64D
                                                                                                   () ))
                                                                                               else
                                                                                                 return False))
                                                                                               (return ((((((((subrange_vec_dec
                                                                                                                   v__469
                                                                                                                   (( 31 :: int)::ii)
                                                                                                                   (( 25 :: int)::ii)
                                                                                                                  ::  7 Word.word)) = ( 0b0000001 ::  7 Word.word)))) \<and> (((((subrange_vec_dec
                                                                                                                   v__469
                                                                                                                   (( 6 :: int)::ii)
                                                                                                                   (( 0 :: int)::ii)
                                                                                                                  ::  7 Word.word)) = ( 0b1010011 ::  7 Word.word)))))))) \<bind> ((\<lambda> (w__119 ::
                                                                                               bool) . 
                                                                                             if w__119
                                                                                             then
                                                                                               (let (mappingpatterns_440 ::
                                                                                                  3 Word.word) =
                                                                                                 ((subrange_vec_dec
                                                                                                    v__469
                                                                                                    (( 14 :: int)::ii)
                                                                                                    (( 12 :: int)::ii)
                                                                                                   ::  3 Word.word)) in
                                                                                               encdec_rounding_mode_backwards
                                                                                                 mappingpatterns_440 \<bind> ((\<lambda> rm . 
                                                                                               return True)))
                                                                                             else
                                                                                               and_boolM
                                                                                                 ((let (mappingpatterns_450 ::
                                                                                                    3 Word.word) =
                                                                                                   ((subrange_vec_dec
                                                                                                      v__469
                                                                                                      (( 14 :: int)::ii)
                                                                                                      (( 12 :: int)::ii)
                                                                                                     ::  3 Word.word)) in
                                                                                                 if ((encdec_rounding_mode_backwards_matches
                                                                                                        mappingpatterns_450))
                                                                                                 then
                                                                                                   encdec_rounding_mode_backwards
                                                                                                     mappingpatterns_450 \<bind> ((\<lambda> rm . 
                                                                                                   is_RV32D_or_RV64D
                                                                                                     () ))
                                                                                                 else
                                                                                                   return False))
                                                                                                 (return ((((((((subrange_vec_dec
                                                                                                                     v__469
                                                                                                                     (( 31 :: int)::ii)
                                                                                                                     (( 25 :: int)::ii)
                                                                                                                    ::  7 Word.word)) = ( 0b0000101 ::  7 Word.word)))) \<and> (((((subrange_vec_dec
                                                                                                                     v__469
                                                                                                                     (( 6 :: int)::ii)
                                                                                                                     (( 0 :: int)::ii)
                                                                                                                    ::  7 Word.word)) = ( 0b1010011 ::  7 Word.word)))))))) \<bind> ((\<lambda> (w__122 ::
                                                                                                 bool) . 
                                                                                               if w__122
                                                                                               then
                                                                                                 (let (mappingpatterns_450 ::
                                                                                                    3 Word.word) =
                                                                                                   ((subrange_vec_dec
                                                                                                      v__469
                                                                                                      (( 14 :: int)::ii)
                                                                                                      (( 12 :: int)::ii)
                                                                                                     ::  3 Word.word)) in
                                                                                                 encdec_rounding_mode_backwards
                                                                                                   mappingpatterns_450 \<bind> ((\<lambda> rm . 
                                                                                                 return True)))
                                                                                               else
                                                                                                 and_boolM
                                                                                                   ((let (mappingpatterns_460 ::
                                                                                                      3 Word.word) =
                                                                                                     ((subrange_vec_dec
                                                                                                        v__469
                                                                                                        (( 14 :: int)::ii)
                                                                                                        (( 12 :: int)::ii)
                                                                                                       ::  3 Word.word)) in
                                                                                                   if
                                                                                                     ((encdec_rounding_mode_backwards_matches
                                                                                                         mappingpatterns_460))
                                                                                                   then
                                                                                                     encdec_rounding_mode_backwards
                                                                                                       mappingpatterns_460 \<bind> ((\<lambda> rm . 
                                                                                                     is_RV32D_or_RV64D
                                                                                                       () ))
                                                                                                   else
                                                                                                     return False))
                                                                                                   (return ((((((((subrange_vec_dec
                                                                                                                       v__469
                                                                                                                       (( 31 :: int)::ii)
                                                                                                                       (( 25 :: int)::ii)
                                                                                                                      ::  7 Word.word)) = ( 0b0001001 ::  7 Word.word)))) \<and> (((((subrange_vec_dec
                                                                                                                       v__469
                                                                                                                       (( 6 :: int)::ii)
                                                                                                                       (( 0 :: int)::ii)
                                                                                                                      ::  7 Word.word)) = ( 0b1010011 ::  7 Word.word)))))))) \<bind> ((\<lambda> (w__125 ::
                                                                                                   bool) . 
                                                                                                 if w__125
                                                                                                 then
                                                                                                   (let (mappingpatterns_460 ::
                                                                                                      3 Word.word) =
                                                                                                     ((subrange_vec_dec
                                                                                                        v__469
                                                                                                        (( 14 :: int)::ii)
                                                                                                        (( 12 :: int)::ii)
                                                                                                       ::  3 Word.word)) in
                                                                                                   encdec_rounding_mode_backwards
                                                                                                     mappingpatterns_460 \<bind> ((\<lambda> rm . 
                                                                                                   return True)))
                                                                                                 else
                                                                                                   and_boolM
                                                                                                     ((let (mappingpatterns_470 ::
                                                                                                        3 Word.word) =
                                                                                                       ((subrange_vec_dec
                                                                                                          v__469
                                                                                                          (( 14 :: int)::ii)
                                                                                                          (( 12 :: int)::ii)
                                                                                                         ::  3 Word.word)) in
                                                                                                     if
                                                                                                       ((encdec_rounding_mode_backwards_matches
                                                                                                           mappingpatterns_470))
                                                                                                     then
                                                                                                       encdec_rounding_mode_backwards
                                                                                                         mappingpatterns_470 \<bind> ((\<lambda> rm . 
                                                                                                       is_RV32D_or_RV64D
                                                                                                         () ))
                                                                                                     else
                                                                                                       return False))
                                                                                                     (return ((((((((subrange_vec_dec
                                                                                                                         v__469
                                                                                                                         (( 31 :: int)::ii)
                                                                                                                         (( 25 :: int)::ii)
                                                                                                                        ::  7 Word.word)) = ( 0b0001101 ::  7 Word.word)))) \<and> (((((subrange_vec_dec
                                                                                                                         v__469
                                                                                                                         (( 6 :: int)::ii)
                                                                                                                         (( 0 :: int)::ii)
                                                                                                                        ::  7 Word.word)) = ( 0b1010011 ::  7 Word.word)))))))) \<bind> ((\<lambda> (w__128 ::
                                                                                                     bool) . 
                                                                                                   if
                                                                                                     w__128
                                                                                                   then
                                                                                                     (let (mappingpatterns_470 ::
                                                                                                        3 Word.word) =
                                                                                                       ((subrange_vec_dec
                                                                                                          v__469
                                                                                                          (( 14 :: int)::ii)
                                                                                                          (( 12 :: int)::ii)
                                                                                                         ::  3 Word.word)) in
                                                                                                     encdec_rounding_mode_backwards
                                                                                                       mappingpatterns_470 \<bind> ((\<lambda> rm . 
                                                                                                     return True)))
                                                                                                   else
                                                                                                     and_boolM
                                                                                                       ((let (mappingpatterns_480 ::
                                                                                                          3 Word.word) =
                                                                                                         ((subrange_vec_dec
                                                                                                            v__469
                                                                                                            (( 14 :: int)::ii)
                                                                                                            (( 12 :: int)::ii)
                                                                                                           ::  3 Word.word)) in
                                                                                                       if
                                                                                                         ((encdec_rounding_mode_backwards_matches
                                                                                                             mappingpatterns_480))
                                                                                                       then
                                                                                                         encdec_rounding_mode_backwards
                                                                                                           mappingpatterns_480 \<bind> ((\<lambda> rm . 
                                                                                                         is_RV32D_or_RV64D
                                                                                                           () ))
                                                                                                       else
                                                                                                         return False))
                                                                                                       (return ((((((((subrange_vec_dec
                                                                                                                           v__469
                                                                                                                           (( 31 :: int)::ii)
                                                                                                                           (( 20 :: int)::ii)
                                                                                                                          ::  12 Word.word)) = ( 0x5A0 ::  12 Word.word)))) \<and> (((((subrange_vec_dec
                                                                                                                           v__469
                                                                                                                           (( 6 :: int)::ii)
                                                                                                                           (( 0 :: int)::ii)
                                                                                                                          ::  7 Word.word)) = ( 0b1010011 ::  7 Word.word)))))))) \<bind> ((\<lambda> (w__131 ::
                                                                                                       bool) . 
                                                                                                     if
                                                                                                       w__131
                                                                                                     then
                                                                                                       (let (mappingpatterns_480 ::
                                                                                                          3 Word.word) =
                                                                                                         ((subrange_vec_dec
                                                                                                            v__469
                                                                                                            (( 14 :: int)::ii)
                                                                                                            (( 12 :: int)::ii)
                                                                                                           ::  3 Word.word)) in
                                                                                                       encdec_rounding_mode_backwards
                                                                                                         mappingpatterns_480 \<bind> ((\<lambda> rm . 
                                                                                                       return True)))
                                                                                                     else
                                                                                                       and_boolM
                                                                                                         ((let (mappingpatterns_490 ::
                                                                                                            3 Word.word) =
                                                                                                           ((subrange_vec_dec
                                                                                                              v__469
                                                                                                              (( 14 :: int)::ii)
                                                                                                              (( 12 :: int)::ii)
                                                                                                             ::  3 Word.word)) in
                                                                                                         if
                                                                                                           ((encdec_rounding_mode_backwards_matches
                                                                                                               mappingpatterns_490))
                                                                                                         then
                                                                                                           encdec_rounding_mode_backwards
                                                                                                             mappingpatterns_490 \<bind> ((\<lambda> rm . 
                                                                                                           is_RV32D_or_RV64D
                                                                                                             () ))
                                                                                                         else
                                                                                                           return False))
                                                                                                         (return ((((((((subrange_vec_dec
                                                                                                                             v__469
                                                                                                                             (( 31 :: int)::ii)
                                                                                                                             (( 20 :: int)::ii)
                                                                                                                            ::  12 Word.word)) = ( 0xC20 ::  12 Word.word)))) \<and> (((((subrange_vec_dec
                                                                                                                             v__469
                                                                                                                             (( 6 :: int)::ii)
                                                                                                                             (( 0 :: int)::ii)
                                                                                                                            ::  7 Word.word)) = ( 0b1010011 ::  7 Word.word)))))))) \<bind> ((\<lambda> (w__134 ::
                                                                                                         bool) . 
                                                                                                       if
                                                                                                         w__134
                                                                                                       then
                                                                                                         (let (mappingpatterns_490 ::
                                                                                                            3 Word.word) =
                                                                                                           ((subrange_vec_dec
                                                                                                              v__469
                                                                                                              (( 14 :: int)::ii)
                                                                                                              (( 12 :: int)::ii)
                                                                                                             ::  3 Word.word)) in
                                                                                                         encdec_rounding_mode_backwards
                                                                                                           mappingpatterns_490 \<bind> ((\<lambda> rm . 
                                                                                                         return True)))
                                                                                                       else
                                                                                                         and_boolM
                                                                                                           ((let (mappingpatterns_500 ::
                                                                                                              3 Word.word) =
                                                                                                             ((subrange_vec_dec
                                                                                                                v__469
                                                                                                                (( 14 :: int)::ii)
                                                                                                                (( 12 :: int)::ii)
                                                                                                               ::  3 Word.word)) in
                                                                                                           if
                                                                                                             ((encdec_rounding_mode_backwards_matches
                                                                                                                 mappingpatterns_500))
                                                                                                           then
                                                                                                             encdec_rounding_mode_backwards
                                                                                                               mappingpatterns_500 \<bind> ((\<lambda> rm . 
                                                                                                             is_RV32D_or_RV64D
                                                                                                               () ))
                                                                                                           else
                                                                                                             return False))
                                                                                                           (return ((((((((subrange_vec_dec
                                                                                                                               v__469
                                                                                                                               (( 31 :: int)::ii)
                                                                                                                               (( 20 :: int)::ii)
                                                                                                                              ::  12 Word.word)) = ( 0xC21 ::  12 Word.word)))) \<and> (((((subrange_vec_dec
                                                                                                                               v__469
                                                                                                                               (( 6 :: int)::ii)
                                                                                                                               (( 0 :: int)::ii)
                                                                                                                              ::  7 Word.word)) = ( 0b1010011 ::  7 Word.word)))))))) \<bind> ((\<lambda> (w__137 ::
                                                                                                           bool) . 
                                                                                                         if
                                                                                                           w__137
                                                                                                         then
                                                                                                           (let (mappingpatterns_500 ::
                                                                                                              3 Word.word) =
                                                                                                             ((subrange_vec_dec
                                                                                                                v__469
                                                                                                                (( 14 :: int)::ii)
                                                                                                                (( 12 :: int)::ii)
                                                                                                               ::  3 Word.word)) in
                                                                                                           encdec_rounding_mode_backwards
                                                                                                             mappingpatterns_500 \<bind> ((\<lambda> rm . 
                                                                                                           return True)))
                                                                                                         else
                                                                                                           and_boolM
                                                                                                             ((let (mappingpatterns_510 ::
                                                                                                                3 Word.word) =
                                                                                                               ((subrange_vec_dec
                                                                                                                  v__469
                                                                                                                  (( 14 :: int)::ii)
                                                                                                                  (( 12 :: int)::ii)
                                                                                                                 ::  3 Word.word)) in
                                                                                                             if
                                                                                                               ((encdec_rounding_mode_backwards_matches
                                                                                                                   mappingpatterns_510))
                                                                                                             then
                                                                                                               encdec_rounding_mode_backwards
                                                                                                                 mappingpatterns_510 \<bind> ((\<lambda> rm . 
                                                                                                               is_RV32D_or_RV64D
                                                                                                                 () ))
                                                                                                             else
                                                                                                               return False))
                                                                                                             (return ((((((((subrange_vec_dec
                                                                                                                                 v__469
                                                                                                                                 (( 31 :: int)::ii)
                                                                                                                                 (( 20 :: int)::ii)
                                                                                                                                ::  12 Word.word)) = ( 0xD20 ::  12 Word.word)))) \<and> (((((subrange_vec_dec
                                                                                                                                 v__469
                                                                                                                                 (( 6 :: int)::ii)
                                                                                                                                 (( 0 :: int)::ii)
                                                                                                                                ::  7 Word.word)) = ( 0b1010011 ::  7 Word.word)))))))) \<bind> ((\<lambda> (w__140 ::
                                                                                                             bool) . 
                                                                                                           if
                                                                                                             w__140
                                                                                                           then
                                                                                                             (let (mappingpatterns_510 ::
                                                                                                                3 Word.word) =
                                                                                                               ((subrange_vec_dec
                                                                                                                  v__469
                                                                                                                  (( 14 :: int)::ii)
                                                                                                                  (( 12 :: int)::ii)
                                                                                                                 ::  3 Word.word)) in
                                                                                                             encdec_rounding_mode_backwards
                                                                                                               mappingpatterns_510 \<bind> ((\<lambda> rm . 
                                                                                                             return True)))
                                                                                                           else
                                                                                                             and_boolM
                                                                                                               ((let (mappingpatterns_520 ::
                                                                                                                  3 Word.word) =
                                                                                                                 ((subrange_vec_dec
                                                                                                                    v__469
                                                                                                                    (( 14 :: int)::ii)
                                                                                                                    (( 12 :: int)::ii)
                                                                                                                   ::  3 Word.word)) in
                                                                                                               if
                                                                                                                 ((encdec_rounding_mode_backwards_matches
                                                                                                                     mappingpatterns_520))
                                                                                                               then
                                                                                                                 encdec_rounding_mode_backwards
                                                                                                                   mappingpatterns_520 \<bind> ((\<lambda> rm . 
                                                                                                                 is_RV32D_or_RV64D
                                                                                                                   () ))
                                                                                                               else
                                                                                                                 return False))
                                                                                                               (return ((((((((subrange_vec_dec
                                                                                                                                   v__469
                                                                                                                                   (( 31 :: int)::ii)
                                                                                                                                   (( 20 :: int)::ii)
                                                                                                                                  ::  12 Word.word)) = ( 0xD21 ::  12 Word.word)))) \<and> (((((subrange_vec_dec
                                                                                                                                   v__469
                                                                                                                                   (( 6 :: int)::ii)
                                                                                                                                   (( 0 :: int)::ii)
                                                                                                                                  ::  7 Word.word)) = ( 0b1010011 ::  7 Word.word)))))))) \<bind> ((\<lambda> (w__143 ::
                                                                                                               bool) . 
                                                                                                             if
                                                                                                               w__143
                                                                                                             then
                                                                                                               (let (mappingpatterns_520 ::
                                                                                                                  3 Word.word) =
                                                                                                                 ((subrange_vec_dec
                                                                                                                    v__469
                                                                                                                    (( 14 :: int)::ii)
                                                                                                                    (( 12 :: int)::ii)
                                                                                                                   ::  3 Word.word)) in
                                                                                                               encdec_rounding_mode_backwards
                                                                                                                 mappingpatterns_520 \<bind> ((\<lambda> rm . 
                                                                                                               return True)))
                                                                                                             else
                                                                                                               and_boolM
                                                                                                                 ((let (mappingpatterns_530 ::
                                                                                                                    3 Word.word) =
                                                                                                                   ((subrange_vec_dec
                                                                                                                      v__469
                                                                                                                      (( 14 :: int)::ii)
                                                                                                                      (( 12 :: int)::ii)
                                                                                                                     ::  3 Word.word)) in
                                                                                                                 if
                                                                                                                   ((encdec_rounding_mode_backwards_matches
                                                                                                                       mappingpatterns_530))
                                                                                                                 then
                                                                                                                   encdec_rounding_mode_backwards
                                                                                                                     mappingpatterns_530 \<bind> ((\<lambda> rm . 
                                                                                                                   is_RV32D_or_RV64D
                                                                                                                     () ))
                                                                                                                 else
                                                                                                                   return False))
                                                                                                                 (return ((((((((subrange_vec_dec
                                                                                                                                     v__469
                                                                                                                                     (( 31 :: int)::ii)
                                                                                                                                     (( 20 :: int)::ii)
                                                                                                                                    ::  12 Word.word)) = ( 0x401 ::  12 Word.word)))) \<and> (((((subrange_vec_dec
                                                                                                                                     v__469
                                                                                                                                     (( 6 :: int)::ii)
                                                                                                                                     (( 0 :: int)::ii)
                                                                                                                                    ::  7 Word.word)) = ( 0b1010011 ::  7 Word.word)))))))) \<bind> ((\<lambda> (w__146 ::
                                                                                                                 bool) . 
                                                                                                               if
                                                                                                                 w__146
                                                                                                               then
                                                                                                                 (let (mappingpatterns_530 ::
                                                                                                                    3 Word.word) =
                                                                                                                   ((subrange_vec_dec
                                                                                                                      v__469
                                                                                                                      (( 14 :: int)::ii)
                                                                                                                      (( 12 :: int)::ii)
                                                                                                                     ::  3 Word.word)) in
                                                                                                                 encdec_rounding_mode_backwards
                                                                                                                   mappingpatterns_530 \<bind> ((\<lambda> rm . 
                                                                                                                 return True)))
                                                                                                               else
                                                                                                                 and_boolM
                                                                                                                   ((let (mappingpatterns_540 ::
                                                                                                                      3 Word.word) =
                                                                                                                     ((subrange_vec_dec
                                                                                                                        v__469
                                                                                                                        (( 14 :: int)::ii)
                                                                                                                        (( 12 :: int)::ii)
                                                                                                                       ::  3 Word.word)) in
                                                                                                                   if
                                                                                                                     ((encdec_rounding_mode_backwards_matches
                                                                                                                         mappingpatterns_540))
                                                                                                                   then
                                                                                                                     encdec_rounding_mode_backwards
                                                                                                                       mappingpatterns_540 \<bind> ((\<lambda> rm . 
                                                                                                                     is_RV32D_or_RV64D
                                                                                                                       () ))
                                                                                                                   else
                                                                                                                     return False))
                                                                                                                   (return ((((((((subrange_vec_dec
                                                                                                                                       v__469
                                                                                                                                       (( 31 :: int)::ii)
                                                                                                                                       (( 20 :: int)::ii)
                                                                                                                                      ::  12 Word.word)) = ( 0x420 ::  12 Word.word)))) \<and> (((((subrange_vec_dec
                                                                                                                                       v__469
                                                                                                                                       (( 6 :: int)::ii)
                                                                                                                                       (( 0 :: int)::ii)
                                                                                                                                      ::  7 Word.word)) = ( 0b1010011 ::  7 Word.word)))))))) \<bind> ((\<lambda> (w__149 ::
                                                                                                                   bool) . 
                                                                                                                 if
                                                                                                                   w__149
                                                                                                                 then
                                                                                                                   (let (mappingpatterns_540 ::
                                                                                                                      3 Word.word) =
                                                                                                                     ((subrange_vec_dec
                                                                                                                        v__469
                                                                                                                        (( 14 :: int)::ii)
                                                                                                                        (( 12 :: int)::ii)
                                                                                                                       ::  3 Word.word)) in
                                                                                                                   encdec_rounding_mode_backwards
                                                                                                                     mappingpatterns_540 \<bind> ((\<lambda> rm . 
                                                                                                                   return True)))
                                                                                                                 else
                                                                                                                   and_boolM
                                                                                                                     ((let (mappingpatterns_550 ::
                                                                                                                        3 Word.word) =
                                                                                                                       ((subrange_vec_dec
                                                                                                                          v__469
                                                                                                                          (( 14 :: int)::ii)
                                                                                                                          (( 12 :: int)::ii)
                                                                                                                         ::  3 Word.word)) in
                                                                                                                     if
                                                                                                                       ((encdec_rounding_mode_backwards_matches
                                                                                                                           mappingpatterns_550))
                                                                                                                     then
                                                                                                                       encdec_rounding_mode_backwards
                                                                                                                         mappingpatterns_550 \<bind> ((\<lambda> rm . 
                                                                                                                       is_RV64D
                                                                                                                         () ))
                                                                                                                     else
                                                                                                                       return False))
                                                                                                                     (return ((((((((subrange_vec_dec
                                                                                                                                         v__469
                                                                                                                                         (( 31 :: int)::ii)
                                                                                                                                         (( 20 :: int)::ii)
                                                                                                                                        ::  12 Word.word)) = ( 0xC22 ::  12 Word.word)))) \<and> (((((subrange_vec_dec
                                                                                                                                         v__469
                                                                                                                                         (( 6 :: int)::ii)
                                                                                                                                         (( 0 :: int)::ii)
                                                                                                                                        ::  7 Word.word)) = ( 0b1010011 ::  7 Word.word)))))))) \<bind> ((\<lambda> (w__152 ::
                                                                                                                     bool) . 
                                                                                                                   if
                                                                                                                     w__152
                                                                                                                   then
                                                                                                                     (let (mappingpatterns_550 ::
                                                                                                                        3 Word.word) =
                                                                                                                       ((subrange_vec_dec
                                                                                                                          v__469
                                                                                                                          (( 14 :: int)::ii)
                                                                                                                          (( 12 :: int)::ii)
                                                                                                                         ::  3 Word.word)) in
                                                                                                                     encdec_rounding_mode_backwards
                                                                                                                       mappingpatterns_550 \<bind> ((\<lambda> rm . 
                                                                                                                     return True)))
                                                                                                                   else
                                                                                                                     and_boolM
                                                                                                                       ((let (mappingpatterns_560 ::
                                                                                                                          3 Word.word) =
                                                                                                                         ((subrange_vec_dec
                                                                                                                            v__469
                                                                                                                            (( 14 :: int)::ii)
                                                                                                                            (( 12 :: int)::ii)
                                                                                                                           ::  3 Word.word)) in
                                                                                                                       if
                                                                                                                         ((encdec_rounding_mode_backwards_matches
                                                                                                                             mappingpatterns_560))
                                                                                                                       then
                                                                                                                         encdec_rounding_mode_backwards
                                                                                                                           mappingpatterns_560 \<bind> ((\<lambda> rm . 
                                                                                                                         is_RV64D
                                                                                                                           () ))
                                                                                                                       else
                                                                                                                         return False))
                                                                                                                       (return ((((((((subrange_vec_dec
                                                                                                                                           v__469
                                                                                                                                           (( 31 :: int)::ii)
                                                                                                                                           (( 20 :: int)::ii)
                                                                                                                                          ::  12 Word.word)) = ( 0xC23 ::  12 Word.word)))) \<and> (((((subrange_vec_dec
                                                                                                                                           v__469
                                                                                                                                           (( 6 :: int)::ii)
                                                                                                                                           (( 0 :: int)::ii)
                                                                                                                                          ::  7 Word.word)) = ( 0b1010011 ::  7 Word.word)))))))) \<bind> ((\<lambda> (w__155 ::
                                                                                                                       bool) . 
                                                                                                                     if
                                                                                                                       w__155
                                                                                                                     then
                                                                                                                       (let (mappingpatterns_560 ::
                                                                                                                          3 Word.word) =
                                                                                                                         ((subrange_vec_dec
                                                                                                                            v__469
                                                                                                                            (( 14 :: int)::ii)
                                                                                                                            (( 12 :: int)::ii)
                                                                                                                           ::  3 Word.word)) in
                                                                                                                       encdec_rounding_mode_backwards
                                                                                                                         mappingpatterns_560 \<bind> ((\<lambda> rm . 
                                                                                                                       return True)))
                                                                                                                     else
                                                                                                                       and_boolM
                                                                                                                         ((let (mappingpatterns_570 ::
                                                                                                                            3 Word.word) =
                                                                                                                           ((subrange_vec_dec
                                                                                                                              v__469
                                                                                                                              (( 14 :: int)::ii)
                                                                                                                              (( 12 :: int)::ii)
                                                                                                                             ::  3 Word.word)) in
                                                                                                                         if
                                                                                                                           ((encdec_rounding_mode_backwards_matches
                                                                                                                               mappingpatterns_570))
                                                                                                                         then
                                                                                                                           encdec_rounding_mode_backwards
                                                                                                                             mappingpatterns_570 \<bind> ((\<lambda> rm . 
                                                                                                                           is_RV64D
                                                                                                                             () ))
                                                                                                                         else
                                                                                                                           return False))
                                                                                                                         (return ((((((((subrange_vec_dec
                                                                                                                                             v__469
                                                                                                                                             (( 31 :: int)::ii)
                                                                                                                                             (( 20 :: int)::ii)
                                                                                                                                            ::  12 Word.word)) = ( 0xD22 ::  12 Word.word)))) \<and> (((((subrange_vec_dec
                                                                                                                                             v__469
                                                                                                                                             (( 6 :: int)::ii)
                                                                                                                                             (( 0 :: int)::ii)
                                                                                                                                            ::  7 Word.word)) = ( 0b1010011 ::  7 Word.word)))))))) \<bind> ((\<lambda> (w__158 ::
                                                                                                                         bool) . 
                                                                                                                       if
                                                                                                                         w__158
                                                                                                                       then
                                                                                                                         (let (mappingpatterns_570 ::
                                                                                                                            3 Word.word) =
                                                                                                                           ((subrange_vec_dec
                                                                                                                              v__469
                                                                                                                              (( 14 :: int)::ii)
                                                                                                                              (( 12 :: int)::ii)
                                                                                                                             ::  3 Word.word)) in
                                                                                                                         encdec_rounding_mode_backwards
                                                                                                                           mappingpatterns_570 \<bind> ((\<lambda> rm . 
                                                                                                                         return True)))
                                                                                                                       else
                                                                                                                         and_boolM
                                                                                                                           ((let (mappingpatterns_580 ::
                                                                                                                              3 Word.word) =
                                                                                                                             ((subrange_vec_dec
                                                                                                                                v__469
                                                                                                                                (( 14 :: int)::ii)
                                                                                                                                (( 12 :: int)::ii)
                                                                                                                               ::  3 Word.word)) in
                                                                                                                           if
                                                                                                                             ((encdec_rounding_mode_backwards_matches
                                                                                                                                 mappingpatterns_580))
                                                                                                                           then
                                                                                                                             encdec_rounding_mode_backwards
                                                                                                                               mappingpatterns_580 \<bind> ((\<lambda> rm . 
                                                                                                                             is_RV64D
                                                                                                                               () ))
                                                                                                                           else
                                                                                                                             return False))
                                                                                                                           (return ((((((((subrange_vec_dec
                                                                                                                                               v__469
                                                                                                                                               (( 31 :: int)::ii)
                                                                                                                                               (( 20 :: int)::ii)
                                                                                                                                              ::  12 Word.word)) = ( 0xD23 ::  12 Word.word)))) \<and> (((((subrange_vec_dec
                                                                                                                                               v__469
                                                                                                                                               (( 6 :: int)::ii)
                                                                                                                                               (( 0 :: int)::ii)
                                                                                                                                              ::  7 Word.word)) = ( 0b1010011 ::  7 Word.word)))))))) \<bind> ((\<lambda> (w__161 ::
                                                                                                                           bool) . 
                                                                                                                         if
                                                                                                                           w__161
                                                                                                                         then
                                                                                                                           (let (mappingpatterns_580 ::
                                                                                                                              3 Word.word) =
                                                                                                                             ((subrange_vec_dec
                                                                                                                                v__469
                                                                                                                                (( 14 :: int)::ii)
                                                                                                                                (( 12 :: int)::ii)
                                                                                                                               ::  3 Word.word)) in
                                                                                                                           encdec_rounding_mode_backwards
                                                                                                                             mappingpatterns_580 \<bind> ((\<lambda> rm . 
                                                                                                                           return True)))
                                                                                                                         else
                                                                                                                           and_boolM
                                                                                                                             ((is_RV32D_or_RV64D
                                                                                                                                 () ))
                                                                                                                             (return ((((((((subrange_vec_dec
                                                                                                                                                 v__469
                                                                                                                                                 (( 31 :: int)::ii)
                                                                                                                                                 (( 25 :: int)::ii)
                                                                                                                                                ::  7 Word.word)) = ( 0b0010001 ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec
                                                                                                                                                     v__469
                                                                                                                                                     (( 14 :: int)::ii)
                                                                                                                                                     (( 12 :: int)::ii)
                                                                                                                                                    ::  3 Word.word)) = ( 0b000 ::  3 Word.word)))) \<and> (((((subrange_vec_dec
                                                                                                                                                     v__469
                                                                                                                                                     (( 6 :: int)::ii)
                                                                                                                                                     (( 0 :: int)::ii)
                                                                                                                                                    ::  7 Word.word)) = ( 0b1010011 ::  7 Word.word))))))))))) \<bind> ((\<lambda> (w__163 ::
                                                                                                                             bool) . 
                                                                                                                           if
                                                                                                                             w__163
                                                                                                                           then
                                                                                                                             return True
                                                                                                                           else
                                                                                                                             and_boolM
                                                                                                                               ((is_RV32D_or_RV64D
                                                                                                                                   () ))
                                                                                                                               (return ((((((((subrange_vec_dec
                                                                                                                                                   v__469
                                                                                                                                                   (( 31 :: int)::ii)
                                                                                                                                                   (( 25 :: int)::ii)
                                                                                                                                                  ::  7 Word.word)) = ( 0b0010001 ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec
                                                                                                                                                       v__469
                                                                                                                                                       (( 14 :: int)::ii)
                                                                                                                                                       (( 12 :: int)::ii)
                                                                                                                                                      ::  3 Word.word)) = ( 0b001 ::  3 Word.word)))) \<and> (((((subrange_vec_dec
                                                                                                                                                       v__469
                                                                                                                                                       (( 6 :: int)::ii)
                                                                                                                                                       (( 0 :: int)::ii)
                                                                                                                                                      ::  7 Word.word)) = ( 0b1010011 ::  7 Word.word))))))))))) \<bind> ((\<lambda> (w__165 ::
                                                                                                                               bool) . 
                                                                                                                             if
                                                                                                                               w__165
                                                                                                                             then
                                                                                                                               return True
                                                                                                                             else
                                                                                                                               and_boolM
                                                                                                                                 ((is_RV32D_or_RV64D
                                                                                                                                     () ))
                                                                                                                                 (return ((((((((subrange_vec_dec
                                                                                                                                                     v__469
                                                                                                                                                     (( 31 :: int)::ii)
                                                                                                                                                     (( 25 :: int)::ii)
                                                                                                                                                    ::  7 Word.word)) = ( 0b0010001 ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec
                                                                                                                                                         v__469
                                                                                                                                                         (( 14 :: int)::ii)
                                                                                                                                                         (( 12 :: int)::ii)
                                                                                                                                                        ::  3 Word.word)) = ( 0b010 ::  3 Word.word)))) \<and> (((((subrange_vec_dec
                                                                                                                                                         v__469
                                                                                                                                                         (( 6 :: int)::ii)
                                                                                                                                                         (( 0 :: int)::ii)
                                                                                                                                                        ::  7 Word.word)) = ( 0b1010011 ::  7 Word.word))))))))))) \<bind> ((\<lambda> (w__167 ::
                                                                                                                                 bool) . 
                                                                                                                               if
                                                                                                                                 w__167
                                                                                                                               then
                                                                                                                                 return True
                                                                                                                               else
                                                                                                                                 and_boolM
                                                                                                                                   ((is_RV32D_or_RV64D
                                                                                                                                       () ))
                                                                                                                                   (return ((((((((subrange_vec_dec
                                                                                                                                                       v__469
                                                                                                                                                       (( 31 :: int)::ii)
                                                                                                                                                       (( 25 :: int)::ii)
                                                                                                                                                      ::  7 Word.word)) = ( 0b0010101 ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec
                                                                                                                                                           v__469
                                                                                                                                                           (( 14 :: int)::ii)
                                                                                                                                                           (( 12 :: int)::ii)
                                                                                                                                                          ::  3 Word.word)) = ( 0b000 ::  3 Word.word)))) \<and> (((((subrange_vec_dec
                                                                                                                                                           v__469
                                                                                                                                                           (( 6 :: int)::ii)
                                                                                                                                                           (( 0 :: int)::ii)
                                                                                                                                                          ::  7 Word.word)) = ( 0b1010011 ::  7 Word.word))))))))))) \<bind> ((\<lambda> (w__169 ::
                                                                                                                                   bool) . 
                                                                                                                                 if
                                                                                                                                   w__169
                                                                                                                                 then
                                                                                                                                   return True
                                                                                                                                 else
                                                                                                                                   and_boolM
                                                                                                                                     ((is_RV32D_or_RV64D
                                                                                                                                         () ))
                                                                                                                                     (return ((((((((subrange_vec_dec
                                                                                                                                                         v__469
                                                                                                                                                         (( 31 :: int)::ii)
                                                                                                                                                         (( 25 :: int)::ii)
                                                                                                                                                        ::  7 Word.word)) = ( 0b0010101 ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec
                                                                                                                                                             v__469
                                                                                                                                                             (( 14 :: int)::ii)
                                                                                                                                                             (( 12 :: int)::ii)
                                                                                                                                                            ::  3 Word.word)) = ( 0b001 ::  3 Word.word)))) \<and> (((((subrange_vec_dec
                                                                                                                                                             v__469
                                                                                                                                                             (( 6 :: int)::ii)
                                                                                                                                                             (( 0 :: int)::ii)
                                                                                                                                                            ::  7 Word.word)) = ( 0b1010011 ::  7 Word.word))))))))))) \<bind> ((\<lambda> (w__171 ::
                                                                                                                                     bool) . 
                                                                                                                                   if
                                                                                                                                     w__171
                                                                                                                                   then
                                                                                                                                     return True
                                                                                                                                   else
                                                                                                                                     and_boolM
                                                                                                                                       ((is_RV32D_or_RV64D
                                                                                                                                           () ))
                                                                                                                                       (return ((((((((subrange_vec_dec
                                                                                                                                                           v__469
                                                                                                                                                           (( 31 :: int)::ii)
                                                                                                                                                           (( 25 :: int)::ii)
                                                                                                                                                          ::  7 Word.word)) = ( 0b1010001 ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec
                                                                                                                                                               v__469
                                                                                                                                                               (( 14 :: int)::ii)
                                                                                                                                                               (( 12 :: int)::ii)
                                                                                                                                                              ::  3 Word.word)) = ( 0b010 ::  3 Word.word)))) \<and> (((((subrange_vec_dec
                                                                                                                                                               v__469
                                                                                                                                                               (( 6 :: int)::ii)
                                                                                                                                                               (( 0 :: int)::ii)
                                                                                                                                                              ::  7 Word.word)) = ( 0b1010011 ::  7 Word.word))))))))))) \<bind> ((\<lambda> (w__173 ::
                                                                                                                                       bool) . 
                                                                                                                                     if
                                                                                                                                       w__173
                                                                                                                                     then
                                                                                                                                       return True
                                                                                                                                     else
                                                                                                                                       and_boolM
                                                                                                                                         ((is_RV32D_or_RV64D
                                                                                                                                             () ))
                                                                                                                                         (return ((((((((subrange_vec_dec
                                                                                                                                                             v__469
                                                                                                                                                             (( 31 :: int)::ii)
                                                                                                                                                             (( 25 :: int)::ii)
                                                                                                                                                            ::  7 Word.word)) = ( 0b1010001 ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec
                                                                                                                                                                 v__469
                                                                                                                                                                 (( 14 :: int)::ii)
                                                                                                                                                                 (( 12 :: int)::ii)
                                                                                                                                                                ::  3 Word.word)) = ( 0b001 ::  3 Word.word)))) \<and> (((((subrange_vec_dec
                                                                                                                                                                 v__469
                                                                                                                                                                 (( 6 :: int)::ii)
                                                                                                                                                                 (( 0 :: int)::ii)
                                                                                                                                                                ::  7 Word.word)) = ( 0b1010011 ::  7 Word.word))))))))))) \<bind> ((\<lambda> (w__175 ::
                                                                                                                                         bool) . 
                                                                                                                                       if
                                                                                                                                         w__175
                                                                                                                                       then
                                                                                                                                         return True
                                                                                                                                       else
                                                                                                                                         and_boolM
                                                                                                                                           ((is_RV32D_or_RV64D
                                                                                                                                               () ))
                                                                                                                                           (return ((((((((subrange_vec_dec
                                                                                                                                                               v__469
                                                                                                                                                               (( 31 :: int)::ii)
                                                                                                                                                               (( 25 :: int)::ii)
                                                                                                                                                              ::  7 Word.word)) = ( 0b1010001 ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec
                                                                                                                                                                   v__469
                                                                                                                                                                   (( 14 :: int)::ii)
                                                                                                                                                                   (( 12 :: int)::ii)
                                                                                                                                                                  ::  3 Word.word)) = ( 0b000 ::  3 Word.word)))) \<and> (((((subrange_vec_dec
                                                                                                                                                                   v__469
                                                                                                                                                                   (( 6 :: int)::ii)
                                                                                                                                                                   (( 0 :: int)::ii)
                                                                                                                                                                  ::  7 Word.word)) = ( 0b1010011 ::  7 Word.word))))))))))) \<bind> ((\<lambda> (w__177 ::
                                                                                                                                           bool) . 
                                                                                                                                         if
                                                                                                                                           w__177
                                                                                                                                         then
                                                                                                                                           return True
                                                                                                                                         else
                                                                                                                                           and_boolM
                                                                                                                                             ((haveDExt
                                                                                                                                                 () ))
                                                                                                                                             (return ((((((((subrange_vec_dec
                                                                                                                                                                 v__469
                                                                                                                                                                 (( 31 :: int)::ii)
                                                                                                                                                                 (( 20 :: int)::ii)
                                                                                                                                                                ::  12 Word.word)) = ( 0xE20 ::  12 Word.word)))) \<and> ((((((((subrange_vec_dec
                                                                                                                                                                     v__469
                                                                                                                                                                     (( 14 :: int)::ii)
                                                                                                                                                                     (( 12 :: int)::ii)
                                                                                                                                                                    ::  3 Word.word)) = ( 0b001 ::  3 Word.word)))) \<and> (((((subrange_vec_dec
                                                                                                                                                                     v__469
                                                                                                                                                                     (( 6 :: int)::ii)
                                                                                                                                                                     (( 0 :: int)::ii)
                                                                                                                                                                    ::  7 Word.word)) = ( 0b1010011 ::  7 Word.word))))))))))) \<bind> ((\<lambda> (w__179 ::
                                                                                                                                             bool) . 
                                                                                                                                           if
                                                                                                                                             w__179
                                                                                                                                           then
                                                                                                                                             return True
                                                                                                                                           else
                                                                                                                                             and_boolM
                                                                                                                                               ((is_RV64D
                                                                                                                                                   () ))
                                                                                                                                               (return ((((((((subrange_vec_dec
                                                                                                                                                                   v__469
                                                                                                                                                                   (( 31 :: int)::ii)
                                                                                                                                                                   (( 20 :: int)::ii)
                                                                                                                                                                  ::  12 Word.word)) = ( 0xE20 ::  12 Word.word)))) \<and> ((((((((subrange_vec_dec
                                                                                                                                                                       v__469
                                                                                                                                                                       (( 14 :: int)::ii)
                                                                                                                                                                       (( 12 :: int)::ii)
                                                                                                                                                                      ::  3 Word.word)) = ( 0b000 ::  3 Word.word)))) \<and> (((((subrange_vec_dec
                                                                                                                                                                       v__469
                                                                                                                                                                       (( 6 :: int)::ii)
                                                                                                                                                                       (( 0 :: int)::ii)
                                                                                                                                                                      ::  7 Word.word)) = ( 0b1010011 ::  7 Word.word))))))))))) \<bind> ((\<lambda> (w__181 ::
                                                                                                                                               bool) . 
                                                                                                                                             if
                                                                                                                                               w__181
                                                                                                                                             then
                                                                                                                                               return True
                                                                                                                                             else
                                                                                                                                               and_boolM
                                                                                                                                                 ((is_RV64D
                                                                                                                                                     () ))
                                                                                                                                                 (return ((((((((subrange_vec_dec
                                                                                                                                                                     v__469
                                                                                                                                                                     (( 31 :: int)::ii)
                                                                                                                                                                     (( 20 :: int)::ii)
                                                                                                                                                                    ::  12 Word.word)) = ( 0xF20 ::  12 Word.word)))) \<and> ((((((((subrange_vec_dec
                                                                                                                                                                         v__469
                                                                                                                                                                         (( 14 :: int)::ii)
                                                                                                                                                                         (( 12 :: int)::ii)
                                                                                                                                                                        ::  3 Word.word)) = ( 0b000 ::  3 Word.word)))) \<and> (((((subrange_vec_dec
                                                                                                                                                                         v__469
                                                                                                                                                                         (( 6 :: int)::ii)
                                                                                                                                                                         (( 0 :: int)::ii)
                                                                                                                                                                        ::  7 Word.word)) = ( 0b1010011 ::  7 Word.word))))))))))) \<bind> ((\<lambda> (w__183 ::
                                                                                                                                                 bool) . 
                                                                                                                                               return (if
                                                                                                                                                         w__183
                                                                                                                                                       then
                                                                                                                                                         True
                                                                                                                                                       else
                                                                                                                                                         True)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))\<close> 
  for  arg1  :: "(32)Word.word "


definition encdec_compressed_forwards  :: \<open> ast \<Rightarrow>((register_value),((16)Word.word),(exception))monad \<close>  where 
     \<open> encdec_compressed_forwards ast = (
   (let arg1 = ast in
   (case  arg1 of
     C_NOP (_) =>
      return ((concat_vec ( 0b000 ::  3 Word.word)
                 ((concat_vec ( 0b0 ::  1 Word.word)
                     ((concat_vec ( 0b00000 ::  5 Word.word)
                         ((concat_vec ( 0b00000 ::  5 Word.word) ( 0b01 ::  2 Word.word)  ::  7 Word.word))
                        ::  12 Word.word))
                    ::  13 Word.word))
                ::  16 Word.word))
   | C_ADDI4SPN ((rd, v__922)) =>
      if ((let (nz96 :: 4 bits) = ((subrange_vec_dec v__922 (( 7 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word)) in
        (let (nz96 :: 4 bits) = ((subrange_vec_dec v__922 (( 7 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word)) in
        (let (nz54 :: 2 bits) = ((subrange_vec_dec v__922 (( 3 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) in
        (let (nz3 :: 1 bits) = ((subrange_vec_dec v__922 (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word)) in
        (let (nz2 :: 1 bits) = ((subrange_vec_dec v__922 (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) in
        (((concat_vec nz96 ((concat_vec nz54 ((concat_vec nz3 nz2  ::  2 Word.word))  ::  4 Word.word))
             ::  8 Word.word)) \<noteq> ( 0x00 ::  8 Word.word)))))))) then
        (let (nz96 :: 4 bits) = ((subrange_vec_dec v__922 (( 7 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word)) in
        (let (nz96 :: 4 bits) = ((subrange_vec_dec v__922 (( 7 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word)) in
        (let (nz54 :: 2 bits) = ((subrange_vec_dec v__922 (( 3 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) in
        (let (nz3 :: 1 bits) = ((subrange_vec_dec v__922 (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word)) in
        (let (nz2 :: 1 bits) = ((subrange_vec_dec v__922 (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) in
        return ((concat_vec ( 0b000 ::  3 Word.word)
                   ((concat_vec nz54
                       ((concat_vec nz96
                           ((concat_vec nz2
                               ((concat_vec nz3 ((concat_vec rd ( 0b00 ::  2 Word.word)  ::  5 Word.word))
                                  ::  6 Word.word))
                              ::  7 Word.word))
                          ::  11 Word.word))
                      ::  13 Word.word))
                  ::  16 Word.word)))))))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () 
   | C_LW ((v__923, rs1, rd)) =>
      (let (ui6 :: 1 bits) = ((subrange_vec_dec v__923 (( 4 :: int)::ii) (( 4 :: int)::ii)  ::  1 Word.word)) in
      (let (ui6 :: 1 bits) = ((subrange_vec_dec v__923 (( 4 :: int)::ii) (( 4 :: int)::ii)  ::  1 Word.word)) in
      (let (ui53 :: 3 bits) = ((subrange_vec_dec v__923 (( 3 :: int)::ii) (( 1 :: int)::ii)  ::  3 Word.word)) in
      (let (ui2 :: 1 bits) = ((subrange_vec_dec v__923 (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) in
      return ((concat_vec ( 0b010 ::  3 Word.word)
                 ((concat_vec ui53
                     ((concat_vec rs1
                         ((concat_vec ui2
                             ((concat_vec ui6 ((concat_vec rd ( 0b00 ::  2 Word.word)  ::  5 Word.word))
                                ::  6 Word.word))
                            ::  7 Word.word))
                        ::  10 Word.word))
                    ::  13 Word.word))
                ::  16 Word.word))))))
   | C_LD ((v__924, rs1, rd)) =>
      if ((((( 64 :: int)::ii) = (( 64 :: int)::ii)))) then
        (let (ui76 :: 2 bits) = ((subrange_vec_dec v__924 (( 4 :: int)::ii) (( 3 :: int)::ii)  ::  2 Word.word)) in
        (let (ui76 :: 2 bits) = ((subrange_vec_dec v__924 (( 4 :: int)::ii) (( 3 :: int)::ii)  ::  2 Word.word)) in
        (let (ui53 :: 3 bits) = ((subrange_vec_dec v__924 (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word)) in
        return ((concat_vec ( 0b011 ::  3 Word.word)
                   ((concat_vec ui53
                       ((concat_vec rs1
                           ((concat_vec ui76 ((concat_vec rd ( 0b00 ::  2 Word.word)  ::  5 Word.word))
                              ::  7 Word.word))
                          ::  10 Word.word))
                      ::  13 Word.word))
                  ::  16 Word.word)))))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () 
   | C_SW ((v__925, rs1, rs2)) =>
      (let (ui6 :: 1 bits) = ((subrange_vec_dec v__925 (( 4 :: int)::ii) (( 4 :: int)::ii)  ::  1 Word.word)) in
      (let (ui6 :: 1 bits) = ((subrange_vec_dec v__925 (( 4 :: int)::ii) (( 4 :: int)::ii)  ::  1 Word.word)) in
      (let (ui53 :: 3 bits) = ((subrange_vec_dec v__925 (( 3 :: int)::ii) (( 1 :: int)::ii)  ::  3 Word.word)) in
      (let (ui2 :: 1 bits) = ((subrange_vec_dec v__925 (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) in
      return ((concat_vec ( 0b110 ::  3 Word.word)
                 ((concat_vec ui53
                     ((concat_vec rs1
                         ((concat_vec ui2
                             ((concat_vec ui6 ((concat_vec rs2 ( 0b00 ::  2 Word.word)  ::  5 Word.word))
                                ::  6 Word.word))
                            ::  7 Word.word))
                        ::  10 Word.word))
                    ::  13 Word.word))
                ::  16 Word.word))))))
   | C_SD ((v__926, rs1, rs2)) =>
      if ((((( 64 :: int)::ii) = (( 64 :: int)::ii)))) then
        (let (ui76 :: 2 bits) = ((subrange_vec_dec v__926 (( 4 :: int)::ii) (( 3 :: int)::ii)  ::  2 Word.word)) in
        (let (ui76 :: 2 bits) = ((subrange_vec_dec v__926 (( 4 :: int)::ii) (( 3 :: int)::ii)  ::  2 Word.word)) in
        (let (ui53 :: 3 bits) = ((subrange_vec_dec v__926 (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word)) in
        return ((concat_vec ( 0b111 ::  3 Word.word)
                   ((concat_vec ui53
                       ((concat_vec rs1
                           ((concat_vec ui76 ((concat_vec rs2 ( 0b00 ::  2 Word.word)  ::  5 Word.word))
                              ::  7 Word.word))
                          ::  10 Word.word))
                      ::  13 Word.word))
                  ::  16 Word.word)))))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () 
   | C_ADDI ((v__927, rsd)) =>
      if ((let (nzi5 :: 1 bits) = ((subrange_vec_dec v__927 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
        (let (nzi5 :: 1 bits) = ((subrange_vec_dec v__927 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
        (let (nzi40 :: 5 bits) = ((subrange_vec_dec v__927 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
        ((((((concat_vec nzi5 nzi40  ::  6 Word.word)) \<noteq> ( 0b000000 ::  6 Word.word)))) \<and> (((rsd \<noteq> zreg)))))))) then
        (let (nzi5 :: 1 bits) = ((subrange_vec_dec v__927 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
        (let (nzi5 :: 1 bits) = ((subrange_vec_dec v__927 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
        (let (nzi40 :: 5 bits) = ((subrange_vec_dec v__927 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
        return ((concat_vec ( 0b000 ::  3 Word.word)
                   ((concat_vec nzi5
                       ((concat_vec rsd ((concat_vec nzi40 ( 0b01 ::  2 Word.word)  ::  7 Word.word))
                          ::  12 Word.word))
                      ::  13 Word.word))
                  ::  16 Word.word)))))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () 
   | C_JAL (v__928) =>
      if ((((( 64 :: int)::ii) = (( 32 :: int)::ii)))) then
        (let (i11 :: 1 bits) = ((subrange_vec_dec v__928 (( 10 :: int)::ii) (( 10 :: int)::ii)  ::  1 Word.word)) in
        (let (i98 :: 2 bits) = ((subrange_vec_dec v__928 (( 8 :: int)::ii) (( 7 :: int)::ii)  ::  2 Word.word)) in
        (let (i7 :: 1 bits) = ((subrange_vec_dec v__928 (( 6 :: int)::ii) (( 6 :: int)::ii)  ::  1 Word.word)) in
        (let (i6 :: 1 bits) = ((subrange_vec_dec v__928 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
        (let (i5 :: 1 bits) = ((subrange_vec_dec v__928 (( 4 :: int)::ii) (( 4 :: int)::ii)  ::  1 Word.word)) in
        (let (i4 :: 1 bits) = ((subrange_vec_dec v__928 (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word)) in
        (let (i31 :: 3 bits) = ((subrange_vec_dec v__928 (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word)) in
        (let (i11 :: 1 bits) = ((subrange_vec_dec v__928 (( 10 :: int)::ii) (( 10 :: int)::ii)  ::  1 Word.word)) in
        (let (i10 :: 1 bits) = ((subrange_vec_dec v__928 (( 9 :: int)::ii) (( 9 :: int)::ii)  ::  1 Word.word)) in
        return ((concat_vec ( 0b001 ::  3 Word.word)
                   ((concat_vec i11
                       ((concat_vec i4
                           ((concat_vec i98
                               ((concat_vec i10
                                   ((concat_vec i6
                                       ((concat_vec i7
                                           ((concat_vec i31
                                               ((concat_vec i5 ( 0b01 ::  2 Word.word)  ::  3 Word.word))
                                              ::  6 Word.word))
                                          ::  7 Word.word))
                                      ::  8 Word.word))
                                  ::  9 Word.word))
                              ::  11 Word.word))
                          ::  12 Word.word))
                      ::  13 Word.word))
                  ::  16 Word.word)))))))))))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () 
   | C_ADDIW ((v__929, rsd)) =>
      if ((((((rsd \<noteq> zreg))) \<and> ((((( 64 :: int)::ii) = (( 64 :: int)::ii))))))) then
        (let (imm5 :: 1 bits) = ((subrange_vec_dec v__929 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
        (let (imm5 :: 1 bits) = ((subrange_vec_dec v__929 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
        (let (imm40 :: 5 bits) = ((subrange_vec_dec v__929 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
        return ((concat_vec ( 0b001 ::  3 Word.word)
                   ((concat_vec imm5
                       ((concat_vec rsd ((concat_vec imm40 ( 0b01 ::  2 Word.word)  ::  7 Word.word))
                          ::  12 Word.word))
                      ::  13 Word.word))
                  ::  16 Word.word)))))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () 
   | C_LI ((v__930, rd)) =>
      if (((rd \<noteq> zreg))) then
        (let (imm5 :: 1 bits) = ((subrange_vec_dec v__930 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
        (let (imm5 :: 1 bits) = ((subrange_vec_dec v__930 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
        (let (imm40 :: 5 bits) = ((subrange_vec_dec v__930 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
        return ((concat_vec ( 0b010 ::  3 Word.word)
                   ((concat_vec imm5
                       ((concat_vec rd ((concat_vec imm40 ( 0b01 ::  2 Word.word)  ::  7 Word.word))
                          ::  12 Word.word))
                      ::  13 Word.word))
                  ::  16 Word.word)))))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () 
   | C_ADDI16SP (v__931) =>
      if ((let (nzi9 :: 1 bits) = ((subrange_vec_dec v__931 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
        (let (nzi9 :: 1 bits) = ((subrange_vec_dec v__931 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
        (let (nzi87 :: 2 bits) = ((subrange_vec_dec v__931 (( 4 :: int)::ii) (( 3 :: int)::ii)  ::  2 Word.word)) in
        (let (nzi6 :: 1 bits) = ((subrange_vec_dec v__931 (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word)) in
        (let (nzi5 :: 1 bits) = ((subrange_vec_dec v__931 (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word)) in
        (let (nzi4 :: 1 bits) = ((subrange_vec_dec v__931 (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) in
        (((concat_vec nzi9
              ((concat_vec nzi87
                  ((concat_vec nzi6 ((concat_vec nzi5 nzi4  ::  2 Word.word))  ::  3 Word.word))
                 ::  5 Word.word))
             ::  6 Word.word)) \<noteq> ( 0b000000 ::  6 Word.word))))))))) then
        (let (nzi9 :: 1 bits) = ((subrange_vec_dec v__931 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
        (let (nzi9 :: 1 bits) = ((subrange_vec_dec v__931 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
        (let (nzi87 :: 2 bits) = ((subrange_vec_dec v__931 (( 4 :: int)::ii) (( 3 :: int)::ii)  ::  2 Word.word)) in
        (let (nzi6 :: 1 bits) = ((subrange_vec_dec v__931 (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word)) in
        (let (nzi5 :: 1 bits) = ((subrange_vec_dec v__931 (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word)) in
        (let (nzi4 :: 1 bits) = ((subrange_vec_dec v__931 (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) in
        return ((concat_vec ( 0b011 ::  3 Word.word)
                   ((concat_vec nzi9
                       ((concat_vec ( 0b00010 ::  5 Word.word)
                           ((concat_vec nzi4
                               ((concat_vec nzi6
                                   ((concat_vec nzi87
                                       ((concat_vec nzi5 ( 0b01 ::  2 Word.word)  ::  3 Word.word))
                                      ::  5 Word.word))
                                  ::  6 Word.word))
                              ::  7 Word.word))
                          ::  12 Word.word))
                      ::  13 Word.word))
                  ::  16 Word.word))))))))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () 
   | C_LUI ((v__932, rd)) =>
      if ((let (imm17 :: 1 bits) = ((subrange_vec_dec v__932 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
        (let (imm17 :: 1 bits) = ((subrange_vec_dec v__932 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
        (let (imm1612 :: 5 bits) = ((subrange_vec_dec v__932 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
        ((((rd \<noteq> zreg))) \<and> ((((((rd \<noteq> sp))) \<and> (((((concat_vec imm17 imm1612  ::  6 Word.word)) \<noteq> ( 0b000000 ::  6 Word.word)))))))))))) then
        (let (imm17 :: 1 bits) = ((subrange_vec_dec v__932 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
        (let (imm17 :: 1 bits) = ((subrange_vec_dec v__932 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
        (let (imm1612 :: 5 bits) = ((subrange_vec_dec v__932 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
        return ((concat_vec ( 0b011 ::  3 Word.word)
                   ((concat_vec imm17
                       ((concat_vec rd ((concat_vec imm1612 ( 0b01 ::  2 Word.word)  ::  7 Word.word))
                          ::  12 Word.word))
                      ::  13 Word.word))
                  ::  16 Word.word)))))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () 
   | C_SRLI ((v__933, rsd)) =>
      if ((let (nzui5 :: 1 bits) = ((subrange_vec_dec v__933 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
        (let (nzui5 :: 1 bits) = ((subrange_vec_dec v__933 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
        (let (nzui40 :: 5 bits) = ((subrange_vec_dec v__933 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
        (((concat_vec nzui5 nzui40  ::  6 Word.word)) \<noteq> ( 0b000000 ::  6 Word.word)))))) then
        (let (nzui5 :: 1 bits) = ((subrange_vec_dec v__933 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
        (let (nzui5 :: 1 bits) = ((subrange_vec_dec v__933 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
        (let (nzui40 :: 5 bits) = ((subrange_vec_dec v__933 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
        return ((concat_vec ( 0b100 ::  3 Word.word)
                   ((concat_vec nzui5
                       ((concat_vec ( 0b00 ::  2 Word.word)
                           ((concat_vec rsd ((concat_vec nzui40 ( 0b01 ::  2 Word.word)  ::  7 Word.word))
                              ::  10 Word.word))
                          ::  12 Word.word))
                      ::  13 Word.word))
                  ::  16 Word.word)))))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () 
   | C_SRAI ((v__934, rsd)) =>
      if ((let (nzui5 :: 1 bits) = ((subrange_vec_dec v__934 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
        (let (nzui5 :: 1 bits) = ((subrange_vec_dec v__934 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
        (let (nzui40 :: 5 bits) = ((subrange_vec_dec v__934 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
        (((concat_vec nzui5 nzui40  ::  6 Word.word)) \<noteq> ( 0b000000 ::  6 Word.word)))))) then
        (let (nzui5 :: 1 bits) = ((subrange_vec_dec v__934 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
        (let (nzui5 :: 1 bits) = ((subrange_vec_dec v__934 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
        (let (nzui40 :: 5 bits) = ((subrange_vec_dec v__934 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
        return ((concat_vec ( 0b100 ::  3 Word.word)
                   ((concat_vec nzui5
                       ((concat_vec ( 0b01 ::  2 Word.word)
                           ((concat_vec rsd ((concat_vec nzui40 ( 0b01 ::  2 Word.word)  ::  7 Word.word))
                              ::  10 Word.word))
                          ::  12 Word.word))
                      ::  13 Word.word))
                  ::  16 Word.word)))))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () 
   | C_ANDI ((v__935, rsd)) =>
      (let (i5 :: 1 bits) = ((subrange_vec_dec v__935 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
      (let (i5 :: 1 bits) = ((subrange_vec_dec v__935 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
      (let (i40 :: 5 bits) = ((subrange_vec_dec v__935 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
      return ((concat_vec ( 0b100 ::  3 Word.word)
                 ((concat_vec i5
                     ((concat_vec ( 0b10 ::  2 Word.word)
                         ((concat_vec rsd ((concat_vec i40 ( 0b01 ::  2 Word.word)  ::  7 Word.word))
                            ::  10 Word.word))
                        ::  12 Word.word))
                    ::  13 Word.word))
                ::  16 Word.word)))))
   | C_SUB ((rsd, rs2)) =>
      return ((concat_vec ( 0b100 ::  3 Word.word)
                 ((concat_vec ( 0b0 ::  1 Word.word)
                     ((concat_vec ( 0b11 ::  2 Word.word)
                         ((concat_vec rsd
                             ((concat_vec ( 0b00 ::  2 Word.word)
                                 ((concat_vec rs2 ( 0b01 ::  2 Word.word)  ::  5 Word.word))
                                ::  7 Word.word))
                            ::  10 Word.word))
                        ::  12 Word.word))
                    ::  13 Word.word))
                ::  16 Word.word))
   | C_XOR ((rsd, rs2)) =>
      return ((concat_vec ( 0b100 ::  3 Word.word)
                 ((concat_vec ( 0b0 ::  1 Word.word)
                     ((concat_vec ( 0b11 ::  2 Word.word)
                         ((concat_vec rsd
                             ((concat_vec ( 0b01 ::  2 Word.word)
                                 ((concat_vec rs2 ( 0b01 ::  2 Word.word)  ::  5 Word.word))
                                ::  7 Word.word))
                            ::  10 Word.word))
                        ::  12 Word.word))
                    ::  13 Word.word))
                ::  16 Word.word))
   | C_OR ((rsd, rs2)) =>
      return ((concat_vec ( 0b100 ::  3 Word.word)
                 ((concat_vec ( 0b0 ::  1 Word.word)
                     ((concat_vec ( 0b11 ::  2 Word.word)
                         ((concat_vec rsd
                             ((concat_vec ( 0b10 ::  2 Word.word)
                                 ((concat_vec rs2 ( 0b01 ::  2 Word.word)  ::  5 Word.word))
                                ::  7 Word.word))
                            ::  10 Word.word))
                        ::  12 Word.word))
                    ::  13 Word.word))
                ::  16 Word.word))
   | C_AND ((rsd, rs2)) =>
      return ((concat_vec ( 0b100 ::  3 Word.word)
                 ((concat_vec ( 0b0 ::  1 Word.word)
                     ((concat_vec ( 0b11 ::  2 Word.word)
                         ((concat_vec rsd
                             ((concat_vec ( 0b11 ::  2 Word.word)
                                 ((concat_vec rs2 ( 0b01 ::  2 Word.word)  ::  5 Word.word))
                                ::  7 Word.word))
                            ::  10 Word.word))
                        ::  12 Word.word))
                    ::  13 Word.word))
                ::  16 Word.word))
   | C_SUBW ((rsd, rs2)) =>
      if ((((( 64 :: int)::ii) = (( 64 :: int)::ii)))) then
        return ((concat_vec ( 0b100 ::  3 Word.word)
                   ((concat_vec ( 0b1 ::  1 Word.word)
                       ((concat_vec ( 0b11 ::  2 Word.word)
                           ((concat_vec rsd
                               ((concat_vec ( 0b00 ::  2 Word.word)
                                   ((concat_vec rs2 ( 0b01 ::  2 Word.word)  ::  5 Word.word))
                                  ::  7 Word.word))
                              ::  10 Word.word))
                          ::  12 Word.word))
                      ::  13 Word.word))
                  ::  16 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () 
   | C_ADDW ((rsd, rs2)) =>
      if ((((( 64 :: int)::ii) = (( 64 :: int)::ii)))) then
        return ((concat_vec ( 0b100 ::  3 Word.word)
                   ((concat_vec ( 0b1 ::  1 Word.word)
                       ((concat_vec ( 0b11 ::  2 Word.word)
                           ((concat_vec rsd
                               ((concat_vec ( 0b01 ::  2 Word.word)
                                   ((concat_vec rs2 ( 0b01 ::  2 Word.word)  ::  5 Word.word))
                                  ::  7 Word.word))
                              ::  10 Word.word))
                          ::  12 Word.word))
                      ::  13 Word.word))
                  ::  16 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () 
   | C_J (v__936) =>
      (let (i11 :: 1 bits) = ((subrange_vec_dec v__936 (( 10 :: int)::ii) (( 10 :: int)::ii)  ::  1 Word.word)) in
      (let (i98 :: 2 bits) = ((subrange_vec_dec v__936 (( 8 :: int)::ii) (( 7 :: int)::ii)  ::  2 Word.word)) in
      (let (i7 :: 1 bits) = ((subrange_vec_dec v__936 (( 6 :: int)::ii) (( 6 :: int)::ii)  ::  1 Word.word)) in
      (let (i6 :: 1 bits) = ((subrange_vec_dec v__936 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
      (let (i5 :: 1 bits) = ((subrange_vec_dec v__936 (( 4 :: int)::ii) (( 4 :: int)::ii)  ::  1 Word.word)) in
      (let (i4 :: 1 bits) = ((subrange_vec_dec v__936 (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word)) in
      (let (i31 :: 3 bits) = ((subrange_vec_dec v__936 (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word)) in
      (let (i11 :: 1 bits) = ((subrange_vec_dec v__936 (( 10 :: int)::ii) (( 10 :: int)::ii)  ::  1 Word.word)) in
      (let (i10 :: 1 bits) = ((subrange_vec_dec v__936 (( 9 :: int)::ii) (( 9 :: int)::ii)  ::  1 Word.word)) in
      return ((concat_vec ( 0b101 ::  3 Word.word)
                 ((concat_vec i11
                     ((concat_vec i4
                         ((concat_vec i98
                             ((concat_vec i10
                                 ((concat_vec i6
                                     ((concat_vec i7
                                         ((concat_vec i31
                                             ((concat_vec i5 ( 0b01 ::  2 Word.word)  ::  3 Word.word))
                                            ::  6 Word.word))
                                        ::  7 Word.word))
                                    ::  8 Word.word))
                                ::  9 Word.word))
                            ::  11 Word.word))
                        ::  12 Word.word))
                    ::  13 Word.word))
                ::  16 Word.word)))))))))))
   | C_BEQZ ((v__937, rs)) =>
      (let (i8 :: 1 bits) = ((subrange_vec_dec v__937 (( 7 :: int)::ii) (( 7 :: int)::ii)  ::  1 Word.word)) in
      (let (i8 :: 1 bits) = ((subrange_vec_dec v__937 (( 7 :: int)::ii) (( 7 :: int)::ii)  ::  1 Word.word)) in
      (let (i76 :: 2 bits) = ((subrange_vec_dec v__937 (( 6 :: int)::ii) (( 5 :: int)::ii)  ::  2 Word.word)) in
      (let (i5 :: 1 bits) = ((subrange_vec_dec v__937 (( 4 :: int)::ii) (( 4 :: int)::ii)  ::  1 Word.word)) in
      (let (i43 :: 2 bits) = ((subrange_vec_dec v__937 (( 3 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) in
      (let (i21 :: 2 bits) = ((subrange_vec_dec v__937 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) in
      return ((concat_vec ( 0b110 ::  3 Word.word)
                 ((concat_vec i8
                     ((concat_vec i43
                         ((concat_vec rs
                             ((concat_vec i76
                                 ((concat_vec i21 ((concat_vec i5 ( 0b01 ::  2 Word.word)  ::  3 Word.word))
                                    ::  5 Word.word))
                                ::  7 Word.word))
                            ::  10 Word.word))
                        ::  12 Word.word))
                    ::  13 Word.word))
                ::  16 Word.word))))))))
   | C_BNEZ ((v__938, rs)) =>
      (let (i8 :: 1 bits) = ((subrange_vec_dec v__938 (( 7 :: int)::ii) (( 7 :: int)::ii)  ::  1 Word.word)) in
      (let (i8 :: 1 bits) = ((subrange_vec_dec v__938 (( 7 :: int)::ii) (( 7 :: int)::ii)  ::  1 Word.word)) in
      (let (i76 :: 2 bits) = ((subrange_vec_dec v__938 (( 6 :: int)::ii) (( 5 :: int)::ii)  ::  2 Word.word)) in
      (let (i5 :: 1 bits) = ((subrange_vec_dec v__938 (( 4 :: int)::ii) (( 4 :: int)::ii)  ::  1 Word.word)) in
      (let (i43 :: 2 bits) = ((subrange_vec_dec v__938 (( 3 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) in
      (let (i21 :: 2 bits) = ((subrange_vec_dec v__938 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) in
      return ((concat_vec ( 0b111 ::  3 Word.word)
                 ((concat_vec i8
                     ((concat_vec i43
                         ((concat_vec rs
                             ((concat_vec i76
                                 ((concat_vec i21 ((concat_vec i5 ( 0b01 ::  2 Word.word)  ::  3 Word.word))
                                    ::  5 Word.word))
                                ::  7 Word.word))
                            ::  10 Word.word))
                        ::  12 Word.word))
                    ::  13 Word.word))
                ::  16 Word.word))))))))
   | C_SLLI ((v__939, rsd)) =>
      if ((let (nzui5 :: 1 bits) = ((subrange_vec_dec v__939 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
        (let (nzui5 :: 1 bits) = ((subrange_vec_dec v__939 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
        (let (nzui40 :: 5 bits) = ((subrange_vec_dec v__939 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
        ((((((concat_vec nzui5 nzui40  ::  6 Word.word)) \<noteq> ( 0b000000 ::  6 Word.word)))) \<and> ((((((rsd \<noteq> zreg))) \<and> (((((((( 64 :: int)::ii) = (( 64 :: int)::ii)))) \<or> (((nzui5 = ( 0b0 ::  1 Word.word))))))))))))))) then
        (let (nzui5 :: 1 bits) = ((subrange_vec_dec v__939 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
        (let (nzui5 :: 1 bits) = ((subrange_vec_dec v__939 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
        (let (nzui40 :: 5 bits) = ((subrange_vec_dec v__939 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
        return ((concat_vec ( 0b000 ::  3 Word.word)
                   ((concat_vec nzui5
                       ((concat_vec rsd ((concat_vec nzui40 ( 0b10 ::  2 Word.word)  ::  7 Word.word))
                          ::  12 Word.word))
                      ::  13 Word.word))
                  ::  16 Word.word)))))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () 
   | C_LWSP ((v__940, rd)) =>
      if (((rd \<noteq> zreg))) then
        (let (ui76 :: 2 bits) = ((subrange_vec_dec v__940 (( 5 :: int)::ii) (( 4 :: int)::ii)  ::  2 Word.word)) in
        (let (ui76 :: 2 bits) = ((subrange_vec_dec v__940 (( 5 :: int)::ii) (( 4 :: int)::ii)  ::  2 Word.word)) in
        (let (ui5 :: 1 bits) = ((subrange_vec_dec v__940 (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word)) in
        (let (ui42 :: 3 bits) = ((subrange_vec_dec v__940 (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word)) in
        return ((concat_vec ( 0b010 ::  3 Word.word)
                   ((concat_vec ui5
                       ((concat_vec rd
                           ((concat_vec ui42 ((concat_vec ui76 ( 0b10 ::  2 Word.word)  ::  4 Word.word))
                              ::  7 Word.word))
                          ::  12 Word.word))
                      ::  13 Word.word))
                  ::  16 Word.word))))))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () 
   | C_LDSP ((v__941, rd)) =>
      if ((((((rd \<noteq> zreg))) \<and> ((((( 64 :: int)::ii) = (( 64 :: int)::ii))))))) then
        (let (ui86 :: 3 bits) = ((subrange_vec_dec v__941 (( 5 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) in
        (let (ui86 :: 3 bits) = ((subrange_vec_dec v__941 (( 5 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) in
        (let (ui5 :: 1 bits) = ((subrange_vec_dec v__941 (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word)) in
        (let (ui43 :: 2 bits) = ((subrange_vec_dec v__941 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) in
        return ((concat_vec ( 0b011 ::  3 Word.word)
                   ((concat_vec ui5
                       ((concat_vec rd
                           ((concat_vec ui43 ((concat_vec ui86 ( 0b10 ::  2 Word.word)  ::  5 Word.word))
                              ::  7 Word.word))
                          ::  12 Word.word))
                      ::  13 Word.word))
                  ::  16 Word.word))))))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () 
   | C_SWSP ((v__942, rs2)) =>
      (let (ui76 :: 2 bits) = ((subrange_vec_dec v__942 (( 5 :: int)::ii) (( 4 :: int)::ii)  ::  2 Word.word)) in
      (let (ui76 :: 2 bits) = ((subrange_vec_dec v__942 (( 5 :: int)::ii) (( 4 :: int)::ii)  ::  2 Word.word)) in
      (let (ui52 :: 4 bits) = ((subrange_vec_dec v__942 (( 3 :: int)::ii) (( 0 :: int)::ii)  ::  4 Word.word)) in
      return ((concat_vec ( 0b110 ::  3 Word.word)
                 ((concat_vec ui52
                     ((concat_vec ui76 ((concat_vec rs2 ( 0b10 ::  2 Word.word)  ::  7 Word.word))
                        ::  9 Word.word))
                    ::  13 Word.word))
                ::  16 Word.word)))))
   | C_SDSP ((v__943, rs2)) =>
      if ((((( 64 :: int)::ii) = (( 64 :: int)::ii)))) then
        (let (ui86 :: 3 bits) = ((subrange_vec_dec v__943 (( 5 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) in
        (let (ui86 :: 3 bits) = ((subrange_vec_dec v__943 (( 5 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) in
        (let (ui53 :: 3 bits) = ((subrange_vec_dec v__943 (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word)) in
        return ((concat_vec ( 0b111 ::  3 Word.word)
                   ((concat_vec ui53
                       ((concat_vec ui86 ((concat_vec rs2 ( 0b10 ::  2 Word.word)  ::  7 Word.word))
                          ::  10 Word.word))
                      ::  13 Word.word))
                  ::  16 Word.word)))))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () 
   | C_JR (rs1) =>
      if (((rs1 \<noteq> zreg))) then
        return ((concat_vec ( 0b100 ::  3 Word.word)
                   ((concat_vec ( 0b0 ::  1 Word.word)
                       ((concat_vec rs1
                           ((concat_vec ( 0b00000 ::  5 Word.word) ( 0b10 ::  2 Word.word)  ::  7 Word.word))
                          ::  12 Word.word))
                      ::  13 Word.word))
                  ::  16 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () 
   | C_JALR (rs1) =>
      if (((rs1 \<noteq> zreg))) then
        return ((concat_vec ( 0b100 ::  3 Word.word)
                   ((concat_vec ( 0b1 ::  1 Word.word)
                       ((concat_vec rs1
                           ((concat_vec ( 0b00000 ::  5 Word.word) ( 0b10 ::  2 Word.word)  ::  7 Word.word))
                          ::  12 Word.word))
                      ::  13 Word.word))
                  ::  16 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () 
   | C_MV ((rd, rs2)) =>
      if ((((((rd \<noteq> zreg))) \<and> (((rs2 \<noteq> zreg)))))) then
        return ((concat_vec ( 0b100 ::  3 Word.word)
                   ((concat_vec ( 0b0 ::  1 Word.word)
                       ((concat_vec rd ((concat_vec rs2 ( 0b10 ::  2 Word.word)  ::  7 Word.word))
                          ::  12 Word.word))
                      ::  13 Word.word))
                  ::  16 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () 
   | C_EBREAK (_) =>
      return ((concat_vec ( 0b100 ::  3 Word.word)
                 ((concat_vec ( 0b1 ::  1 Word.word)
                     ((concat_vec ( 0b00000 ::  5 Word.word)
                         ((concat_vec ( 0b00000 ::  5 Word.word) ( 0b10 ::  2 Word.word)  ::  7 Word.word))
                        ::  12 Word.word))
                    ::  13 Word.word))
                ::  16 Word.word))
   | C_ADD ((rsd, rs2)) =>
      if ((((((rsd \<noteq> zreg))) \<and> (((rs2 \<noteq> zreg)))))) then
        return ((concat_vec ( 0b100 ::  3 Word.word)
                   ((concat_vec ( 0b1 ::  1 Word.word)
                       ((concat_vec rsd ((concat_vec rs2 ( 0b10 ::  2 Word.word)  ::  7 Word.word))
                          ::  12 Word.word))
                      ::  13 Word.word))
                  ::  16 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () 
   | C_NOP_HINT (v__944) =>
      if ((let (im5 :: 1 bits) = ((subrange_vec_dec v__944 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
        (let (im5 :: 1 bits) = ((subrange_vec_dec v__944 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
        (let (im40 :: 5 bits) = ((subrange_vec_dec v__944 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
        (((concat_vec im5 im40  ::  6 Word.word)) \<noteq> ( 0b000000 ::  6 Word.word)))))) then
        (let (im5 :: 1 bits) = ((subrange_vec_dec v__944 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
        (let (im5 :: 1 bits) = ((subrange_vec_dec v__944 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
        (let (im40 :: 5 bits) = ((subrange_vec_dec v__944 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
        return ((concat_vec ( 0b000 ::  3 Word.word)
                   ((concat_vec im5
                       ((concat_vec ( 0b00000 ::  5 Word.word)
                           ((concat_vec im40 ( 0b01 ::  2 Word.word)  ::  7 Word.word))
                          ::  12 Word.word))
                      ::  13 Word.word))
                  ::  16 Word.word)))))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () 
   | C_ADDI_HINT (rsd) =>
      if (((rsd \<noteq> zreg))) then
        return ((concat_vec ( 0b000 ::  3 Word.word)
                   ((concat_vec ( 0b0 ::  1 Word.word)
                       ((concat_vec rsd
                           ((concat_vec ( 0b00000 ::  5 Word.word) ( 0b01 ::  2 Word.word)  ::  7 Word.word))
                          ::  12 Word.word))
                      ::  13 Word.word))
                  ::  16 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () 
   | C_LI_HINT (v__945) =>
      (let (imm5 :: 1 bits) = ((subrange_vec_dec v__945 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
      (let (imm5 :: 1 bits) = ((subrange_vec_dec v__945 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
      (let (imm40 :: 5 bits) = ((subrange_vec_dec v__945 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
      return ((concat_vec ( 0b010 ::  3 Word.word)
                 ((concat_vec imm5
                     ((concat_vec ( 0b00000 ::  5 Word.word)
                         ((concat_vec imm40 ( 0b01 ::  2 Word.word)  ::  7 Word.word))
                        ::  12 Word.word))
                    ::  13 Word.word))
                ::  16 Word.word)))))
   | C_LUI_HINT (v__946) =>
      if ((let (imm17 :: 1 bits) = ((subrange_vec_dec v__946 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
        (let (imm17 :: 1 bits) = ((subrange_vec_dec v__946 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
        (let (imm1612 :: 5 bits) = ((subrange_vec_dec v__946 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
        (((concat_vec imm17 imm1612  ::  6 Word.word)) \<noteq> ( 0b000000 ::  6 Word.word)))))) then
        (let (imm17 :: 1 bits) = ((subrange_vec_dec v__946 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
        (let (imm17 :: 1 bits) = ((subrange_vec_dec v__946 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
        (let (imm1612 :: 5 bits) = ((subrange_vec_dec v__946 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
        return ((concat_vec ( 0b011 ::  3 Word.word)
                   ((concat_vec imm17
                       ((concat_vec ( 0b00000 ::  5 Word.word)
                           ((concat_vec imm1612 ( 0b01 ::  2 Word.word)  ::  7 Word.word))
                          ::  12 Word.word))
                      ::  13 Word.word))
                  ::  16 Word.word)))))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () 
   | C_MV_HINT (rs2) =>
      if (((rs2 \<noteq> zreg))) then
        return ((concat_vec ( 0b100 ::  3 Word.word)
                   ((concat_vec ( 0b0 ::  1 Word.word)
                       ((concat_vec ( 0b00000 ::  5 Word.word)
                           ((concat_vec rs2 ( 0b10 ::  2 Word.word)  ::  7 Word.word))
                          ::  12 Word.word))
                      ::  13 Word.word))
                  ::  16 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () 
   | C_ADD_HINT (rs2) =>
      if (((rs2 \<noteq> zreg))) then
        return ((concat_vec ( 0b100 ::  3 Word.word)
                   ((concat_vec ( 0b1 ::  1 Word.word)
                       ((concat_vec ( 0b00000 ::  5 Word.word)
                           ((concat_vec rs2 ( 0b10 ::  2 Word.word)  ::  7 Word.word))
                          ::  12 Word.word))
                      ::  13 Word.word))
                  ::  16 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () 
   | C_SLLI_HINT ((v__947, rsd)) =>
      if ((let (nzui5 :: 1 bits) = ((subrange_vec_dec v__947 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
        (let (nzui5 :: 1 bits) = ((subrange_vec_dec v__947 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
        (let (nzui40 :: 5 bits) = ((subrange_vec_dec v__947 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
        (((((((((concat_vec nzui5 nzui40  ::  6 Word.word)) = ( 0b000000 ::  6 Word.word)))) \<or> (((rsd = zreg)))))) \<and> (((((((( 64 :: int)::ii) = (( 64 :: int)::ii)))) \<or> (((nzui5 = ( 0b0 ::  1 Word.word)))))))))))) then
        (let (nzui5 :: 1 bits) = ((subrange_vec_dec v__947 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
        (let (nzui5 :: 1 bits) = ((subrange_vec_dec v__947 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
        (let (nzui40 :: 5 bits) = ((subrange_vec_dec v__947 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
        return ((concat_vec ( 0b000 ::  3 Word.word)
                   ((concat_vec nzui5
                       ((concat_vec rsd ((concat_vec nzui40 ( 0b10 ::  2 Word.word)  ::  7 Word.word))
                          ::  12 Word.word))
                      ::  13 Word.word))
                  ::  16 Word.word)))))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () 
   | C_SRLI_HINT (rsd) =>
      return ((concat_vec ( 0b100 ::  3 Word.word)
                 ((concat_vec ( 0b0 ::  1 Word.word)
                     ((concat_vec ( 0b00 ::  2 Word.word)
                         ((concat_vec rsd
                             ((concat_vec ( 0b00000 ::  5 Word.word) ( 0b01 ::  2 Word.word)  ::  7 Word.word))
                            ::  10 Word.word))
                        ::  12 Word.word))
                    ::  13 Word.word))
                ::  16 Word.word))
   | C_SRAI_HINT (rsd) =>
      return ((concat_vec ( 0b100 ::  3 Word.word)
                 ((concat_vec ( 0b0 ::  1 Word.word)
                     ((concat_vec ( 0b01 ::  2 Word.word)
                         ((concat_vec rsd
                             ((concat_vec ( 0b00000 ::  5 Word.word) ( 0b01 ::  2 Word.word)  ::  7 Word.word))
                            ::  10 Word.word))
                        ::  12 Word.word))
                    ::  13 Word.word))
                ::  16 Word.word))
   | C_FLWSP ((v__948, rd)) =>
      and_boolM (return ((((( 64 :: int)::ii) = (( 32 :: int)::ii))))) (and_boolM ((haveRVC () )) ((haveFExt () ))) \<bind> ((\<lambda> (w__57 ::
        bool) . 
      if w__57 then
        (let (ui76 :: 2 bits) = ((subrange_vec_dec v__948 (( 5 :: int)::ii) (( 4 :: int)::ii)  ::  2 Word.word)) in
        (let (ui76 :: 2 bits) = ((subrange_vec_dec v__948 (( 5 :: int)::ii) (( 4 :: int)::ii)  ::  2 Word.word)) in
        (let (ui5 :: 1 bits) = ((subrange_vec_dec v__948 (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word)) in
        (let (ui42 :: 3 bits) = ((subrange_vec_dec v__948 (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word)) in
        return ((concat_vec ( 0b011 ::  3 Word.word)
                   ((concat_vec ui5
                       ((concat_vec rd
                           ((concat_vec ui42 ((concat_vec ui76 ( 0b10 ::  2 Word.word)  ::  4 Word.word))
                              ::  7 Word.word))
                          ::  12 Word.word))
                      ::  13 Word.word))
                  ::  16 Word.word))))))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))
   | C_FSWSP ((v__949, rs2)) =>
      and_boolM (return ((((( 64 :: int)::ii) = (( 32 :: int)::ii))))) (and_boolM ((haveRVC () )) ((haveFExt () ))) \<bind> ((\<lambda> (w__63 ::
        bool) . 
      if w__63 then
        (let (ui76 :: 2 bits) = ((subrange_vec_dec v__949 (( 5 :: int)::ii) (( 4 :: int)::ii)  ::  2 Word.word)) in
        (let (ui76 :: 2 bits) = ((subrange_vec_dec v__949 (( 5 :: int)::ii) (( 4 :: int)::ii)  ::  2 Word.word)) in
        (let (ui52 :: 4 bits) = ((subrange_vec_dec v__949 (( 3 :: int)::ii) (( 0 :: int)::ii)  ::  4 Word.word)) in
        return ((concat_vec ( 0b111 ::  3 Word.word)
                   ((concat_vec ui52
                       ((concat_vec ui76 ((concat_vec rs2 ( 0b10 ::  2 Word.word)  ::  7 Word.word))
                          ::  9 Word.word))
                      ::  13 Word.word))
                  ::  16 Word.word)))))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))
   | C_FLW ((v__950, rs1, rd)) =>
      and_boolM (return ((((( 64 :: int)::ii) = (( 32 :: int)::ii))))) (and_boolM ((haveRVC () )) ((haveFExt () ))) \<bind> ((\<lambda> (w__69 ::
        bool) . 
      if w__69 then
        (let (ui6 :: 1 bits) = ((subrange_vec_dec v__950 (( 4 :: int)::ii) (( 4 :: int)::ii)  ::  1 Word.word)) in
        (let (ui6 :: 1 bits) = ((subrange_vec_dec v__950 (( 4 :: int)::ii) (( 4 :: int)::ii)  ::  1 Word.word)) in
        (let (ui53 :: 3 bits) = ((subrange_vec_dec v__950 (( 3 :: int)::ii) (( 1 :: int)::ii)  ::  3 Word.word)) in
        (let (ui2 :: 1 bits) = ((subrange_vec_dec v__950 (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) in
        return ((concat_vec ( 0b011 ::  3 Word.word)
                   ((concat_vec ui53
                       ((concat_vec rs1
                           ((concat_vec ui2
                               ((concat_vec ui6 ((concat_vec rd ( 0b00 ::  2 Word.word)  ::  5 Word.word))
                                  ::  6 Word.word))
                              ::  7 Word.word))
                          ::  10 Word.word))
                      ::  13 Word.word))
                  ::  16 Word.word))))))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))
   | C_FSW ((v__951, rs1, rs2)) =>
      and_boolM (return ((((( 64 :: int)::ii) = (( 32 :: int)::ii))))) (and_boolM ((haveRVC () )) ((haveFExt () ))) \<bind> ((\<lambda> (w__75 ::
        bool) . 
      if w__75 then
        (let (ui6 :: 1 bits) = ((subrange_vec_dec v__951 (( 4 :: int)::ii) (( 4 :: int)::ii)  ::  1 Word.word)) in
        (let (ui6 :: 1 bits) = ((subrange_vec_dec v__951 (( 4 :: int)::ii) (( 4 :: int)::ii)  ::  1 Word.word)) in
        (let (ui53 :: 3 bits) = ((subrange_vec_dec v__951 (( 3 :: int)::ii) (( 1 :: int)::ii)  ::  3 Word.word)) in
        (let (ui2 :: 1 bits) = ((subrange_vec_dec v__951 (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) in
        return ((concat_vec ( 0b111 ::  3 Word.word)
                   ((concat_vec ui53
                       ((concat_vec rs1
                           ((concat_vec ui2
                               ((concat_vec ui6 ((concat_vec rs2 ( 0b00 ::  2 Word.word)  ::  5 Word.word))
                                  ::  6 Word.word))
                              ::  7 Word.word))
                          ::  10 Word.word))
                      ::  13 Word.word))
                  ::  16 Word.word))))))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))
   | C_FLDSP ((v__952, rd)) =>
      and_boolM (return (((((((( 64 :: int)::ii) = (( 32 :: int)::ii)))) \<or> ((((( 64 :: int)::ii) = (( 64 :: int)::ii))))))))
        (and_boolM ((haveRVC () )) ((haveDExt () ))) \<bind> ((\<lambda> (w__81 :: bool) . 
      if w__81 then
        (let (ui86 :: 3 bits) = ((subrange_vec_dec v__952 (( 5 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) in
        (let (ui86 :: 3 bits) = ((subrange_vec_dec v__952 (( 5 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) in
        (let (ui5 :: 1 bits) = ((subrange_vec_dec v__952 (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word)) in
        (let (ui43 :: 2 bits) = ((subrange_vec_dec v__952 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) in
        return ((concat_vec ( 0b001 ::  3 Word.word)
                   ((concat_vec ui5
                       ((concat_vec rd
                           ((concat_vec ui43 ((concat_vec ui86 ( 0b10 ::  2 Word.word)  ::  5 Word.word))
                              ::  7 Word.word))
                          ::  12 Word.word))
                      ::  13 Word.word))
                  ::  16 Word.word))))))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))
   | C_FSDSP ((v__953, rs2)) =>
      and_boolM (return (((((((( 64 :: int)::ii) = (( 32 :: int)::ii)))) \<or> ((((( 64 :: int)::ii) = (( 64 :: int)::ii))))))))
        (and_boolM ((haveRVC () )) ((haveDExt () ))) \<bind> ((\<lambda> (w__87 :: bool) . 
      if w__87 then
        (let (ui86 :: 3 bits) = ((subrange_vec_dec v__953 (( 5 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) in
        (let (ui86 :: 3 bits) = ((subrange_vec_dec v__953 (( 5 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) in
        (let (ui53 :: 3 bits) = ((subrange_vec_dec v__953 (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word)) in
        return ((concat_vec ( 0b101 ::  3 Word.word)
                   ((concat_vec ui53
                       ((concat_vec ui86 ((concat_vec rs2 ( 0b10 ::  2 Word.word)  ::  7 Word.word))
                          ::  10 Word.word))
                      ::  13 Word.word))
                  ::  16 Word.word)))))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))
   | C_FLD ((v__954, rs1, rd)) =>
      and_boolM (return (((((((( 64 :: int)::ii) = (( 32 :: int)::ii)))) \<or> ((((( 64 :: int)::ii) = (( 64 :: int)::ii))))))))
        (and_boolM ((haveRVC () )) ((haveDExt () ))) \<bind> ((\<lambda> (w__93 :: bool) . 
      if w__93 then
        (let (ui76 :: 2 bits) = ((subrange_vec_dec v__954 (( 4 :: int)::ii) (( 3 :: int)::ii)  ::  2 Word.word)) in
        (let (ui76 :: 2 bits) = ((subrange_vec_dec v__954 (( 4 :: int)::ii) (( 3 :: int)::ii)  ::  2 Word.word)) in
        (let (ui53 :: 3 bits) = ((subrange_vec_dec v__954 (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word)) in
        return ((concat_vec ( 0b001 ::  3 Word.word)
                   ((concat_vec ui53
                       ((concat_vec rs1
                           ((concat_vec ui76 ((concat_vec rd ( 0b00 ::  2 Word.word)  ::  5 Word.word))
                              ::  7 Word.word))
                          ::  10 Word.word))
                      ::  13 Word.word))
                  ::  16 Word.word)))))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))
   | C_FSD ((v__955, rs1, rs2)) =>
      and_boolM (return (((((((( 64 :: int)::ii) = (( 32 :: int)::ii)))) \<or> ((((( 64 :: int)::ii) = (( 64 :: int)::ii))))))))
        (and_boolM ((haveRVC () )) ((haveDExt () ))) \<bind> ((\<lambda> (w__99 :: bool) . 
      if w__99 then
        (let (ui76 :: 2 bits) = ((subrange_vec_dec v__955 (( 4 :: int)::ii) (( 3 :: int)::ii)  ::  2 Word.word)) in
        (let (ui76 :: 2 bits) = ((subrange_vec_dec v__955 (( 4 :: int)::ii) (( 3 :: int)::ii)  ::  2 Word.word)) in
        (let (ui53 :: 3 bits) = ((subrange_vec_dec v__955 (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word)) in
        return ((concat_vec ( 0b101 ::  3 Word.word)
                   ((concat_vec ui53
                       ((concat_vec rs1
                           ((concat_vec ui76 ((concat_vec rs2 ( 0b00 ::  2 Word.word)  ::  5 Word.word))
                              ::  7 Word.word))
                          ::  10 Word.word))
                      ::  13 Word.word))
                  ::  16 Word.word)))))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))
   | C_ILLEGAL (s) => return s
   | _ => assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () 
   )))\<close> 
  for  ast  :: " ast "


definition encdec_compressed_backwards  :: \<open>(16)Word.word \<Rightarrow>((register_value),(ast),(exception))monad \<close>  where 
     \<open> encdec_compressed_backwards arg1 = (
   (let v__956 = arg1 in
   if (((v__956 = ( 0x0001 ::  16 Word.word)))) then return (C_NOP () )
   else if (((((let (nz96 :: 4 bits) = ((subrange_vec_dec v__956 (( 10 :: int)::ii) (( 7 :: int)::ii)  ::  4 Word.word)) in
               (let (nz54 :: 2 bits) = ((subrange_vec_dec v__956 (( 12 :: int)::ii) (( 11 :: int)::ii)  ::  2 Word.word)) in
               (let (nz3 :: 1 bits) = ((subrange_vec_dec v__956 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
               (let (nz2 :: 1 bits) = ((subrange_vec_dec v__956 (( 6 :: int)::ii) (( 6 :: int)::ii)  ::  1 Word.word)) in
               (((concat_vec nz96
                     ((concat_vec nz54 ((concat_vec nz3 nz2  ::  2 Word.word))  ::  4 Word.word))
                    ::  8 Word.word)) \<noteq> ( 0x00 ::  8 Word.word))))))) \<and> ((((((((subrange_vec_dec v__956 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = ( 0b000 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__956 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b00 ::  2 Word.word)))))))))) then
     (let (rd :: cregidx) = ((subrange_vec_dec v__956 (( 4 :: int)::ii) (( 2 :: int)::ii)  ::  3 Word.word)) in
     (let (nz96 :: 4 bits) = ((subrange_vec_dec v__956 (( 10 :: int)::ii) (( 7 :: int)::ii)  ::  4 Word.word)) in
     (let (nz54 :: 2 bits) = ((subrange_vec_dec v__956 (( 12 :: int)::ii) (( 11 :: int)::ii)  ::  2 Word.word)) in
     (let (nz3 :: 1 bits) = ((subrange_vec_dec v__956 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
     (let (nz2 :: 1 bits) = ((subrange_vec_dec v__956 (( 6 :: int)::ii) (( 6 :: int)::ii)  ::  1 Word.word)) in
     return (C_ADDI4SPN (rd,
                         (concat_vec nz96
                            ((concat_vec nz54 ((concat_vec nz3 nz2  ::  2 Word.word))  ::  4 Word.word))
                           ::  8 Word.word))))))))
   else if ((((((((subrange_vec_dec v__956 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = ( 0b010 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__956 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b00 ::  2 Word.word)))))))
   then
     (let (ui6 :: 1 bits) = ((subrange_vec_dec v__956 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
     (let (ui53 :: 3 bits) = ((subrange_vec_dec v__956 (( 12 :: int)::ii) (( 10 :: int)::ii)  ::  3 Word.word)) in
     (let (ui2 :: 1 bits) = ((subrange_vec_dec v__956 (( 6 :: int)::ii) (( 6 :: int)::ii)  ::  1 Word.word)) in
     (let (rs1 :: cregidx) = ((subrange_vec_dec v__956 (( 9 :: int)::ii) (( 7 :: int)::ii)  ::  3 Word.word)) in
     (let (rd :: cregidx) = ((subrange_vec_dec v__956 (( 4 :: int)::ii) (( 2 :: int)::ii)  ::  3 Word.word)) in
     return (C_LW ((concat_vec ui6 ((concat_vec ui53 ui2  ::  4 Word.word))  ::  5 Word.word), rs1, rd)))))))
   else if (((((((( 64 :: int)::ii) = (( 64 :: int)::ii)))) \<and> ((((((((subrange_vec_dec v__956 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = ( 0b011 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__956 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b00 ::  2 Word.word)))))))))) then
     (let (ui76 :: 2 bits) = ((subrange_vec_dec v__956 (( 6 :: int)::ii) (( 5 :: int)::ii)  ::  2 Word.word)) in
     (let (ui53 :: 3 bits) = ((subrange_vec_dec v__956 (( 12 :: int)::ii) (( 10 :: int)::ii)  ::  3 Word.word)) in
     (let (rs1 :: cregidx) = ((subrange_vec_dec v__956 (( 9 :: int)::ii) (( 7 :: int)::ii)  ::  3 Word.word)) in
     (let (rd :: cregidx) = ((subrange_vec_dec v__956 (( 4 :: int)::ii) (( 2 :: int)::ii)  ::  3 Word.word)) in
     return (C_LD ((concat_vec ui76 ui53  ::  5 Word.word), rs1, rd))))))
   else if ((((((((subrange_vec_dec v__956 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = ( 0b110 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__956 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b00 ::  2 Word.word)))))))
   then
     (let (ui6 :: 1 bits) = ((subrange_vec_dec v__956 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
     (let (ui53 :: 3 bits) = ((subrange_vec_dec v__956 (( 12 :: int)::ii) (( 10 :: int)::ii)  ::  3 Word.word)) in
     (let (ui2 :: 1 bits) = ((subrange_vec_dec v__956 (( 6 :: int)::ii) (( 6 :: int)::ii)  ::  1 Word.word)) in
     (let (rs2 :: cregidx) = ((subrange_vec_dec v__956 (( 4 :: int)::ii) (( 2 :: int)::ii)  ::  3 Word.word)) in
     (let (rs1 :: cregidx) = ((subrange_vec_dec v__956 (( 9 :: int)::ii) (( 7 :: int)::ii)  ::  3 Word.word)) in
     return (C_SW ((concat_vec ui6 ((concat_vec ui53 ui2  ::  4 Word.word))  ::  5 Word.word), rs1, rs2)))))))
   else if (((((((( 64 :: int)::ii) = (( 64 :: int)::ii)))) \<and> ((((((((subrange_vec_dec v__956 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = ( 0b111 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__956 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b00 ::  2 Word.word)))))))))) then
     (let (ui76 :: 2 bits) = ((subrange_vec_dec v__956 (( 6 :: int)::ii) (( 5 :: int)::ii)  ::  2 Word.word)) in
     (let (ui53 :: 3 bits) = ((subrange_vec_dec v__956 (( 12 :: int)::ii) (( 10 :: int)::ii)  ::  3 Word.word)) in
     (let (rs2 :: 3 bits) = ((subrange_vec_dec v__956 (( 4 :: int)::ii) (( 2 :: int)::ii)  ::  3 Word.word)) in
     (let (rs1 :: 3 bits) = ((subrange_vec_dec v__956 (( 9 :: int)::ii) (( 7 :: int)::ii)  ::  3 Word.word)) in
     return (C_SD ((concat_vec ui76 ui53  ::  5 Word.word), rs1, rs2))))))
   else if (((((let (rsd :: regidx) = ((subrange_vec_dec v__956 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
               (let (nzi5 :: 1 bits) = ((subrange_vec_dec v__956 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
               (let (nzi40 :: 5 bits) = ((subrange_vec_dec v__956 (( 6 :: int)::ii) (( 2 :: int)::ii)  ::  5 Word.word)) in
               ((((((concat_vec nzi5 nzi40  ::  6 Word.word)) \<noteq> ( 0b000000 ::  6 Word.word)))) \<and> (((rsd \<noteq> zreg)))))))) \<and> ((((((((subrange_vec_dec v__956 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = ( 0b000 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__956 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b01 ::  2 Word.word)))))))))) then
     (let (rsd :: regidx) = ((subrange_vec_dec v__956 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     (let (nzi5 :: 1 bits) = ((subrange_vec_dec v__956 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
     (let (nzi40 :: 5 bits) = ((subrange_vec_dec v__956 (( 6 :: int)::ii) (( 2 :: int)::ii)  ::  5 Word.word)) in
     return (C_ADDI ((concat_vec nzi5 nzi40  ::  6 Word.word), rsd)))))
   else if (((((((( 64 :: int)::ii) = (( 32 :: int)::ii)))) \<and> ((((((((subrange_vec_dec v__956 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = ( 0b001 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__956 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b01 ::  2 Word.word)))))))))) then
     (let (i98 :: 2 bits) = ((subrange_vec_dec v__956 (( 10 :: int)::ii) (( 9 :: int)::ii)  ::  2 Word.word)) in
     (let (i7 :: 1 bits) = ((subrange_vec_dec v__956 (( 6 :: int)::ii) (( 6 :: int)::ii)  ::  1 Word.word)) in
     (let (i6 :: 1 bits) = ((subrange_vec_dec v__956 (( 7 :: int)::ii) (( 7 :: int)::ii)  ::  1 Word.word)) in
     (let (i5 :: 1 bits) = ((subrange_vec_dec v__956 (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word)) in
     (let (i4 :: 1 bits) = ((subrange_vec_dec v__956 (( 11 :: int)::ii) (( 11 :: int)::ii)  ::  1 Word.word)) in
     (let (i31 :: 3 bits) = ((subrange_vec_dec v__956 (( 5 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) in
     (let (i11 :: 1 bits) = ((subrange_vec_dec v__956 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
     (let (i10 :: 1 bits) = ((subrange_vec_dec v__956 (( 8 :: int)::ii) (( 8 :: int)::ii)  ::  1 Word.word)) in
     return (C_JAL ((concat_vec i11
                       ((concat_vec i10
                           ((concat_vec i98
                               ((concat_vec i7
                                   ((concat_vec i6
                                       ((concat_vec i5 ((concat_vec i4 i31  ::  4 Word.word))
                                          ::  5 Word.word))
                                      ::  6 Word.word))
                                  ::  7 Word.word))
                              ::  9 Word.word))
                          ::  10 Word.word))
                      ::  11 Word.word)))))))))))
   else if (((((let (rsd :: regidx) = ((subrange_vec_dec v__956 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
               ((((rsd \<noteq> zreg))) \<and> ((((( 64 :: int)::ii) = (( 64 :: int)::ii))))))) \<and> ((((((((subrange_vec_dec v__956 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = ( 0b001 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__956 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b01 ::  2 Word.word)))))))))) then
     (let (rsd :: regidx) = ((subrange_vec_dec v__956 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     (let (imm5 :: 1 bits) = ((subrange_vec_dec v__956 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
     (let (imm40 :: 5 bits) = ((subrange_vec_dec v__956 (( 6 :: int)::ii) (( 2 :: int)::ii)  ::  5 Word.word)) in
     return (C_ADDIW ((concat_vec imm5 imm40  ::  6 Word.word), rsd)))))
   else if (((((let (rd :: regidx) = ((subrange_vec_dec v__956 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
               (rd \<noteq> zreg))) \<and> ((((((((subrange_vec_dec v__956 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = ( 0b010 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__956 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b01 ::  2 Word.word)))))))))) then
     (let (rd :: regidx) = ((subrange_vec_dec v__956 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     (let (imm5 :: 1 bits) = ((subrange_vec_dec v__956 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
     (let (imm40 :: 5 bits) = ((subrange_vec_dec v__956 (( 6 :: int)::ii) (( 2 :: int)::ii)  ::  5 Word.word)) in
     return (C_LI ((concat_vec imm5 imm40  ::  6 Word.word), rd)))))
   else if (((((let (nzi9 :: 1 bits) = ((subrange_vec_dec v__956 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
               (let (nzi87 :: 2 bits) = ((subrange_vec_dec v__956 (( 4 :: int)::ii) (( 3 :: int)::ii)  ::  2 Word.word)) in
               (let (nzi6 :: 1 bits) = ((subrange_vec_dec v__956 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
               (let (nzi5 :: 1 bits) = ((subrange_vec_dec v__956 (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word)) in
               (let (nzi4 :: 1 bits) = ((subrange_vec_dec v__956 (( 6 :: int)::ii) (( 6 :: int)::ii)  ::  1 Word.word)) in
               (((concat_vec nzi9
                     ((concat_vec nzi87
                         ((concat_vec nzi6 ((concat_vec nzi5 nzi4  ::  2 Word.word))  ::  3 Word.word))
                        ::  5 Word.word))
                    ::  6 Word.word)) \<noteq> ( 0b000000 ::  6 Word.word)))))))) \<and> ((((((((subrange_vec_dec v__956 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = ( 0b011 ::  3 Word.word)))) \<and> ((((((((subrange_vec_dec v__956 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) = ( 0b00010 ::  5 Word.word)))) \<and> (((((subrange_vec_dec v__956 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b01 ::  2 Word.word))))))))))))) then
     (let (nzi9 :: 1 bits) = ((subrange_vec_dec v__956 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
     (let (nzi87 :: 2 bits) = ((subrange_vec_dec v__956 (( 4 :: int)::ii) (( 3 :: int)::ii)  ::  2 Word.word)) in
     (let (nzi6 :: 1 bits) = ((subrange_vec_dec v__956 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
     (let (nzi5 :: 1 bits) = ((subrange_vec_dec v__956 (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word)) in
     (let (nzi4 :: 1 bits) = ((subrange_vec_dec v__956 (( 6 :: int)::ii) (( 6 :: int)::ii)  ::  1 Word.word)) in
     return (C_ADDI16SP ((concat_vec nzi9
                            ((concat_vec nzi87
                                ((concat_vec nzi6 ((concat_vec nzi5 nzi4  ::  2 Word.word))  ::  3 Word.word))
                               ::  5 Word.word))
                           ::  6 Word.word))))))))
   else if (((((let (rd :: regidx) = ((subrange_vec_dec v__956 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
               (let (imm17 :: 1 bits) = ((subrange_vec_dec v__956 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
               (let (imm1612 :: 5 bits) = ((subrange_vec_dec v__956 (( 6 :: int)::ii) (( 2 :: int)::ii)  ::  5 Word.word)) in
               ((((rd \<noteq> zreg))) \<and> ((((((rd \<noteq> sp))) \<and> (((((concat_vec imm17 imm1612  ::  6 Word.word)) \<noteq> ( 0b000000 ::  6 Word.word)))))))))))) \<and> ((((((((subrange_vec_dec v__956 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = ( 0b011 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__956 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b01 ::  2 Word.word)))))))))) then
     (let (rd :: regidx) = ((subrange_vec_dec v__956 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     (let (imm17 :: 1 bits) = ((subrange_vec_dec v__956 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
     (let (imm1612 :: 5 bits) = ((subrange_vec_dec v__956 (( 6 :: int)::ii) (( 2 :: int)::ii)  ::  5 Word.word)) in
     return (C_LUI ((concat_vec imm17 imm1612  ::  6 Word.word), rd)))))
   else if (((((let (nzui5 :: 1 bits) = ((subrange_vec_dec v__956 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
               (let (nzui40 :: 5 bits) = ((subrange_vec_dec v__956 (( 6 :: int)::ii) (( 2 :: int)::ii)  ::  5 Word.word)) in
               (((concat_vec nzui5 nzui40  ::  6 Word.word)) \<noteq> ( 0b000000 ::  6 Word.word))))) \<and> ((((((((subrange_vec_dec v__956 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = ( 0b100 ::  3 Word.word)))) \<and> ((((((((subrange_vec_dec v__956 (( 11 :: int)::ii) (( 10 :: int)::ii)  ::  2 Word.word)) = ( 0b00 ::  2 Word.word)))) \<and> (((((subrange_vec_dec v__956 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b01 ::  2 Word.word))))))))))))) then
     (let (rsd :: cregidx) = ((subrange_vec_dec v__956 (( 9 :: int)::ii) (( 7 :: int)::ii)  ::  3 Word.word)) in
     (let (nzui5 :: 1 bits) = ((subrange_vec_dec v__956 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
     (let (nzui40 :: 5 bits) = ((subrange_vec_dec v__956 (( 6 :: int)::ii) (( 2 :: int)::ii)  ::  5 Word.word)) in
     return (C_SRLI ((concat_vec nzui5 nzui40  ::  6 Word.word), rsd)))))
   else if (((((let (nzui5 :: 1 bits) = ((subrange_vec_dec v__956 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
               (let (nzui40 :: 5 bits) = ((subrange_vec_dec v__956 (( 6 :: int)::ii) (( 2 :: int)::ii)  ::  5 Word.word)) in
               (((concat_vec nzui5 nzui40  ::  6 Word.word)) \<noteq> ( 0b000000 ::  6 Word.word))))) \<and> ((((((((subrange_vec_dec v__956 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = ( 0b100 ::  3 Word.word)))) \<and> ((((((((subrange_vec_dec v__956 (( 11 :: int)::ii) (( 10 :: int)::ii)  ::  2 Word.word)) = ( 0b01 ::  2 Word.word)))) \<and> (((((subrange_vec_dec v__956 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b01 ::  2 Word.word))))))))))))) then
     (let (rsd :: cregidx) = ((subrange_vec_dec v__956 (( 9 :: int)::ii) (( 7 :: int)::ii)  ::  3 Word.word)) in
     (let (nzui5 :: 1 bits) = ((subrange_vec_dec v__956 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
     (let (nzui40 :: 5 bits) = ((subrange_vec_dec v__956 (( 6 :: int)::ii) (( 2 :: int)::ii)  ::  5 Word.word)) in
     return (C_SRAI ((concat_vec nzui5 nzui40  ::  6 Word.word), rsd)))))
   else if ((((((((subrange_vec_dec v__956 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = ( 0b100 ::  3 Word.word)))) \<and> ((((((((subrange_vec_dec v__956 (( 11 :: int)::ii) (( 10 :: int)::ii)  ::  2 Word.word)) = ( 0b10 ::  2 Word.word)))) \<and> (((((subrange_vec_dec v__956 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b01 ::  2 Word.word)))))))))) then
     (let (rsd :: cregidx) = ((subrange_vec_dec v__956 (( 9 :: int)::ii) (( 7 :: int)::ii)  ::  3 Word.word)) in
     (let (i5 :: 1 bits) = ((subrange_vec_dec v__956 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
     (let (i40 :: 5 bits) = ((subrange_vec_dec v__956 (( 6 :: int)::ii) (( 2 :: int)::ii)  ::  5 Word.word)) in
     return (C_ANDI ((concat_vec i5 i40  ::  6 Word.word), rsd)))))
   else if ((((((((subrange_vec_dec v__956 (( 15 :: int)::ii) (( 10 :: int)::ii)  ::  6 Word.word)) = ( 0b100011 ::  6 Word.word)))) \<and> ((((((((subrange_vec_dec v__956 (( 6 :: int)::ii) (( 5 :: int)::ii)  ::  2 Word.word)) = ( 0b00 ::  2 Word.word)))) \<and> (((((subrange_vec_dec v__956 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b01 ::  2 Word.word)))))))))) then
     (let (rsd :: cregidx) = ((subrange_vec_dec v__956 (( 9 :: int)::ii) (( 7 :: int)::ii)  ::  3 Word.word)) in
     (let (rs2 :: cregidx) = ((subrange_vec_dec v__956 (( 4 :: int)::ii) (( 2 :: int)::ii)  ::  3 Word.word)) in
     return (C_SUB (rsd, rs2))))
   else if ((((((((subrange_vec_dec v__956 (( 15 :: int)::ii) (( 10 :: int)::ii)  ::  6 Word.word)) = ( 0b100011 ::  6 Word.word)))) \<and> ((((((((subrange_vec_dec v__956 (( 6 :: int)::ii) (( 5 :: int)::ii)  ::  2 Word.word)) = ( 0b01 ::  2 Word.word)))) \<and> (((((subrange_vec_dec v__956 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b01 ::  2 Word.word)))))))))) then
     (let (rsd :: cregidx) = ((subrange_vec_dec v__956 (( 9 :: int)::ii) (( 7 :: int)::ii)  ::  3 Word.word)) in
     (let (rs2 :: cregidx) = ((subrange_vec_dec v__956 (( 4 :: int)::ii) (( 2 :: int)::ii)  ::  3 Word.word)) in
     return (C_XOR (rsd, rs2))))
   else if ((((((((subrange_vec_dec v__956 (( 15 :: int)::ii) (( 10 :: int)::ii)  ::  6 Word.word)) = ( 0b100011 ::  6 Word.word)))) \<and> ((((((((subrange_vec_dec v__956 (( 6 :: int)::ii) (( 5 :: int)::ii)  ::  2 Word.word)) = ( 0b10 ::  2 Word.word)))) \<and> (((((subrange_vec_dec v__956 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b01 ::  2 Word.word)))))))))) then
     (let (rsd :: cregidx) = ((subrange_vec_dec v__956 (( 9 :: int)::ii) (( 7 :: int)::ii)  ::  3 Word.word)) in
     (let (rs2 :: cregidx) = ((subrange_vec_dec v__956 (( 4 :: int)::ii) (( 2 :: int)::ii)  ::  3 Word.word)) in
     return (C_OR (rsd, rs2))))
   else if ((((((((subrange_vec_dec v__956 (( 15 :: int)::ii) (( 10 :: int)::ii)  ::  6 Word.word)) = ( 0b100011 ::  6 Word.word)))) \<and> ((((((((subrange_vec_dec v__956 (( 6 :: int)::ii) (( 5 :: int)::ii)  ::  2 Word.word)) = ( 0b11 ::  2 Word.word)))) \<and> (((((subrange_vec_dec v__956 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b01 ::  2 Word.word)))))))))) then
     (let (rsd :: cregidx) = ((subrange_vec_dec v__956 (( 9 :: int)::ii) (( 7 :: int)::ii)  ::  3 Word.word)) in
     (let (rs2 :: cregidx) = ((subrange_vec_dec v__956 (( 4 :: int)::ii) (( 2 :: int)::ii)  ::  3 Word.word)) in
     return (C_AND (rsd, rs2))))
   else if (((((((( 64 :: int)::ii) = (( 64 :: int)::ii)))) \<and> ((((((((subrange_vec_dec v__956 (( 15 :: int)::ii) (( 10 :: int)::ii)  ::  6 Word.word)) = ( 0b100111 ::  6 Word.word)))) \<and> ((((((((subrange_vec_dec v__956 (( 6 :: int)::ii) (( 5 :: int)::ii)  ::  2 Word.word)) = ( 0b00 ::  2 Word.word)))) \<and> (((((subrange_vec_dec v__956 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b01 ::  2 Word.word))))))))))))) then
     (let (rsd :: cregidx) = ((subrange_vec_dec v__956 (( 9 :: int)::ii) (( 7 :: int)::ii)  ::  3 Word.word)) in
     (let (rs2 :: cregidx) = ((subrange_vec_dec v__956 (( 4 :: int)::ii) (( 2 :: int)::ii)  ::  3 Word.word)) in
     return (C_SUBW (rsd, rs2))))
   else if (((((((( 64 :: int)::ii) = (( 64 :: int)::ii)))) \<and> ((((((((subrange_vec_dec v__956 (( 15 :: int)::ii) (( 10 :: int)::ii)  ::  6 Word.word)) = ( 0b100111 ::  6 Word.word)))) \<and> ((((((((subrange_vec_dec v__956 (( 6 :: int)::ii) (( 5 :: int)::ii)  ::  2 Word.word)) = ( 0b01 ::  2 Word.word)))) \<and> (((((subrange_vec_dec v__956 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b01 ::  2 Word.word))))))))))))) then
     (let (rsd :: cregidx) = ((subrange_vec_dec v__956 (( 9 :: int)::ii) (( 7 :: int)::ii)  ::  3 Word.word)) in
     (let (rs2 :: cregidx) = ((subrange_vec_dec v__956 (( 4 :: int)::ii) (( 2 :: int)::ii)  ::  3 Word.word)) in
     return (C_ADDW (rsd, rs2))))
   else if ((((((((subrange_vec_dec v__956 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = ( 0b101 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__956 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b01 ::  2 Word.word)))))))
   then
     (let (i98 :: 2 bits) = ((subrange_vec_dec v__956 (( 10 :: int)::ii) (( 9 :: int)::ii)  ::  2 Word.word)) in
     (let (i7 :: 1 bits) = ((subrange_vec_dec v__956 (( 6 :: int)::ii) (( 6 :: int)::ii)  ::  1 Word.word)) in
     (let (i6 :: 1 bits) = ((subrange_vec_dec v__956 (( 7 :: int)::ii) (( 7 :: int)::ii)  ::  1 Word.word)) in
     (let (i5 :: 1 bits) = ((subrange_vec_dec v__956 (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word)) in
     (let (i4 :: 1 bits) = ((subrange_vec_dec v__956 (( 11 :: int)::ii) (( 11 :: int)::ii)  ::  1 Word.word)) in
     (let (i31 :: 3 bits) = ((subrange_vec_dec v__956 (( 5 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) in
     (let (i11 :: 1 bits) = ((subrange_vec_dec v__956 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
     (let (i10 :: 1 bits) = ((subrange_vec_dec v__956 (( 8 :: int)::ii) (( 8 :: int)::ii)  ::  1 Word.word)) in
     return (C_J ((concat_vec i11
                     ((concat_vec i10
                         ((concat_vec i98
                             ((concat_vec i7
                                 ((concat_vec i6
                                     ((concat_vec i5 ((concat_vec i4 i31  ::  4 Word.word))  ::  5 Word.word))
                                    ::  6 Word.word))
                                ::  7 Word.word))
                            ::  9 Word.word))
                        ::  10 Word.word))
                    ::  11 Word.word)))))))))))
   else if ((((((((subrange_vec_dec v__956 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = ( 0b110 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__956 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b01 ::  2 Word.word)))))))
   then
     (let (rs :: cregidx) = ((subrange_vec_dec v__956 (( 9 :: int)::ii) (( 7 :: int)::ii)  ::  3 Word.word)) in
     (let (i8 :: 1 bits) = ((subrange_vec_dec v__956 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
     (let (i76 :: 2 bits) = ((subrange_vec_dec v__956 (( 6 :: int)::ii) (( 5 :: int)::ii)  ::  2 Word.word)) in
     (let (i5 :: 1 bits) = ((subrange_vec_dec v__956 (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word)) in
     (let (i43 :: 2 bits) = ((subrange_vec_dec v__956 (( 11 :: int)::ii) (( 10 :: int)::ii)  ::  2 Word.word)) in
     (let (i21 :: 2 bits) = ((subrange_vec_dec v__956 (( 4 :: int)::ii) (( 3 :: int)::ii)  ::  2 Word.word)) in
     return (C_BEQZ ((concat_vec i8
                        ((concat_vec i76
                            ((concat_vec i5 ((concat_vec i43 i21  ::  4 Word.word))  ::  5 Word.word))
                           ::  7 Word.word))
                       ::  8 Word.word),
                     rs))))))))
   else if ((((((((subrange_vec_dec v__956 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = ( 0b111 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__956 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b01 ::  2 Word.word)))))))
   then
     (let (rs :: cregidx) = ((subrange_vec_dec v__956 (( 9 :: int)::ii) (( 7 :: int)::ii)  ::  3 Word.word)) in
     (let (i8 :: 1 bits) = ((subrange_vec_dec v__956 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
     (let (i76 :: 2 bits) = ((subrange_vec_dec v__956 (( 6 :: int)::ii) (( 5 :: int)::ii)  ::  2 Word.word)) in
     (let (i5 :: 1 bits) = ((subrange_vec_dec v__956 (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word)) in
     (let (i43 :: 2 bits) = ((subrange_vec_dec v__956 (( 11 :: int)::ii) (( 10 :: int)::ii)  ::  2 Word.word)) in
     (let (i21 :: 2 bits) = ((subrange_vec_dec v__956 (( 4 :: int)::ii) (( 3 :: int)::ii)  ::  2 Word.word)) in
     return (C_BNEZ ((concat_vec i8
                        ((concat_vec i76
                            ((concat_vec i5 ((concat_vec i43 i21  ::  4 Word.word))  ::  5 Word.word))
                           ::  7 Word.word))
                       ::  8 Word.word),
                     rs))))))))
   else if (((((let (rsd :: regidx) = ((subrange_vec_dec v__956 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
               (let (nzui5 :: 1 bits) = ((subrange_vec_dec v__956 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
               (let (nzui40 :: 5 bits) = ((subrange_vec_dec v__956 (( 6 :: int)::ii) (( 2 :: int)::ii)  ::  5 Word.word)) in
               ((((((concat_vec nzui5 nzui40  ::  6 Word.word)) \<noteq> ( 0b000000 ::  6 Word.word)))) \<and> ((((((rsd \<noteq> zreg))) \<and> (((((((( 64 :: int)::ii) = (( 64 :: int)::ii)))) \<or> (((nzui5 = ( 0b0 ::  1 Word.word))))))))))))))) \<and> ((((((((subrange_vec_dec v__956 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = ( 0b000 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__956 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b10 ::  2 Word.word)))))))))) then
     (let (rsd :: regidx) = ((subrange_vec_dec v__956 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     (let (nzui5 :: 1 bits) = ((subrange_vec_dec v__956 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
     (let (nzui40 :: 5 bits) = ((subrange_vec_dec v__956 (( 6 :: int)::ii) (( 2 :: int)::ii)  ::  5 Word.word)) in
     return (C_SLLI ((concat_vec nzui5 nzui40  ::  6 Word.word), rsd)))))
   else if (((((let (rd :: regidx) = ((subrange_vec_dec v__956 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
               (rd \<noteq> zreg))) \<and> ((((((((subrange_vec_dec v__956 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = ( 0b010 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__956 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b10 ::  2 Word.word)))))))))) then
     (let (ui76 :: 2 bits) = ((subrange_vec_dec v__956 (( 3 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) in
     (let (ui5 :: 1 bits) = ((subrange_vec_dec v__956 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
     (let (ui42 :: 3 bits) = ((subrange_vec_dec v__956 (( 6 :: int)::ii) (( 4 :: int)::ii)  ::  3 Word.word)) in
     (let (rd :: regidx) = ((subrange_vec_dec v__956 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     return (C_LWSP ((concat_vec ui76 ((concat_vec ui5 ui42  ::  4 Word.word))  ::  6 Word.word), rd))))))
   else if (((((let (rd :: regidx) = ((subrange_vec_dec v__956 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
               ((((rd \<noteq> zreg))) \<and> ((((( 64 :: int)::ii) = (( 64 :: int)::ii))))))) \<and> ((((((((subrange_vec_dec v__956 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = ( 0b011 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__956 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b10 ::  2 Word.word)))))))))) then
     (let (ui86 :: 3 bits) = ((subrange_vec_dec v__956 (( 4 :: int)::ii) (( 2 :: int)::ii)  ::  3 Word.word)) in
     (let (ui5 :: 1 bits) = ((subrange_vec_dec v__956 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
     (let (ui43 :: 2 bits) = ((subrange_vec_dec v__956 (( 6 :: int)::ii) (( 5 :: int)::ii)  ::  2 Word.word)) in
     (let (rd :: regidx) = ((subrange_vec_dec v__956 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     return (C_LDSP ((concat_vec ui86 ((concat_vec ui5 ui43  ::  3 Word.word))  ::  6 Word.word), rd))))))
   else if ((((((((subrange_vec_dec v__956 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = ( 0b110 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__956 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b10 ::  2 Word.word)))))))
   then
     (let (ui76 :: 2 bits) = ((subrange_vec_dec v__956 (( 8 :: int)::ii) (( 7 :: int)::ii)  ::  2 Word.word)) in
     (let (ui52 :: 4 bits) = ((subrange_vec_dec v__956 (( 12 :: int)::ii) (( 9 :: int)::ii)  ::  4 Word.word)) in
     (let (rs2 :: regidx) = ((subrange_vec_dec v__956 (( 6 :: int)::ii) (( 2 :: int)::ii)  ::  5 Word.word)) in
     return (C_SWSP ((concat_vec ui76 ui52  ::  6 Word.word), rs2)))))
   else if (((((((( 64 :: int)::ii) = (( 64 :: int)::ii)))) \<and> ((((((((subrange_vec_dec v__956 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = ( 0b111 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__956 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b10 ::  2 Word.word)))))))))) then
     (let (ui86 :: 3 bits) = ((subrange_vec_dec v__956 (( 9 :: int)::ii) (( 7 :: int)::ii)  ::  3 Word.word)) in
     (let (ui53 :: 3 bits) = ((subrange_vec_dec v__956 (( 12 :: int)::ii) (( 10 :: int)::ii)  ::  3 Word.word)) in
     (let (rs2 :: regidx) = ((subrange_vec_dec v__956 (( 6 :: int)::ii) (( 2 :: int)::ii)  ::  5 Word.word)) in
     return (C_SDSP ((concat_vec ui86 ui53  ::  6 Word.word), rs2)))))
   else if (((((let (rs1 :: regidx) = ((subrange_vec_dec v__956 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
               (rs1 \<noteq> zreg))) \<and> ((((((((subrange_vec_dec v__956 (( 15 :: int)::ii) (( 12 :: int)::ii)  ::  4 Word.word)) = ( 0x8 ::  4 Word.word)))) \<and> (((((subrange_vec_dec v__956 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b0000010 ::  7 Word.word)))))))))) then
     (let (rs1 :: regidx) = ((subrange_vec_dec v__956 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     return (C_JR rs1))
   else if (((((let (rs1 :: regidx) = ((subrange_vec_dec v__956 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
               (rs1 \<noteq> zreg))) \<and> ((((((((subrange_vec_dec v__956 (( 15 :: int)::ii) (( 12 :: int)::ii)  ::  4 Word.word)) = ( 0x9 ::  4 Word.word)))) \<and> (((((subrange_vec_dec v__956 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b0000010 ::  7 Word.word)))))))))) then
     (let (rs1 :: regidx) = ((subrange_vec_dec v__956 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     return (C_JALR rs1))
   else if (((((let (rs2 :: regidx) = ((subrange_vec_dec v__956 (( 6 :: int)::ii) (( 2 :: int)::ii)  ::  5 Word.word)) in
               (let (rd :: regidx) = ((subrange_vec_dec v__956 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
               ((((rd \<noteq> zreg))) \<and> (((rs2 \<noteq> zreg))))))) \<and> ((((((((subrange_vec_dec v__956 (( 15 :: int)::ii) (( 12 :: int)::ii)  ::  4 Word.word)) = ( 0x8 ::  4 Word.word)))) \<and> (((((subrange_vec_dec v__956 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b10 ::  2 Word.word)))))))))) then
     (let (rs2 :: regidx) = ((subrange_vec_dec v__956 (( 6 :: int)::ii) (( 2 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regidx) = ((subrange_vec_dec v__956 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     return (C_MV (rd, rs2))))
   else if (((v__956 = ( 0x9002 ::  16 Word.word)))) then return (C_EBREAK () )
   else if (((((let (rsd :: regidx) = ((subrange_vec_dec v__956 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
               (let (rs2 :: regidx) = ((subrange_vec_dec v__956 (( 6 :: int)::ii) (( 2 :: int)::ii)  ::  5 Word.word)) in
               ((((rsd \<noteq> zreg))) \<and> (((rs2 \<noteq> zreg))))))) \<and> ((((((((subrange_vec_dec v__956 (( 15 :: int)::ii) (( 12 :: int)::ii)  ::  4 Word.word)) = ( 0x9 ::  4 Word.word)))) \<and> (((((subrange_vec_dec v__956 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b10 ::  2 Word.word)))))))))) then
     (let (rsd :: regidx) = ((subrange_vec_dec v__956 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     (let (rs2 :: regidx) = ((subrange_vec_dec v__956 (( 6 :: int)::ii) (( 2 :: int)::ii)  ::  5 Word.word)) in
     return (C_ADD (rsd, rs2))))
   else if (((((let (im5 :: 1 bits) = ((subrange_vec_dec v__956 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
               (let (im40 :: 5 bits) = ((subrange_vec_dec v__956 (( 6 :: int)::ii) (( 2 :: int)::ii)  ::  5 Word.word)) in
               (((concat_vec im5 im40  ::  6 Word.word)) \<noteq> ( 0b000000 ::  6 Word.word))))) \<and> ((((((((subrange_vec_dec v__956 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = ( 0b000 ::  3 Word.word)))) \<and> ((((((((subrange_vec_dec v__956 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) = ( 0b00000 ::  5 Word.word)))) \<and> (((((subrange_vec_dec v__956 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b01 ::  2 Word.word))))))))))))) then
     (let (im5 :: 1 bits) = ((subrange_vec_dec v__956 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
     (let (im40 :: 5 bits) = ((subrange_vec_dec v__956 (( 6 :: int)::ii) (( 2 :: int)::ii)  ::  5 Word.word)) in
     return (C_NOP_HINT ((concat_vec im5 im40  ::  6 Word.word)))))
   else if (((((let (rsd :: regidx) = ((subrange_vec_dec v__956 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
               (rsd \<noteq> zreg))) \<and> ((((((((subrange_vec_dec v__956 (( 15 :: int)::ii) (( 12 :: int)::ii)  ::  4 Word.word)) = ( 0x0 ::  4 Word.word)))) \<and> (((((subrange_vec_dec v__956 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b0000001 ::  7 Word.word)))))))))) then
     (let (rsd :: regidx) = ((subrange_vec_dec v__956 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     return (C_ADDI_HINT rsd))
   else if ((((((((subrange_vec_dec v__956 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = ( 0b010 ::  3 Word.word)))) \<and> ((((((((subrange_vec_dec v__956 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) = ( 0b00000 ::  5 Word.word)))) \<and> (((((subrange_vec_dec v__956 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b01 ::  2 Word.word)))))))))) then
     (let (imm5 :: 1 bits) = ((subrange_vec_dec v__956 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
     (let (imm40 :: 5 bits) = ((subrange_vec_dec v__956 (( 6 :: int)::ii) (( 2 :: int)::ii)  ::  5 Word.word)) in
     return (C_LI_HINT ((concat_vec imm5 imm40  ::  6 Word.word)))))
   else if (((((let (imm17 :: 1 bits) = ((subrange_vec_dec v__956 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
               (let (imm1612 :: 5 bits) = ((subrange_vec_dec v__956 (( 6 :: int)::ii) (( 2 :: int)::ii)  ::  5 Word.word)) in
               (((concat_vec imm17 imm1612  ::  6 Word.word)) \<noteq> ( 0b000000 ::  6 Word.word))))) \<and> ((((((((subrange_vec_dec v__956 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = ( 0b011 ::  3 Word.word)))) \<and> ((((((((subrange_vec_dec v__956 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) = ( 0b00000 ::  5 Word.word)))) \<and> (((((subrange_vec_dec v__956 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b01 ::  2 Word.word))))))))))))) then
     (let (imm17 :: 1 bits) = ((subrange_vec_dec v__956 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
     (let (imm1612 :: 5 bits) = ((subrange_vec_dec v__956 (( 6 :: int)::ii) (( 2 :: int)::ii)  ::  5 Word.word)) in
     return (C_LUI_HINT ((concat_vec imm17 imm1612  ::  6 Word.word)))))
   else if (((((let (rs2 :: regidx) = ((subrange_vec_dec v__956 (( 6 :: int)::ii) (( 2 :: int)::ii)  ::  5 Word.word)) in
               (rs2 \<noteq> zreg))) \<and> ((((((((subrange_vec_dec v__956 (( 15 :: int)::ii) (( 7 :: int)::ii)  ::  9 Word.word)) = ( 0b100000000 ::  9 Word.word)))) \<and> (((((subrange_vec_dec v__956 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b10 ::  2 Word.word)))))))))) then
     (let (rs2 :: regidx) = ((subrange_vec_dec v__956 (( 6 :: int)::ii) (( 2 :: int)::ii)  ::  5 Word.word)) in
     return (C_MV_HINT rs2))
   else if (((((let (rs2 :: regidx) = ((subrange_vec_dec v__956 (( 6 :: int)::ii) (( 2 :: int)::ii)  ::  5 Word.word)) in
               (rs2 \<noteq> zreg))) \<and> ((((((((subrange_vec_dec v__956 (( 15 :: int)::ii) (( 7 :: int)::ii)  ::  9 Word.word)) = ( 0b100100000 ::  9 Word.word)))) \<and> (((((subrange_vec_dec v__956 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b10 ::  2 Word.word)))))))))) then
     (let (rs2 :: regidx) = ((subrange_vec_dec v__956 (( 6 :: int)::ii) (( 2 :: int)::ii)  ::  5 Word.word)) in
     return (C_ADD_HINT rs2))
   else if (((((let (rsd :: regidx) = ((subrange_vec_dec v__956 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
               (let (nzui5 :: 1 bits) = ((subrange_vec_dec v__956 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
               (let (nzui40 :: 5 bits) = ((subrange_vec_dec v__956 (( 6 :: int)::ii) (( 2 :: int)::ii)  ::  5 Word.word)) in
               (((((((((concat_vec nzui5 nzui40  ::  6 Word.word)) = ( 0b000000 ::  6 Word.word)))) \<or> (((rsd = zreg)))))) \<and> (((((((( 64 :: int)::ii) = (( 64 :: int)::ii)))) \<or> (((nzui5 = ( 0b0 ::  1 Word.word)))))))))))) \<and> ((((((((subrange_vec_dec v__956 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = ( 0b000 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__956 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b10 ::  2 Word.word)))))))))) then
     (let (rsd :: regidx) = ((subrange_vec_dec v__956 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     (let (nzui5 :: 1 bits) = ((subrange_vec_dec v__956 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
     (let (nzui40 :: 5 bits) = ((subrange_vec_dec v__956 (( 6 :: int)::ii) (( 2 :: int)::ii)  ::  5 Word.word)) in
     return (C_SLLI_HINT ((concat_vec nzui5 nzui40  ::  6 Word.word), rsd)))))
   else if ((((((((subrange_vec_dec v__956 (( 15 :: int)::ii) (( 10 :: int)::ii)  ::  6 Word.word)) = ( 0b100000 ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__956 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b0000001 ::  7 Word.word))))))) then
     (let (rsd :: cregidx) = ((subrange_vec_dec v__956 (( 9 :: int)::ii) (( 7 :: int)::ii)  ::  3 Word.word)) in
     return (C_SRLI_HINT rsd))
   else if ((((((((subrange_vec_dec v__956 (( 15 :: int)::ii) (( 10 :: int)::ii)  ::  6 Word.word)) = ( 0b100001 ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__956 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b0000001 ::  7 Word.word))))))) then
     (let (rsd :: cregidx) = ((subrange_vec_dec v__956 (( 9 :: int)::ii) (( 7 :: int)::ii)  ::  3 Word.word)) in
     return (C_SRAI_HINT rsd))
   else
     and_boolM
       (and_boolM (return ((((( 64 :: int)::ii) = (( 32 :: int)::ii))))) (and_boolM ((haveRVC () )) ((haveFExt () ))))
       (return ((((((((subrange_vec_dec v__956 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = ( 0b011 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__956 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b10 ::  2 Word.word)))))))) \<bind> ((\<lambda> (w__4 :: bool) . 
     if w__4 then
       (let (ui76 :: 2 bits) = ((subrange_vec_dec v__956 (( 3 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) in
       (let (ui5 :: 1 bits) = ((subrange_vec_dec v__956 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
       (let (ui42 :: 3 bits) = ((subrange_vec_dec v__956 (( 6 :: int)::ii) (( 4 :: int)::ii)  ::  3 Word.word)) in
       (let (rd :: regidx) = ((subrange_vec_dec v__956 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
       return (C_FLWSP ((concat_vec ui76 ((concat_vec ui5 ui42  ::  4 Word.word))  ::  6 Word.word), rd))))))
     else
       and_boolM
         (and_boolM (return ((((( 64 :: int)::ii) = (( 32 :: int)::ii))))) (and_boolM ((haveRVC () )) ((haveFExt () ))))
         (return ((((((((subrange_vec_dec v__956 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = ( 0b111 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__956 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b10 ::  2 Word.word)))))))) \<bind> ((\<lambda> (w__9 :: bool) . 
       if w__9 then
         (let (ui76 :: 2 bits) = ((subrange_vec_dec v__956 (( 8 :: int)::ii) (( 7 :: int)::ii)  ::  2 Word.word)) in
         (let (ui52 :: 4 bits) = ((subrange_vec_dec v__956 (( 12 :: int)::ii) (( 9 :: int)::ii)  ::  4 Word.word)) in
         (let (rs2 :: regidx) = ((subrange_vec_dec v__956 (( 6 :: int)::ii) (( 2 :: int)::ii)  ::  5 Word.word)) in
         return (C_FSWSP ((concat_vec ui76 ui52  ::  6 Word.word), rs2)))))
       else
         and_boolM
           (and_boolM (return ((((( 64 :: int)::ii) = (( 32 :: int)::ii))))) (and_boolM ((haveRVC () )) ((haveFExt () ))))
           (return ((((((((subrange_vec_dec v__956 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = ( 0b011 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__956 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b00 ::  2 Word.word)))))))) \<bind> ((\<lambda> (w__14 :: bool) . 
         if w__14 then
           (let (ui6 :: 1 bits) = ((subrange_vec_dec v__956 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
           (let (ui53 :: 3 bits) = ((subrange_vec_dec v__956 (( 12 :: int)::ii) (( 10 :: int)::ii)  ::  3 Word.word)) in
           (let (ui2 :: 1 bits) = ((subrange_vec_dec v__956 (( 6 :: int)::ii) (( 6 :: int)::ii)  ::  1 Word.word)) in
           (let (rs1 :: cregidx) = ((subrange_vec_dec v__956 (( 9 :: int)::ii) (( 7 :: int)::ii)  ::  3 Word.word)) in
           (let (rd :: cregidx) = ((subrange_vec_dec v__956 (( 4 :: int)::ii) (( 2 :: int)::ii)  ::  3 Word.word)) in
           return (C_FLW ((concat_vec ui6 ((concat_vec ui53 ui2  ::  4 Word.word))  ::  5 Word.word),
                          rs1,
                          rd)))))))
         else
           and_boolM
             (and_boolM (return ((((( 64 :: int)::ii) = (( 32 :: int)::ii))))) (and_boolM ((haveRVC () )) ((haveFExt () ))))
             (return ((((((((subrange_vec_dec v__956 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = ( 0b111 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__956 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b00 ::  2 Word.word)))))))) \<bind> ((\<lambda> (w__19 :: bool) . 
           if w__19 then
             (let (ui6 :: 1 bits) = ((subrange_vec_dec v__956 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
             (let (ui53 :: 3 bits) = ((subrange_vec_dec v__956 (( 12 :: int)::ii) (( 10 :: int)::ii)  ::  3 Word.word)) in
             (let (ui2 :: 1 bits) = ((subrange_vec_dec v__956 (( 6 :: int)::ii) (( 6 :: int)::ii)  ::  1 Word.word)) in
             (let (rs2 :: cregidx) = ((subrange_vec_dec v__956 (( 4 :: int)::ii) (( 2 :: int)::ii)  ::  3 Word.word)) in
             (let (rs1 :: cregidx) = ((subrange_vec_dec v__956 (( 9 :: int)::ii) (( 7 :: int)::ii)  ::  3 Word.word)) in
             return (C_FSW ((concat_vec ui6 ((concat_vec ui53 ui2  ::  4 Word.word))  ::  5 Word.word),
                            rs1,
                            rs2)))))))
           else
             and_boolM
               (and_boolM (return (((((((( 64 :: int)::ii) = (( 32 :: int)::ii)))) \<or> ((((( 64 :: int)::ii) = (( 64 :: int)::ii))))))))
                  (and_boolM ((haveRVC () )) ((haveDExt () ))))
               (return ((((((((subrange_vec_dec v__956 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = ( 0b001 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__956 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b10 ::  2 Word.word)))))))) \<bind> ((\<lambda> (w__24 :: bool) . 
             if w__24 then
               (let (ui86 :: 3 bits) = ((subrange_vec_dec v__956 (( 4 :: int)::ii) (( 2 :: int)::ii)  ::  3 Word.word)) in
               (let (ui5 :: 1 bits) = ((subrange_vec_dec v__956 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
               (let (ui43 :: 2 bits) = ((subrange_vec_dec v__956 (( 6 :: int)::ii) (( 5 :: int)::ii)  ::  2 Word.word)) in
               (let (rd :: regidx) = ((subrange_vec_dec v__956 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
               return (C_FLDSP ((concat_vec ui86 ((concat_vec ui5 ui43  ::  3 Word.word))  ::  6 Word.word),
                                rd))))))
             else
               and_boolM
                 (and_boolM (return (((((((( 64 :: int)::ii) = (( 32 :: int)::ii)))) \<or> ((((( 64 :: int)::ii) = (( 64 :: int)::ii))))))))
                    (and_boolM ((haveRVC () )) ((haveDExt () ))))
                 (return ((((((((subrange_vec_dec v__956 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = ( 0b101 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__956 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b10 ::  2 Word.word)))))))) \<bind> ((\<lambda> (w__29 :: bool) . 
               if w__29 then
                 (let (ui86 :: 3 bits) = ((subrange_vec_dec v__956 (( 9 :: int)::ii) (( 7 :: int)::ii)  ::  3 Word.word)) in
                 (let (ui53 :: 3 bits) = ((subrange_vec_dec v__956 (( 12 :: int)::ii) (( 10 :: int)::ii)  ::  3 Word.word)) in
                 (let (rs2 :: regidx) = ((subrange_vec_dec v__956 (( 6 :: int)::ii) (( 2 :: int)::ii)  ::  5 Word.word)) in
                 return (C_FSDSP ((concat_vec ui86 ui53  ::  6 Word.word), rs2)))))
               else
                 and_boolM
                   (and_boolM (return (((((((( 64 :: int)::ii) = (( 32 :: int)::ii)))) \<or> ((((( 64 :: int)::ii) = (( 64 :: int)::ii))))))))
                      (and_boolM ((haveRVC () )) ((haveDExt () ))))
                   (return ((((((((subrange_vec_dec v__956 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = ( 0b001 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__956 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b00 ::  2 Word.word)))))))) \<bind> ((\<lambda> (w__34 :: bool) . 
                 if w__34 then
                   (let (ui76 :: 2 bits) = ((subrange_vec_dec v__956 (( 6 :: int)::ii) (( 5 :: int)::ii)  ::  2 Word.word)) in
                   (let (ui53 :: 3 bits) = ((subrange_vec_dec v__956 (( 12 :: int)::ii) (( 10 :: int)::ii)  ::  3 Word.word)) in
                   (let (rs1 :: cregidx) = ((subrange_vec_dec v__956 (( 9 :: int)::ii) (( 7 :: int)::ii)  ::  3 Word.word)) in
                   (let (rd :: cregidx) = ((subrange_vec_dec v__956 (( 4 :: int)::ii) (( 2 :: int)::ii)  ::  3 Word.word)) in
                   return (C_FLD ((concat_vec ui76 ui53  ::  5 Word.word), rs1, rd))))))
                 else
                   and_boolM
                     (and_boolM (return (((((((( 64 :: int)::ii) = (( 32 :: int)::ii)))) \<or> ((((( 64 :: int)::ii) = (( 64 :: int)::ii))))))))
                        (and_boolM ((haveRVC () )) ((haveDExt () ))))
                     (return ((((((((subrange_vec_dec v__956 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = ( 0b101 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__956 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b00 ::  2 Word.word)))))))) \<bind> ((\<lambda> (w__39 :: bool) . 
                   return (if w__39 then
                             (let (ui76 :: 2 bits) =
                               ((subrange_vec_dec v__956 (( 6 :: int)::ii) (( 5 :: int)::ii)  ::  2 Word.word)) in
                             (let (ui53 :: 3 bits) =
                               ((subrange_vec_dec v__956 (( 12 :: int)::ii) (( 10 :: int)::ii)  ::  3 Word.word)) in
                             (let (rs2 :: 3 bits) =
                               ((subrange_vec_dec v__956 (( 4 :: int)::ii) (( 2 :: int)::ii)  ::  3 Word.word)) in
                             (let (rs1 :: 3 bits) =
                               ((subrange_vec_dec v__956 (( 9 :: int)::ii) (( 7 :: int)::ii)  ::  3 Word.word)) in
                             C_FSD ((concat_vec ui76 ui53  ::  5 Word.word), rs1, rs2)))))
                           else C_ILLEGAL v__956)))))))))))))))))))\<close> 
  for  arg1  :: "(16)Word.word "


definition encdec_compressed_forwards_matches  :: \<open> ast \<Rightarrow>((register_value),(bool),(exception))monad \<close>  where 
     \<open> encdec_compressed_forwards_matches ast = (
   (let arg1 = ast in
   (case  arg1 of
     C_NOP (_) => return True
   | C_ADDI4SPN ((rd, v__1158)) =>
      return (if ((let (nz96 :: 4 bits) = ((subrange_vec_dec v__1158 (( 7 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word)) in
                (let (nz96 :: 4 bits) = ((subrange_vec_dec v__1158 (( 7 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word)) in
                (let (nz54 :: 2 bits) = ((subrange_vec_dec v__1158 (( 3 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) in
                (let (nz3 :: 1 bits) = ((subrange_vec_dec v__1158 (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word)) in
                (let (nz2 :: 1 bits) = ((subrange_vec_dec v__1158 (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) in
                (((concat_vec nz96
                      ((concat_vec nz54 ((concat_vec nz3 nz2  ::  2 Word.word))  ::  4 Word.word))
                     ::  8 Word.word)) \<noteq> ( 0x00 ::  8 Word.word)))))))) then
                True
              else False)
   | C_LW ((v__1159, rs1, rd)) => return True
   | C_LD ((v__1160, rs1, rd)) => return (if ((((( 64 :: int)::ii) = (( 64 :: int)::ii)))) then True else False)
   | C_SW ((v__1161, rs1, rs2)) => return True
   | C_SD ((v__1162, rs1, rs2)) => return (if ((((( 64 :: int)::ii) = (( 64 :: int)::ii)))) then True else False)
   | C_ADDI ((v__1163, rsd)) =>
      return (if ((let (nzi5 :: 1 bits) = ((subrange_vec_dec v__1163 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
                (let (nzi5 :: 1 bits) = ((subrange_vec_dec v__1163 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
                (let (nzi40 :: 5 bits) = ((subrange_vec_dec v__1163 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
                ((((((concat_vec nzi5 nzi40  ::  6 Word.word)) \<noteq> ( 0b000000 ::  6 Word.word)))) \<and> (((rsd \<noteq> zreg)))))))) then
                True
              else False)
   | C_JAL (v__1164) => return (if ((((( 64 :: int)::ii) = (( 32 :: int)::ii)))) then True else False)
   | C_ADDIW ((v__1165, rsd)) =>
      return (if ((((((rsd \<noteq> zreg))) \<and> ((((( 64 :: int)::ii) = (( 64 :: int)::ii))))))) then True else False)
   | C_LI ((v__1166, rd)) => return (if (((rd \<noteq> zreg))) then True else False)
   | C_ADDI16SP (v__1167) =>
      return (if ((let (nzi9 :: 1 bits) = ((subrange_vec_dec v__1167 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
                (let (nzi9 :: 1 bits) = ((subrange_vec_dec v__1167 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
                (let (nzi87 :: 2 bits) = ((subrange_vec_dec v__1167 (( 4 :: int)::ii) (( 3 :: int)::ii)  ::  2 Word.word)) in
                (let (nzi6 :: 1 bits) = ((subrange_vec_dec v__1167 (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word)) in
                (let (nzi5 :: 1 bits) = ((subrange_vec_dec v__1167 (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word)) in
                (let (nzi4 :: 1 bits) = ((subrange_vec_dec v__1167 (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) in
                (((concat_vec nzi9
                      ((concat_vec nzi87
                          ((concat_vec nzi6 ((concat_vec nzi5 nzi4  ::  2 Word.word))  ::  3 Word.word))
                         ::  5 Word.word))
                     ::  6 Word.word)) \<noteq> ( 0b000000 ::  6 Word.word))))))))) then
                True
              else False)
   | C_LUI ((v__1168, rd)) =>
      return (if ((let (imm17 :: 1 bits) = ((subrange_vec_dec v__1168 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
                (let (imm17 :: 1 bits) = ((subrange_vec_dec v__1168 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
                (let (imm1612 :: 5 bits) = ((subrange_vec_dec v__1168 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
                ((((rd \<noteq> zreg))) \<and> ((((((rd \<noteq> sp))) \<and> (((((concat_vec imm17 imm1612  ::  6 Word.word)) \<noteq> ( 0b000000 ::  6 Word.word))))))))))))
              then
                True
              else False)
   | C_SRLI ((v__1169, rsd)) =>
      return (if ((let (nzui5 :: 1 bits) = ((subrange_vec_dec v__1169 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
                (let (nzui5 :: 1 bits) = ((subrange_vec_dec v__1169 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
                (let (nzui40 :: 5 bits) = ((subrange_vec_dec v__1169 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
                (((concat_vec nzui5 nzui40  ::  6 Word.word)) \<noteq> ( 0b000000 ::  6 Word.word)))))) then
                True
              else False)
   | C_SRAI ((v__1170, rsd)) =>
      return (if ((let (nzui5 :: 1 bits) = ((subrange_vec_dec v__1170 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
                (let (nzui5 :: 1 bits) = ((subrange_vec_dec v__1170 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
                (let (nzui40 :: 5 bits) = ((subrange_vec_dec v__1170 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
                (((concat_vec nzui5 nzui40  ::  6 Word.word)) \<noteq> ( 0b000000 ::  6 Word.word)))))) then
                True
              else False)
   | C_ANDI ((v__1171, rsd)) => return True
   | C_SUB ((rsd, rs2)) => return True
   | C_XOR ((rsd, rs2)) => return True
   | C_OR ((rsd, rs2)) => return True
   | C_AND ((rsd, rs2)) => return True
   | C_SUBW ((rsd, rs2)) => return (if ((((( 64 :: int)::ii) = (( 64 :: int)::ii)))) then True else False)
   | C_ADDW ((rsd, rs2)) => return (if ((((( 64 :: int)::ii) = (( 64 :: int)::ii)))) then True else False)
   | C_J (v__1172) => return True
   | C_BEQZ ((v__1173, rs)) => return True
   | C_BNEZ ((v__1174, rs)) => return True
   | C_SLLI ((v__1175, rsd)) =>
      return (if ((let (nzui5 :: 1 bits) = ((subrange_vec_dec v__1175 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
                (let (nzui5 :: 1 bits) = ((subrange_vec_dec v__1175 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
                (let (nzui40 :: 5 bits) = ((subrange_vec_dec v__1175 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
                ((((((concat_vec nzui5 nzui40  ::  6 Word.word)) \<noteq> ( 0b000000 ::  6 Word.word)))) \<and> ((((((rsd \<noteq> zreg))) \<and> (((((((( 64 :: int)::ii) = (( 64 :: int)::ii)))) \<or> (((nzui5 = ( 0b0 ::  1 Word.word))))))))))))))) then
                True
              else False)
   | C_LWSP ((v__1176, rd)) => return (if (((rd \<noteq> zreg))) then True else False)
   | C_LDSP ((v__1177, rd)) =>
      return (if ((((((rd \<noteq> zreg))) \<and> ((((( 64 :: int)::ii) = (( 64 :: int)::ii))))))) then True else False)
   | C_SWSP ((v__1178, rs2)) => return True
   | C_SDSP ((v__1179, rs2)) => return (if ((((( 64 :: int)::ii) = (( 64 :: int)::ii)))) then True else False)
   | C_JR (rs1) => return (if (((rs1 \<noteq> zreg))) then True else False)
   | C_JALR (rs1) => return (if (((rs1 \<noteq> zreg))) then True else False)
   | C_MV ((rd, rs2)) =>
      return (if ((((((rd \<noteq> zreg))) \<and> (((rs2 \<noteq> zreg)))))) then True else False)
   | C_EBREAK (_) => return True
   | C_ADD ((rsd, rs2)) =>
      return (if ((((((rsd \<noteq> zreg))) \<and> (((rs2 \<noteq> zreg)))))) then True else False)
   | C_NOP_HINT (v__1180) =>
      return (if ((let (im5 :: 1 bits) = ((subrange_vec_dec v__1180 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
                (let (im5 :: 1 bits) = ((subrange_vec_dec v__1180 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
                (let (im40 :: 5 bits) = ((subrange_vec_dec v__1180 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
                (((concat_vec im5 im40  ::  6 Word.word)) \<noteq> ( 0b000000 ::  6 Word.word)))))) then
                True
              else False)
   | C_ADDI_HINT (rsd) => return (if (((rsd \<noteq> zreg))) then True else False)
   | C_LI_HINT (v__1181) => return True
   | C_LUI_HINT (v__1182) =>
      return (if ((let (imm17 :: 1 bits) = ((subrange_vec_dec v__1182 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
                (let (imm17 :: 1 bits) = ((subrange_vec_dec v__1182 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
                (let (imm1612 :: 5 bits) = ((subrange_vec_dec v__1182 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
                (((concat_vec imm17 imm1612  ::  6 Word.word)) \<noteq> ( 0b000000 ::  6 Word.word)))))) then
                True
              else False)
   | C_MV_HINT (rs2) => return (if (((rs2 \<noteq> zreg))) then True else False)
   | C_ADD_HINT (rs2) => return (if (((rs2 \<noteq> zreg))) then True else False)
   | C_SLLI_HINT ((v__1183, rsd)) =>
      return (if ((let (nzui5 :: 1 bits) = ((subrange_vec_dec v__1183 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
                (let (nzui5 :: 1 bits) = ((subrange_vec_dec v__1183 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
                (let (nzui40 :: 5 bits) = ((subrange_vec_dec v__1183 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
                (((((((((concat_vec nzui5 nzui40  ::  6 Word.word)) = ( 0b000000 ::  6 Word.word)))) \<or> (((rsd = zreg)))))) \<and> (((((((( 64 :: int)::ii) = (( 64 :: int)::ii)))) \<or> (((nzui5 = ( 0b0 ::  1 Word.word)))))))))))) then
                True
              else False)
   | C_SRLI_HINT (rsd) => return True
   | C_SRAI_HINT (rsd) => return True
   | C_FLWSP ((v__1184, rd)) =>
      and_boolM (return ((((( 64 :: int)::ii) = (( 32 :: int)::ii))))) (and_boolM ((haveRVC () )) ((haveFExt () ))) \<bind> ((\<lambda> (w__3 ::
        bool) . 
      return (if w__3 then True
              else False)))
   | C_FSWSP ((v__1185, rs2)) =>
      and_boolM (return ((((( 64 :: int)::ii) = (( 32 :: int)::ii))))) (and_boolM ((haveRVC () )) ((haveFExt () ))) \<bind> ((\<lambda> (w__7 ::
        bool) . 
      return (if w__7 then True
              else False)))
   | C_FLW ((v__1186, rs1, rd)) =>
      and_boolM (return ((((( 64 :: int)::ii) = (( 32 :: int)::ii))))) (and_boolM ((haveRVC () )) ((haveFExt () ))) \<bind> ((\<lambda> (w__11 ::
        bool) . 
      return (if w__11 then True
              else False)))
   | C_FSW ((v__1187, rs1, rs2)) =>
      and_boolM (return ((((( 64 :: int)::ii) = (( 32 :: int)::ii))))) (and_boolM ((haveRVC () )) ((haveFExt () ))) \<bind> ((\<lambda> (w__15 ::
        bool) . 
      return (if w__15 then True
              else False)))
   | C_FLDSP ((v__1188, rd)) =>
      and_boolM (return (((((((( 64 :: int)::ii) = (( 32 :: int)::ii)))) \<or> ((((( 64 :: int)::ii) = (( 64 :: int)::ii))))))))
        (and_boolM ((haveRVC () )) ((haveDExt () ))) \<bind> ((\<lambda> (w__19 :: bool) . 
      return (if w__19 then True
              else False)))
   | C_FSDSP ((v__1189, rs2)) =>
      and_boolM (return (((((((( 64 :: int)::ii) = (( 32 :: int)::ii)))) \<or> ((((( 64 :: int)::ii) = (( 64 :: int)::ii))))))))
        (and_boolM ((haveRVC () )) ((haveDExt () ))) \<bind> ((\<lambda> (w__23 :: bool) . 
      return (if w__23 then True
              else False)))
   | C_FLD ((v__1190, rs1, rd)) =>
      and_boolM (return (((((((( 64 :: int)::ii) = (( 32 :: int)::ii)))) \<or> ((((( 64 :: int)::ii) = (( 64 :: int)::ii))))))))
        (and_boolM ((haveRVC () )) ((haveDExt () ))) \<bind> ((\<lambda> (w__27 :: bool) . 
      return (if w__27 then True
              else False)))
   | C_FSD ((v__1191, rs1, rs2)) =>
      and_boolM (return (((((((( 64 :: int)::ii) = (( 32 :: int)::ii)))) \<or> ((((( 64 :: int)::ii) = (( 64 :: int)::ii))))))))
        (and_boolM ((haveRVC () )) ((haveDExt () ))) \<bind> ((\<lambda> (w__31 :: bool) . 
      return (if w__31 then True
              else False)))
   | C_ILLEGAL (s) => return True
   | _ => return False
   )))\<close> 
  for  ast  :: " ast "


definition encdec_compressed_backwards_matches  :: \<open>(16)Word.word \<Rightarrow>((register_value),(bool),(exception))monad \<close>  where 
     \<open> encdec_compressed_backwards_matches arg1 = (
   (let v__1192 = arg1 in
   if (((v__1192 = ( 0x0001 ::  16 Word.word)))) then return True
   else if (((((let (nz96 :: 4 bits) = ((subrange_vec_dec v__1192 (( 10 :: int)::ii) (( 7 :: int)::ii)  ::  4 Word.word)) in
               (let (nz54 :: 2 bits) = ((subrange_vec_dec v__1192 (( 12 :: int)::ii) (( 11 :: int)::ii)  ::  2 Word.word)) in
               (let (nz3 :: 1 bits) = ((subrange_vec_dec v__1192 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
               (let (nz2 :: 1 bits) = ((subrange_vec_dec v__1192 (( 6 :: int)::ii) (( 6 :: int)::ii)  ::  1 Word.word)) in
               (((concat_vec nz96
                     ((concat_vec nz54 ((concat_vec nz3 nz2  ::  2 Word.word))  ::  4 Word.word))
                    ::  8 Word.word)) \<noteq> ( 0x00 ::  8 Word.word))))))) \<and> ((((((((subrange_vec_dec v__1192 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = ( 0b000 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__1192 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b00 ::  2 Word.word)))))))))) then
     return True
   else if ((((((((subrange_vec_dec v__1192 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = ( 0b010 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__1192 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b00 ::  2 Word.word)))))))
   then
     return True
   else if (((((((( 64 :: int)::ii) = (( 64 :: int)::ii)))) \<and> ((((((((subrange_vec_dec v__1192 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = ( 0b011 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__1192 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b00 ::  2 Word.word)))))))))) then
     return True
   else if ((((((((subrange_vec_dec v__1192 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = ( 0b110 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__1192 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b00 ::  2 Word.word)))))))
   then
     return True
   else if (((((((( 64 :: int)::ii) = (( 64 :: int)::ii)))) \<and> ((((((((subrange_vec_dec v__1192 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = ( 0b111 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__1192 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b00 ::  2 Word.word)))))))))) then
     return True
   else if (((((let (rsd :: regidx) = ((subrange_vec_dec v__1192 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
               (let (nzi5 :: 1 bits) = ((subrange_vec_dec v__1192 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
               (let (nzi40 :: 5 bits) = ((subrange_vec_dec v__1192 (( 6 :: int)::ii) (( 2 :: int)::ii)  ::  5 Word.word)) in
               ((((((concat_vec nzi5 nzi40  ::  6 Word.word)) \<noteq> ( 0b000000 ::  6 Word.word)))) \<and> (((rsd \<noteq> zreg)))))))) \<and> ((((((((subrange_vec_dec v__1192 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = ( 0b000 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__1192 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b01 ::  2 Word.word)))))))))) then
     return True
   else if (((((((( 64 :: int)::ii) = (( 32 :: int)::ii)))) \<and> ((((((((subrange_vec_dec v__1192 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = ( 0b001 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__1192 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b01 ::  2 Word.word)))))))))) then
     return True
   else if (((((let (rsd :: regidx) = ((subrange_vec_dec v__1192 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
               ((((rsd \<noteq> zreg))) \<and> ((((( 64 :: int)::ii) = (( 64 :: int)::ii))))))) \<and> ((((((((subrange_vec_dec v__1192 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = ( 0b001 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__1192 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b01 ::  2 Word.word)))))))))) then
     return True
   else if (((((let (rd :: regidx) = ((subrange_vec_dec v__1192 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
               (rd \<noteq> zreg))) \<and> ((((((((subrange_vec_dec v__1192 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = ( 0b010 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__1192 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b01 ::  2 Word.word)))))))))) then
     return True
   else if (((((let (nzi9 :: 1 bits) = ((subrange_vec_dec v__1192 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
               (let (nzi87 :: 2 bits) = ((subrange_vec_dec v__1192 (( 4 :: int)::ii) (( 3 :: int)::ii)  ::  2 Word.word)) in
               (let (nzi6 :: 1 bits) = ((subrange_vec_dec v__1192 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
               (let (nzi5 :: 1 bits) = ((subrange_vec_dec v__1192 (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word)) in
               (let (nzi4 :: 1 bits) = ((subrange_vec_dec v__1192 (( 6 :: int)::ii) (( 6 :: int)::ii)  ::  1 Word.word)) in
               (((concat_vec nzi9
                     ((concat_vec nzi87
                         ((concat_vec nzi6 ((concat_vec nzi5 nzi4  ::  2 Word.word))  ::  3 Word.word))
                        ::  5 Word.word))
                    ::  6 Word.word)) \<noteq> ( 0b000000 ::  6 Word.word)))))))) \<and> ((((((((subrange_vec_dec v__1192 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = ( 0b011 ::  3 Word.word)))) \<and> ((((((((subrange_vec_dec v__1192 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) = ( 0b00010 ::  5 Word.word)))) \<and> (((((subrange_vec_dec v__1192 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b01 ::  2 Word.word))))))))))))) then
     return True
   else if (((((let (rd :: regidx) = ((subrange_vec_dec v__1192 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
               (let (imm17 :: 1 bits) = ((subrange_vec_dec v__1192 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
               (let (imm1612 :: 5 bits) = ((subrange_vec_dec v__1192 (( 6 :: int)::ii) (( 2 :: int)::ii)  ::  5 Word.word)) in
               ((((rd \<noteq> zreg))) \<and> ((((((rd \<noteq> sp))) \<and> (((((concat_vec imm17 imm1612  ::  6 Word.word)) \<noteq> ( 0b000000 ::  6 Word.word)))))))))))) \<and> ((((((((subrange_vec_dec v__1192 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = ( 0b011 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__1192 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b01 ::  2 Word.word)))))))))) then
     return True
   else if (((((let (nzui5 :: 1 bits) = ((subrange_vec_dec v__1192 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
               (let (nzui40 :: 5 bits) = ((subrange_vec_dec v__1192 (( 6 :: int)::ii) (( 2 :: int)::ii)  ::  5 Word.word)) in
               (((concat_vec nzui5 nzui40  ::  6 Word.word)) \<noteq> ( 0b000000 ::  6 Word.word))))) \<and> ((((((((subrange_vec_dec v__1192 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = ( 0b100 ::  3 Word.word)))) \<and> ((((((((subrange_vec_dec v__1192 (( 11 :: int)::ii) (( 10 :: int)::ii)  ::  2 Word.word)) = ( 0b00 ::  2 Word.word)))) \<and> (((((subrange_vec_dec v__1192 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b01 ::  2 Word.word))))))))))))) then
     return True
   else if (((((let (nzui5 :: 1 bits) = ((subrange_vec_dec v__1192 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
               (let (nzui40 :: 5 bits) = ((subrange_vec_dec v__1192 (( 6 :: int)::ii) (( 2 :: int)::ii)  ::  5 Word.word)) in
               (((concat_vec nzui5 nzui40  ::  6 Word.word)) \<noteq> ( 0b000000 ::  6 Word.word))))) \<and> ((((((((subrange_vec_dec v__1192 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = ( 0b100 ::  3 Word.word)))) \<and> ((((((((subrange_vec_dec v__1192 (( 11 :: int)::ii) (( 10 :: int)::ii)  ::  2 Word.word)) = ( 0b01 ::  2 Word.word)))) \<and> (((((subrange_vec_dec v__1192 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b01 ::  2 Word.word))))))))))))) then
     return True
   else if ((((((((subrange_vec_dec v__1192 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = ( 0b100 ::  3 Word.word)))) \<and> ((((((((subrange_vec_dec v__1192 (( 11 :: int)::ii) (( 10 :: int)::ii)  ::  2 Word.word)) = ( 0b10 ::  2 Word.word)))) \<and> (((((subrange_vec_dec v__1192 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b01 ::  2 Word.word)))))))))) then
     return True
   else if ((((((((subrange_vec_dec v__1192 (( 15 :: int)::ii) (( 10 :: int)::ii)  ::  6 Word.word)) = ( 0b100011 ::  6 Word.word)))) \<and> ((((((((subrange_vec_dec v__1192 (( 6 :: int)::ii) (( 5 :: int)::ii)  ::  2 Word.word)) = ( 0b00 ::  2 Word.word)))) \<and> (((((subrange_vec_dec v__1192 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b01 ::  2 Word.word)))))))))) then
     return True
   else if ((((((((subrange_vec_dec v__1192 (( 15 :: int)::ii) (( 10 :: int)::ii)  ::  6 Word.word)) = ( 0b100011 ::  6 Word.word)))) \<and> ((((((((subrange_vec_dec v__1192 (( 6 :: int)::ii) (( 5 :: int)::ii)  ::  2 Word.word)) = ( 0b01 ::  2 Word.word)))) \<and> (((((subrange_vec_dec v__1192 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b01 ::  2 Word.word)))))))))) then
     return True
   else if ((((((((subrange_vec_dec v__1192 (( 15 :: int)::ii) (( 10 :: int)::ii)  ::  6 Word.word)) = ( 0b100011 ::  6 Word.word)))) \<and> ((((((((subrange_vec_dec v__1192 (( 6 :: int)::ii) (( 5 :: int)::ii)  ::  2 Word.word)) = ( 0b10 ::  2 Word.word)))) \<and> (((((subrange_vec_dec v__1192 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b01 ::  2 Word.word)))))))))) then
     return True
   else if ((((((((subrange_vec_dec v__1192 (( 15 :: int)::ii) (( 10 :: int)::ii)  ::  6 Word.word)) = ( 0b100011 ::  6 Word.word)))) \<and> ((((((((subrange_vec_dec v__1192 (( 6 :: int)::ii) (( 5 :: int)::ii)  ::  2 Word.word)) = ( 0b11 ::  2 Word.word)))) \<and> (((((subrange_vec_dec v__1192 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b01 ::  2 Word.word)))))))))) then
     return True
   else if (((((((( 64 :: int)::ii) = (( 64 :: int)::ii)))) \<and> ((((((((subrange_vec_dec v__1192 (( 15 :: int)::ii) (( 10 :: int)::ii)  ::  6 Word.word)) = ( 0b100111 ::  6 Word.word)))) \<and> ((((((((subrange_vec_dec v__1192 (( 6 :: int)::ii) (( 5 :: int)::ii)  ::  2 Word.word)) = ( 0b00 ::  2 Word.word)))) \<and> (((((subrange_vec_dec v__1192 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b01 ::  2 Word.word))))))))))))) then
     return True
   else if (((((((( 64 :: int)::ii) = (( 64 :: int)::ii)))) \<and> ((((((((subrange_vec_dec v__1192 (( 15 :: int)::ii) (( 10 :: int)::ii)  ::  6 Word.word)) = ( 0b100111 ::  6 Word.word)))) \<and> ((((((((subrange_vec_dec v__1192 (( 6 :: int)::ii) (( 5 :: int)::ii)  ::  2 Word.word)) = ( 0b01 ::  2 Word.word)))) \<and> (((((subrange_vec_dec v__1192 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b01 ::  2 Word.word))))))))))))) then
     return True
   else if ((((((((subrange_vec_dec v__1192 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = ( 0b101 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__1192 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b01 ::  2 Word.word)))))))
   then
     return True
   else if ((((((((subrange_vec_dec v__1192 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = ( 0b110 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__1192 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b01 ::  2 Word.word)))))))
   then
     return True
   else if ((((((((subrange_vec_dec v__1192 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = ( 0b111 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__1192 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b01 ::  2 Word.word)))))))
   then
     return True
   else if (((((let (rsd :: regidx) = ((subrange_vec_dec v__1192 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
               (let (nzui5 :: 1 bits) = ((subrange_vec_dec v__1192 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
               (let (nzui40 :: 5 bits) = ((subrange_vec_dec v__1192 (( 6 :: int)::ii) (( 2 :: int)::ii)  ::  5 Word.word)) in
               ((((((concat_vec nzui5 nzui40  ::  6 Word.word)) \<noteq> ( 0b000000 ::  6 Word.word)))) \<and> ((((((rsd \<noteq> zreg))) \<and> (((((((( 64 :: int)::ii) = (( 64 :: int)::ii)))) \<or> (((nzui5 = ( 0b0 ::  1 Word.word))))))))))))))) \<and> ((((((((subrange_vec_dec v__1192 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = ( 0b000 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__1192 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b10 ::  2 Word.word)))))))))) then
     return True
   else if (((((let (rd :: regidx) = ((subrange_vec_dec v__1192 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
               (rd \<noteq> zreg))) \<and> ((((((((subrange_vec_dec v__1192 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = ( 0b010 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__1192 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b10 ::  2 Word.word)))))))))) then
     return True
   else if (((((let (rd :: regidx) = ((subrange_vec_dec v__1192 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
               ((((rd \<noteq> zreg))) \<and> ((((( 64 :: int)::ii) = (( 64 :: int)::ii))))))) \<and> ((((((((subrange_vec_dec v__1192 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = ( 0b011 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__1192 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b10 ::  2 Word.word)))))))))) then
     return True
   else if ((((((((subrange_vec_dec v__1192 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = ( 0b110 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__1192 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b10 ::  2 Word.word)))))))
   then
     return True
   else if (((((((( 64 :: int)::ii) = (( 64 :: int)::ii)))) \<and> ((((((((subrange_vec_dec v__1192 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = ( 0b111 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__1192 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b10 ::  2 Word.word)))))))))) then
     return True
   else if (((((let (rs1 :: regidx) = ((subrange_vec_dec v__1192 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
               (rs1 \<noteq> zreg))) \<and> ((((((((subrange_vec_dec v__1192 (( 15 :: int)::ii) (( 12 :: int)::ii)  ::  4 Word.word)) = ( 0x8 ::  4 Word.word)))) \<and> (((((subrange_vec_dec v__1192 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b0000010 ::  7 Word.word)))))))))) then
     return True
   else if (((((let (rs1 :: regidx) = ((subrange_vec_dec v__1192 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
               (rs1 \<noteq> zreg))) \<and> ((((((((subrange_vec_dec v__1192 (( 15 :: int)::ii) (( 12 :: int)::ii)  ::  4 Word.word)) = ( 0x9 ::  4 Word.word)))) \<and> (((((subrange_vec_dec v__1192 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b0000010 ::  7 Word.word)))))))))) then
     return True
   else if (((((let (rs2 :: regidx) = ((subrange_vec_dec v__1192 (( 6 :: int)::ii) (( 2 :: int)::ii)  ::  5 Word.word)) in
               (let (rd :: regidx) = ((subrange_vec_dec v__1192 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
               ((((rd \<noteq> zreg))) \<and> (((rs2 \<noteq> zreg))))))) \<and> ((((((((subrange_vec_dec v__1192 (( 15 :: int)::ii) (( 12 :: int)::ii)  ::  4 Word.word)) = ( 0x8 ::  4 Word.word)))) \<and> (((((subrange_vec_dec v__1192 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b10 ::  2 Word.word)))))))))) then
     return True
   else if (((v__1192 = ( 0x9002 ::  16 Word.word)))) then return True
   else if (((((let (rsd :: regidx) = ((subrange_vec_dec v__1192 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
               (let (rs2 :: regidx) = ((subrange_vec_dec v__1192 (( 6 :: int)::ii) (( 2 :: int)::ii)  ::  5 Word.word)) in
               ((((rsd \<noteq> zreg))) \<and> (((rs2 \<noteq> zreg))))))) \<and> ((((((((subrange_vec_dec v__1192 (( 15 :: int)::ii) (( 12 :: int)::ii)  ::  4 Word.word)) = ( 0x9 ::  4 Word.word)))) \<and> (((((subrange_vec_dec v__1192 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b10 ::  2 Word.word)))))))))) then
     return True
   else if (((((let (im5 :: 1 bits) = ((subrange_vec_dec v__1192 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
               (let (im40 :: 5 bits) = ((subrange_vec_dec v__1192 (( 6 :: int)::ii) (( 2 :: int)::ii)  ::  5 Word.word)) in
               (((concat_vec im5 im40  ::  6 Word.word)) \<noteq> ( 0b000000 ::  6 Word.word))))) \<and> ((((((((subrange_vec_dec v__1192 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = ( 0b000 ::  3 Word.word)))) \<and> ((((((((subrange_vec_dec v__1192 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) = ( 0b00000 ::  5 Word.word)))) \<and> (((((subrange_vec_dec v__1192 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b01 ::  2 Word.word))))))))))))) then
     return True
   else if (((((let (rsd :: regidx) = ((subrange_vec_dec v__1192 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
               (rsd \<noteq> zreg))) \<and> ((((((((subrange_vec_dec v__1192 (( 15 :: int)::ii) (( 12 :: int)::ii)  ::  4 Word.word)) = ( 0x0 ::  4 Word.word)))) \<and> (((((subrange_vec_dec v__1192 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b0000001 ::  7 Word.word)))))))))) then
     return True
   else if ((((((((subrange_vec_dec v__1192 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = ( 0b010 ::  3 Word.word)))) \<and> ((((((((subrange_vec_dec v__1192 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) = ( 0b00000 ::  5 Word.word)))) \<and> (((((subrange_vec_dec v__1192 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b01 ::  2 Word.word)))))))))) then
     return True
   else if (((((let (imm17 :: 1 bits) = ((subrange_vec_dec v__1192 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
               (let (imm1612 :: 5 bits) = ((subrange_vec_dec v__1192 (( 6 :: int)::ii) (( 2 :: int)::ii)  ::  5 Word.word)) in
               (((concat_vec imm17 imm1612  ::  6 Word.word)) \<noteq> ( 0b000000 ::  6 Word.word))))) \<and> ((((((((subrange_vec_dec v__1192 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = ( 0b011 ::  3 Word.word)))) \<and> ((((((((subrange_vec_dec v__1192 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) = ( 0b00000 ::  5 Word.word)))) \<and> (((((subrange_vec_dec v__1192 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b01 ::  2 Word.word))))))))))))) then
     return True
   else if (((((let (rs2 :: regidx) = ((subrange_vec_dec v__1192 (( 6 :: int)::ii) (( 2 :: int)::ii)  ::  5 Word.word)) in
               (rs2 \<noteq> zreg))) \<and> ((((((((subrange_vec_dec v__1192 (( 15 :: int)::ii) (( 7 :: int)::ii)  ::  9 Word.word)) = ( 0b100000000 ::  9 Word.word)))) \<and> (((((subrange_vec_dec v__1192 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b10 ::  2 Word.word)))))))))) then
     return True
   else if (((((let (rs2 :: regidx) = ((subrange_vec_dec v__1192 (( 6 :: int)::ii) (( 2 :: int)::ii)  ::  5 Word.word)) in
               (rs2 \<noteq> zreg))) \<and> ((((((((subrange_vec_dec v__1192 (( 15 :: int)::ii) (( 7 :: int)::ii)  ::  9 Word.word)) = ( 0b100100000 ::  9 Word.word)))) \<and> (((((subrange_vec_dec v__1192 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b10 ::  2 Word.word)))))))))) then
     return True
   else if (((((let (rsd :: regidx) = ((subrange_vec_dec v__1192 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
               (let (nzui5 :: 1 bits) = ((subrange_vec_dec v__1192 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
               (let (nzui40 :: 5 bits) = ((subrange_vec_dec v__1192 (( 6 :: int)::ii) (( 2 :: int)::ii)  ::  5 Word.word)) in
               (((((((((concat_vec nzui5 nzui40  ::  6 Word.word)) = ( 0b000000 ::  6 Word.word)))) \<or> (((rsd = zreg)))))) \<and> (((((((( 64 :: int)::ii) = (( 64 :: int)::ii)))) \<or> (((nzui5 = ( 0b0 ::  1 Word.word)))))))))))) \<and> ((((((((subrange_vec_dec v__1192 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = ( 0b000 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__1192 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b10 ::  2 Word.word)))))))))) then
     return True
   else if ((((((((subrange_vec_dec v__1192 (( 15 :: int)::ii) (( 10 :: int)::ii)  ::  6 Word.word)) = ( 0b100000 ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__1192 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b0000001 ::  7 Word.word))))))) then
     return True
   else if ((((((((subrange_vec_dec v__1192 (( 15 :: int)::ii) (( 10 :: int)::ii)  ::  6 Word.word)) = ( 0b100001 ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__1192 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = ( 0b0000001 ::  7 Word.word))))))) then
     return True
   else
     and_boolM
       (and_boolM (return ((((( 64 :: int)::ii) = (( 32 :: int)::ii))))) (and_boolM ((haveRVC () )) ((haveFExt () ))))
       (return ((((((((subrange_vec_dec v__1192 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = ( 0b011 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__1192 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b10 ::  2 Word.word)))))))) \<bind> ((\<lambda> (w__4 :: bool) . 
     if w__4 then return True
     else
       and_boolM
         (and_boolM (return ((((( 64 :: int)::ii) = (( 32 :: int)::ii))))) (and_boolM ((haveRVC () )) ((haveFExt () ))))
         (return ((((((((subrange_vec_dec v__1192 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = ( 0b111 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__1192 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b10 ::  2 Word.word)))))))) \<bind> ((\<lambda> (w__9 :: bool) . 
       if w__9 then return True
       else
         and_boolM
           (and_boolM (return ((((( 64 :: int)::ii) = (( 32 :: int)::ii))))) (and_boolM ((haveRVC () )) ((haveFExt () ))))
           (return ((((((((subrange_vec_dec v__1192 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = ( 0b011 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__1192 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b00 ::  2 Word.word)))))))) \<bind> ((\<lambda> (w__14 :: bool) . 
         if w__14 then return True
         else
           and_boolM
             (and_boolM (return ((((( 64 :: int)::ii) = (( 32 :: int)::ii))))) (and_boolM ((haveRVC () )) ((haveFExt () ))))
             (return ((((((((subrange_vec_dec v__1192 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = ( 0b111 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__1192 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b00 ::  2 Word.word)))))))) \<bind> ((\<lambda> (w__19 :: bool) . 
           if w__19 then return True
           else
             and_boolM
               (and_boolM (return (((((((( 64 :: int)::ii) = (( 32 :: int)::ii)))) \<or> ((((( 64 :: int)::ii) = (( 64 :: int)::ii))))))))
                  (and_boolM ((haveRVC () )) ((haveDExt () ))))
               (return ((((((((subrange_vec_dec v__1192 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = ( 0b001 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__1192 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b10 ::  2 Word.word)))))))) \<bind> ((\<lambda> (w__24 :: bool) . 
             if w__24 then return True
             else
               and_boolM
                 (and_boolM (return (((((((( 64 :: int)::ii) = (( 32 :: int)::ii)))) \<or> ((((( 64 :: int)::ii) = (( 64 :: int)::ii))))))))
                    (and_boolM ((haveRVC () )) ((haveDExt () ))))
                 (return ((((((((subrange_vec_dec v__1192 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = ( 0b101 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__1192 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b10 ::  2 Word.word)))))))) \<bind> ((\<lambda> (w__29 :: bool) . 
               if w__29 then return True
               else
                 and_boolM
                   (and_boolM (return (((((((( 64 :: int)::ii) = (( 32 :: int)::ii)))) \<or> ((((( 64 :: int)::ii) = (( 64 :: int)::ii))))))))
                      (and_boolM ((haveRVC () )) ((haveDExt () ))))
                   (return ((((((((subrange_vec_dec v__1192 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = ( 0b001 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__1192 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b00 ::  2 Word.word)))))))) \<bind> ((\<lambda> (w__34 :: bool) . 
                 if w__34 then return True
                 else
                   and_boolM
                     (and_boolM (return (((((((( 64 :: int)::ii) = (( 32 :: int)::ii)))) \<or> ((((( 64 :: int)::ii) = (( 64 :: int)::ii))))))))
                        (and_boolM ((haveRVC () )) ((haveDExt () ))))
                     (return ((((((((subrange_vec_dec v__1192 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = ( 0b101 ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__1192 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b00 ::  2 Word.word)))))))) \<bind> ((\<lambda> (w__39 :: bool) . 
                   return (if w__39 then True
                           else True)))))))))))))))))))\<close> 
  for  arg1  :: "(16)Word.word "


\<comment> \<open>\<open>val execute_WFI : unit -> M Retired\<close>\<close>

definition execute_WFI  :: \<open> unit \<Rightarrow>((register_value),(Retired),(exception))monad \<close>  where 
     \<open> execute_WFI _ = (
   read_reg cur_privilege_ref \<bind> ((\<lambda> (w__0 :: Privilege) . 
   (case  w__0 of
     Machine => platform_wfi ()  \<then> return RETIRE_SUCCESS
   | Supervisor =>
      read_reg mstatus_ref \<bind> ((\<lambda> (w__1 :: Mstatus) . 
      if (((((get_Mstatus_TW w__1  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))) then
        handle_illegal ()  \<then> return RETIRE_FAIL
      else platform_wfi ()  \<then> return RETIRE_SUCCESS))
   | User => handle_illegal ()  \<then> return RETIRE_FAIL
   ))))\<close>


\<comment> \<open>\<open>val execute_UTYPE : mword ty20 -> mword ty5 -> uop -> M Retired\<close>\<close>

definition execute_UTYPE  :: \<open>(20)Word.word \<Rightarrow>(5)Word.word \<Rightarrow> uop \<Rightarrow>((register_value),(Retired),(exception))monad \<close>  where 
     \<open> execute_UTYPE imm rd op1 = (
   (let (off :: xlenbits) =
     ((EXTS (( 64 :: int)::ii) ((concat_vec imm ( 0x000 ::  12 Word.word)  ::  32 Word.word))  ::  64 Word.word)) in
   (case  op1 of
     RISCV_LUI => return off
   | RISCV_AUIPC =>
      (get_arch_pc ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
      return ((add_vec w__0 off  ::  64 Word.word))))
   ) \<bind> ((\<lambda> (ret :: xlenbits) . 
   wX_bits rd ret \<then> return RETIRE_SUCCESS))))\<close> 
  for  imm  :: "(20)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  op1  :: " uop "


\<comment> \<open>\<open>val execute_URET : unit -> M Retired\<close>\<close>

definition execute_URET  :: \<open> unit \<Rightarrow>((register_value),(Retired),(exception))monad \<close>  where 
     \<open> execute_URET _ = (
   or_boolM (haveUsrMode ()  \<bind> ((\<lambda> (w__0 :: bool) .  return ((\<not> w__0)))))
     (return ((\<not> ((sys_enable_next () ))))) \<bind> ((\<lambda> (w__1 :: bool) . 
   (if w__1 then handle_illegal () 
    else if ((\<not> ((ext_check_xret_priv User)))) then return ((ext_fail_xret_priv () ))
    else
      read_reg cur_privilege_ref \<bind> ((\<lambda> (w__2 :: Privilege) . 
      (read_reg PC_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__3 ::  64 Word.word) . 
      (exception_handler w__2 (CTL_URET () ) w__3  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__4 ::  64 Word.word) . 
      set_next_pc w__4))))))) \<then>
   return RETIRE_FAIL)))\<close>


\<comment> \<open>\<open>val execute_STORE_FP : mword ty12 -> mword ty5 -> mword ty5 -> word_width -> M Retired\<close>\<close>

definition execute_STORE_FP  :: \<open>(12)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow> word_width \<Rightarrow>((register_value),(Retired),(exception))monad \<close>  where 
     \<open> execute_STORE_FP imm rs2 rs1 width = (
   (let (offset :: xlenbits) = ((EXTS (( 64 :: int)::ii) imm  ::  64 Word.word)) in
   (let (aq, rl, con) = (False, False, False) in
   ext_data_get_addr rs1 offset (Write Data) width \<bind> ((\<lambda> (w__0 :: unit Ext_DataAddr_Check) . 
   (case  w__0 of
     Ext_DataAddr_Error (e) =>
      (let (_ :: unit) = (ext_handle_data_check_error e) in
      return RETIRE_FAIL)
   | Ext_DataAddr_OK (vaddr) =>
      if ((check_misaligned vaddr width)) then
        handle_mem_exception vaddr (E_SAMO_Addr_Align () ) \<then> return RETIRE_FAIL
      else
        (translateAddr vaddr (Write Data)  :: ( (( 64 Word.word), ExceptionType)TR_Result) M) \<bind> ((\<lambda> (w__1 :: (( 64 Word.word), ExceptionType)
          TR_Result) . 
        (case  w__1 of
          TR_Failure ((e, _)) => handle_mem_exception vaddr e \<then> return RETIRE_FAIL
        | TR_Address ((addr, _)) =>
           (case  width of
             BYTE => return (MemValue () )
           | HALF => return (MemValue () )
           | WORD => mem_write_ea addr (( 4 :: int)::ii) aq rl False
           | DOUBLE => mem_write_ea addr (( 8 :: int)::ii) aq rl False
           ) \<bind> ((\<lambda> (eares :: unit MemoryOpResult) . 
           (case  eares of
             MemException (e) => handle_mem_exception addr e \<then> return RETIRE_FAIL
           | MemValue (_) =>
              (rF_bits rs2  :: ( 64 Word.word) M) \<bind> ((\<lambda> rs2_val .  
  (case  (width, (( 64 :: int):: ii)) of
        (BYTE, g__332) => handle_illegal ()  \<then> return RETIRE_FAIL
    | (HALF, g__333) => handle_illegal ()  \<then> return RETIRE_FAIL
    | (WORD, g__334) =>
  mem_write_value addr (( 4 :: int):: ii)
    ((subrange_vec_dec rs2_val (( 31 :: int):: ii) (( 0 :: int):: ii) :: 32 Word.word))
    aq rl con \<bind>
    ((\<lambda> (w__4 :: bool MemoryOpResult) .  process_fstore vaddr w__4))
    | (DOUBLE, l__9) =>
  if (((l__9 = (( 64 :: int):: ii)))) then
    mem_write_value addr (( 8 :: int):: ii) rs2_val aq rl con \<bind>
      ((\<lambda> (w__6 :: bool MemoryOpResult) .  process_fstore vaddr w__6))
  else
    assert_exp False
      (''Pattern match failure at model/riscv_insts_fext.sail 401:14 - 406:15'')
      \<then> exit0 () 
  )))
           )))
        )))
   ))))))\<close> 
  for  imm  :: "(12)Word.word " 
  and  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  width  :: " word_width "


\<comment> \<open>\<open>val execute_STORECON : bool -> bool -> mword ty5 -> mword ty5 -> word_width -> mword ty5 -> M Retired\<close>\<close>

definition execute_STORECON  :: \<open> bool \<Rightarrow> bool \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow> word_width \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(Retired),(exception))monad \<close>  where 
     \<open> execute_STORECON aq rl rs2 rs1 width rd = (
   speculate_conditional_success ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if (((w__0 = False))) then
     wX_bits rd ((EXTZ (( 64 :: int)::ii) ( 0b1 ::  1 Word.word)  ::  64 Word.word)) \<then> return RETIRE_SUCCESS
   else
     haveAtomics ()  \<bind> ((\<lambda> (w__1 :: bool) . 
     if w__1 then
       ext_data_get_addr rs1 ((zeros_implicit (( 64 :: int)::ii)  ::  64 Word.word)) (Write Data) width \<bind> ((\<lambda> (w__2 :: unit
         Ext_DataAddr_Check) . 
       (case  w__2 of
         Ext_DataAddr_Error (e) =>
          (let (_ :: unit) = (ext_handle_data_check_error e) in
          return RETIRE_FAIL)
       | Ext_DataAddr_OK (vaddr) =>
          (let (aligned :: bool) =
            ((case  width of
              BYTE => True
            | HALF => (((subrange_vec_dec vaddr (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) = ( 0b0 ::  1 Word.word))
            | WORD =>
               (((subrange_vec_dec vaddr (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b00 ::  2 Word.word))
            | DOUBLE =>
               (((subrange_vec_dec vaddr (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word)) = ( 0b000 ::  3 Word.word))
            )) in
          if ((\<not> aligned)) then
            handle_mem_exception vaddr (E_SAMO_Addr_Align () ) \<then> return RETIRE_FAIL
          else if (((((match_reservation vaddr)) = False))) then
            wX_bits rd ((EXTZ (( 64 :: int)::ii) ( 0b1 ::  1 Word.word)  ::  64 Word.word)) \<then>
            ((let (_ :: unit) = (cancel_reservation () ) in
            return RETIRE_SUCCESS))
          else
            (translateAddr vaddr (Write Data)  :: ( (( 64 Word.word), ExceptionType)TR_Result) M) \<bind> ((\<lambda> (w__3 :: (( 64 Word.word), ExceptionType)
              TR_Result) . 
            (case  w__3 of
              TR_Failure ((e, _)) => handle_mem_exception vaddr e \<then> return RETIRE_FAIL
            | TR_Address ((addr, _)) => 
  (case  (width, (( 64 :: int):: ii)) of
        (BYTE, g__317) => mem_write_ea addr (( 1 :: int):: ii)
                            (((aq \<and> rl))) rl True
    | (HALF, g__318) => mem_write_ea addr (( 2 :: int):: ii)
                          (((aq \<and> rl))) rl True
    | (WORD, g__319) => mem_write_ea addr (( 4 :: int):: ii)
                          (((aq \<and> rl))) rl True
    | (DOUBLE, l__4) =>
  if (((l__4 = (( 64 :: int):: ii)))) then
    mem_write_ea addr (( 8 :: int):: ii) (((aq \<and> rl))) rl True else
    internal_error (''STORECON expected word or double'')
  ) \<bind> ((\<lambda> (eares :: unit MemoryOpResult) . 
               (case  eares of
                 MemException (e) => handle_mem_exception addr e \<then> return RETIRE_FAIL
               | MemValue (_) =>
                  (rX_bits rs2  :: ( 64 Word.word) M) \<bind> ((\<lambda> rs2_val .  
  (case  (width, (( 64 :: int):: ii)) of
        (BYTE, g__314) =>
  mem_write_value addr (( 1 :: int):: ii)
    ((subrange_vec_dec rs2_val (( 7 :: int):: ii) (( 0 :: int):: ii) :: 8 Word.word))
    (((aq \<and> rl))) rl True
    | (HALF, g__315) =>
  mem_write_value addr (( 2 :: int):: ii)
    ((subrange_vec_dec rs2_val (( 15 :: int):: ii) (( 0 :: int):: ii) :: 16 Word.word))
    (((aq \<and> rl))) rl True
    | (WORD, g__316) =>
  mem_write_value addr (( 4 :: int):: ii)
    ((subrange_vec_dec rs2_val (( 31 :: int):: ii) (( 0 :: int):: ii) :: 32 Word.word))
    (((aq \<and> rl))) rl True
    | (DOUBLE, l__3) =>
  if (((l__3 = (( 64 :: int):: ii)))) then
    mem_write_value addr (( 8 :: int):: ii) rs2_val (((aq \<and> rl))) 
    rl True else internal_error (''STORECON expected word or double'')
  ) \<bind> ((\<lambda> (res :: bool MemoryOpResult) . 
                  (case  res of
                    MemValue (True) =>
                     wX_bits rd ((EXTZ (( 64 :: int)::ii) ( 0b0 ::  1 Word.word)  ::  64 Word.word)) \<then>
                     ((let (_ :: unit) = (cancel_reservation () ) in
                     return RETIRE_SUCCESS))
                  | MemValue (False) =>
                     wX_bits rd ((EXTZ (( 64 :: int)::ii) ( 0b1 ::  1 Word.word)  ::  64 Word.word)) \<then>
                     ((let (_ :: unit) = (cancel_reservation () ) in
                     return RETIRE_SUCCESS))
                  | MemException (e) => handle_mem_exception addr e \<then> return RETIRE_FAIL
                  )))))
               )))
            ))))
       )))
     else handle_illegal ()  \<then> return RETIRE_FAIL)))))\<close> 
  for  aq  :: " bool " 
  and  rl  :: " bool " 
  and  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  width  :: " word_width " 
  and  rd  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_STORE : mword ty12 -> mword ty5 -> mword ty5 -> word_width -> bool -> bool -> M Retired\<close>\<close>

definition execute_STORE  :: \<open>(12)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow> word_width \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow>((register_value),(Retired),(exception))monad \<close>  where 
     \<open> execute_STORE imm rs2 rs1 width aq rl = (
   (let (offset :: xlenbits) = ((EXTS (( 64 :: int)::ii) imm  ::  64 Word.word)) in
   ext_data_get_addr rs1 offset (Write Data) width \<bind> ((\<lambda> (w__0 :: unit Ext_DataAddr_Check) . 
   (case  w__0 of
     Ext_DataAddr_Error (e) =>
      (let (_ :: unit) = (ext_handle_data_check_error e) in
      return RETIRE_FAIL)
   | Ext_DataAddr_OK (vaddr) =>
      if ((check_misaligned vaddr width)) then
        handle_mem_exception vaddr (E_SAMO_Addr_Align () ) \<then> return RETIRE_FAIL
      else
        (translateAddr vaddr (Write Data)  :: ( (( 64 Word.word), ExceptionType)TR_Result) M) \<bind> ((\<lambda> (w__1 :: (( 64 Word.word), ExceptionType)
          TR_Result) . 
        (case  w__1 of
          TR_Failure ((e, _)) => handle_mem_exception vaddr e \<then> return RETIRE_FAIL
        | TR_Address ((paddr, _)) =>
           (case  width of
             BYTE => mem_write_ea paddr (( 1 :: int)::ii) aq rl False
           | HALF => mem_write_ea paddr (( 2 :: int)::ii) aq rl False
           | WORD => mem_write_ea paddr (( 4 :: int)::ii) aq rl False
           | DOUBLE => mem_write_ea paddr (( 8 :: int)::ii) aq rl False
           ) \<bind> ((\<lambda> (eares :: unit MemoryOpResult) . 
           (case  eares of
             MemException (e) => handle_mem_exception vaddr e \<then> return RETIRE_FAIL
           | MemValue (_) =>
              (rX_bits rs2  :: ( 64 Word.word) M) \<bind> ((\<lambda> rs2_val .  
  (case  (width, (( 64 :: int):: ii)) of
        (BYTE, g__306) =>
  mem_write_value paddr (( 1 :: int):: ii)
    ((subrange_vec_dec rs2_val (( 7 :: int):: ii) (( 0 :: int):: ii) :: 8 Word.word))
    aq rl False
    | (HALF, g__307) =>
  mem_write_value paddr (( 2 :: int):: ii)
    ((subrange_vec_dec rs2_val (( 15 :: int):: ii) (( 0 :: int):: ii) :: 16 Word.word))
    aq rl False
    | (WORD, g__308) =>
  mem_write_value paddr (( 4 :: int):: ii)
    ((subrange_vec_dec rs2_val (( 31 :: int):: ii) (( 0 :: int):: ii) :: 32 Word.word))
    aq rl False
    | (DOUBLE, l__1) =>
  if (((l__1 = (( 64 :: int):: ii)))) then
    mem_write_value paddr (( 8 :: int):: ii) rs2_val aq rl False else
    assert_exp False
      (''Pattern match failure at model/riscv_insts_base.sail 394:47 - 399:15'')
      \<then> exit0 () 
  ) \<bind> ((\<lambda> (res :: bool MemoryOpResult) . 
              (case  res of
                MemValue (True) => return RETIRE_SUCCESS
              | MemValue (False) => internal_error (''store got false from mem_write_value'')
              | MemException (e) => handle_mem_exception vaddr e \<then> return RETIRE_FAIL
              )))))
           )))
        )))
   )))))\<close> 
  for  imm  :: "(12)Word.word " 
  and  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  width  :: " word_width " 
  and  aq  :: " bool " 
  and  rl  :: " bool "


\<comment> \<open>\<open>val execute_SRET : unit -> M Retired\<close>\<close>

definition execute_SRET  :: \<open> unit \<Rightarrow>((register_value),(Retired),(exception))monad \<close>  where 
     \<open> execute_SRET _ = (
   read_reg cur_privilege_ref \<bind> ((\<lambda> (w__0 :: Privilege) . 
   (case  w__0 of
     User => return True
   | Supervisor =>
      or_boolM (haveSupMode ()  \<bind> ((\<lambda> (w__1 :: bool) .  return ((\<not> w__1)))))
        (read_reg mstatus_ref \<bind> ((\<lambda> (w__2 :: Mstatus) . 
         return (((((get_Mstatus_TSR w__2  ::  1 Word.word)) = ( 0b1 ::  1 Word.word)))))))
   | Machine => haveSupMode ()  \<bind> ((\<lambda> (w__4 :: bool) .  return ((\<not> w__4))))
   ) \<bind> ((\<lambda> (sret_illegal :: bool) . 
   if sret_illegal then handle_illegal ()  \<then> return RETIRE_FAIL
   else if ((\<not> ((ext_check_xret_priv Supervisor)))) then
     (let (_ :: unit) = (ext_fail_xret_priv () ) in
     return RETIRE_FAIL)
   else
     read_reg cur_privilege_ref \<bind> ((\<lambda> (w__5 :: Privilege) . 
     (read_reg PC_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__6 ::  64 Word.word) . 
     (exception_handler w__5 (CTL_SRET () ) w__6  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__7 ::  64 Word.word) . 
     set_next_pc w__7 \<then> return RETIRE_SUCCESS)))))))))))\<close>


\<comment> \<open>\<open>val execute_SHIFTW : mword ty5 -> mword ty5 -> mword ty5 -> sop -> M Retired\<close>\<close>

definition execute_SHIFTW  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow> sop \<Rightarrow>((register_value),(Retired),(exception))monad \<close>  where 
     \<open> execute_SHIFTW shamt rs1 rd op1 = (
   (rX_bits rs1  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (let rs1_val = ((subrange_vec_dec w__0 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)) in
   (let (result :: 32 bits) =
     ((case  op1 of
       RISCV_SLLI => (shift_bits_left rs1_val shamt  ::  32 Word.word)
     | RISCV_SRLI => (shift_bits_right rs1_val shamt  ::  32 Word.word)
     | RISCV_SRAI => (shift_right_arith32 rs1_val shamt  ::  32 Word.word)
     )) in
   wX_bits rd ((EXTS (( 64 :: int)::ii) result  ::  64 Word.word)) \<then> return RETIRE_SUCCESS)))))\<close> 
  for  shamt  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  op1  :: " sop "


\<comment> \<open>\<open>val execute_SHIFTIWOP : mword ty5 -> mword ty5 -> mword ty5 -> sopw -> M Retired\<close>\<close>

definition execute_SHIFTIWOP  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow> sopw \<Rightarrow>((register_value),(Retired),(exception))monad \<close>  where 
     \<open> execute_SHIFTIWOP shamt rs1 rd op1 = (
   (rX_bits rs1  :: ( 64 Word.word) M) \<bind> ((\<lambda> rs1_val . 
   (let (result :: 32 bits) =
     ((case  op1 of
       RISCV_SLLIW =>
        (shift_bits_left ((subrange_vec_dec rs1_val (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)) shamt
          ::  32 Word.word)
     | RISCV_SRLIW =>
        (shift_bits_right ((subrange_vec_dec rs1_val (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)) shamt
          ::  32 Word.word)
     | RISCV_SRAIW =>
        (shift_right_arith32 ((subrange_vec_dec rs1_val (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)) shamt
          ::  32 Word.word)
     )) in
   wX_bits rd ((EXTS (( 64 :: int)::ii) result  ::  64 Word.word)) \<then> return RETIRE_SUCCESS))))\<close> 
  for  shamt  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  op1  :: " sopw "


\<comment> \<open>\<open>val execute_SHIFTIOP : mword ty6 -> mword ty5 -> mword ty5 -> sop -> M Retired\<close>\<close>

definition execute_SHIFTIOP  :: \<open>(6)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow> sop \<Rightarrow>((register_value),(Retired),(exception))monad \<close>  where 
     \<open> execute_SHIFTIOP shamt rs1 rd op1 = (
   (rX_bits rs1  :: ( 64 Word.word) M) \<bind> ((\<lambda> rs1_val . 
   (let (result :: xlenbits) =
     ((case  op1 of
       RISCV_SLLI => (shift_bits_left rs1_val shamt  ::  64 Word.word)
     | RISCV_SRLI => (shift_bits_right rs1_val shamt  ::  64 Word.word)
     | RISCV_SRAI => (shift_right_arith64 rs1_val shamt  ::  64 Word.word)
     )) in
   wX_bits rd result \<then> return RETIRE_SUCCESS))))\<close> 
  for  shamt  :: "(6)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  op1  :: " sop "


\<comment> \<open>\<open>val execute_SFENCE_VMA : mword ty5 -> mword ty5 -> M Retired\<close>\<close>

definition execute_SFENCE_VMA  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(Retired),(exception))monad \<close>  where 
     \<open> execute_SFENCE_VMA rs1 rs2 = (
   (if (((rs1 = ( 0b00000 ::  5 Word.word)))) then return None
    else (rX_bits rs1  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) .  return (Some w__0)))) \<bind> ((\<lambda> (addr ::
      xlenbits option) . 
   (if (((rs2 = ( 0b00000 ::  5 Word.word)))) then return None
    else (rX_bits rs2  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) .  return (Some w__1)))) \<bind> ((\<lambda> (asid ::
      xlenbits option) . 
   read_reg cur_privilege_ref \<bind> ((\<lambda> (w__2 :: Privilege) . 
   (case  w__2 of
     User => handle_illegal ()  \<then> return RETIRE_FAIL
   | Supervisor =>
      read_reg mstatus_ref \<bind> ((\<lambda> (w__3 :: Mstatus) . 
      read_reg mstatus_ref \<bind> ((\<lambda> (w__4 :: Mstatus) . 
      (let p__310 =
        (architecture ((get_mstatus_SXL w__3  ::  2 Word.word)), (get_Mstatus_TVM w__4  ::  1 Word.word)) in
      (case  p__310 of
        (Some (g__309), b__0) =>
         if (((b__0 = ( 0b1 ::  1 Word.word)))) then handle_illegal ()  \<then> return RETIRE_FAIL
         else if (((b__0 = ( 0b0 ::  1 Word.word)))) then flush_TLB asid addr \<then> return RETIRE_SUCCESS
         else
           (case  (Some g__309, b__0) of
             (_, _) => internal_error (''unimplemented sfence architecture'')
           )
      | (_, _) => internal_error (''unimplemented sfence architecture'')
      ))))))
   | Machine => flush_TLB asid addr \<then> return RETIRE_SUCCESS
   ))))))))\<close> 
  for  rs1  :: "(5)Word.word " 
  and  rs2  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_RTYPEW : mword ty5 -> mword ty5 -> mword ty5 -> ropw -> M Retired\<close>\<close>

definition execute_RTYPEW  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow> ropw \<Rightarrow>((register_value),(Retired),(exception))monad \<close>  where 
     \<open> execute_RTYPEW rs2 rs1 rd op1 = (
   (rX_bits rs1  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (let rs1_val = ((subrange_vec_dec w__0 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)) in
   (rX_bits rs2  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
   (let rs2_val = ((subrange_vec_dec w__1 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)) in
   (let (result :: 32 bits) =
     ((case  op1 of
       RISCV_ADDW => (add_vec rs1_val rs2_val  ::  32 Word.word)
     | RISCV_SUBW => (sub_vec rs1_val rs2_val  ::  32 Word.word)
     | RISCV_SLLW =>
        (shift_bits_left rs1_val ((subrange_vec_dec rs2_val (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word))
          ::  32 Word.word)
     | RISCV_SRLW =>
        (shift_bits_right rs1_val ((subrange_vec_dec rs2_val (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word))
          ::  32 Word.word)
     | RISCV_SRAW =>
        (shift_right_arith32 rs1_val ((subrange_vec_dec rs2_val (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word))
          ::  32 Word.word)
     )) in
   wX_bits rd ((EXTS (( 64 :: int)::ii) result  ::  64 Word.word)) \<then> return RETIRE_SUCCESS))))))))\<close> 
  for  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  op1  :: " ropw "


\<comment> \<open>\<open>val execute_RTYPE : mword ty5 -> mword ty5 -> mword ty5 -> rop -> M Retired\<close>\<close>

definition execute_RTYPE  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow> rop \<Rightarrow>((register_value),(Retired),(exception))monad \<close>  where 
     \<open> execute_RTYPE rs2 rs1 rd op1 = (
   (rX_bits rs1  :: ( 64 Word.word) M) \<bind> ((\<lambda> rs1_val . 
   (rX_bits rs2  :: ( 64 Word.word) M) \<bind> ((\<lambda> rs2_val . 
   (let (result :: xlenbits) =
     ((case  op1 of
       RISCV_ADD => (add_vec rs1_val rs2_val  ::  64 Word.word)
     | RISCV_SLT =>
        (EXTZ (( 64 :: int)::ii) ((bool_to_bits ((zopz0zI_s rs1_val rs2_val))  ::  1 Word.word))  ::  64 Word.word)
     | RISCV_SLTU =>
        (EXTZ (( 64 :: int)::ii) ((bool_to_bits ((zopz0zI_u rs1_val rs2_val))  ::  1 Word.word))  ::  64 Word.word)
     | RISCV_AND => (and_vec rs1_val rs2_val  ::  64 Word.word)
     | RISCV_OR => (or_vec rs1_val rs2_val  ::  64 Word.word)
     | RISCV_XOR => (xor_vec rs1_val rs2_val  ::  64 Word.word)
     | RISCV_SLL =>
        (shift_bits_left rs1_val ((subrange_vec_dec rs2_val (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word))
          ::  64 Word.word)
     | RISCV_SRL =>
        (shift_bits_right rs1_val ((subrange_vec_dec rs2_val (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word))
          ::  64 Word.word)
     | RISCV_SUB => (sub_vec rs1_val rs2_val  ::  64 Word.word)
     | RISCV_SRA =>
        (shift_right_arith64 rs1_val ((subrange_vec_dec rs2_val (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word))
          ::  64 Word.word)
     )) in
   wX_bits rd result \<then> return RETIRE_SUCCESS))))))\<close> 
  for  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  op1  :: " rop "


\<comment> \<open>\<open>val execute_RISCV_JALR : mword ty12 -> mword ty5 -> mword ty5 -> M Retired\<close>\<close>

definition execute_RISCV_JALR  :: \<open>(12)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(Retired),(exception))monad \<close>  where 
     \<open> execute_RISCV_JALR imm rs1 rd = (
   (rX_bits rs1  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (let (t :: xlenbits) = ((add_vec w__0 ((EXTS (( 64 :: int)::ii) imm  ::  64 Word.word))  ::  64 Word.word)) in
   (case  ((ext_control_check_addr t)) of
     Ext_ControlAddr_Error (e) =>
      (let (_ :: unit) = (ext_handle_control_check_error e) in
      return RETIRE_FAIL)
   | Ext_ControlAddr_OK (addr) =>
      (let target = ((update_vec_dec addr (( 0 :: int)::ii) B0  ::  64 Word.word)) in
      and_boolM (return ((bit_to_bool ((access_vec_dec target (( 1 :: int)::ii))))))
        (haveRVC ()  \<bind> ((\<lambda> (w__1 :: bool) .  return ((\<not> w__1))))) \<bind> ((\<lambda> (w__2 :: bool) . 
      if w__2 then handle_mem_exception target (E_Fetch_Addr_Align () ) \<then> return RETIRE_FAIL
      else
        (get_next_pc ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__3 ::  64 Word.word) . 
        (wX_bits rd w__3 \<then> set_next_pc target) \<then> return RETIRE_SUCCESS)))))
   )))))\<close> 
  for  imm  :: "(12)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_RISCV_JAL : mword ty21 -> mword ty5 -> M Retired\<close>\<close>

definition execute_RISCV_JAL  :: \<open>(21)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(Retired),(exception))monad \<close>  where 
     \<open> execute_RISCV_JAL imm rd = (
   (read_reg PC_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (let (t :: xlenbits) = ((add_vec w__0 ((EXTS (( 64 :: int)::ii) imm  ::  64 Word.word))  ::  64 Word.word)) in
   (case  ((ext_control_check_pc t)) of
     Ext_ControlAddr_Error (e) =>
      (let (_ :: unit) = (ext_handle_control_check_error e) in
      return RETIRE_FAIL)
   | Ext_ControlAddr_OK (target) =>
      and_boolM (return ((bit_to_bool ((access_vec_dec target (( 1 :: int)::ii))))))
        (haveRVC ()  \<bind> ((\<lambda> (w__1 :: bool) .  return ((\<not> w__1))))) \<bind> ((\<lambda> (w__2 :: bool) . 
      if w__2 then handle_mem_exception target (E_Fetch_Addr_Align () ) \<then> return RETIRE_FAIL
      else
        (get_next_pc ()   :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__3 ::  64 Word.word) . 
        (wX_bits rd w__3 \<then> set_next_pc target) \<then> return RETIRE_SUCCESS))))
   )))))\<close> 
  for  imm  :: "(21)Word.word " 
  and  rd  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_REMW : mword ty5 -> mword ty5 -> mword ty5 -> bool -> M Retired\<close>\<close>

definition execute_REMW  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow> bool \<Rightarrow>((register_value),(Retired),(exception))monad \<close>  where 
     \<open> execute_REMW rs2 rs1 rd s = (
   haveMulDiv ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (rX_bits rs1  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
     (let rs1_val = ((subrange_vec_dec w__1 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)) in
     (rX_bits rs2  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
     (let rs2_val = ((subrange_vec_dec w__2 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)) in
     (let (rs1_int :: ii) = (if s then Word.sint rs1_val else Word.uint rs1_val) in
     (let (rs2_int :: ii) = (if s then Word.sint rs2_val else Word.uint rs2_val) in
     (let (r :: ii) = (if (((rs2_int = (( 0 :: int)::ii)))) then rs1_int else hardware_mod rs1_int rs2_int) in
     wX_bits rd ((EXTS (( 64 :: int)::ii) ((to_bits (( 32 :: int)::ii) r  ::  32 Word.word))  ::  64 Word.word)) \<then>
     return RETIRE_SUCCESS)))))))))
   else handle_illegal ()  \<then> return RETIRE_FAIL)))\<close> 
  for  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  s  :: " bool "


\<comment> \<open>\<open>val execute_REM : mword ty5 -> mword ty5 -> mword ty5 -> bool -> M Retired\<close>\<close>

definition execute_REM  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow> bool \<Rightarrow>((register_value),(Retired),(exception))monad \<close>  where 
     \<open> execute_REM rs2 rs1 rd s = (
   haveMulDiv ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (rX_bits rs1  :: ( 64 Word.word) M) \<bind> ((\<lambda> rs1_val . 
     (rX_bits rs2  :: ( 64 Word.word) M) \<bind> ((\<lambda> rs2_val . 
     (let (rs1_int :: ii) = (if s then Word.sint rs1_val else Word.uint rs1_val) in
     (let (rs2_int :: ii) = (if s then Word.sint rs2_val else Word.uint rs2_val) in
     (let (r :: ii) = (if (((rs2_int = (( 0 :: int)::ii)))) then rs1_int else hardware_mod rs1_int rs2_int) in
     wX_bits rd ((to_bits (( 64 :: int)::ii) r  ::  64 Word.word)) \<then> return RETIRE_SUCCESS)))))))
   else handle_illegal ()  \<then> return RETIRE_FAIL)))\<close> 
  for  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  s  :: " bool "


\<comment> \<open>\<open>val execute_MULW : mword ty5 -> mword ty5 -> mword ty5 -> M Retired\<close>\<close>

definition execute_MULW  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(Retired),(exception))monad \<close>  where 
     \<open> execute_MULW rs2 rs1 rd = (
   haveMulDiv ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (rX_bits rs1  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
     (let rs1_val = ((subrange_vec_dec w__1 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)) in
     (rX_bits rs2  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
     (let rs2_val = ((subrange_vec_dec w__2 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)) in
     (let (rs1_int :: ii) = (Word.sint rs1_val) in
     (let (rs2_int :: ii) = (Word.sint rs2_val) in
     (let result32 =
       ((subrange_vec_dec ((to_bits (( 64 :: int)::ii) ((rs1_int * rs2_int))  ::  64 Word.word)) (( 31 :: int)::ii)
          (( 0 :: int)::ii)
         ::  32 Word.word)) in
     (let (result :: xlenbits) = ((EXTS (( 64 :: int)::ii) result32  ::  64 Word.word)) in
     wX_bits rd result \<then> return RETIRE_SUCCESS))))))))))
   else handle_illegal ()  \<then> return RETIRE_FAIL)))\<close> 
  for  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_MUL : mword ty5 -> mword ty5 -> mword ty5 -> bool -> bool -> bool -> M Retired\<close>\<close>

definition execute_MUL  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow>((register_value),(Retired),(exception))monad \<close>  where 
     \<open> execute_MUL rs2 rs1 rd high signed1 signed2 = (
   haveMulDiv ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (rX_bits rs1  :: ( 64 Word.word) M) \<bind> ((\<lambda> rs1_val . 
     (rX_bits rs2  :: ( 64 Word.word) M) \<bind> ((\<lambda> rs2_val . 
     (let (rs1_int :: ii) = (if signed1 then Word.sint rs1_val else Word.uint rs1_val) in
     (let (rs2_int :: ii) = (if signed2 then Word.sint rs2_val else Word.uint rs2_val) in
     (let result_wide =
       ((to_bits (((( 2 :: int)::ii) * (( 64 :: int)::ii))) ((rs1_int * rs2_int))  ::  128 Word.word)) in
     (let result =
       (if high then
         (subrange_vec_dec result_wide (((((( 2 :: int)::ii) * (( 64 :: int)::ii))) - (( 1 :: int)::ii)))
            (( 64 :: int)::ii)
           ::  64 Word.word)
       else (subrange_vec_dec result_wide (((( 64 :: int)::ii) - (( 1 :: int)::ii))) (( 0 :: int)::ii)  ::  64 Word.word)) in
     wX_bits rd result \<then> return RETIRE_SUCCESS))))))))
   else handle_illegal ()  \<then> return RETIRE_FAIL)))\<close> 
  for  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  high  :: " bool " 
  and  signed1  :: " bool " 
  and  signed2  :: " bool "


\<comment> \<open>\<open>val execute_MRET : unit -> M Retired\<close>\<close>

definition execute_MRET  :: \<open> unit \<Rightarrow>((register_value),(Retired),(exception))monad \<close>  where 
     \<open> execute_MRET _ = (
   read_reg cur_privilege_ref \<bind> ((\<lambda> (w__0 :: Privilege) . 
   if (((w__0 \<noteq> Machine))) then handle_illegal ()  \<then> return RETIRE_FAIL
   else if ((\<not> ((ext_check_xret_priv Machine)))) then
     (let (_ :: unit) = (ext_fail_xret_priv () ) in
     return RETIRE_FAIL)
   else
     read_reg cur_privilege_ref \<bind> ((\<lambda> (w__1 :: Privilege) . 
     (read_reg PC_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
     (exception_handler w__1 (CTL_MRET () ) w__2  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__3 ::  64 Word.word) . 
     set_next_pc w__3 \<then> return RETIRE_SUCCESS)))))))))\<close>


\<comment> \<open>\<open>val execute_LOAD_FP : mword ty12 -> mword ty5 -> mword ty5 -> word_width -> M Retired\<close>\<close>

definition execute_LOAD_FP  :: \<open>(12)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow> word_width \<Rightarrow>((register_value),(Retired),(exception))monad \<close>  where 
     \<open> execute_LOAD_FP imm rs1 rd width = (
   (let (offset :: xlenbits) = ((EXTS (( 64 :: int)::ii) imm  ::  64 Word.word)) in
   ext_data_get_addr rs1 offset (Read Data) width \<bind> ((\<lambda> (w__0 :: unit Ext_DataAddr_Check) . 
   (case  w__0 of
     Ext_DataAddr_Error (e) =>
      (let (_ :: unit) = (ext_handle_data_check_error e) in
      return RETIRE_FAIL)
   | Ext_DataAddr_OK (vaddr) =>
      if ((check_misaligned vaddr width)) then
        handle_mem_exception vaddr (E_Load_Addr_Align () ) \<then> return RETIRE_FAIL
      else
        (translateAddr vaddr (Read Data)  :: ( (( 64 Word.word), ExceptionType)TR_Result) M) \<bind> ((\<lambda> (w__1 :: (( 64 Word.word), ExceptionType)
          TR_Result) . 
        (case  w__1 of
          TR_Failure ((e, _)) => handle_mem_exception vaddr e \<then> return RETIRE_FAIL
        | TR_Address ((addr, _)) =>
           (let (aq, rl, res) = (False, False, False) in  
  (case  (width, (( 64 :: int):: ii)) of
        (BYTE, g__329) => handle_illegal ()  \<then> return RETIRE_FAIL
    | (HALF, g__330) => handle_illegal ()  \<then> return RETIRE_FAIL
    | (WORD, g__331) =>
  (mem_read (Read Data) addr (( 4 :: int):: ii) aq rl res :: ( ( 32 Word.word) MemoryOpResult) M)
    \<bind>
    ((\<lambda> (w__2 :: ( 32 Word.word) MemoryOpResult) . 
     process_fload32 rd vaddr w__2))
    | (DOUBLE, l__8) =>
  if (((l__8 = (( 64 :: int):: ii)))) then
    (mem_read (Read Data) addr (( 8 :: int):: ii) aq rl res :: ( ( 64 Word.word) MemoryOpResult) M)
      \<bind>
      ((\<lambda> (w__4 :: ( 64 Word.word) MemoryOpResult) . 
       process_fload64 rd vaddr w__4)) else
    assert_exp False
      (''Pattern match failure at model/riscv_insts_fext.sail 331:10 - 338:11'')
      \<then> exit0 () 
  ))
        )))
   )))))\<close> 
  for  imm  :: "(12)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  width  :: " word_width "


\<comment> \<open>\<open>val execute_LOADRES : bool -> bool -> mword ty5 -> word_width -> mword ty5 -> M Retired\<close>\<close>

definition execute_LOADRES  :: \<open> bool \<Rightarrow> bool \<Rightarrow>(5)Word.word \<Rightarrow> word_width \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(Retired),(exception))monad \<close>  where 
     \<open> execute_LOADRES aq rl rs1 width rd = (
   haveAtomics ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     ext_data_get_addr rs1 ((zeros_implicit (( 64 :: int)::ii)  ::  64 Word.word)) (Read Data) width \<bind> ((\<lambda> (w__1 :: unit
       Ext_DataAddr_Check) . 
     (case  w__1 of
       Ext_DataAddr_Error (e) =>
        (let (_ :: unit) = (ext_handle_data_check_error e) in
        return RETIRE_FAIL)
     | Ext_DataAddr_OK (vaddr) =>
        (let (aligned :: bool) =
          ((case  width of
            BYTE => True
          | HALF => (((subrange_vec_dec vaddr (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) = ( 0b0 ::  1 Word.word))
          | WORD => (((subrange_vec_dec vaddr (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b00 ::  2 Word.word))
          | DOUBLE =>
             (((subrange_vec_dec vaddr (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word)) = ( 0b000 ::  3 Word.word))
          )) in
        if ((\<not> aligned)) then
          handle_mem_exception vaddr (E_Load_Addr_Align () ) \<then> return RETIRE_FAIL
        else
          (translateAddr vaddr (Read Data)  :: ( (( 64 Word.word), ExceptionType)TR_Result) M) \<bind> ((\<lambda> (w__2 :: (( 64 Word.word), ExceptionType)
            TR_Result) . 
          (case  w__2 of
            TR_Failure ((e, _)) => handle_mem_exception vaddr e \<then> return RETIRE_FAIL
          | TR_Address ((addr, _)) => 
  (case  (width, (( 64 :: int):: ii)) of
        (BYTE, g__311) =>
  (mem_read (Read Data) addr (( 1 :: int):: ii) aq (((aq \<and> rl))) True
  :: ( ( 8 Word.word) MemoryOpResult) M) \<bind>
    ((\<lambda> (w__3 :: ( 8 Word.word) MemoryOpResult) . 
     process_loadres rd vaddr w__3 False))
    | (HALF, g__312) =>
  (mem_read (Read Data) addr (( 2 :: int):: ii) aq (((aq \<and> rl))) True
  :: ( ( 16 Word.word) MemoryOpResult) M) \<bind>
    ((\<lambda> (w__5 :: ( 16 Word.word) MemoryOpResult) . 
     process_loadres rd vaddr w__5 False))
    | (WORD, g__313) =>
  (mem_read (Read Data) addr (( 4 :: int):: ii) aq (((aq \<and> rl))) True
  :: ( ( 32 Word.word) MemoryOpResult) M) \<bind>
    ((\<lambda> (w__7 :: ( 32 Word.word) MemoryOpResult) . 
     process_loadres rd vaddr w__7 False))
    | (DOUBLE, l__2) =>
  if (((l__2 = (( 64 :: int):: ii)))) then
    (mem_read (Read Data) addr (( 8 :: int):: ii) aq (((aq \<and> rl))) True
    :: ( ( 64 Word.word) MemoryOpResult) M) \<bind>
      ((\<lambda> (w__9 :: ( 64 Word.word) MemoryOpResult) . 
       process_loadres rd vaddr w__9 False)) else
    internal_error (''Unexpected AMO width'')
  )
          ))))
     )))
   else handle_illegal ()  \<then> return RETIRE_FAIL)))\<close> 
  for  aq  :: " bool " 
  and  rl  :: " bool " 
  and  rs1  :: "(5)Word.word " 
  and  width  :: " word_width " 
  and  rd  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_LOAD : mword ty12 -> mword ty5 -> mword ty5 -> bool -> word_width -> bool -> bool -> M Retired\<close>\<close>

definition execute_LOAD  :: \<open>(12)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow> bool \<Rightarrow> word_width \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow>((register_value),(Retired),(exception))monad \<close>  where 
     \<open> execute_LOAD imm rs1 rd is_unsigned width aq rl = (
   (let (offset :: xlenbits) = ((EXTS (( 64 :: int)::ii) imm  ::  64 Word.word)) in
   ext_data_get_addr rs1 offset (Read Data) width \<bind> ((\<lambda> (w__0 :: unit Ext_DataAddr_Check) . 
   (case  w__0 of
     Ext_DataAddr_Error (e) =>
      (let (_ :: unit) = (ext_handle_data_check_error e) in
      return RETIRE_FAIL)
   | Ext_DataAddr_OK (vaddr) =>
      if ((check_misaligned vaddr width)) then
        handle_mem_exception vaddr (E_Load_Addr_Align () ) \<then> return RETIRE_FAIL
      else
        (translateAddr vaddr (Read Data)  :: ( (( 64 Word.word), ExceptionType)TR_Result) M) \<bind> ((\<lambda> (w__1 :: (( 64 Word.word), ExceptionType)
          TR_Result) . 
        (case  w__1 of
          TR_Failure ((e, _)) => handle_mem_exception vaddr e \<then> return RETIRE_FAIL
        | TR_Address ((paddr, _)) => 
  (case  (width, (( 64 :: int):: ii)) of
        (BYTE, g__303) =>
  (mem_read (Read Data) paddr (( 1 :: int):: ii) aq rl False :: ( ( 8 Word.word) MemoryOpResult) M)
    \<bind>
    ((\<lambda> (w__2 :: ( 8 Word.word) MemoryOpResult) . 
     process_load rd vaddr w__2 is_unsigned))
    | (HALF, g__304) =>
  (mem_read (Read Data) paddr (( 2 :: int):: ii) aq rl False :: ( ( 16 Word.word) MemoryOpResult) M)
    \<bind>
    ((\<lambda> (w__4 :: ( 16 Word.word) MemoryOpResult) . 
     process_load rd vaddr w__4 is_unsigned))
    | (WORD, g__305) =>
  (mem_read (Read Data) paddr (( 4 :: int):: ii) aq rl False :: ( ( 32 Word.word) MemoryOpResult) M)
    \<bind>
    ((\<lambda> (w__6 :: ( 32 Word.word) MemoryOpResult) . 
     process_load rd vaddr w__6 is_unsigned))
    | (DOUBLE, l__0) =>
  if (((l__0 = (( 64 :: int):: ii)))) then
    (mem_read (Read Data) paddr (( 8 :: int):: ii) aq rl False :: ( ( 64 Word.word) MemoryOpResult) M)
      \<bind>
      ((\<lambda> (w__8 :: ( 64 Word.word) MemoryOpResult) . 
       process_load rd vaddr w__8 is_unsigned)) else
    assert_exp False
      (''Pattern match failure at model/riscv_insts_base.sail 329:10 - 338:11'')
      \<then> exit0 () 
  )
        )))
   )))))\<close> 
  for  imm  :: "(12)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  is_unsigned  :: " bool " 
  and  width  :: " word_width " 
  and  aq  :: " bool " 
  and  rl  :: " bool "


\<comment> \<open>\<open>val execute_ITYPE : mword ty12 -> mword ty5 -> mword ty5 -> iop -> M Retired\<close>\<close>

definition execute_ITYPE  :: \<open>(12)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow> iop \<Rightarrow>((register_value),(Retired),(exception))monad \<close>  where 
     \<open> execute_ITYPE imm rs1 rd op1 = (
   (rX_bits rs1  :: ( 64 Word.word) M) \<bind> ((\<lambda> rs1_val . 
   (let (immext :: xlenbits) = ((EXTS (( 64 :: int)::ii) imm  ::  64 Word.word)) in
   (let (result :: xlenbits) =
     ((case  op1 of
       RISCV_ADDI => (add_vec rs1_val immext  ::  64 Word.word)
     | RISCV_SLTI =>
        (EXTZ (( 64 :: int)::ii) ((bool_to_bits ((zopz0zI_s rs1_val immext))  ::  1 Word.word))  ::  64 Word.word)
     | RISCV_SLTIU =>
        (EXTZ (( 64 :: int)::ii) ((bool_to_bits ((zopz0zI_u rs1_val immext))  ::  1 Word.word))  ::  64 Word.word)
     | RISCV_ANDI => (and_vec rs1_val immext  ::  64 Word.word)
     | RISCV_ORI => (or_vec rs1_val immext  ::  64 Word.word)
     | RISCV_XORI => (xor_vec rs1_val immext  ::  64 Word.word)
     )) in
   wX_bits rd result \<then> return RETIRE_SUCCESS)))))\<close> 
  for  imm  :: "(12)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  op1  :: " iop "


\<comment> \<open>\<open>val execute_ILLEGAL : mword ty32 -> M Retired\<close>\<close>

definition execute_ILLEGAL  :: \<open>(32)Word.word \<Rightarrow>((register_value),(Retired),(exception))monad \<close>  where 
     \<open> execute_ILLEGAL s = ( handle_illegal ()  \<then> return RETIRE_FAIL )\<close> 
  for  s  :: "(32)Word.word "


\<comment> \<open>\<open>val execute_F_UN_TYPE_S : mword ty5 -> mword ty5 -> f_un_op_S -> M Retired\<close>\<close>

definition execute_F_UN_TYPE_S  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow> f_un_op_S \<Rightarrow>((register_value),(Retired),(exception))monad \<close>  where 
     \<open> execute_F_UN_TYPE_S arg0 arg1 arg2 = (
   (let merge_var = (arg0, arg1, arg2) in
   (case  merge_var of
     (rs1, rd, FCLASS_S) =>
      (rF_bits rs1  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
      (let rs1_val_S = ((nan_unbox w__0  ::  32 Word.word)) in
      (let (rd_val_10b :: 10 bits) =
        (if ((f_is_neg_inf_S rs1_val_S)) then ( 0b0000000001 ::  10 Word.word)
        else if ((f_is_neg_norm_S rs1_val_S)) then ( 0b0000000010 ::  10 Word.word)
        else if ((f_is_neg_subnorm_S rs1_val_S)) then ( 0b0000000100 ::  10 Word.word)
        else if ((f_is_neg_zero_S rs1_val_S)) then ( 0b0000001000 ::  10 Word.word)
        else if ((f_is_pos_zero_S rs1_val_S)) then ( 0b0000010000 ::  10 Word.word)
        else if ((f_is_pos_subnorm_S rs1_val_S)) then ( 0b0000100000 ::  10 Word.word)
        else if ((f_is_pos_norm_S rs1_val_S)) then ( 0b0001000000 ::  10 Word.word)
        else if ((f_is_pos_inf_S rs1_val_S)) then ( 0b0010000000 ::  10 Word.word)
        else if ((f_is_SNaN_S rs1_val_S)) then ( 0b0100000000 ::  10 Word.word)
        else if ((f_is_QNaN_S rs1_val_S)) then ( 0b1000000000 ::  10 Word.word)
        else (zeros_implicit (( 10 :: int)::ii)  ::  10 Word.word)) in
      wX_bits rd ((EXTZ (( 64 :: int)::ii) rd_val_10b  ::  64 Word.word)) \<then> return RETIRE_SUCCESS))))
   | (rs1, rd, FMV_X_W) =>
      (rF_bits rs1  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
      (let rs1_val_S = ((subrange_vec_dec w__0 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)) in
      (let (rd_val_X :: xlenbits) = ((EXTS (( 64 :: int)::ii) rs1_val_S  ::  64 Word.word)) in
      wX_bits rd rd_val_X \<then> return RETIRE_SUCCESS))))
   | (rs1, rd, FMV_W_X) =>
      (rX_bits rs1  :: ( 64 Word.word) M) \<bind> ((\<lambda> rs1_val_X . 
      (let rd_val_S = ((subrange_vec_dec rs1_val_X (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)) in
      wF_bits rd ((nan_box rd_val_S  ::  64 Word.word)) \<then> return RETIRE_SUCCESS)))
   )))\<close> 
  for  arg0  :: "(5)Word.word " 
  and  arg1  :: "(5)Word.word " 
  and  arg2  :: " f_un_op_S "


\<comment> \<open>\<open>val execute_F_UN_TYPE_D : mword ty5 -> mword ty5 -> f_un_op_D -> M Retired\<close>\<close>

definition execute_F_UN_TYPE_D  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow> f_un_op_D \<Rightarrow>((register_value),(Retired),(exception))monad \<close>  where 
     \<open> execute_F_UN_TYPE_D arg0 arg1 arg2 = (
   (let merge_var = (arg0, arg1, arg2) in
   (case  merge_var of
     (rs1, rd, FCLASS_D) =>
      (rF_bits rs1  :: ( 64 Word.word) M) \<bind> ((\<lambda> rs1_val_D . 
      (let (rd_val_10b :: 10 bits) =
        (if ((f_is_neg_inf_D rs1_val_D)) then ( 0b0000000001 ::  10 Word.word)
        else if ((f_is_neg_norm_D rs1_val_D)) then ( 0b0000000010 ::  10 Word.word)
        else if ((f_is_neg_subnorm_D rs1_val_D)) then ( 0b0000000100 ::  10 Word.word)
        else if ((f_is_neg_zero_D rs1_val_D)) then ( 0b0000001000 ::  10 Word.word)
        else if ((f_is_pos_zero_D rs1_val_D)) then ( 0b0000010000 ::  10 Word.word)
        else if ((f_is_pos_subnorm_D rs1_val_D)) then ( 0b0000100000 ::  10 Word.word)
        else if ((f_is_pos_norm_D rs1_val_D)) then ( 0b0001000000 ::  10 Word.word)
        else if ((f_is_pos_inf_D rs1_val_D)) then ( 0b0010000000 ::  10 Word.word)
        else if ((f_is_SNaN_D rs1_val_D)) then ( 0b0100000000 ::  10 Word.word)
        else if ((f_is_QNaN_D rs1_val_D)) then ( 0b1000000000 ::  10 Word.word)
        else (zeros_implicit (( 10 :: int)::ii)  ::  10 Word.word)) in
      wX_bits rd ((EXTZ (( 64 :: int)::ii) rd_val_10b  ::  64 Word.word)) \<then> return RETIRE_SUCCESS)))
   | (rs1, rd, FMV_X_D) =>
      (rF_bits rs1  :: ( 64 Word.word) M) \<bind> ((\<lambda> rs1_val_D . 
      (let rd_val_X = rs1_val_D in
      wX_bits rd rd_val_X \<then> return RETIRE_SUCCESS)))
   | (rs1, rd, FMV_D_X) =>
      (rX_bits rs1  :: ( 64 Word.word) M) \<bind> ((\<lambda> rs1_val_X . 
      (let rd_val_D = rs1_val_X in
      wF_bits rd rd_val_D \<then> return RETIRE_SUCCESS)))
   )))\<close> 
  for  arg0  :: "(5)Word.word " 
  and  arg1  :: "(5)Word.word " 
  and  arg2  :: " f_un_op_D "


\<comment> \<open>\<open>val execute_F_UN_RM_TYPE_S : mword ty5 -> rounding_mode -> mword ty5 -> f_un_rm_op_S -> M Retired\<close>\<close>

definition execute_F_UN_RM_TYPE_S  :: \<open>(5)Word.word \<Rightarrow> rounding_mode \<Rightarrow>(5)Word.word \<Rightarrow> f_un_rm_op_S \<Rightarrow>((register_value),(Retired),(exception))monad \<close>  where 
     \<open> execute_F_UN_RM_TYPE_S arg0 arg1 arg2 arg3 = (
   (let merge_var = (arg0, arg1, arg2, arg3) in
   (case  merge_var of
     (rs1, rm, rd, FSQRT_S) =>
      (rF_bits rs1  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
      (let rs1_val_S = ((nan_unbox w__0  ::  32 Word.word)) in
      select_instr_or_fcsr_rm rm \<bind> ((\<lambda> (w__1 :: rounding_mode) . 
      (let rm_3b = ((encdec_rounding_mode_forwards w__1  ::  3 Word.word)) in
      (riscv_f32Sqrt rm_3b rs1_val_S  :: (( 5 Word.word *  32 Word.word)) M) \<bind> ((\<lambda> varstup .  (let (fflags, rd_val_S) = varstup in
      (write_fflags fflags \<then> wF_bits rd ((nan_box rd_val_S  ::  64 Word.word))) \<then> return RETIRE_SUCCESS)))))))))
   | (rs1, rm, rd, FCVT_W_S) =>
      (rF_bits rs1  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
      (let rs1_val_S = ((nan_unbox w__0  ::  32 Word.word)) in
      select_instr_or_fcsr_rm rm \<bind> ((\<lambda> (w__1 :: rounding_mode) . 
      (let rm_3b = ((encdec_rounding_mode_forwards w__1  ::  3 Word.word)) in
      (riscv_f32ToI32 rm_3b rs1_val_S  :: (( 5 Word.word *  32 Word.word)) M) \<bind> ((\<lambda> varstup .  (let (fflags, rd_val_W) = varstup in
      (write_fflags fflags \<then>
      wX_bits rd ((EXTS (( 64 :: int)::ii) rd_val_W  ::  64 Word.word))) \<then> return RETIRE_SUCCESS)))))))))
   | (rs1, rm, rd, FCVT_WU_S) =>
      (rF_bits rs1  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
      (let rs1_val_S = ((nan_unbox w__0  ::  32 Word.word)) in
      select_instr_or_fcsr_rm rm \<bind> ((\<lambda> (w__1 :: rounding_mode) . 
      (let rm_3b = ((encdec_rounding_mode_forwards w__1  ::  3 Word.word)) in
      (riscv_f32ToUi32 rm_3b rs1_val_S  :: (( 5 Word.word *  32 Word.word)) M) \<bind> ((\<lambda> varstup .  (let (fflags, rd_val_WU) = varstup in
      (write_fflags fflags \<then>
      wX_bits rd ((EXTS (( 64 :: int)::ii) rd_val_WU  ::  64 Word.word))) \<then> return RETIRE_SUCCESS)))))))))
   | (rs1, rm, rd, FCVT_S_W) =>
      (rX_bits rs1  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
      (let rs1_val_W = ((subrange_vec_dec w__0 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)) in
      select_instr_or_fcsr_rm rm \<bind> ((\<lambda> (w__1 :: rounding_mode) . 
      (let rm_3b = ((encdec_rounding_mode_forwards w__1  ::  3 Word.word)) in
      (riscv_i32ToF32 rm_3b rs1_val_W  :: (( 5 Word.word *  32 Word.word)) M) \<bind> ((\<lambda> varstup .  (let (fflags, rd_val_S) = varstup in
      (write_fflags fflags \<then> wF_bits rd ((nan_box rd_val_S  ::  64 Word.word))) \<then> return RETIRE_SUCCESS)))))))))
   | (rs1, rm, rd, FCVT_S_WU) =>
      (rX_bits rs1  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
      (let rs1_val_WU = ((subrange_vec_dec w__0 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)) in
      select_instr_or_fcsr_rm rm \<bind> ((\<lambda> (w__1 :: rounding_mode) . 
      (let rm_3b = ((encdec_rounding_mode_forwards w__1  ::  3 Word.word)) in
      (riscv_ui32ToF32 rm_3b rs1_val_WU  :: (( 5 Word.word *  32 Word.word)) M) \<bind> ((\<lambda> varstup .  (let (fflags, rd_val_S) = varstup in
      (write_fflags fflags \<then> wF_bits rd ((nan_box rd_val_S  ::  64 Word.word))) \<then> return RETIRE_SUCCESS)))))))))
   | (rs1, rm, rd, FCVT_L_S) =>
      (rF_bits rs1  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
      (let rs1_val_S = ((nan_unbox w__0  ::  32 Word.word)) in
      select_instr_or_fcsr_rm rm \<bind> ((\<lambda> (w__1 :: rounding_mode) . 
      (let rm_3b = ((encdec_rounding_mode_forwards w__1  ::  3 Word.word)) in
      (riscv_f32ToI64 rm_3b rs1_val_S  :: (( 5 Word.word *  64 Word.word)) M) \<bind> ((\<lambda> varstup .  (let (fflags, rd_val_L) = varstup in
      (write_fflags fflags \<then> wX_bits rd rd_val_L) \<then> return RETIRE_SUCCESS)))))))))
   | (rs1, rm, rd, FCVT_LU_S) =>
      (rF_bits rs1  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
      (let rs1_val_S = ((nan_unbox w__0  ::  32 Word.word)) in
      select_instr_or_fcsr_rm rm \<bind> ((\<lambda> (w__1 :: rounding_mode) . 
      (let rm_3b = ((encdec_rounding_mode_forwards w__1  ::  3 Word.word)) in
      (riscv_f32ToUi64 rm_3b rs1_val_S  :: (( 5 Word.word *  64 Word.word)) M) \<bind> ((\<lambda> varstup .  (let (fflags, rd_val_LU) = varstup in
      (write_fflags fflags \<then> wX_bits rd rd_val_LU) \<then> return RETIRE_SUCCESS)))))))))
   | (rs1, rm, rd, FCVT_S_L) =>
      (rX_bits rs1  :: ( 64 Word.word) M) \<bind> ((\<lambda> rs1_val_L . 
      select_instr_or_fcsr_rm rm \<bind> ((\<lambda> (w__0 :: rounding_mode) . 
      (let rm_3b = ((encdec_rounding_mode_forwards w__0  ::  3 Word.word)) in
      (riscv_i64ToF32 rm_3b rs1_val_L  :: (( 5 Word.word *  32 Word.word)) M) \<bind> ((\<lambda> varstup .  (let (fflags, rd_val_S) = varstup in
      (write_fflags fflags \<then> wF_bits rd ((nan_box rd_val_S  ::  64 Word.word))) \<then> return RETIRE_SUCCESS))))))))
   | (rs1, rm, rd, FCVT_S_LU) =>
      (rX_bits rs1  :: ( 64 Word.word) M) \<bind> ((\<lambda> rs1_val_LU . 
      select_instr_or_fcsr_rm rm \<bind> ((\<lambda> (w__0 :: rounding_mode) . 
      (let rm_3b = ((encdec_rounding_mode_forwards w__0  ::  3 Word.word)) in
      (riscv_ui64ToF32 rm_3b rs1_val_LU  :: (( 5 Word.word *  32 Word.word)) M) \<bind> ((\<lambda> varstup .  (let (fflags, rd_val_S) = varstup in
      (write_fflags fflags \<then> wF_bits rd ((nan_box rd_val_S  ::  64 Word.word))) \<then> return RETIRE_SUCCESS))))))))
   )))\<close> 
  for  arg0  :: "(5)Word.word " 
  and  arg1  :: " rounding_mode " 
  and  arg2  :: "(5)Word.word " 
  and  arg3  :: " f_un_rm_op_S "


\<comment> \<open>\<open>val execute_F_UN_RM_TYPE_D : mword ty5 -> rounding_mode -> mword ty5 -> f_un_rm_op_D -> M Retired\<close>\<close>

definition execute_F_UN_RM_TYPE_D  :: \<open>(5)Word.word \<Rightarrow> rounding_mode \<Rightarrow>(5)Word.word \<Rightarrow> f_un_rm_op_D \<Rightarrow>((register_value),(Retired),(exception))monad \<close>  where 
     \<open> execute_F_UN_RM_TYPE_D arg0 arg1 arg2 arg3 = (
   (let merge_var = (arg0, arg1, arg2, arg3) in
   (case  merge_var of
     (rs1, rm, rd, FSQRT_D) =>
      (rF_bits rs1  :: ( 64 Word.word) M) \<bind> ((\<lambda> rs1_val_D . 
      select_instr_or_fcsr_rm rm \<bind> ((\<lambda> (w__0 :: rounding_mode) . 
      (let rm_3b = ((encdec_rounding_mode_forwards w__0  ::  3 Word.word)) in
      (riscv_f64Sqrt rm_3b rs1_val_D  :: (( 5 Word.word *  64 Word.word)) M) \<bind> ((\<lambda> varstup .  (let (fflags, rd_val_D) = varstup in
      (write_fflags fflags \<then> wF_bits rd rd_val_D) \<then> return RETIRE_SUCCESS))))))))
   | (rs1, rm, rd, FCVT_W_D) =>
      (rF_bits rs1  :: ( 64 Word.word) M) \<bind> ((\<lambda> rs1_val_D . 
      select_instr_or_fcsr_rm rm \<bind> ((\<lambda> (w__0 :: rounding_mode) . 
      (let rm_3b = ((encdec_rounding_mode_forwards w__0  ::  3 Word.word)) in
      (riscv_f64ToI32 rm_3b rs1_val_D  :: (( 5 Word.word *  32 Word.word)) M) \<bind> ((\<lambda> varstup .  (let (fflags, rd_val_W) = varstup in
      (write_fflags fflags \<then>
      wX_bits rd ((EXTS (( 64 :: int)::ii) rd_val_W  ::  64 Word.word))) \<then> return RETIRE_SUCCESS))))))))
   | (rs1, rm, rd, FCVT_WU_D) =>
      (rF_bits rs1  :: ( 64 Word.word) M) \<bind> ((\<lambda> rs1_val_D . 
      select_instr_or_fcsr_rm rm \<bind> ((\<lambda> (w__0 :: rounding_mode) . 
      (let rm_3b = ((encdec_rounding_mode_forwards w__0  ::  3 Word.word)) in
      (riscv_f64ToUi32 rm_3b rs1_val_D  :: (( 5 Word.word *  32 Word.word)) M) \<bind> ((\<lambda> varstup .  (let (fflags, rd_val_WU) = varstup in
      (write_fflags fflags \<then>
      wX_bits rd ((EXTS (( 64 :: int)::ii) rd_val_WU  ::  64 Word.word))) \<then> return RETIRE_SUCCESS))))))))
   | (rs1, rm, rd, FCVT_D_W) =>
      (rX_bits rs1  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
      (let rs1_val_W = ((subrange_vec_dec w__0 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)) in
      select_instr_or_fcsr_rm rm \<bind> ((\<lambda> (w__1 :: rounding_mode) . 
      (let rm_3b = ((encdec_rounding_mode_forwards w__1  ::  3 Word.word)) in
      (riscv_i32ToF64 rm_3b rs1_val_W  :: (( 5 Word.word *  64 Word.word)) M) \<bind> ((\<lambda> varstup .  (let (fflags, rd_val_D) = varstup in
      (write_fflags fflags \<then> wF_bits rd rd_val_D) \<then> return RETIRE_SUCCESS)))))))))
   | (rs1, rm, rd, FCVT_D_WU) =>
      (rX_bits rs1  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
      (let rs1_val_WU = ((subrange_vec_dec w__0 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)) in
      select_instr_or_fcsr_rm rm \<bind> ((\<lambda> (w__1 :: rounding_mode) . 
      (let rm_3b = ((encdec_rounding_mode_forwards w__1  ::  3 Word.word)) in
      (riscv_ui32ToF64 rm_3b rs1_val_WU  :: (( 5 Word.word *  64 Word.word)) M) \<bind> ((\<lambda> varstup .  (let (fflags, rd_val_D) = varstup in
      (write_fflags fflags \<then> wF_bits rd rd_val_D) \<then> return RETIRE_SUCCESS)))))))))
   | (rs1, rm, rd, FCVT_S_D) =>
      (rF_bits rs1  :: ( 64 Word.word) M) \<bind> ((\<lambda> rs1_val_D . 
      select_instr_or_fcsr_rm rm \<bind> ((\<lambda> (w__0 :: rounding_mode) . 
      (let rm_3b = ((encdec_rounding_mode_forwards w__0  ::  3 Word.word)) in
      (riscv_f64ToF32 rm_3b rs1_val_D  :: (( 5 Word.word *  32 Word.word)) M) \<bind> ((\<lambda> varstup .  (let (fflags, rd_val_S) = varstup in
      (write_fflags fflags \<then> wF_bits rd ((nan_box rd_val_S  ::  64 Word.word))) \<then> return RETIRE_SUCCESS))))))))
   | (rs1, rm, rd, FCVT_D_S) =>
      (rF_bits rs1  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
      (let rs1_val_S = ((nan_unbox w__0  ::  32 Word.word)) in
      select_instr_or_fcsr_rm rm \<bind> ((\<lambda> (w__1 :: rounding_mode) . 
      (let rm_3b = ((encdec_rounding_mode_forwards w__1  ::  3 Word.word)) in
      (riscv_f32ToF64 rm_3b rs1_val_S  :: (( 5 Word.word *  64 Word.word)) M) \<bind> ((\<lambda> varstup .  (let (fflags, rd_val_D) = varstup in
      (write_fflags fflags \<then> wF_bits rd rd_val_D) \<then> return RETIRE_SUCCESS)))))))))
   | (rs1, rm, rd, FCVT_L_D) =>
      (rF_bits rs1  :: ( 64 Word.word) M) \<bind> ((\<lambda> rs1_val_D . 
      select_instr_or_fcsr_rm rm \<bind> ((\<lambda> (w__0 :: rounding_mode) . 
      (let rm_3b = ((encdec_rounding_mode_forwards w__0  ::  3 Word.word)) in
      (riscv_f64ToI64 rm_3b rs1_val_D  :: (( 5 Word.word *  64 Word.word)) M) \<bind> ((\<lambda> varstup .  (let (fflags, rd_val_L) = varstup in
      (write_fflags fflags \<then> wX_bits rd rd_val_L) \<then> return RETIRE_SUCCESS))))))))
   | (rs1, rm, rd, FCVT_LU_D) =>
      (rF_bits rs1  :: ( 64 Word.word) M) \<bind> ((\<lambda> rs1_val_D . 
      select_instr_or_fcsr_rm rm \<bind> ((\<lambda> (w__0 :: rounding_mode) . 
      (let rm_3b = ((encdec_rounding_mode_forwards w__0  ::  3 Word.word)) in
      (riscv_f64ToUi64 rm_3b rs1_val_D  :: (( 5 Word.word *  64 Word.word)) M) \<bind> ((\<lambda> varstup .  (let (fflags, rd_val_LU) = varstup in
      (write_fflags fflags \<then> wX_bits rd rd_val_LU) \<then> return RETIRE_SUCCESS))))))))
   | (rs1, rm, rd, FCVT_D_L) =>
      (rX_bits rs1  :: ( 64 Word.word) M) \<bind> ((\<lambda> rs1_val_L . 
      select_instr_or_fcsr_rm rm \<bind> ((\<lambda> (w__0 :: rounding_mode) . 
      (let rm_3b = ((encdec_rounding_mode_forwards w__0  ::  3 Word.word)) in
      (riscv_i64ToF64 rm_3b rs1_val_L  :: (( 5 Word.word *  64 Word.word)) M) \<bind> ((\<lambda> varstup .  (let (fflags, rd_val_D) = varstup in
      (write_fflags fflags \<then> wF_bits rd rd_val_D) \<then> return RETIRE_SUCCESS))))))))
   | (rs1, rm, rd, FCVT_D_LU) =>
      (rX_bits rs1  :: ( 64 Word.word) M) \<bind> ((\<lambda> rs1_val_LU . 
      select_instr_or_fcsr_rm rm \<bind> ((\<lambda> (w__0 :: rounding_mode) . 
      (let rm_3b = ((encdec_rounding_mode_forwards w__0  ::  3 Word.word)) in
      (riscv_ui64ToF64 rm_3b rs1_val_LU  :: (( 5 Word.word *  64 Word.word)) M) \<bind> ((\<lambda> varstup .  (let (fflags, rd_val_D) = varstup in
      (write_fflags fflags \<then> wF_bits rd rd_val_D) \<then> return RETIRE_SUCCESS))))))))
   )))\<close> 
  for  arg0  :: "(5)Word.word " 
  and  arg1  :: " rounding_mode " 
  and  arg2  :: "(5)Word.word " 
  and  arg3  :: " f_un_rm_op_D "


\<comment> \<open>\<open>val execute_F_MADD_TYPE_S : mword ty5 -> mword ty5 -> mword ty5 -> rounding_mode -> mword ty5 -> f_madd_op_S -> M Retired\<close>\<close>

definition execute_F_MADD_TYPE_S  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow> rounding_mode \<Rightarrow>(5)Word.word \<Rightarrow> f_madd_op_S \<Rightarrow>((register_value),(Retired),(exception))monad \<close>  where 
     \<open> execute_F_MADD_TYPE_S rs3 rs2 rs1 rm rd op1 = (
   (rF_bits rs1  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (let rs1_val_32b = ((nan_unbox w__0  ::  32 Word.word)) in
   (rF_bits rs2  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
   (let rs2_val_32b = ((nan_unbox w__1  ::  32 Word.word)) in
   (rF_bits rs3  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
   (let rs3_val_32b = ((nan_unbox w__2  ::  32 Word.word)) in
   select_instr_or_fcsr_rm rm \<bind> ((\<lambda> (w__3 :: rounding_mode) . 
   (let rm_3b = ((encdec_rounding_mode_forwards w__3  ::  3 Word.word)) in
   (case  op1 of
     FMADD_S =>
      (riscv_f32MulAdd rm_3b rs1_val_32b rs2_val_32b rs3_val_32b  :: (( 5 Word.word *  32 Word.word)) M)
   | FMSUB_S =>
      (riscv_f32MulAdd rm_3b rs1_val_32b rs2_val_32b ((negate_S rs3_val_32b  ::  32 Word.word))
        :: (( 5 Word.word *  32 Word.word)) M)
   | FNMSUB_S =>
      (riscv_f32MulAdd rm_3b ((negate_S rs1_val_32b  ::  32 Word.word)) rs2_val_32b rs3_val_32b
        :: (( 5 Word.word *  32 Word.word)) M)
   | FNMADD_S =>
      (riscv_f32MulAdd rm_3b ((negate_S rs1_val_32b  ::  32 Word.word)) rs2_val_32b
         ((negate_S rs3_val_32b  ::  32 Word.word))
        :: (( 5 Word.word *  32 Word.word)) M)
   ) \<bind> ((\<lambda> varstup .  (let ((fflags :: 5 bits), (rd_val_32b :: 32 bits)) = varstup in
   (write_fflags fflags \<then> wF_bits rd ((nan_box rd_val_32b  ::  64 Word.word))) \<then> return RETIRE_SUCCESS))))))))))))))))\<close> 
  for  rs3  :: "(5)Word.word " 
  and  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rm  :: " rounding_mode " 
  and  rd  :: "(5)Word.word " 
  and  op1  :: " f_madd_op_S "


\<comment> \<open>\<open>val execute_F_MADD_TYPE_D : mword ty5 -> mword ty5 -> mword ty5 -> rounding_mode -> mword ty5 -> f_madd_op_D -> M Retired\<close>\<close>

definition execute_F_MADD_TYPE_D  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow> rounding_mode \<Rightarrow>(5)Word.word \<Rightarrow> f_madd_op_D \<Rightarrow>((register_value),(Retired),(exception))monad \<close>  where 
     \<open> execute_F_MADD_TYPE_D rs3 rs2 rs1 rm rd op1 = (
   (rF_bits rs1  :: ( 64 Word.word) M) \<bind> ((\<lambda> rs1_val_64b . 
   (rF_bits rs2  :: ( 64 Word.word) M) \<bind> ((\<lambda> rs2_val_64b . 
   (rF_bits rs3  :: ( 64 Word.word) M) \<bind> ((\<lambda> rs3_val_64b . 
   select_instr_or_fcsr_rm rm \<bind> ((\<lambda> (w__0 :: rounding_mode) . 
   (let rm_3b = ((encdec_rounding_mode_forwards w__0  ::  3 Word.word)) in
   (case  op1 of
     FMADD_D =>
      (riscv_f64MulAdd rm_3b rs1_val_64b rs2_val_64b rs3_val_64b  :: (( 5 Word.word *  64 Word.word)) M)
   | FMSUB_D =>
      (riscv_f64MulAdd rm_3b rs1_val_64b rs2_val_64b ((negate_D rs3_val_64b  ::  64 Word.word))
        :: (( 5 Word.word *  64 Word.word)) M)
   | FNMSUB_D =>
      (riscv_f64MulAdd rm_3b ((negate_D rs1_val_64b  ::  64 Word.word)) rs2_val_64b rs3_val_64b
        :: (( 5 Word.word *  64 Word.word)) M)
   | FNMADD_D =>
      (riscv_f64MulAdd rm_3b ((negate_D rs1_val_64b  ::  64 Word.word)) rs2_val_64b
         ((negate_D rs3_val_64b  ::  64 Word.word))
        :: (( 5 Word.word *  64 Word.word)) M)
   ) \<bind> ((\<lambda> varstup .  (let ((fflags :: 5 bits), (rd_val_64b :: 64 bits)) = varstup in
   (write_fflags fflags \<then> wF_bits rd rd_val_64b) \<then> return RETIRE_SUCCESS)))))))))))))\<close> 
  for  rs3  :: "(5)Word.word " 
  and  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rm  :: " rounding_mode " 
  and  rd  :: "(5)Word.word " 
  and  op1  :: " f_madd_op_D "


\<comment> \<open>\<open>val execute_F_BIN_TYPE_S : mword ty5 -> mword ty5 -> mword ty5 -> f_bin_op_S -> M Retired\<close>\<close>

definition execute_F_BIN_TYPE_S  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow> f_bin_op_S \<Rightarrow>((register_value),(Retired),(exception))monad \<close>  where 
     \<open> execute_F_BIN_TYPE_S arg0 arg1 arg2 arg3 = (
   (let merge_var = (arg0, arg1, arg2, arg3) in
   (case  merge_var of
     (rs2, rs1, rd, FSGNJ_S) =>
      (rF_bits rs1  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
      (let rs1_val_S = ((nan_unbox w__0  ::  32 Word.word)) in
      (rF_bits rs2  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
      (let rs2_val_S = ((nan_unbox w__1  ::  32 Word.word)) in
      (let (s1, e1, m1) = ((fsplit_S rs1_val_S  :: ( 1 Word.word *  8 Word.word *  23 Word.word))) in
      (let (s2, e2, m2) = ((fsplit_S rs2_val_S  :: ( 1 Word.word *  8 Word.word *  23 Word.word))) in
      (let rd_val_S = ((fmake_S s2 e1 m1  ::  32 Word.word)) in
      wF_bits rd ((nan_box rd_val_S  ::  64 Word.word)) \<then> return RETIRE_SUCCESS)))))))))
   | (rs2, rs1, rd, FSGNJN_S) =>
      (rF_bits rs1  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
      (let rs1_val_S = ((nan_unbox w__0  ::  32 Word.word)) in
      (rF_bits rs2  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
      (let rs2_val_S = ((nan_unbox w__1  ::  32 Word.word)) in
      (let (s1, e1, m1) = ((fsplit_S rs1_val_S  :: ( 1 Word.word *  8 Word.word *  23 Word.word))) in
      (let (s2, e2, m2) = ((fsplit_S rs2_val_S  :: ( 1 Word.word *  8 Word.word *  23 Word.word))) in
      (let rd_val_S = ((fmake_S ((xor_vec ( 0b1 ::  1 Word.word) s2  ::  1 Word.word)) e1 m1  ::  32 Word.word)) in
      wF_bits rd ((nan_box rd_val_S  ::  64 Word.word)) \<then> return RETIRE_SUCCESS)))))))))
   | (rs2, rs1, rd, FSGNJX_S) =>
      (rF_bits rs1  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
      (let rs1_val_S = ((nan_unbox w__0  ::  32 Word.word)) in
      (rF_bits rs2  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
      (let rs2_val_S = ((nan_unbox w__1  ::  32 Word.word)) in
      (let (s1, e1, m1) = ((fsplit_S rs1_val_S  :: ( 1 Word.word *  8 Word.word *  23 Word.word))) in
      (let (s2, e2, m2) = ((fsplit_S rs2_val_S  :: ( 1 Word.word *  8 Word.word *  23 Word.word))) in
      (let rd_val_S = ((fmake_S ((xor_vec s1 s2  ::  1 Word.word)) e1 m1  ::  32 Word.word)) in
      wF_bits rd ((nan_box rd_val_S  ::  64 Word.word)) \<then> return RETIRE_SUCCESS)))))))))
   | (rs2, rs1, rd, FMIN_S) =>
      (rF_bits rs1  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
      (let rs1_val_S = ((nan_unbox w__0  ::  32 Word.word)) in
      (rF_bits rs2  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
      (let rs2_val_S = ((nan_unbox w__1  ::  32 Word.word)) in
      (let is_quiet = True in
      (let (rs1_lt_rs2, fflags) = ((fle_S rs1_val_S rs2_val_S is_quiet  :: (bool *  5 Word.word))) in
      (let rd_val_S =
        (if (((((f_is_NaN_S rs1_val_S)) \<and> ((f_is_NaN_S rs2_val_S))))) then
          (canonical_NaN_S ()   ::  32 Word.word)
        else if ((f_is_NaN_S rs1_val_S)) then rs2_val_S
        else if ((f_is_NaN_S rs2_val_S)) then rs1_val_S
        else if (((((f_is_neg_zero_S rs1_val_S)) \<and> ((f_is_pos_zero_S rs2_val_S))))) then
          rs1_val_S
        else if (((((f_is_neg_zero_S rs2_val_S)) \<and> ((f_is_pos_zero_S rs1_val_S))))) then
          rs2_val_S
        else if rs1_lt_rs2 then rs1_val_S
        else rs2_val_S) in
      (accrue_fflags fflags \<then> wF_bits rd ((nan_box rd_val_S  ::  64 Word.word))) \<then> return RETIRE_SUCCESS)))))))))
   | (rs2, rs1, rd, FMAX_S) =>
      (rF_bits rs1  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
      (let rs1_val_S = ((nan_unbox w__0  ::  32 Word.word)) in
      (rF_bits rs2  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
      (let rs2_val_S = ((nan_unbox w__1  ::  32 Word.word)) in
      (let is_quiet = True in
      (let (rs2_lt_rs1, fflags) = ((fle_S rs2_val_S rs1_val_S is_quiet  :: (bool *  5 Word.word))) in
      (let rd_val_S =
        (if (((((f_is_NaN_S rs1_val_S)) \<and> ((f_is_NaN_S rs2_val_S))))) then
          (canonical_NaN_S ()   ::  32 Word.word)
        else if ((f_is_NaN_S rs1_val_S)) then rs2_val_S
        else if ((f_is_NaN_S rs2_val_S)) then rs1_val_S
        else if (((((f_is_neg_zero_S rs1_val_S)) \<and> ((f_is_pos_zero_S rs2_val_S))))) then
          rs2_val_S
        else if (((((f_is_neg_zero_S rs2_val_S)) \<and> ((f_is_pos_zero_S rs1_val_S))))) then
          rs1_val_S
        else if rs2_lt_rs1 then rs1_val_S
        else rs2_val_S) in
      (accrue_fflags fflags \<then> wF_bits rd ((nan_box rd_val_S  ::  64 Word.word))) \<then> return RETIRE_SUCCESS)))))))))
   | (rs2, rs1, rd, FEQ_S) =>
      (rF_bits rs1  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
      (let rs1_val_S = ((nan_unbox w__0  ::  32 Word.word)) in
      (rF_bits rs2  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
      (let rs2_val_S = ((nan_unbox w__1  ::  32 Word.word)) in
      (riscv_f32Eq rs1_val_S rs2_val_S  :: (( 5 Word.word *  32 Word.word)) M) \<bind> ((\<lambda> varstup .  (let ((fflags ::
        bits_fflags), (rd_val :: bits_WU)) = varstup in
      (write_fflags fflags \<then>
      wX_bits rd ((EXTZ (( 64 :: int)::ii) rd_val  ::  64 Word.word))) \<then> return RETIRE_SUCCESS)))))))))
   | (rs2, rs1, rd, FLT_S) =>
      (rF_bits rs1  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
      (let rs1_val_S = ((nan_unbox w__0  ::  32 Word.word)) in
      (rF_bits rs2  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
      (let rs2_val_S = ((nan_unbox w__1  ::  32 Word.word)) in
      (riscv_f32Lt rs1_val_S rs2_val_S  :: (( 5 Word.word *  32 Word.word)) M) \<bind> ((\<lambda> varstup .  (let ((fflags ::
        bits_fflags), (rd_val :: bits_WU)) = varstup in
      (write_fflags fflags \<then>
      wX_bits rd ((EXTZ (( 64 :: int)::ii) rd_val  ::  64 Word.word))) \<then> return RETIRE_SUCCESS)))))))))
   | (rs2, rs1, rd, FLE_S) =>
      (rF_bits rs1  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
      (let rs1_val_S = ((nan_unbox w__0  ::  32 Word.word)) in
      (rF_bits rs2  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
      (let rs2_val_S = ((nan_unbox w__1  ::  32 Word.word)) in
      (riscv_f32Le rs1_val_S rs2_val_S  :: (( 5 Word.word *  32 Word.word)) M) \<bind> ((\<lambda> varstup .  (let ((fflags ::
        bits_fflags), (rd_val :: bits_WU)) = varstup in
      (write_fflags fflags \<then>
      wX_bits rd ((EXTZ (( 64 :: int)::ii) rd_val  ::  64 Word.word))) \<then> return RETIRE_SUCCESS)))))))))
   )))\<close> 
  for  arg0  :: "(5)Word.word " 
  and  arg1  :: "(5)Word.word " 
  and  arg2  :: "(5)Word.word " 
  and  arg3  :: " f_bin_op_S "


\<comment> \<open>\<open>val execute_F_BIN_TYPE_D : mword ty5 -> mword ty5 -> mword ty5 -> f_bin_op_D -> M Retired\<close>\<close>

definition execute_F_BIN_TYPE_D  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow> f_bin_op_D \<Rightarrow>((register_value),(Retired),(exception))monad \<close>  where 
     \<open> execute_F_BIN_TYPE_D arg0 arg1 arg2 arg3 = (
   (let merge_var = (arg0, arg1, arg2, arg3) in
   (case  merge_var of
     (rs2, rs1, rd, FSGNJ_D) =>
      (rF_bits rs1  :: ( 64 Word.word) M) \<bind> ((\<lambda> rs1_val_D . 
      (rF_bits rs2  :: ( 64 Word.word) M) \<bind> ((\<lambda> rs2_val_D . 
      (let (s1, e1, m1) = ((fsplit_D rs1_val_D  :: ( 1 Word.word *  11 Word.word *  52 Word.word))) in
      (let (s2, e2, m2) = ((fsplit_D rs2_val_D  :: ( 1 Word.word *  11 Word.word *  52 Word.word))) in
      (let rd_val_D = ((fmake_D s2 e1 m1  ::  64 Word.word)) in
      wF_bits rd rd_val_D \<then> return RETIRE_SUCCESS)))))))
   | (rs2, rs1, rd, FSGNJN_D) =>
      (rF_bits rs1  :: ( 64 Word.word) M) \<bind> ((\<lambda> rs1_val_D . 
      (rF_bits rs2  :: ( 64 Word.word) M) \<bind> ((\<lambda> rs2_val_D . 
      (let (s1, e1, m1) = ((fsplit_D rs1_val_D  :: ( 1 Word.word *  11 Word.word *  52 Word.word))) in
      (let (s2, e2, m2) = ((fsplit_D rs2_val_D  :: ( 1 Word.word *  11 Word.word *  52 Word.word))) in
      (let rd_val_D = ((fmake_D ((xor_vec ( 0b1 ::  1 Word.word) s2  ::  1 Word.word)) e1 m1  ::  64 Word.word)) in
      wF_bits rd rd_val_D \<then> return RETIRE_SUCCESS)))))))
   | (rs2, rs1, rd, FSGNJX_D) =>
      (rF_bits rs1  :: ( 64 Word.word) M) \<bind> ((\<lambda> rs1_val_D . 
      (rF_bits rs2  :: ( 64 Word.word) M) \<bind> ((\<lambda> rs2_val_D . 
      (let (s1, e1, m1) = ((fsplit_D rs1_val_D  :: ( 1 Word.word *  11 Word.word *  52 Word.word))) in
      (let (s2, e2, m2) = ((fsplit_D rs2_val_D  :: ( 1 Word.word *  11 Word.word *  52 Word.word))) in
      (let rd_val_D = ((fmake_D ((xor_vec s1 s2  ::  1 Word.word)) e1 m1  ::  64 Word.word)) in
      wF_bits rd rd_val_D \<then> return RETIRE_SUCCESS)))))))
   | (rs2, rs1, rd, FMIN_D) =>
      (rF_bits rs1  :: ( 64 Word.word) M) \<bind> ((\<lambda> rs1_val_D . 
      (rF_bits rs2  :: ( 64 Word.word) M) \<bind> ((\<lambda> rs2_val_D . 
      (let is_quiet = True in
      (let (rs1_lt_rs2, fflags) = ((fle_D rs1_val_D rs2_val_D is_quiet  :: (bool *  5 Word.word))) in
      (let rd_val_D =
        (if (((((f_is_NaN_D rs1_val_D)) \<and> ((f_is_NaN_D rs2_val_D))))) then
          (canonical_NaN_D ()   ::  64 Word.word)
        else if ((f_is_NaN_D rs1_val_D)) then rs2_val_D
        else if ((f_is_NaN_D rs2_val_D)) then rs1_val_D
        else if (((((f_is_neg_zero_D rs1_val_D)) \<and> ((f_is_pos_zero_D rs2_val_D))))) then
          rs1_val_D
        else if (((((f_is_neg_zero_D rs2_val_D)) \<and> ((f_is_pos_zero_D rs1_val_D))))) then
          rs2_val_D
        else if rs1_lt_rs2 then rs1_val_D
        else rs2_val_D) in
      (accrue_fflags fflags \<then> wF_bits rd rd_val_D) \<then> return RETIRE_SUCCESS)))))))
   | (rs2, rs1, rd, FMAX_D) =>
      (rF_bits rs1  :: ( 64 Word.word) M) \<bind> ((\<lambda> rs1_val_D . 
      (rF_bits rs2  :: ( 64 Word.word) M) \<bind> ((\<lambda> rs2_val_D . 
      (let is_quiet = True in
      (let (rs2_lt_rs1, fflags) = ((fle_D rs2_val_D rs1_val_D is_quiet  :: (bool *  5 Word.word))) in
      (let rd_val_D =
        (if (((((f_is_NaN_D rs1_val_D)) \<and> ((f_is_NaN_D rs2_val_D))))) then
          (canonical_NaN_D ()   ::  64 Word.word)
        else if ((f_is_NaN_D rs1_val_D)) then rs2_val_D
        else if ((f_is_NaN_D rs2_val_D)) then rs1_val_D
        else if (((((f_is_neg_zero_D rs1_val_D)) \<and> ((f_is_pos_zero_D rs2_val_D))))) then
          rs2_val_D
        else if (((((f_is_neg_zero_D rs2_val_D)) \<and> ((f_is_pos_zero_D rs1_val_D))))) then
          rs1_val_D
        else if rs2_lt_rs1 then rs1_val_D
        else rs2_val_D) in
      (accrue_fflags fflags \<then> wF_bits rd rd_val_D) \<then> return RETIRE_SUCCESS)))))))
   | (rs2, rs1, rd, FEQ_D) =>
      (rF_bits rs1  :: ( 64 Word.word) M) \<bind> ((\<lambda> rs1_val_D . 
      (rF_bits rs2  :: ( 64 Word.word) M) \<bind> ((\<lambda> rs2_val_D . 
      (riscv_f64Eq rs1_val_D rs2_val_D  :: (( 5 Word.word *  64 Word.word)) M) \<bind> ((\<lambda> varstup .  (let ((fflags ::
        bits_fflags), (rd_val :: bits_LU)) = varstup in
      (write_fflags fflags \<then> wX_bits rd rd_val) \<then> return RETIRE_SUCCESS)))))))
   | (rs2, rs1, rd, FLT_D) =>
      (rF_bits rs1  :: ( 64 Word.word) M) \<bind> ((\<lambda> rs1_val_D . 
      (rF_bits rs2  :: ( 64 Word.word) M) \<bind> ((\<lambda> rs2_val_D . 
      (riscv_f64Lt rs1_val_D rs2_val_D  :: (( 5 Word.word *  64 Word.word)) M) \<bind> ((\<lambda> varstup .  (let ((fflags ::
        bits_fflags), (rd_val :: bits_LU)) = varstup in
      (write_fflags fflags \<then> wX_bits rd rd_val) \<then> return RETIRE_SUCCESS)))))))
   | (rs2, rs1, rd, FLE_D) =>
      (rF_bits rs1  :: ( 64 Word.word) M) \<bind> ((\<lambda> rs1_val_D . 
      (rF_bits rs2  :: ( 64 Word.word) M) \<bind> ((\<lambda> rs2_val_D . 
      (riscv_f64Le rs1_val_D rs2_val_D  :: (( 5 Word.word *  64 Word.word)) M) \<bind> ((\<lambda> varstup .  (let ((fflags ::
        bits_fflags), (rd_val :: bits_LU)) = varstup in
      (write_fflags fflags \<then> wX_bits rd rd_val) \<then> return RETIRE_SUCCESS)))))))
   )))\<close> 
  for  arg0  :: "(5)Word.word " 
  and  arg1  :: "(5)Word.word " 
  and  arg2  :: "(5)Word.word " 
  and  arg3  :: " f_bin_op_D "


\<comment> \<open>\<open>val execute_F_BIN_RM_TYPE_S : mword ty5 -> mword ty5 -> rounding_mode -> mword ty5 -> f_bin_rm_op_S -> M Retired\<close>\<close>

definition execute_F_BIN_RM_TYPE_S  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow> rounding_mode \<Rightarrow>(5)Word.word \<Rightarrow> f_bin_rm_op_S \<Rightarrow>((register_value),(Retired),(exception))monad \<close>  where 
     \<open> execute_F_BIN_RM_TYPE_S rs2 rs1 rm rd op1 = (
   (rF_bits rs1  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (let rs1_val_32b = ((nan_unbox w__0  ::  32 Word.word)) in
   (rF_bits rs2  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
   (let rs2_val_32b = ((nan_unbox w__1  ::  32 Word.word)) in
   select_instr_or_fcsr_rm rm \<bind> ((\<lambda> (w__2 :: rounding_mode) . 
   (let rm_3b = ((encdec_rounding_mode_forwards w__2  ::  3 Word.word)) in
   (case  op1 of
     FADD_S => (riscv_f32Add rm_3b rs1_val_32b rs2_val_32b  :: (( 5 Word.word *  32 Word.word)) M)
   | FSUB_S => (riscv_f32Sub rm_3b rs1_val_32b rs2_val_32b  :: (( 5 Word.word *  32 Word.word)) M)
   | FMUL_S => (riscv_f32Mul rm_3b rs1_val_32b rs2_val_32b  :: (( 5 Word.word *  32 Word.word)) M)
   | FDIV_S => (riscv_f32Div rm_3b rs1_val_32b rs2_val_32b  :: (( 5 Word.word *  32 Word.word)) M)
   ) \<bind> ((\<lambda> varstup .  (let ((fflags :: 5 bits), (rd_val_32b :: 32 bits)) = varstup in
   (write_fflags fflags \<then> wF_bits rd ((nan_box rd_val_32b  ::  64 Word.word))) \<then> return RETIRE_SUCCESS)))))))))))))\<close> 
  for  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rm  :: " rounding_mode " 
  and  rd  :: "(5)Word.word " 
  and  op1  :: " f_bin_rm_op_S "


\<comment> \<open>\<open>val execute_F_BIN_RM_TYPE_D : mword ty5 -> mword ty5 -> rounding_mode -> mword ty5 -> f_bin_rm_op_D -> M Retired\<close>\<close>

definition execute_F_BIN_RM_TYPE_D  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow> rounding_mode \<Rightarrow>(5)Word.word \<Rightarrow> f_bin_rm_op_D \<Rightarrow>((register_value),(Retired),(exception))monad \<close>  where 
     \<open> execute_F_BIN_RM_TYPE_D rs2 rs1 rm rd op1 = (
   (rF_bits rs1  :: ( 64 Word.word) M) \<bind> ((\<lambda> rs1_val_64b . 
   (rF_bits rs2  :: ( 64 Word.word) M) \<bind> ((\<lambda> rs2_val_64b . 
   select_instr_or_fcsr_rm rm \<bind> ((\<lambda> (w__0 :: rounding_mode) . 
   (let rm_3b = ((encdec_rounding_mode_forwards w__0  ::  3 Word.word)) in
   (case  op1 of
     FADD_D => (riscv_f64Add rm_3b rs1_val_64b rs2_val_64b  :: (( 5 Word.word *  64 Word.word)) M)
   | FSUB_D => (riscv_f64Sub rm_3b rs1_val_64b rs2_val_64b  :: (( 5 Word.word *  64 Word.word)) M)
   | FMUL_D => (riscv_f64Mul rm_3b rs1_val_64b rs2_val_64b  :: (( 5 Word.word *  64 Word.word)) M)
   | FDIV_D => (riscv_f64Div rm_3b rs1_val_64b rs2_val_64b  :: (( 5 Word.word *  64 Word.word)) M)
   ) \<bind> ((\<lambda> varstup .  (let ((fflags :: 5 bits), (rd_val_64b :: 64 bits)) = varstup in
   (write_fflags fflags \<then> wF_bits rd rd_val_64b) \<then> return RETIRE_SUCCESS)))))))))))\<close> 
  for  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rm  :: " rounding_mode " 
  and  rd  :: "(5)Word.word " 
  and  op1  :: " f_bin_rm_op_D "


\<comment> \<open>\<open>val execute_FENCE_TSO : mword ty4 -> mword ty4 -> M Retired\<close>\<close>

definition execute_FENCE_TSO  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(Retired),(exception))monad \<close>  where 
     \<open> execute_FENCE_TSO pred succ = (
   (case  (pred, succ) of
     (v__1434, v__1435) =>
      if ((((((((subrange_vec_dec v__1434 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b11 ::  2 Word.word)))) \<and> (((((subrange_vec_dec v__1435 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b11 ::  2 Word.word)))))))
      then
        barrier (Barrier_RISCV_tso () )
      else
        return (if ((((((((subrange_vec_dec v__1434 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b00 ::  2 Word.word)))) \<and> (((((subrange_vec_dec v__1435 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b00 ::  2 Word.word))))))) then
                  () 
                else
                  (let (_ :: unit) = (print_endline (''FIXME: unsupported fence'')) in
                  () ))
   ) \<then>
   return RETIRE_SUCCESS )\<close> 
  for  pred  :: "(4)Word.word " 
  and  succ  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_FENCE_RESERVED : mword ty4 -> mword ty4 -> mword ty4 -> mword ty5 -> mword ty5 -> Retired\<close>\<close>

definition execute_FENCE_RESERVED  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow> Retired \<close>  where 
     \<open> execute_FENCE_RESERVED fm pred succ rs rd = ( RETIRE_SUCCESS )\<close> 
  for  fm  :: "(4)Word.word " 
  and  pred  :: "(4)Word.word " 
  and  succ  :: "(4)Word.word " 
  and  rs  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_FENCEI_RESERVED : mword ty12 -> mword ty5 -> mword ty5 -> Retired\<close>\<close>

definition execute_FENCEI_RESERVED  :: \<open>(12)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow> Retired \<close>  where 
     \<open> execute_FENCEI_RESERVED imm rs rd = ( RETIRE_SUCCESS )\<close> 
  for  imm  :: "(12)Word.word " 
  and  rs  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_FENCEI : unit -> Retired\<close>\<close>

definition execute_FENCEI  :: \<open> unit \<Rightarrow> Retired \<close>  where 
     \<open> execute_FENCEI _ = ( RETIRE_SUCCESS )\<close>


\<comment> \<open>\<open>val execute_FENCE : mword ty4 -> mword ty4 -> M Retired\<close>\<close>

definition execute_FENCE  :: \<open>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(Retired),(exception))monad \<close>  where 
     \<open> execute_FENCE pred succ = (
   (case  (pred, succ) of
     (v__1394, v__1395) =>
      if ((((((((subrange_vec_dec v__1394 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b11 ::  2 Word.word)))) \<and> (((((subrange_vec_dec v__1395 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b11 ::  2 Word.word)))))))
      then
        barrier (Barrier_RISCV_rw_rw () )
      else if ((((((((subrange_vec_dec v__1394 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b10 ::  2 Word.word)))) \<and> (((((subrange_vec_dec v__1395 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b11 ::  2 Word.word))))))) then
        barrier (Barrier_RISCV_r_rw () )
      else if ((((((((subrange_vec_dec v__1394 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b10 ::  2 Word.word)))) \<and> (((((subrange_vec_dec v__1395 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b10 ::  2 Word.word))))))) then
        barrier (Barrier_RISCV_r_r () )
      else if ((((((((subrange_vec_dec v__1394 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b11 ::  2 Word.word)))) \<and> (((((subrange_vec_dec v__1395 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b01 ::  2 Word.word))))))) then
        barrier (Barrier_RISCV_rw_w () )
      else if ((((((((subrange_vec_dec v__1394 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b01 ::  2 Word.word)))) \<and> (((((subrange_vec_dec v__1395 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b01 ::  2 Word.word))))))) then
        barrier (Barrier_RISCV_w_w () )
      else if ((((((((subrange_vec_dec v__1394 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b01 ::  2 Word.word)))) \<and> (((((subrange_vec_dec v__1395 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b11 ::  2 Word.word))))))) then
        barrier (Barrier_RISCV_w_rw () )
      else if ((((((((subrange_vec_dec v__1394 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b11 ::  2 Word.word)))) \<and> (((((subrange_vec_dec v__1395 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b10 ::  2 Word.word))))))) then
        barrier (Barrier_RISCV_rw_r () )
      else if ((((((((subrange_vec_dec v__1394 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b10 ::  2 Word.word)))) \<and> (((((subrange_vec_dec v__1395 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b01 ::  2 Word.word))))))) then
        barrier (Barrier_RISCV_r_w () )
      else if ((((((((subrange_vec_dec v__1394 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b01 ::  2 Word.word)))) \<and> (((((subrange_vec_dec v__1395 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b10 ::  2 Word.word))))))) then
        barrier (Barrier_RISCV_w_r () )
      else
        return (if (((((subrange_vec_dec v__1395 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b00 ::  2 Word.word)))) then
                  () 
                else if (((((subrange_vec_dec v__1394 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b00 ::  2 Word.word)))) then
                  () 
                else
                  (let (_ :: unit) = (print_endline (''FIXME: unsupported fence'')) in
                  () ))
   ) \<then>
   return RETIRE_SUCCESS )\<close> 
  for  pred  :: "(4)Word.word " 
  and  succ  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_ECALL : unit -> M Retired\<close>\<close>

definition execute_ECALL  :: \<open> unit \<Rightarrow>((register_value),(Retired),(exception))monad \<close>  where 
     \<open> execute_ECALL _ = (
   read_reg cur_privilege_ref \<bind> ((\<lambda> (w__0 :: Privilege) . 
   (let (t :: sync_exception) =
     ((| sync_exception_trap =
          ((case  w__0 of
            User => E_U_EnvCall () 
          | Supervisor => E_S_EnvCall () 
          | Machine => E_M_EnvCall () 
          )), 
        sync_exception_excinfo = None, 
        sync_exception_ext_exception = None |)) in
   read_reg cur_privilege_ref \<bind> ((\<lambda> (w__1 :: Privilege) . 
   (read_reg PC_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
   (exception_handler w__1 (CTL_TRAP t) w__2  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__3 ::  64 Word.word) . 
   set_next_pc w__3 \<then> return RETIRE_FAIL))))))))))\<close>


\<comment> \<open>\<open>val execute_EBREAK : unit -> M Retired\<close>\<close>

definition execute_EBREAK  :: \<open> unit \<Rightarrow>((register_value),(Retired),(exception))monad \<close>  where 
     \<open> execute_EBREAK _ = (
   (read_reg PC_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   handle_mem_exception w__0 (E_Breakpoint () ) \<then> return RETIRE_FAIL)))\<close>


\<comment> \<open>\<open>val execute_DIVW : mword ty5 -> mword ty5 -> mword ty5 -> bool -> M Retired\<close>\<close>

definition execute_DIVW  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow> bool \<Rightarrow>((register_value),(Retired),(exception))monad \<close>  where 
     \<open> execute_DIVW rs2 rs1 rd s = (
   haveMulDiv ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (rX_bits rs1  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
     (let rs1_val = ((subrange_vec_dec w__1 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)) in
     (rX_bits rs2  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
     (let rs2_val = ((subrange_vec_dec w__2 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)) in
     (let (rs1_int :: ii) = (if s then Word.sint rs1_val else Word.uint rs1_val) in
     (let (rs2_int :: ii) = (if s then Word.sint rs2_val else Word.uint rs2_val) in
     (let (q :: ii) = (if (((rs2_int = (( 0 :: int)::ii)))) then ((( 0 :: int)-( 1 :: int))::ii) else hardware_quot rs1_int rs2_int) in
     (let (q' :: ii) =
       (if (((s \<and> ((q > ((((pow2 (( 31 :: int)::ii))) - (( 1 :: int)::ii)))))))) then
         (( 0 :: int)::ii) - ((pow (( 2 :: int)::ii) (( 31 :: int)::ii)))
       else q) in
     wX_bits rd ((EXTS (( 64 :: int)::ii) ((to_bits (( 32 :: int)::ii) q'  ::  32 Word.word))  ::  64 Word.word)) \<then>
     return RETIRE_SUCCESS))))))))))
   else handle_illegal ()  \<then> return RETIRE_FAIL)))\<close> 
  for  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  s  :: " bool "


\<comment> \<open>\<open>val execute_DIV : mword ty5 -> mword ty5 -> mword ty5 -> bool -> M Retired\<close>\<close>

definition execute_DIV  :: \<open>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow> bool \<Rightarrow>((register_value),(Retired),(exception))monad \<close>  where 
     \<open> execute_DIV rs2 rs1 rd s = (
   haveMulDiv ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     (rX_bits rs1  :: ( 64 Word.word) M) \<bind> ((\<lambda> rs1_val . 
     (rX_bits rs2  :: ( 64 Word.word) M) \<bind> ((\<lambda> rs2_val . 
     (let (rs1_int :: ii) = (if s then Word.sint rs1_val else Word.uint rs1_val) in
     (let (rs2_int :: ii) = (if s then Word.sint rs2_val else Word.uint rs2_val) in
     (let (q :: ii) = (if (((rs2_int = (( 0 :: int)::ii)))) then ((( 0 :: int)-( 1 :: int))::ii) else hardware_quot rs1_int rs2_int) in
     (let (q' :: ii) = (if (((s \<and> ((q > xlen_max_signed))))) then xlen_min_signed else q) in
     wX_bits rd ((to_bits (( 64 :: int)::ii) q'  ::  64 Word.word)) \<then> return RETIRE_SUCCESS))))))))
   else handle_illegal ()  \<then> return RETIRE_FAIL)))\<close> 
  for  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  s  :: " bool "


\<comment> \<open>\<open>val execute_C_SRLI_HINT : mword ty3 -> Retired\<close>\<close>

definition execute_C_SRLI_HINT  :: \<open>(3)Word.word \<Rightarrow> Retired \<close>  where 
     \<open> execute_C_SRLI_HINT rsd = ( RETIRE_SUCCESS )\<close> 
  for  rsd  :: "(3)Word.word "


\<comment> \<open>\<open>val execute_C_SRAI_HINT : mword ty3 -> Retired\<close>\<close>

definition execute_C_SRAI_HINT  :: \<open>(3)Word.word \<Rightarrow> Retired \<close>  where 
     \<open> execute_C_SRAI_HINT rsd = ( RETIRE_SUCCESS )\<close> 
  for  rsd  :: "(3)Word.word "


\<comment> \<open>\<open>val execute_C_SLLI_HINT : mword ty6 -> mword ty5 -> Retired\<close>\<close>

definition execute_C_SLLI_HINT  :: \<open>(6)Word.word \<Rightarrow>(5)Word.word \<Rightarrow> Retired \<close>  where 
     \<open> execute_C_SLLI_HINT shamt rsd = ( RETIRE_SUCCESS )\<close> 
  for  shamt  :: "(6)Word.word " 
  and  rsd  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_C_NOP_HINT : mword ty6 -> Retired\<close>\<close>

definition execute_C_NOP_HINT  :: \<open>(6)Word.word \<Rightarrow> Retired \<close>  where 
     \<open> execute_C_NOP_HINT imm = ( RETIRE_SUCCESS )\<close> 
  for  imm  :: "(6)Word.word "


\<comment> \<open>\<open>val execute_C_NOP : unit -> Retired\<close>\<close>

definition execute_C_NOP  :: \<open> unit \<Rightarrow> Retired \<close>  where 
     \<open> execute_C_NOP _ = ( RETIRE_SUCCESS )\<close>


\<comment> \<open>\<open>val execute_C_MV_HINT : mword ty5 -> Retired\<close>\<close>

definition execute_C_MV_HINT  :: \<open>(5)Word.word \<Rightarrow> Retired \<close>  where 
     \<open> execute_C_MV_HINT rs2 = ( RETIRE_SUCCESS )\<close> 
  for  rs2  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_C_LUI_HINT : mword ty6 -> Retired\<close>\<close>

definition execute_C_LUI_HINT  :: \<open>(6)Word.word \<Rightarrow> Retired \<close>  where 
     \<open> execute_C_LUI_HINT imm = ( RETIRE_SUCCESS )\<close> 
  for  imm  :: "(6)Word.word "


\<comment> \<open>\<open>val execute_C_LI_HINT : mword ty6 -> Retired\<close>\<close>

definition execute_C_LI_HINT  :: \<open>(6)Word.word \<Rightarrow> Retired \<close>  where 
     \<open> execute_C_LI_HINT imm = ( RETIRE_SUCCESS )\<close> 
  for  imm  :: "(6)Word.word "


\<comment> \<open>\<open>val execute_C_ILLEGAL : mword ty16 -> M Retired\<close>\<close>

definition execute_C_ILLEGAL  :: \<open>(16)Word.word \<Rightarrow>((register_value),(Retired),(exception))monad \<close>  where 
     \<open> execute_C_ILLEGAL s = ( handle_illegal ()  \<then> return RETIRE_FAIL )\<close> 
  for  s  :: "(16)Word.word "


\<comment> \<open>\<open>val execute_C_ADD_HINT : mword ty5 -> Retired\<close>\<close>

definition execute_C_ADD_HINT  :: \<open>(5)Word.word \<Rightarrow> Retired \<close>  where 
     \<open> execute_C_ADD_HINT rs2 = ( RETIRE_SUCCESS )\<close> 
  for  rs2  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_C_ADDI_HINT : mword ty5 -> Retired\<close>\<close>

definition execute_C_ADDI_HINT  :: \<open>(5)Word.word \<Rightarrow> Retired \<close>  where 
     \<open> execute_C_ADDI_HINT rsd = ( RETIRE_SUCCESS )\<close> 
  for  rsd  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_CSR : mword ty12 -> mword ty5 -> mword ty5 -> bool -> csrop -> M Retired\<close>\<close>

definition execute_CSR  :: \<open>(12)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow> bool \<Rightarrow> csrop \<Rightarrow>((register_value),(Retired),(exception))monad \<close>  where 
     \<open> execute_CSR csr rs1 rd is_imm op1 = (
   (if is_imm then return ((EXTZ (( 64 :: int)::ii) rs1  ::  64 Word.word))
    else (rX_bits rs1  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (rs1_val :: xlenbits) . 
   (let (isWrite :: bool) =
     ((case  op1 of
       CSRRW => True
     | _ => if is_imm then (((Word.uint rs1_val)) \<noteq> (( 0 :: int)::ii)) else (((Word.uint rs1)) \<noteq> (( 0 :: int)::ii))
     )) in
   read_reg cur_privilege_ref \<bind> ((\<lambda> (w__1 :: Privilege) . 
   check_CSR csr w__1 isWrite \<bind> ((\<lambda> (w__2 :: bool) . 
   if ((\<not> w__2)) then handle_illegal ()  \<then> return RETIRE_FAIL
   else
     read_reg cur_privilege_ref \<bind> ((\<lambda> (w__3 :: Privilege) . 
     if ((\<not> ((ext_check_CSR csr w__3 isWrite)))) then
       (let (_ :: unit) = (ext_check_CSR_fail () ) in
       return RETIRE_FAIL)
     else
       (readCSR csr  :: ( 64 Word.word) M) \<bind> ((\<lambda> csr_val . 
       ((if isWrite then
          (let (new_val :: xlenbits) =
            ((case  op1 of
              CSRRW => rs1_val
            | CSRRS => (or_vec csr_val rs1_val  ::  64 Word.word)
            | CSRRC => (and_vec csr_val ((not_vec rs1_val  ::  64 Word.word))  ::  64 Word.word)
            )) in
          writeCSR csr new_val)
        else return () ) \<then>
       wX_bits rd csr_val) \<then> return RETIRE_SUCCESS))))))))))))\<close> 
  for  csr  :: "(12)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  is_imm  :: " bool " 
  and  op1  :: " csrop "


\<comment> \<open>\<open>val execute_BTYPE : mword ty13 -> mword ty5 -> mword ty5 -> bop -> M Retired\<close>\<close>

definition execute_BTYPE  :: \<open>(13)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow> bop \<Rightarrow>((register_value),(Retired),(exception))monad \<close>  where 
     \<open> execute_BTYPE imm rs2 rs1 op1 = (
   (rX_bits rs1  :: ( 64 Word.word) M) \<bind> ((\<lambda> rs1_val . 
   (rX_bits rs2  :: ( 64 Word.word) M) \<bind> ((\<lambda> rs2_val . 
   (let (taken :: bool) =
     ((case  op1 of
       RISCV_BEQ => (rs1_val = rs2_val)
     | RISCV_BNE => (rs1_val \<noteq> rs2_val)
     | RISCV_BLT => zopz0zI_s rs1_val rs2_val
     | RISCV_BGE => zopz0zKzJ_s rs1_val rs2_val
     | RISCV_BLTU => zopz0zI_u rs1_val rs2_val
     | RISCV_BGEU => zopz0zKzJ_u rs1_val rs2_val
     )) in
   (read_reg PC_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (let (t :: xlenbits) = ((add_vec w__0 ((EXTS (( 64 :: int)::ii) imm  ::  64 Word.word))  ::  64 Word.word)) in
   if taken then
     (case  ((ext_control_check_pc t)) of
       Ext_ControlAddr_Error (e) =>
        (let (_ :: unit) = (ext_handle_control_check_error e) in
        return RETIRE_FAIL)
     | Ext_ControlAddr_OK (target) =>
        and_boolM (return ((bit_to_bool ((access_vec_dec target (( 1 :: int)::ii))))))
          (haveRVC ()  \<bind> ((\<lambda> (w__1 :: bool) .  return ((\<not> w__1))))) \<bind> ((\<lambda> (w__2 :: bool) . 
        if w__2 then handle_mem_exception target (E_Fetch_Addr_Align () ) \<then> return RETIRE_FAIL
        else set_next_pc target \<then> return RETIRE_SUCCESS))
     )
   else return RETIRE_SUCCESS)))))))))\<close> 
  for  imm  :: "(13)Word.word " 
  and  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  op1  :: " bop "


\<comment> \<open>\<open>val execute_AMO : amoop -> bool -> bool -> mword ty5 -> mword ty5 -> word_width -> mword ty5 -> M Retired\<close>\<close>

definition execute_AMO  :: \<open> amoop \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow> word_width \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(Retired),(exception))monad \<close>  where 
     \<open> execute_AMO op1 aq rl rs2 rs1 width rd = (
   haveAtomics ()  \<bind> ((\<lambda> (w__0 :: bool) . 
   if w__0 then
     ext_data_get_addr rs1 ((zeros_implicit (( 64 :: int)::ii)  ::  64 Word.word)) (ReadWrite (Data, Data)) width \<bind> ((\<lambda> (w__1 :: unit
       Ext_DataAddr_Check) . 
     (case  w__1 of
       Ext_DataAddr_Error (e) =>
        (let (_ :: unit) = (ext_handle_data_check_error e) in
        return RETIRE_FAIL)
     | Ext_DataAddr_OK (vaddr) =>
        (translateAddr vaddr (ReadWrite (Data, Data))  :: ( (( 64 Word.word), ExceptionType)TR_Result) M) \<bind> ((\<lambda> (w__2 :: (( 64 Word.word), ExceptionType)
          TR_Result) . 
        (case  w__2 of
          TR_Failure ((e, _)) => handle_mem_exception vaddr e \<then> return RETIRE_FAIL
        | TR_Address ((addr, _)) => 
  (case  (width, (( 64 :: int):: ii)) of
        (BYTE, g__326) => mem_write_ea addr (( 1 :: int):: ii)
                            (((aq \<and> rl))) rl True
    | (HALF, g__327) => mem_write_ea addr (( 2 :: int):: ii)
                          (((aq \<and> rl))) rl True
    | (WORD, g__328) => mem_write_ea addr (( 4 :: int):: ii)
                          (((aq \<and> rl))) rl True
    | (DOUBLE, l__7) =>
  if (((l__7 = (( 64 :: int):: ii)))) then
    mem_write_ea addr (( 8 :: int):: ii) (((aq \<and> rl))) rl True else
    internal_error (''Unexpected AMO width'')
  ) \<bind> ((\<lambda> (eares :: unit MemoryOpResult) . 
           (let (is_unsigned :: bool) =
             ((case  op1 of   AMOMINU => True | AMOMAXU => True | _ => False )) in
           (case  width of
             BYTE =>
              if is_unsigned then
                (rX_bits rs2  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__10 ::  64 Word.word) . 
                return ((EXTZ (( 64 :: int)::ii) ((subrange_vec_dec w__10 (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))
                          ::  64 Word.word))))
              else
                (rX_bits rs2  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__11 ::  64 Word.word) . 
                return ((EXTS (( 64 :: int)::ii) ((subrange_vec_dec w__11 (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))
                          ::  64 Word.word))))
           | HALF =>
              if is_unsigned then
                (rX_bits rs2  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__13 ::  64 Word.word) . 
                return ((EXTZ (( 64 :: int)::ii) ((subrange_vec_dec w__13 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))
                          ::  64 Word.word))))
              else
                (rX_bits rs2  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__14 ::  64 Word.word) . 
                return ((EXTS (( 64 :: int)::ii) ((subrange_vec_dec w__14 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))
                          ::  64 Word.word))))
           | WORD =>
              if is_unsigned then
                (rX_bits rs2  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__16 ::  64 Word.word) . 
                return ((EXTZ (( 64 :: int)::ii) ((subrange_vec_dec w__16 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
                          ::  64 Word.word))))
              else
                (rX_bits rs2  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__17 ::  64 Word.word) . 
                return ((EXTS (( 64 :: int)::ii) ((subrange_vec_dec w__17 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
                          ::  64 Word.word))))
           | DOUBLE => (rX_bits rs2  :: ( 64 Word.word) M)
           ) \<bind> ((\<lambda> (rs2_val :: xlenbits) . 
           (case  eares of
             MemException (e) => handle_mem_exception addr e \<then> return RETIRE_FAIL
           | MemValue (_) => 
  (case  (width, (( 64 :: int):: ii)) of
        (BYTE, g__323) =>
  (mem_read (ReadWrite (Data, Data)) addr (( 1 :: int):: ii) aq
     (((aq \<and> rl))) True :: ( ( 8 Word.word) MemoryOpResult) M) \<bind>
    ((\<lambda> (w__20 :: ( 8 Word.word) MemoryOpResult) . 
     return
       ((extend_value is_unsigned w__20 :: ( 64 Word.word) MemoryOpResult))))
    | (HALF, g__324) =>
  (mem_read (ReadWrite (Data, Data)) addr (( 2 :: int):: ii) aq
     (((aq \<and> rl))) True :: ( ( 16 Word.word) MemoryOpResult) M) \<bind>
    ((\<lambda> (w__21 :: ( 16 Word.word) MemoryOpResult) . 
     return
       ((extend_value is_unsigned w__21 :: ( 64 Word.word) MemoryOpResult))))
    | (WORD, g__325) =>
  (mem_read (ReadWrite (Data, Data)) addr (( 4 :: int):: ii) aq
     (((aq \<and> rl))) True :: ( ( 32 Word.word) MemoryOpResult) M) \<bind>
    ((\<lambda> (w__22 :: ( 32 Word.word) MemoryOpResult) . 
     return
       ((extend_value is_unsigned w__22 :: ( 64 Word.word) MemoryOpResult))))
    | (DOUBLE, l__6) =>
  if (((l__6 = (( 64 :: int):: ii)))) then
    (mem_read (ReadWrite (Data, Data)) addr (( 8 :: int):: ii) aq
       (((aq \<and> rl))) True :: ( ( 64 Word.word) MemoryOpResult) M)
      \<bind>
      ((\<lambda> (w__23 :: ( 64 Word.word) MemoryOpResult) . 
       return
         ((extend_value is_unsigned w__23 :: ( 64 Word.word) MemoryOpResult))))
  else
    (internal_error (''Unexpected AMO width'') :: ( ( 64 Word.word) MemoryOpResult) M)
  ) \<bind> ((\<lambda> (mval :: xlenbits MemoryOpResult) . 
              (case  mval of
                MemException (e) => handle_mem_exception addr e \<then> return RETIRE_FAIL
              | MemValue (loaded) =>
                 (let (result :: xlenbits) =
                   ((case  op1 of
                     AMOSWAP => rs2_val
                   | AMOADD => (add_vec rs2_val loaded  ::  64 Word.word)
                   | AMOXOR => (xor_vec rs2_val loaded  ::  64 Word.word)
                   | AMOAND => (and_vec rs2_val loaded  ::  64 Word.word)
                   | AMOOR => (or_vec rs2_val loaded  ::  64 Word.word)
                   | AMOMIN =>
                      (to_bits (( 64 :: int)::ii) ((min ((Word.sint rs2_val)) ((Word.sint loaded))))  ::  64 Word.word)
                   | AMOMAX =>
                      (to_bits (( 64 :: int)::ii) ((max ((Word.sint rs2_val)) ((Word.sint loaded))))  ::  64 Word.word)
                   | AMOMINU =>
                      (to_bits (( 64 :: int)::ii) ((min ((Word.uint rs2_val)) ((Word.uint loaded))))  ::  64 Word.word)
                   | AMOMAXU =>
                      (to_bits (( 64 :: int)::ii) ((max ((Word.uint rs2_val)) ((Word.uint loaded))))  ::  64 Word.word)
                   )) in
                 (let (rval :: xlenbits) =
                   ((case  width of
                     BYTE =>
                      (EXTS (( 64 :: int)::ii) ((subrange_vec_dec loaded (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))
                        ::  64 Word.word)
                   | HALF =>
                      (EXTS (( 64 :: int)::ii) ((subrange_vec_dec loaded (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))
                        ::  64 Word.word)
                   | WORD =>
                      (EXTS (( 64 :: int)::ii) ((subrange_vec_dec loaded (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
                        ::  64 Word.word)
                   | DOUBLE => loaded
                   )) in  
  (case  (width, (( 64 :: int):: ii)) of
        (BYTE, g__320) =>
  mem_write_value addr (( 1 :: int):: ii)
    ((subrange_vec_dec result (( 7 :: int):: ii) (( 0 :: int):: ii) :: 8 Word.word))
    (((aq \<and> rl))) rl True
    | (HALF, g__321) =>
  mem_write_value addr (( 2 :: int):: ii)
    ((subrange_vec_dec result (( 15 :: int):: ii) (( 0 :: int):: ii) :: 16 Word.word))
    (((aq \<and> rl))) rl True
    | (WORD, g__322) =>
  mem_write_value addr (( 4 :: int):: ii)
    ((subrange_vec_dec result (( 31 :: int):: ii) (( 0 :: int):: ii) :: 32 Word.word))
    (((aq \<and> rl))) rl True
    | (DOUBLE, l__5) =>
  if (((l__5 = (( 64 :: int):: ii)))) then
    mem_write_value addr (( 8 :: int):: ii) result (((aq \<and> rl))) rl True
  else internal_error (''Unexpected AMO width'')
  ) \<bind> ((\<lambda> (wval :: bool MemoryOpResult) . 
                 (case  wval of
                   MemValue (True) => wX_bits rd rval \<then> return RETIRE_SUCCESS
                 | MemValue (False) => internal_error (''AMO got false from mem_write_value'')
                 | MemException (e) => handle_mem_exception addr e \<then> return RETIRE_FAIL
                 )))))
              )))
           ))))))
        )))
     )))
   else handle_illegal ()  \<then> return RETIRE_FAIL)))\<close> 
  for  op1  :: " amoop " 
  and  aq  :: " bool " 
  and  rl  :: " bool " 
  and  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  width  :: " word_width " 
  and  rd  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_ADDIW : mword ty12 -> mword ty5 -> mword ty5 -> M Retired\<close>\<close>

definition execute_ADDIW  :: \<open>(12)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(Retired),(exception))monad \<close>  where 
     \<open> execute_ADDIW imm rs1 rd = (
   (rX_bits rs1  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (let (result :: xlenbits) = ((add_vec ((EXTS (( 64 :: int)::ii) imm  ::  64 Word.word)) w__0  ::  64 Word.word)) in
   wX_bits rd
     ((EXTS (( 64 :: int)::ii) ((subrange_vec_dec result (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))  ::  64 Word.word)) \<then>
   return RETIRE_SUCCESS))))\<close> 
  for  imm  :: "(12)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "


function (sequential,domintros)  execute  :: \<open> ast \<Rightarrow>((register_value),(Retired),(exception))monad \<close>  where 
     \<open> execute (C_ADDI4SPN ((rdc, nzimm))) = (
      (let (imm :: 12 bits) =
        ((concat_vec ( 0b00 ::  2 Word.word) ((concat_vec nzimm ( 0b00 ::  2 Word.word)  ::  10 Word.word))
          ::  12 Word.word)) in
      (let rd = ((creg2reg_idx rdc  ::  5 Word.word)) in
      execute (ITYPE (imm, sp, rd, RISCV_ADDI)))))\<close> 
  for  nzimm  :: "(8)Word.word " 
  and  rdc  :: "(3)Word.word "
|\<open> execute (C_LW ((uimm, rsc, rdc))) = (
      (let (imm :: 12 bits) =
        ((EXTZ (( 12 :: int)::ii) ((concat_vec uimm ( 0b00 ::  2 Word.word)  ::  7 Word.word))  ::  12 Word.word)) in
      (let rd = ((creg2reg_idx rdc  ::  5 Word.word)) in
      (let rs = ((creg2reg_idx rsc  ::  5 Word.word)) in
      execute (LOAD (imm, rs, rd, False, WORD, False, False))))))\<close> 
  for  rsc  :: "(3)Word.word " 
  and  uimm  :: "(5)Word.word " 
  and  rdc  :: "(3)Word.word "
|\<open> execute (C_LD ((uimm, rsc, rdc))) = (
      (let (imm :: 12 bits) =
        ((EXTZ (( 12 :: int)::ii) ((concat_vec uimm ( 0b000 ::  3 Word.word)  ::  8 Word.word))  ::  12 Word.word)) in
      (let rd = ((creg2reg_idx rdc  ::  5 Word.word)) in
      (let rs = ((creg2reg_idx rsc  ::  5 Word.word)) in
      execute (LOAD (imm, rs, rd, False, DOUBLE, False, False))))))\<close> 
  for  rsc  :: "(3)Word.word " 
  and  uimm  :: "(5)Word.word " 
  and  rdc  :: "(3)Word.word "
|\<open> execute (C_SW ((uimm, rsc1, rsc2))) = (
      (let (imm :: 12 bits) =
        ((EXTZ (( 12 :: int)::ii) ((concat_vec uimm ( 0b00 ::  2 Word.word)  ::  7 Word.word))  ::  12 Word.word)) in
      (let rs1 = ((creg2reg_idx rsc1  ::  5 Word.word)) in
      (let rs2 = ((creg2reg_idx rsc2  ::  5 Word.word)) in
      execute (STORE (imm, rs2, rs1, WORD, False, False))))))\<close> 
  for  rsc2  :: "(3)Word.word " 
  and  rsc1  :: "(3)Word.word " 
  and  uimm  :: "(5)Word.word "
|\<open> execute (C_SD ((uimm, rsc1, rsc2))) = (
      (let (imm :: 12 bits) =
        ((EXTZ (( 12 :: int)::ii) ((concat_vec uimm ( 0b000 ::  3 Word.word)  ::  8 Word.word))  ::  12 Word.word)) in
      (let rs1 = ((creg2reg_idx rsc1  ::  5 Word.word)) in
      (let rs2 = ((creg2reg_idx rsc2  ::  5 Word.word)) in
      execute (STORE (imm, rs2, rs1, DOUBLE, False, False))))))\<close> 
  for  rsc2  :: "(3)Word.word " 
  and  rsc1  :: "(3)Word.word " 
  and  uimm  :: "(5)Word.word "
|\<open> execute (C_ADDI ((nzi, rsd))) = (
      (let (imm :: 12 bits) = ((EXTS (( 12 :: int)::ii) nzi  ::  12 Word.word)) in
      execute (ITYPE (imm, rsd, rsd, RISCV_ADDI))))\<close> 
  for  nzi  :: "(6)Word.word " 
  and  rsd  :: "(5)Word.word "
|\<open> execute (C_JAL (imm)) = (
      execute
        (RISCV_JAL ((EXTS (( 21 :: int)::ii) ((concat_vec imm ( 0b0 ::  1 Word.word)  ::  12 Word.word))  ::  21 Word.word),
                    ra)))\<close> 
  for  imm  :: "(11)Word.word "
|\<open> execute (C_ADDIW ((imm, rsd))) = ( execute (ADDIW ((EXTS (( 12 :: int)::ii) imm  ::  12 Word.word), rsd, rsd)))\<close> 
  for  rsd  :: "(5)Word.word " 
  and  imm  :: "(6)Word.word "
|\<open> execute (C_LI ((imm, rd))) = (
      (let (imm :: 12 bits) = ((EXTS (( 12 :: int)::ii) imm  ::  12 Word.word)) in
      execute (ITYPE (imm, zreg, rd, RISCV_ADDI))))\<close> 
  for  imm  :: "(6)Word.word " 
  and  rd  :: "(5)Word.word "
|\<open> execute (C_ADDI16SP (imm)) = (
      (let (imm :: 12 bits) =
        ((EXTS (( 12 :: int)::ii) ((concat_vec imm ( 0x0 ::  4 Word.word)  ::  10 Word.word))  ::  12 Word.word)) in
      execute (ITYPE (imm, sp, sp, RISCV_ADDI))))\<close> 
  for  imm  :: "(6)Word.word "
|\<open> execute (C_LUI ((imm, rd))) = (
      (let (res :: 20 bits) = ((EXTS (( 20 :: int)::ii) imm  ::  20 Word.word)) in
      execute (UTYPE (res, rd, RISCV_LUI))))\<close> 
  for  imm  :: "(6)Word.word " 
  and  rd  :: "(5)Word.word "
|\<open> execute (C_SRLI ((shamt, rsd))) = (
      (let rsd = ((creg2reg_idx rsd  ::  5 Word.word)) in
      execute (SHIFTIOP (shamt, rsd, rsd, RISCV_SRLI))))\<close> 
  for  rsd  :: "(3)Word.word " 
  and  shamt  :: "(6)Word.word "
|\<open> execute (C_SRAI ((shamt, rsd))) = (
      (let rsd = ((creg2reg_idx rsd  ::  5 Word.word)) in
      execute (SHIFTIOP (shamt, rsd, rsd, RISCV_SRAI))))\<close> 
  for  rsd  :: "(3)Word.word " 
  and  shamt  :: "(6)Word.word "
|\<open> execute (C_ANDI ((imm, rsd))) = (
      (let rsd = ((creg2reg_idx rsd  ::  5 Word.word)) in
      execute (ITYPE ((EXTS (( 12 :: int)::ii) imm  ::  12 Word.word), rsd, rsd, RISCV_ANDI))))\<close> 
  for  rsd  :: "(3)Word.word " 
  and  imm  :: "(6)Word.word "
|\<open> execute (C_SUB ((rsd, rs2))) = (
      (let rsd = ((creg2reg_idx rsd  ::  5 Word.word)) in
      (let rs2 = ((creg2reg_idx rs2  ::  5 Word.word)) in
      execute (RTYPE (rs2, rsd, rsd, RISCV_SUB)))))\<close> 
  for  rsd  :: "(3)Word.word " 
  and  rs2  :: "(3)Word.word "
|\<open> execute (C_XOR ((rsd, rs2))) = (
      (let rsd = ((creg2reg_idx rsd  ::  5 Word.word)) in
      (let rs2 = ((creg2reg_idx rs2  ::  5 Word.word)) in
      execute (RTYPE (rs2, rsd, rsd, RISCV_XOR)))))\<close> 
  for  rsd  :: "(3)Word.word " 
  and  rs2  :: "(3)Word.word "
|\<open> execute (C_OR ((rsd, rs2))) = (
      (let rsd = ((creg2reg_idx rsd  ::  5 Word.word)) in
      (let rs2 = ((creg2reg_idx rs2  ::  5 Word.word)) in
      execute (RTYPE (rs2, rsd, rsd, RISCV_OR)))))\<close> 
  for  rsd  :: "(3)Word.word " 
  and  rs2  :: "(3)Word.word "
|\<open> execute (C_AND ((rsd, rs2))) = (
      (let rsd = ((creg2reg_idx rsd  ::  5 Word.word)) in
      (let rs2 = ((creg2reg_idx rs2  ::  5 Word.word)) in
      execute (RTYPE (rs2, rsd, rsd, RISCV_AND)))))\<close> 
  for  rsd  :: "(3)Word.word " 
  and  rs2  :: "(3)Word.word "
|\<open> execute (C_SUBW ((rsd, rs2))) = (
      (let rsd = ((creg2reg_idx rsd  ::  5 Word.word)) in
      (let rs2 = ((creg2reg_idx rs2  ::  5 Word.word)) in
      execute (RTYPEW (rs2, rsd, rsd, RISCV_SUBW)))))\<close> 
  for  rsd  :: "(3)Word.word " 
  and  rs2  :: "(3)Word.word "
|\<open> execute (C_ADDW ((rsd, rs2))) = (
      (let rsd = ((creg2reg_idx rsd  ::  5 Word.word)) in
      (let rs2 = ((creg2reg_idx rs2  ::  5 Word.word)) in
      execute (RTYPEW (rs2, rsd, rsd, RISCV_ADDW)))))\<close> 
  for  rsd  :: "(3)Word.word " 
  and  rs2  :: "(3)Word.word "
|\<open> execute (C_J (imm)) = (
      execute
        (RISCV_JAL ((EXTS (( 21 :: int)::ii) ((concat_vec imm ( 0b0 ::  1 Word.word)  ::  12 Word.word))  ::  21 Word.word),
                    zreg)))\<close> 
  for  imm  :: "(11)Word.word "
|\<open> execute (C_BEQZ ((imm, rs))) = (
      execute
        (BTYPE ((EXTS (( 13 :: int)::ii) ((concat_vec imm ( 0b0 ::  1 Word.word)  ::  9 Word.word))  ::  13 Word.word),
                zreg,
                (creg2reg_idx rs  ::  5 Word.word),
                RISCV_BEQ)))\<close> 
  for  rs  :: "(3)Word.word " 
  and  imm  :: "(8)Word.word "
|\<open> execute (C_BNEZ ((imm, rs))) = (
      execute
        (BTYPE ((EXTS (( 13 :: int)::ii) ((concat_vec imm ( 0b0 ::  1 Word.word)  ::  9 Word.word))  ::  13 Word.word),
                zreg,
                (creg2reg_idx rs  ::  5 Word.word),
                RISCV_BNE)))\<close> 
  for  rs  :: "(3)Word.word " 
  and  imm  :: "(8)Word.word "
|\<open> execute (C_SLLI ((shamt, rsd))) = ( execute (SHIFTIOP (shamt, rsd, rsd, RISCV_SLLI)))\<close> 
  for  rsd  :: "(5)Word.word " 
  and  shamt  :: "(6)Word.word "
|\<open> execute (C_LWSP ((uimm, rd))) = (
      (let (imm :: 12 bits) =
        ((EXTZ (( 12 :: int)::ii) ((concat_vec uimm ( 0b00 ::  2 Word.word)  ::  8 Word.word))  ::  12 Word.word)) in
      execute (LOAD (imm, sp, rd, False, WORD, False, False))))\<close> 
  for  uimm  :: "(6)Word.word " 
  and  rd  :: "(5)Word.word "
|\<open> execute (C_LDSP ((uimm, rd))) = (
      (let (imm :: 12 bits) =
        ((EXTZ (( 12 :: int)::ii) ((concat_vec uimm ( 0b000 ::  3 Word.word)  ::  9 Word.word))  ::  12 Word.word)) in
      execute (LOAD (imm, sp, rd, False, DOUBLE, False, False))))\<close> 
  for  uimm  :: "(6)Word.word " 
  and  rd  :: "(5)Word.word "
|\<open> execute (C_SWSP ((uimm, rs2))) = (
      (let (imm :: 12 bits) =
        ((EXTZ (( 12 :: int)::ii) ((concat_vec uimm ( 0b00 ::  2 Word.word)  ::  8 Word.word))  ::  12 Word.word)) in
      execute (STORE (imm, rs2, sp, WORD, False, False))))\<close> 
  for  uimm  :: "(6)Word.word " 
  and  rs2  :: "(5)Word.word "
|\<open> execute (C_SDSP ((uimm, rs2))) = (
      (let (imm :: 12 bits) =
        ((EXTZ (( 12 :: int)::ii) ((concat_vec uimm ( 0b000 ::  3 Word.word)  ::  9 Word.word))  ::  12 Word.word)) in
      execute (STORE (imm, rs2, sp, DOUBLE, False, False))))\<close> 
  for  uimm  :: "(6)Word.word " 
  and  rs2  :: "(5)Word.word "
|\<open> execute (C_JR (rs1)) = ( execute (RISCV_JALR ((EXTZ (( 12 :: int)::ii) ( 0b0 ::  1 Word.word)  ::  12 Word.word), rs1, zreg)))\<close> 
  for  rs1  :: "(5)Word.word "
|\<open> execute (C_JALR (rs1)) = ( execute (RISCV_JALR ((EXTZ (( 12 :: int)::ii) ( 0b0 ::  1 Word.word)  ::  12 Word.word), rs1, ra)))\<close> 
  for  rs1  :: "(5)Word.word "
|\<open> execute (C_MV ((rd, rs2))) = ( execute (RTYPE (rs2, zreg, rd, RISCV_ADD)))\<close> 
  for  rs2  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|\<open> execute (C_EBREAK (_)) = ( execute (EBREAK () ))\<close>
|\<open> execute (C_ADD ((rsd, rs2))) = ( execute (RTYPE (rs2, rsd, rsd, RISCV_ADD)))\<close> 
  for  rsd  :: "(5)Word.word " 
  and  rs2  :: "(5)Word.word "
|\<open> execute (C_FLWSP ((imm, rd))) = (
      (let (imm :: 12 bits) =
        ((EXTZ (( 12 :: int)::ii) ((concat_vec imm ( 0b00 ::  2 Word.word)  ::  8 Word.word))  ::  12 Word.word)) in
      execute (LOAD_FP (imm, sp, rd, WORD))))\<close> 
  for  imm  :: "(6)Word.word " 
  and  rd  :: "(5)Word.word "
|\<open> execute (C_FSWSP ((uimm, rs2))) = (
      (let (imm :: 12 bits) =
        ((EXTZ (( 12 :: int)::ii) ((concat_vec uimm ( 0b00 ::  2 Word.word)  ::  8 Word.word))  ::  12 Word.word)) in
      execute (STORE_FP (imm, rs2, sp, WORD))))\<close> 
  for  uimm  :: "(6)Word.word " 
  and  rs2  :: "(5)Word.word "
|\<open> execute (C_FLW ((uimm, rsc, rdc))) = (
      (let (imm :: 12 bits) =
        ((EXTZ (( 12 :: int)::ii) ((concat_vec uimm ( 0b00 ::  2 Word.word)  ::  7 Word.word))  ::  12 Word.word)) in
      (let rd = ((creg2reg_idx rdc  ::  5 Word.word)) in
      (let rs = ((creg2reg_idx rsc  ::  5 Word.word)) in
      execute (LOAD_FP (imm, rs, rd, WORD))))))\<close> 
  for  rsc  :: "(3)Word.word " 
  and  uimm  :: "(5)Word.word " 
  and  rdc  :: "(3)Word.word "
|\<open> execute (C_FSW ((uimm, rsc1, rsc2))) = (
      (let (imm :: 12 bits) =
        ((EXTZ (( 12 :: int)::ii) ((concat_vec uimm ( 0b00 ::  2 Word.word)  ::  7 Word.word))  ::  12 Word.word)) in
      (let rs1 = ((creg2reg_idx rsc1  ::  5 Word.word)) in
      (let rs2 = ((creg2reg_idx rsc2  ::  5 Word.word)) in
      execute (STORE_FP (imm, rs2, rs1, WORD))))))\<close> 
  for  rsc2  :: "(3)Word.word " 
  and  rsc1  :: "(3)Word.word " 
  and  uimm  :: "(5)Word.word "
|\<open> execute (C_FLDSP ((uimm, rd))) = (
      (let (imm :: 12 bits) =
        ((EXTZ (( 12 :: int)::ii) ((concat_vec uimm ( 0b000 ::  3 Word.word)  ::  9 Word.word))  ::  12 Word.word)) in
      execute (LOAD_FP (imm, sp, rd, DOUBLE))))\<close> 
  for  uimm  :: "(6)Word.word " 
  and  rd  :: "(5)Word.word "
|\<open> execute (C_FSDSP ((uimm, rs2))) = (
      (let (imm :: 12 bits) =
        ((EXTZ (( 12 :: int)::ii) ((concat_vec uimm ( 0b000 ::  3 Word.word)  ::  9 Word.word))  ::  12 Word.word)) in
      execute (STORE_FP (imm, rs2, sp, DOUBLE))))\<close> 
  for  uimm  :: "(6)Word.word " 
  and  rs2  :: "(5)Word.word "
|\<open> execute (C_FLD ((uimm, rsc, rdc))) = (
      (let (imm :: 12 bits) =
        ((EXTZ (( 12 :: int)::ii) ((concat_vec uimm ( 0b000 ::  3 Word.word)  ::  8 Word.word))  ::  12 Word.word)) in
      (let rd = ((creg2reg_idx rdc  ::  5 Word.word)) in
      (let rs = ((creg2reg_idx rsc  ::  5 Word.word)) in
      execute (LOAD_FP (imm, rs, rd, DOUBLE))))))\<close> 
  for  rsc  :: "(3)Word.word " 
  and  uimm  :: "(5)Word.word " 
  and  rdc  :: "(3)Word.word "
|\<open> execute (C_FSD ((uimm, rsc1, rsc2))) = (
      (let (imm :: 12 bits) =
        ((EXTZ (( 12 :: int)::ii) ((concat_vec uimm ( 0b000 ::  3 Word.word)  ::  8 Word.word))  ::  12 Word.word)) in
      (let rs1 = ((creg2reg_idx rsc1  ::  5 Word.word)) in
      (let rs2 = ((creg2reg_idx rsc2  ::  5 Word.word)) in
      execute (STORE_FP (imm, rs2, rs1, DOUBLE))))))\<close> 
  for  rsc2  :: "(3)Word.word " 
  and  rsc1  :: "(3)Word.word " 
  and  uimm  :: "(5)Word.word "
|\<open> execute (UTYPE ((imm, rd, op1))) = ( execute_UTYPE imm rd op1 )\<close> 
  for  op1  :: " uop " 
  and  imm  :: "(20)Word.word " 
  and  rd  :: "(5)Word.word "
|\<open> execute (RISCV_JAL ((imm, rd))) = ( execute_RISCV_JAL imm rd )\<close> 
  for  imm  :: "(21)Word.word " 
  and  rd  :: "(5)Word.word "
|\<open> execute (BTYPE ((imm, rs2, rs1, op1))) = ( execute_BTYPE imm rs2 rs1 op1 )\<close> 
  for  op1  :: " bop " 
  and  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  imm  :: "(13)Word.word "
|\<open> execute (ITYPE ((imm, rs1, rd, op1))) = ( execute_ITYPE imm rs1 rd op1 )\<close> 
  for  op1  :: " iop " 
  and  rs1  :: "(5)Word.word " 
  and  imm  :: "(12)Word.word " 
  and  rd  :: "(5)Word.word "
|\<open> execute (SHIFTIOP ((shamt, rs1, rd, op1))) = ( execute_SHIFTIOP shamt rs1 rd op1 )\<close> 
  for  op1  :: " sop " 
  and  shamt  :: "(6)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|\<open> execute (RTYPE ((rs2, rs1, rd, op1))) = ( execute_RTYPE rs2 rs1 rd op1 )\<close> 
  for  op1  :: " rop " 
  and  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|\<open> execute (LOAD ((imm, rs1, rd, is_unsigned, width, aq, rl))) = (
      execute_LOAD imm rs1 rd is_unsigned width aq rl )\<close> 
  for  rs1  :: "(5)Word.word " 
  and  imm  :: "(12)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  is_unsigned  :: " bool " 
  and  aq  :: " bool " 
  and  width  :: " word_width " 
  and  rl  :: " bool "
|\<open> execute (STORE ((imm, rs2, rs1, width, aq, rl))) = ( execute_STORE imm rs2 rs1 width aq rl )\<close> 
  for  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  imm  :: "(12)Word.word " 
  and  aq  :: " bool " 
  and  width  :: " word_width " 
  and  rl  :: " bool "
|\<open> execute (ADDIW ((imm, rs1, rd))) = ( execute_ADDIW imm rs1 rd )\<close> 
  for  rs1  :: "(5)Word.word " 
  and  imm  :: "(12)Word.word " 
  and  rd  :: "(5)Word.word "
|\<open> execute (SHIFTW ((shamt, rs1, rd, op1))) = ( execute_SHIFTW shamt rs1 rd op1 )\<close> 
  for  op1  :: " sop " 
  and  shamt  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|\<open> execute (RTYPEW ((rs2, rs1, rd, op1))) = ( execute_RTYPEW rs2 rs1 rd op1 )\<close> 
  for  op1  :: " ropw " 
  and  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|\<open> execute (SHIFTIWOP ((shamt, rs1, rd, op1))) = ( execute_SHIFTIWOP shamt rs1 rd op1 )\<close> 
  for  op1  :: " sopw " 
  and  shamt  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|\<open> execute (FENCE ((pred, succ))) = ( execute_FENCE pred succ )\<close> 
  for  pred  :: "(4)Word.word " 
  and  succ  :: "(4)Word.word "
|\<open> execute (FENCE_TSO ((pred, succ))) = ( execute_FENCE_TSO pred succ )\<close> 
  for  pred  :: "(4)Word.word " 
  and  succ  :: "(4)Word.word "
|\<open> execute (FENCEI (arg0)) = ( return ((execute_FENCEI arg0)))\<close> 
  for  arg0  :: " unit "
|\<open> execute (ECALL (arg0)) = ( execute_ECALL arg0 )\<close> 
  for  arg0  :: " unit "
|\<open> execute (MRET (arg0)) = ( execute_MRET arg0 )\<close> 
  for  arg0  :: " unit "
|\<open> execute (SRET (arg0)) = ( execute_SRET arg0 )\<close> 
  for  arg0  :: " unit "
|\<open> execute (EBREAK (arg0)) = ( execute_EBREAK arg0 )\<close> 
  for  arg0  :: " unit "
|\<open> execute (WFI (arg0)) = ( execute_WFI arg0 )\<close> 
  for  arg0  :: " unit "
|\<open> execute (SFENCE_VMA ((rs1, rs2))) = ( execute_SFENCE_VMA rs1 rs2 )\<close> 
  for  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word "
|\<open> execute (LOADRES ((aq, rl, rs1, width, rd))) = ( execute_LOADRES aq rl rs1 width rd )\<close> 
  for  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  aq  :: " bool " 
  and  width  :: " word_width " 
  and  rl  :: " bool "
|\<open> execute (STORECON ((aq, rl, rs2, rs1, width, rd))) = ( execute_STORECON aq rl rs2 rs1 width rd )\<close> 
  for  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  aq  :: " bool " 
  and  width  :: " word_width " 
  and  rl  :: " bool "
|\<open> execute (AMO ((op1, aq, rl, rs2, rs1, width, rd))) = ( execute_AMO op1 aq rl rs2 rs1 width rd )\<close> 
  for  op1  :: " amoop " 
  and  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  aq  :: " bool " 
  and  width  :: " word_width " 
  and  rl  :: " bool "
|\<open> execute (C_NOP (arg0)) = ( return ((execute_C_NOP arg0)))\<close> 
  for  arg0  :: " unit "
|\<open> execute (MUL ((rs2, rs1, rd, high, signed1, signed2))) = ( execute_MUL rs2 rs1 rd high signed1 signed2 )\<close> 
  for  signed2  :: " bool " 
  and  signed1  :: " bool " 
  and  high  :: " bool " 
  and  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|\<open> execute (DIV ((rs2, rs1, rd, s))) = ( execute_DIV rs2 rs1 rd s )\<close> 
  for  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  s  :: " bool "
|\<open> execute (REM ((rs2, rs1, rd, s))) = ( execute_REM rs2 rs1 rd s )\<close> 
  for  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  s  :: " bool "
|\<open> execute (MULW ((rs2, rs1, rd))) = ( execute_MULW rs2 rs1 rd )\<close> 
  for  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|\<open> execute (DIVW ((rs2, rs1, rd, s))) = ( execute_DIVW rs2 rs1 rd s )\<close> 
  for  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  s  :: " bool "
|\<open> execute (REMW ((rs2, rs1, rd, s))) = ( execute_REMW rs2 rs1 rd s )\<close> 
  for  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  s  :: " bool "
|\<open> execute (CSR ((csr, rs1, rd, is_imm, op1))) = ( execute_CSR csr rs1 rd is_imm op1 )\<close> 
  for  op1  :: " csrop " 
  and  is_imm  :: " bool " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  csr  :: "(12)Word.word "
|\<open> execute (URET (arg0)) = ( execute_URET arg0 )\<close> 
  for  arg0  :: " unit "
|\<open> execute (C_NOP_HINT (imm)) = ( return ((execute_C_NOP_HINT imm)))\<close> 
  for  imm  :: "(6)Word.word "
|\<open> execute (C_ADDI_HINT (rsd)) = ( return ((execute_C_ADDI_HINT rsd)))\<close> 
  for  rsd  :: "(5)Word.word "
|\<open> execute (C_LI_HINT (imm)) = ( return ((execute_C_LI_HINT imm)))\<close> 
  for  imm  :: "(6)Word.word "
|\<open> execute (C_LUI_HINT (imm)) = ( return ((execute_C_LUI_HINT imm)))\<close> 
  for  imm  :: "(6)Word.word "
|\<open> execute (C_MV_HINT (rs2)) = ( return ((execute_C_MV_HINT rs2)))\<close> 
  for  rs2  :: "(5)Word.word "
|\<open> execute (C_ADD_HINT (rs2)) = ( return ((execute_C_ADD_HINT rs2)))\<close> 
  for  rs2  :: "(5)Word.word "
|\<open> execute (C_SLLI_HINT ((shamt, rsd))) = ( return ((execute_C_SLLI_HINT shamt rsd)))\<close> 
  for  rsd  :: "(5)Word.word " 
  and  shamt  :: "(6)Word.word "
|\<open> execute (C_SRLI_HINT (rsd)) = ( return ((execute_C_SRLI_HINT rsd)))\<close> 
  for  rsd  :: "(3)Word.word "
|\<open> execute (C_SRAI_HINT (rsd)) = ( return ((execute_C_SRAI_HINT rsd)))\<close> 
  for  rsd  :: "(3)Word.word "
|\<open> execute (FENCE_RESERVED ((fm, pred, succ, rs, rd))) = (
      return ((execute_FENCE_RESERVED fm pred succ rs rd)))\<close> 
  for  rs  :: "(5)Word.word " 
  and  fm  :: "(4)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  pred  :: "(4)Word.word " 
  and  succ  :: "(4)Word.word "
|\<open> execute (FENCEI_RESERVED ((imm, rs, rd))) = ( return ((execute_FENCEI_RESERVED imm rs rd)))\<close> 
  for  rs  :: "(5)Word.word " 
  and  imm  :: "(12)Word.word " 
  and  rd  :: "(5)Word.word "
|\<open> execute (LOAD_FP ((imm, rs1, rd, width))) = ( execute_LOAD_FP imm rs1 rd width )\<close> 
  for  rs1  :: "(5)Word.word " 
  and  imm  :: "(12)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  width  :: " word_width "
|\<open> execute (STORE_FP ((imm, rs2, rs1, width))) = ( execute_STORE_FP imm rs2 rs1 width )\<close> 
  for  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  imm  :: "(12)Word.word " 
  and  width  :: " word_width "
|\<open> execute (F_MADD_TYPE_S ((rs3, rs2, rs1, rm, rd, op1))) = ( execute_F_MADD_TYPE_S rs3 rs2 rs1 rm rd op1 )\<close> 
  for  op1  :: " f_madd_op_S " 
  and  rs3  :: "(5)Word.word " 
  and  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  rm  :: " rounding_mode "
|\<open> execute (F_BIN_RM_TYPE_S ((rs2, rs1, rm, rd, op1))) = ( execute_F_BIN_RM_TYPE_S rs2 rs1 rm rd op1 )\<close> 
  for  op1  :: " f_bin_rm_op_S " 
  and  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  rm  :: " rounding_mode "
|\<open> execute (F_UN_RM_TYPE_S ((rs1, rm, rd, arg3))) = ( execute_F_UN_RM_TYPE_S rs1 rm rd arg3 )\<close> 
  for  arg3  :: " f_un_rm_op_S " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  rm  :: " rounding_mode "
|\<open> execute (F_BIN_TYPE_S ((rs2, rs1, rd, arg3))) = ( execute_F_BIN_TYPE_S rs2 rs1 rd arg3 )\<close> 
  for  arg3  :: " f_bin_op_S " 
  and  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|\<open> execute (F_UN_TYPE_S ((rs1, rd, arg2))) = ( execute_F_UN_TYPE_S rs1 rd arg2 )\<close> 
  for  arg2  :: " f_un_op_S " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|\<open> execute (F_MADD_TYPE_D ((rs3, rs2, rs1, rm, rd, op1))) = ( execute_F_MADD_TYPE_D rs3 rs2 rs1 rm rd op1 )\<close> 
  for  op1  :: " f_madd_op_D " 
  and  rs3  :: "(5)Word.word " 
  and  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  rm  :: " rounding_mode "
|\<open> execute (F_BIN_RM_TYPE_D ((rs2, rs1, rm, rd, op1))) = ( execute_F_BIN_RM_TYPE_D rs2 rs1 rm rd op1 )\<close> 
  for  op1  :: " f_bin_rm_op_D " 
  and  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  rm  :: " rounding_mode "
|\<open> execute (F_UN_RM_TYPE_D ((rs1, rm, rd, arg3))) = ( execute_F_UN_RM_TYPE_D rs1 rm rd arg3 )\<close> 
  for  arg3  :: " f_un_rm_op_D " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  rm  :: " rounding_mode "
|\<open> execute (F_BIN_TYPE_D ((rs2, rs1, rd, arg3))) = ( execute_F_BIN_TYPE_D rs2 rs1 rd arg3 )\<close> 
  for  arg3  :: " f_bin_op_D " 
  and  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|\<open> execute (F_UN_TYPE_D ((rs1, rd, arg2))) = ( execute_F_UN_TYPE_D rs1 rd arg2 )\<close> 
  for  arg2  :: " f_un_op_D " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|\<open> execute (RISCV_JALR ((imm, rs1, rd))) = ( execute_RISCV_JALR imm rs1 rd )\<close> 
  for  rs1  :: "(5)Word.word " 
  and  imm  :: "(12)Word.word " 
  and  rd  :: "(5)Word.word "
|\<open> execute (ILLEGAL (s)) = ( execute_ILLEGAL s )\<close> 
  for  s  :: "(32)Word.word "
|\<open> execute (C_ILLEGAL (s)) = ( execute_C_ILLEGAL s )\<close> 
  for  s  :: "(16)Word.word " 
by pat_completeness (auto intro!: let_cong bind_cong MemoryOpResult.case_cong)


definition assembly_forwards  :: \<open> ast \<Rightarrow>((register_value),(string),(exception))monad \<close>  where 
     \<open> assembly_forwards ast = (
   (let arg1 = ast in  
  (case  arg1 of
        UTYPE ((imm, rd, op1)) =>
  reg_name_forwards rd \<bind>
    ((\<lambda> (w__0 :: string) . 
     return
       ((string_append ((utype_mnemonic_forwards op1))
           ((string_append ((spc_forwards () ))
               ((string_append w__0
                   ((string_append ((sep_forwards () ))
                       ((string_append ((decimal_string_of_bits imm)) ('''')))))))))))))
    | RISCV_JAL ((imm, rd)) =>
  reg_name_forwards rd \<bind>
    ((\<lambda> (w__1 :: string) . 
     return
       ((string_append (''jal'')
           ((string_append ((spc_forwards () ))
               ((string_append w__1
                   ((string_append ((sep_forwards () ))
                       ((string_append ((decimal_string_of_bits imm)) ('''')))))))))))))
    | RISCV_JALR ((imm, rs1, rd)) =>
  reg_name_forwards rd \<bind>
    ((\<lambda> (w__2 :: string) . 
     reg_name_forwards rs1 \<bind>
       ((\<lambda> (w__3 :: string) . 
        return
          ((string_append (''jalr'')
              ((string_append ((spc_forwards () ))
                  ((string_append w__2
                      ((string_append ((sep_forwards () ))
                          ((string_append w__3
                              ((string_append ((sep_forwards () ))
                                  ((string_append
                                      ((decimal_string_of_bits imm)) 
                                    ('''')))))))))))))))))))
    | BTYPE ((imm, rs2, rs1, op1)) =>
  reg_name_forwards rs1 \<bind>
    ((\<lambda> (w__4 :: string) . 
     reg_name_forwards rs2 \<bind>
       ((\<lambda> (w__5 :: string) . 
        return
          ((string_append ((btype_mnemonic_forwards op1))
              ((string_append ((spc_forwards () ))
                  ((string_append w__4
                      ((string_append ((sep_forwards () ))
                          ((string_append w__5
                              ((string_append ((sep_forwards () ))
                                  ((string_append
                                      ((decimal_string_of_bits imm)) 
                                    ('''')))))))))))))))))))
    | ITYPE ((imm, rs1, rd, op1)) =>
  reg_name_forwards rd \<bind>
    ((\<lambda> (w__6 :: string) . 
     reg_name_forwards rs1 \<bind>
       ((\<lambda> (w__7 :: string) . 
        return
          ((string_append ((itype_mnemonic_forwards op1))
              ((string_append ((spc_forwards () ))
                  ((string_append w__6
                      ((string_append ((sep_forwards () ))
                          ((string_append w__7
                              ((string_append ((sep_forwards () ))
                                  ((string_append
                                      ((decimal_string_of_bits imm)) 
                                    ('''')))))))))))))))))))
    | SHIFTIOP ((shamt, rs1, rd, op1)) =>
  reg_name_forwards rd \<bind>
    ((\<lambda> (w__8 :: string) . 
     reg_name_forwards rs1 \<bind>
       ((\<lambda> (w__9 :: string) . 
        return
          ((string_append ((shiftiop_mnemonic_forwards op1))
              ((string_append ((spc_forwards () ))
                  ((string_append w__8
                      ((string_append ((sep_forwards () ))
                          ((string_append w__9
                              ((string_append ((sep_forwards () ))
                                  ((string_append
                                      ((decimal_string_of_bits shamt)) 
                                    ('''')))))))))))))))))))
    | RTYPE ((rs2, rs1, rd, op1)) =>
  reg_name_forwards rd \<bind>
    ((\<lambda> (w__10 :: string) . 
     reg_name_forwards rs1 \<bind>
       ((\<lambda> (w__11 :: string) . 
        reg_name_forwards rs2 \<bind>
          ((\<lambda> (w__12 :: string) . 
           return
             ((string_append ((rtype_mnemonic_forwards op1))
                 ((string_append ((spc_forwards () ))
                     ((string_append w__10
                         ((string_append ((sep_forwards () ))
                             ((string_append w__11
                                 ((string_append ((sep_forwards () ))
                                     ((string_append w__12 ('''')))))))))))))))))))))
    | LOAD ((imm, rs1, rd, is_unsigned, size1, aq, rl)) =>
  reg_name_forwards rd \<bind>
    ((\<lambda> (w__13 :: string) . 
     reg_name_forwards rs1 \<bind>
       ((\<lambda> (w__14 :: string) . 
        return
          ((string_append (''l'')
              ((string_append ((size_mnemonic_forwards size1))
                  ((string_append ((maybe_u_forwards is_unsigned))
                      ((string_append ((maybe_aq_forwards aq))
                          ((string_append ((maybe_rl_forwards rl))
                              ((string_append ((spc_forwards () ))
                                  ((string_append w__13
                                      ((string_append ((sep_forwards () ))
                                          ((string_append
                                              ((decimal_string_of_bits imm))
                                              ((string_append
                                                  ((opt_spc_forwards () ))
                                                  ((string_append (''('')
                                                      ((string_append
                                                          ((opt_spc_forwards
                                                              () ))
                                                          ((string_append
                                                              w__14
                                                              ((string_append
                                                                  ((opt_spc_forwards
                                                                    () ))
                                                                  ((string_append
                                                                    ('')'')
                                                                    ('''')))))))))))))))))))))))))))))))))))
    | STORE ((imm, rs2, rs1, size1, aq, rl)) =>
  reg_name_forwards rs2 \<bind>
    ((\<lambda> (w__15 :: string) . 
     reg_name_forwards rs1 \<bind>
       ((\<lambda> (w__16 :: string) . 
        return
          ((string_append (''s'')
              ((string_append ((size_mnemonic_forwards size1))
                  ((string_append ((maybe_aq_forwards aq))
                      ((string_append ((maybe_rl_forwards rl))
                          ((string_append ((spc_forwards () ))
                              ((string_append w__15
                                  ((string_append ((sep_forwards () ))
                                      ((string_append
                                          ((decimal_string_of_bits imm))
                                          ((string_append
                                              ((opt_spc_forwards () ))
                                              ((string_append (''('')
                                                  ((string_append
                                                      ((opt_spc_forwards () ))
                                                      ((string_append 
                                                        w__16
                                                          ((string_append
                                                              ((opt_spc_forwards
                                                                  () ))
                                                              ((string_append
                                                                  ('')'')
                                                                  ('''')))))))))))))))))))))))))))))))))
    | ADDIW ((imm, rs1, rd)) =>
  if ((((( 64 :: int):: ii) = (( 64 :: int):: ii)))) then
    reg_name_forwards rd \<bind>
      ((\<lambda> (w__17 :: string) . 
       reg_name_forwards rs1 \<bind>
         ((\<lambda> (w__18 :: string) . 
          return
            ((string_append (''addiw'')
                ((string_append ((spc_forwards () ))
                    ((string_append w__17
                        ((string_append ((sep_forwards () ))
                            ((string_append w__18
                                ((string_append ((sep_forwards () ))
                                    ((string_append
                                        ((decimal_string_of_bits imm)) 
                                      (''''))))))))))))))))))) else
    assert_exp False (''Pattern match failure at unknown location'') \<then>
      exit0 () 
    | SHIFTW ((shamt, rs1, rd, op1)) =>
  if ((((( 64 :: int):: ii) = (( 64 :: int):: ii)))) then
    reg_name_forwards rd \<bind>
      ((\<lambda> (w__21 :: string) . 
       reg_name_forwards rs1 \<bind>
         ((\<lambda> (w__22 :: string) . 
          return
            ((string_append ((shiftw_mnemonic_forwards op1))
                ((string_append ((spc_forwards () ))
                    ((string_append w__21
                        ((string_append ((sep_forwards () ))
                            ((string_append w__22
                                ((string_append ((sep_forwards () ))
                                    ((string_append
                                        ((decimal_string_of_bits shamt))
                                        (''''))))))))))))))))))) else
    assert_exp False (''Pattern match failure at unknown location'') \<then>
      exit0 () 
    | RTYPEW ((rs2, rs1, rd, op1)) =>
  if ((((( 64 :: int):: ii) = (( 64 :: int):: ii)))) then
    reg_name_forwards rd \<bind>
      ((\<lambda> (w__25 :: string) . 
       reg_name_forwards rs1 \<bind>
         ((\<lambda> (w__26 :: string) . 
          reg_name_forwards rs2 \<bind>
            ((\<lambda> (w__27 :: string) . 
             return
               ((string_append ((rtypew_mnemonic_forwards op1))
                   ((string_append ((spc_forwards () ))
                       ((string_append w__25
                           ((string_append ((sep_forwards () ))
                               ((string_append w__26
                                   ((string_append ((sep_forwards () ))
                                       ((string_append w__27 ('''')))))))))))))))))))))
  else
    assert_exp False (''Pattern match failure at unknown location'') \<then>
      exit0 () 
    | SHIFTIWOP ((shamt, rs1, rd, op1)) =>
  if ((((( 64 :: int):: ii) = (( 64 :: int):: ii)))) then
    reg_name_forwards rd \<bind>
      ((\<lambda> (w__30 :: string) . 
       reg_name_forwards rs1 \<bind>
         ((\<lambda> (w__31 :: string) . 
          return
            ((string_append ((shiftiwop_mnemonic_forwards op1))
                ((string_append ((spc_forwards () ))
                    ((string_append w__30
                        ((string_append ((sep_forwards () ))
                            ((string_append w__31
                                ((string_append ((sep_forwards () ))
                                    ((string_append
                                        ((decimal_string_of_bits shamt))
                                        (''''))))))))))))))))))) else
    assert_exp False (''Pattern match failure at unknown location'') \<then>
      exit0 () 
    | FENCE ((pred, succ)) =>
  fence_bits_forwards pred \<bind>
    ((\<lambda> (w__34 :: string) . 
     fence_bits_forwards succ \<bind>
       ((\<lambda> (w__35 :: string) . 
        return
          ((string_append (''fence'')
              ((string_append ((spc_forwards () ))
                  ((string_append w__34
                      ((string_append ((sep_forwards () ))
                          ((string_append w__35 ('''')))))))))))))))
    | FENCE_TSO ((pred, succ)) =>
  fence_bits_forwards pred \<bind>
    ((\<lambda> (w__36 :: string) . 
     fence_bits_forwards succ \<bind>
       ((\<lambda> (w__37 :: string) . 
        return
          ((string_append (''fence.tso'')
              ((string_append ((spc_forwards () ))
                  ((string_append w__36
                      ((string_append ((sep_forwards () ))
                          ((string_append w__37 ('''')))))))))))))))
    | FENCEI (_) => return (''fence.i'')
    | ECALL (_) => return (''ecall'')
    | MRET (_) => return (''mret'')
    | SRET (_) => return (''sret'')
    | EBREAK (_) => return (''ebreak'')
    | WFI (_) => return (''wfi'')
    | SFENCE_VMA ((rs1, rs2)) =>
  reg_name_forwards rs1 \<bind>
    ((\<lambda> (w__38 :: string) . 
     reg_name_forwards rs2 \<bind>
       ((\<lambda> (w__39 :: string) . 
        return
          ((string_append (''sfence.vma'')
              ((string_append ((spc_forwards () ))
                  ((string_append w__38
                      ((string_append ((sep_forwards () ))
                          ((string_append w__39 ('''')))))))))))))))
    | LOADRES ((aq, rl, rs1, size1, rd)) =>
  reg_name_forwards rd \<bind>
    ((\<lambda> (w__40 :: string) . 
     reg_name_forwards rs1 \<bind>
       ((\<lambda> (w__41 :: string) . 
        return
          ((string_append (''lr.'')
              ((string_append ((size_mnemonic_forwards size1))
                  ((string_append ((maybe_aq_forwards aq))
                      ((string_append ((maybe_rl_forwards rl))
                          ((string_append ((spc_forwards () ))
                              ((string_append w__40
                                  ((string_append ((sep_forwards () ))
                                      ((string_append w__41 ('''')))))))))))))))))))))
    | STORECON ((aq, rl, rs2, rs1, size1, rd)) =>
  reg_name_forwards rd \<bind>
    ((\<lambda> (w__42 :: string) . 
     reg_name_forwards rs1 \<bind>
       ((\<lambda> (w__43 :: string) . 
        reg_name_forwards rs2 \<bind>
          ((\<lambda> (w__44 :: string) . 
           return
             ((string_append (''sc.'')
                 ((string_append ((size_mnemonic_forwards size1))
                     ((string_append ((maybe_aq_forwards aq))
                         ((string_append ((maybe_rl_forwards rl))
                             ((string_append ((spc_forwards () ))
                                 ((string_append w__42
                                     ((string_append ((sep_forwards () ))
                                         ((string_append w__43
                                             ((string_append
                                                 ((sep_forwards () ))
                                                 ((string_append w__44 ('''')))))))))))))))))))))))))))
    | AMO ((op1, aq, rl, rs2, rs1, width, rd)) =>
  reg_name_forwards rd \<bind>
    ((\<lambda> (w__45 :: string) . 
     reg_name_forwards rs2 \<bind>
       ((\<lambda> (w__46 :: string) . 
        reg_name_forwards rs1 \<bind>
          ((\<lambda> (w__47 :: string) . 
           return
             ((string_append ((amo_mnemonic_forwards op1))
                 ((string_append (''.'')
                     ((string_append ((size_mnemonic_forwards width))
                         ((string_append ((maybe_aq_forwards aq))
                             ((string_append ((maybe_rl_forwards rl))
                                 ((string_append ((spc_forwards () ))
                                     ((string_append w__45
                                         ((string_append ((sep_forwards () ))
                                             ((string_append w__46
                                                 ((string_append
                                                     ((sep_forwards () ))
                                                     ((string_append 
                                                       (''('')
                                                         ((string_append
                                                             w__47
                                                             ((string_append
                                                                 ('')'')
                                                                 ('''')))))))))))))))))))))))))))))))))
    | C_NOP (_) => return (''c.nop'')
    | C_ADDI4SPN ((rdc, nzimm)) =>
  if (((nzimm \<noteq> ( 0x00 :: 8 Word.word)))) then
    creg_name_forwards rdc \<bind>
      ((\<lambda> (w__48 :: string) . 
       return
         ((string_append (''c.addi4spn'')
             ((string_append ((spc_forwards () ))
                 ((string_append w__48
                     ((string_append ((sep_forwards () ))
                         ((string_append
                             ((decimal_string_of_bits
                                 ((concat_vec nzimm ( 0b00 :: 2 Word.word) :: 10 Word.word))))
                             (''''))))))))))))) else
    assert_exp False (''Pattern match failure at unknown location'') \<then>
      exit0 () 
    | C_LW ((uimm, rsc, rdc)) =>
  creg_name_forwards rdc \<bind>
    ((\<lambda> (w__51 :: string) . 
     creg_name_forwards rsc \<bind>
       ((\<lambda> (w__52 :: string) . 
        return
          ((string_append (''c.lw'')
              ((string_append ((spc_forwards () ))
                  ((string_append w__51
                      ((string_append ((sep_forwards () ))
                          ((string_append w__52
                              ((string_append ((sep_forwards () ))
                                  ((string_append
                                      ((decimal_string_of_bits
                                          ((concat_vec uimm
                                              ( 0b00 :: 2 Word.word) :: 7 Word.word))))
                                      ('''')))))))))))))))))))
    | C_LD ((uimm, rsc, rdc)) =>
  if ((((( 64 :: int):: ii) = (( 64 :: int):: ii)))) then
    creg_name_forwards rdc \<bind>
      ((\<lambda> (w__53 :: string) . 
       creg_name_forwards rsc \<bind>
         ((\<lambda> (w__54 :: string) . 
          return
            ((string_append (''c.ld'')
                ((string_append ((spc_forwards () ))
                    ((string_append w__53
                        ((string_append ((sep_forwards () ))
                            ((string_append w__54
                                ((string_append ((sep_forwards () ))
                                    ((string_append
                                        ((decimal_string_of_bits
                                            ((concat_vec uimm
                                                ( 0b000 :: 3 Word.word) :: 8 Word.word))))
                                        (''''))))))))))))))))))) else
    assert_exp False (''Pattern match failure at unknown location'') \<then>
      exit0 () 
    | C_SW ((uimm, rsc1, rsc2)) =>
  creg_name_forwards rsc1 \<bind>
    ((\<lambda> (w__57 :: string) . 
     creg_name_forwards rsc2 \<bind>
       ((\<lambda> (w__58 :: string) . 
        return
          ((string_append (''c.sw'')
              ((string_append ((spc_forwards () ))
                  ((string_append w__57
                      ((string_append ((sep_forwards () ))
                          ((string_append w__58
                              ((string_append ((sep_forwards () ))
                                  ((string_append
                                      ((decimal_string_of_bits
                                          ((concat_vec uimm
                                              ( 0b00 :: 2 Word.word) :: 7 Word.word))))
                                      ('''')))))))))))))))))))
    | C_SD ((uimm, rsc1, rsc2)) =>
  if ((((( 64 :: int):: ii) = (( 64 :: int):: ii)))) then
    creg_name_forwards rsc1 \<bind>
      ((\<lambda> (w__59 :: string) . 
       creg_name_forwards rsc2 \<bind>
         ((\<lambda> (w__60 :: string) . 
          return
            ((string_append (''c.sd'')
                ((string_append ((spc_forwards () ))
                    ((string_append w__59
                        ((string_append ((sep_forwards () ))
                            ((string_append w__60
                                ((string_append ((sep_forwards () ))
                                    ((string_append
                                        ((decimal_string_of_bits
                                            ((concat_vec uimm
                                                ( 0b000 :: 3 Word.word) :: 8 Word.word))))
                                        (''''))))))))))))))))))) else
    assert_exp False (''Pattern match failure at unknown location'') \<then>
      exit0 () 
    | C_ADDI ((nzi, rsd)) =>
  if ((((((nzi \<noteq> ( 0b000000 :: 6 Word.word)))) \<and>
          (((rsd \<noteq> zreg)))))) then
    reg_name_forwards rsd \<bind>
      ((\<lambda> (w__63 :: string) . 
       return
         ((string_append (''c.addi'')
             ((string_append ((spc_forwards () ))
                 ((string_append w__63
                     ((string_append ((sep_forwards () ))
                         ((string_append ((decimal_string_of_bits nzi))
                             (''''))))))))))))) else
    assert_exp False (''Pattern match failure at unknown location'') \<then>
      exit0 () 
    | C_JAL (imm) =>
  if ((((( 64 :: int):: ii) = (( 32 :: int):: ii)))) then
    return
      ((string_append (''c.jal'')
          ((string_append ((spc_forwards () ))
              ((string_append
                  ((decimal_string_of_bits
                      ((concat_vec imm ( 0b0 :: 1 Word.word) :: 12 Word.word))))
                  (''''))))))) else
    assert_exp False (''Pattern match failure at unknown location'') \<then>
      exit0 () 
    | C_ADDIW ((imm, rsd)) =>
  if ((((( 64 :: int):: ii) = (( 64 :: int):: ii)))) then
    reg_name_forwards rsd \<bind>
      ((\<lambda> (w__68 :: string) . 
       return
         ((string_append (''c.addiw'')
             ((string_append ((spc_forwards () ))
                 ((string_append w__68
                     ((string_append ((sep_forwards () ))
                         ((string_append ((decimal_string_of_bits imm))
                             (''''))))))))))))) else
    assert_exp False (''Pattern match failure at unknown location'') \<then>
      exit0 () 
    | C_LI ((imm, rd)) =>
  if (((rd \<noteq> zreg))) then
    reg_name_forwards rd \<bind>
      ((\<lambda> (w__71 :: string) . 
       return
         ((string_append (''c.li'')
             ((string_append ((spc_forwards () ))
                 ((string_append w__71
                     ((string_append ((sep_forwards () ))
                         ((string_append ((decimal_string_of_bits imm))
                             (''''))))))))))))) else
    assert_exp False (''Pattern match failure at unknown location'') \<then>
      exit0 () 
    | C_ADDI16SP (imm) =>
  if (((imm \<noteq> ( 0b000000 :: 6 Word.word)))) then
    return
      ((string_append (''c.addi16sp'')
          ((string_append ((spc_forwards () ))
              ((string_append ((decimal_string_of_bits imm)) ('''')))))))
  else
    assert_exp False (''Pattern match failure at unknown location'') \<then>
      exit0 () 
    | C_LUI ((imm, rd)) =>
  if ((((((rd \<noteq> zreg))) \<and>
          ((((((rd \<noteq> sp))) \<and>
               (((imm \<noteq> ( 0b000000 :: 6 Word.word)))))))))) then
    reg_name_forwards rd \<bind>
      ((\<lambda> (w__76 :: string) . 
       return
         ((string_append (''c.lui'')
             ((string_append ((spc_forwards () ))
                 ((string_append w__76
                     ((string_append ((sep_forwards () ))
                         ((string_append ((decimal_string_of_bits imm))
                             (''''))))))))))))) else
    assert_exp False (''Pattern match failure at unknown location'') \<then>
      exit0 () 
    | C_SRLI ((shamt, rsd)) =>
  if (((shamt \<noteq> ( 0b000000 :: 6 Word.word)))) then
    creg_name_forwards rsd \<bind>
      ((\<lambda> (w__79 :: string) . 
       return
         ((string_append (''c.srli'')
             ((string_append ((spc_forwards () ))
                 ((string_append w__79
                     ((string_append ((sep_forwards () ))
                         ((string_append ((decimal_string_of_bits shamt))
                             (''''))))))))))))) else
    assert_exp False (''Pattern match failure at unknown location'') \<then>
      exit0 () 
    | C_SRAI ((shamt, rsd)) =>
  if (((shamt \<noteq> ( 0b000000 :: 6 Word.word)))) then
    creg_name_forwards rsd \<bind>
      ((\<lambda> (w__82 :: string) . 
       return
         ((string_append (''c.srai'')
             ((string_append ((spc_forwards () ))
                 ((string_append w__82
                     ((string_append ((sep_forwards () ))
                         ((string_append ((decimal_string_of_bits shamt))
                             (''''))))))))))))) else
    assert_exp False (''Pattern match failure at unknown location'') \<then>
      exit0 () 
    | C_ANDI ((imm, rsd)) =>
  creg_name_forwards rsd \<bind>
    ((\<lambda> (w__85 :: string) . 
     return
       ((string_append (''c.andi'')
           ((string_append ((spc_forwards () ))
               ((string_append w__85
                   ((string_append ((sep_forwards () ))
                       ((string_append ((decimal_string_of_bits imm)) ('''')))))))))))))
    | C_SUB ((rsd, rs2)) =>
  creg_name_forwards rsd \<bind>
    ((\<lambda> (w__86 :: string) . 
     creg_name_forwards rs2 \<bind>
       ((\<lambda> (w__87 :: string) . 
        return
          ((string_append (''c.sub'')
              ((string_append ((spc_forwards () ))
                  ((string_append w__86
                      ((string_append ((sep_forwards () ))
                          ((string_append w__87 ('''')))))))))))))))
    | C_XOR ((rsd, rs2)) =>
  creg_name_forwards rsd \<bind>
    ((\<lambda> (w__88 :: string) . 
     creg_name_forwards rs2 \<bind>
       ((\<lambda> (w__89 :: string) . 
        return
          ((string_append (''c.xor'')
              ((string_append ((spc_forwards () ))
                  ((string_append w__88
                      ((string_append ((sep_forwards () ))
                          ((string_append w__89 ('''')))))))))))))))
    | C_OR ((rsd, rs2)) =>
  creg_name_forwards rsd \<bind>
    ((\<lambda> (w__90 :: string) . 
     creg_name_forwards rs2 \<bind>
       ((\<lambda> (w__91 :: string) . 
        return
          ((string_append (''c.or'')
              ((string_append ((spc_forwards () ))
                  ((string_append w__90
                      ((string_append ((sep_forwards () ))
                          ((string_append w__91 ('''')))))))))))))))
    | C_AND ((rsd, rs2)) =>
  creg_name_forwards rsd \<bind>
    ((\<lambda> (w__92 :: string) . 
     creg_name_forwards rs2 \<bind>
       ((\<lambda> (w__93 :: string) . 
        return
          ((string_append (''c.and'')
              ((string_append ((spc_forwards () ))
                  ((string_append w__92
                      ((string_append ((sep_forwards () ))
                          ((string_append w__93 ('''')))))))))))))))
    | C_SUBW ((rsd, rs2)) =>
  if ((((( 64 :: int):: ii) = (( 64 :: int):: ii)))) then
    creg_name_forwards rsd \<bind>
      ((\<lambda> (w__94 :: string) . 
       creg_name_forwards rs2 \<bind>
         ((\<lambda> (w__95 :: string) . 
          return
            ((string_append (''c.subw'')
                ((string_append ((spc_forwards () ))
                    ((string_append w__94
                        ((string_append ((sep_forwards () ))
                            ((string_append w__95 (''''))))))))))))))) else
    assert_exp False (''Pattern match failure at unknown location'') \<then>
      exit0 () 
    | C_ADDW ((rsd, rs2)) =>
  if ((((( 64 :: int):: ii) = (( 64 :: int):: ii)))) then
    creg_name_forwards rsd \<bind>
      ((\<lambda> (w__98 :: string) . 
       creg_name_forwards rs2 \<bind>
         ((\<lambda> (w__99 :: string) . 
          return
            ((string_append (''c.addw'')
                ((string_append ((spc_forwards () ))
                    ((string_append w__98
                        ((string_append ((sep_forwards () ))
                            ((string_append w__99 (''''))))))))))))))) else
    assert_exp False (''Pattern match failure at unknown location'') \<then>
      exit0 () 
    | C_J (imm) =>
  return
    ((string_append (''c.j'')
        ((string_append ((spc_forwards () ))
            ((string_append ((decimal_string_of_bits imm)) ('''')))))))
    | C_BEQZ ((imm, rs)) =>
  creg_name_forwards rs \<bind>
    ((\<lambda> (w__102 :: string) . 
     return
       ((string_append (''c.beqz'')
           ((string_append ((spc_forwards () ))
               ((string_append w__102
                   ((string_append ((sep_forwards () ))
                       ((string_append ((decimal_string_of_bits imm)) ('''')))))))))))))
    | C_BNEZ ((imm, rs)) =>
  creg_name_forwards rs \<bind>
    ((\<lambda> (w__103 :: string) . 
     return
       ((string_append (''c.bnez'')
           ((string_append ((spc_forwards () ))
               ((string_append w__103
                   ((string_append ((sep_forwards () ))
                       ((string_append ((decimal_string_of_bits imm)) ('''')))))))))))))
    | C_SLLI ((shamt, rsd)) =>
  if ((((((shamt \<noteq> ( 0b000000 :: 6 Word.word)))) \<and>
          (((rsd \<noteq> zreg)))))) then
    reg_name_forwards rsd \<bind>
      ((\<lambda> (w__104 :: string) . 
       return
         ((string_append (''c.slli'')
             ((string_append ((spc_forwards () ))
                 ((string_append w__104
                     ((string_append ((sep_forwards () ))
                         ((string_append ((decimal_string_of_bits shamt))
                             (''''))))))))))))) else
    assert_exp False (''Pattern match failure at unknown location'') \<then>
      exit0 () 
    | C_LWSP ((uimm, rd)) =>
  if (((rd \<noteq> zreg))) then
    reg_name_forwards rd \<bind>
      ((\<lambda> (w__107 :: string) . 
       return
         ((string_append (''c.lwsp'')
             ((string_append ((spc_forwards () ))
                 ((string_append w__107
                     ((string_append ((sep_forwards () ))
                         ((string_append ((decimal_string_of_bits uimm))
                             (''''))))))))))))) else
    assert_exp False (''Pattern match failure at unknown location'') \<then>
      exit0 () 
    | C_LDSP ((uimm, rd)) =>
  if ((((((rd \<noteq> zreg))) \<and>
          ((((( 64 :: int):: ii) = (( 64 :: int):: ii))))))) then
    reg_name_forwards rd \<bind>
      ((\<lambda> (w__110 :: string) . 
       return
         ((string_append (''c.ldsp'')
             ((string_append ((spc_forwards () ))
                 ((string_append w__110
                     ((string_append ((sep_forwards () ))
                         ((string_append ((decimal_string_of_bits uimm))
                             (''''))))))))))))) else
    assert_exp False (''Pattern match failure at unknown location'') \<then>
      exit0 () 
    | C_SWSP ((uimm, rd)) =>
  reg_name_forwards rd \<bind>
    ((\<lambda> (w__113 :: string) . 
     return
       ((string_append (''c.swsp'')
           ((string_append ((spc_forwards () ))
               ((string_append w__113
                   ((string_append ((sep_forwards () ))
                       ((string_append ((decimal_string_of_bits uimm)) ('''')))))))))))))
    | C_SDSP ((uimm, rs2)) =>
  if ((((( 64 :: int):: ii) = (( 64 :: int):: ii)))) then
    reg_name_forwards rs2 \<bind>
      ((\<lambda> (w__114 :: string) . 
       return
         ((string_append (''c.sdsp'')
             ((string_append ((spc_forwards () ))
                 ((string_append w__114
                     ((string_append ((sep_forwards () ))
                         ((string_append ((decimal_string_of_bits uimm))
                             (''''))))))))))))) else
    assert_exp False (''Pattern match failure at unknown location'') \<then>
      exit0 () 
    | C_JR (rs1) =>
  if (((rs1 \<noteq> zreg))) then
    reg_name_forwards rs1 \<bind>
      ((\<lambda> (w__117 :: string) . 
       return
         ((string_append (''c.jr'')
             ((string_append ((spc_forwards () ))
                 ((string_append w__117 (''''))))))))) else
    assert_exp False (''Pattern match failure at unknown location'') \<then>
      exit0 () 
    | C_JALR (rs1) =>
  if (((rs1 \<noteq> zreg))) then
    reg_name_forwards rs1 \<bind>
      ((\<lambda> (w__120 :: string) . 
       return
         ((string_append (''c.jalr'')
             ((string_append ((spc_forwards () ))
                 ((string_append w__120 (''''))))))))) else
    assert_exp False (''Pattern match failure at unknown location'') \<then>
      exit0 () 
    | C_MV ((rd, rs2)) =>
  if ((((((rd \<noteq> zreg))) \<and> (((rs2 \<noteq> zreg)))))) then
    reg_name_forwards rd \<bind>
      ((\<lambda> (w__123 :: string) . 
       reg_name_forwards rs2 \<bind>
         ((\<lambda> (w__124 :: string) . 
          return
            ((string_append (''c.mv'')
                ((string_append ((spc_forwards () ))
                    ((string_append w__123
                        ((string_append ((sep_forwards () ))
                            ((string_append w__124 (''''))))))))))))))) else
    assert_exp False (''Pattern match failure at unknown location'') \<then>
      exit0 () 
    | C_EBREAK (_) => return (''c.ebreak'')
    | C_ADD ((rsd, rs2)) =>
  if ((((((rsd \<noteq> zreg))) \<and> (((rs2 \<noteq> zreg)))))) then
    reg_name_forwards rsd \<bind>
      ((\<lambda> (w__127 :: string) . 
       reg_name_forwards rs2 \<bind>
         ((\<lambda> (w__128 :: string) . 
          return
            ((string_append (''c.add'')
                ((string_append ((spc_forwards () ))
                    ((string_append w__127
                        ((string_append ((sep_forwards () ))
                            ((string_append w__128 (''''))))))))))))))) else
    assert_exp False (''Pattern match failure at unknown location'') \<then>
      exit0 () 
    | MUL ((rs2, rs1, rd, high, signed1, signed2)) =>
  reg_name_forwards rd \<bind>
    ((\<lambda> (w__131 :: string) . 
     reg_name_forwards rs1 \<bind>
       ((\<lambda> (w__132 :: string) . 
        reg_name_forwards rs2 \<bind>
          ((\<lambda> (w__133 :: string) . 
           return
             ((string_append
                 ((mul_mnemonic_forwards (high, signed1, signed2)))
                 ((string_append ((spc_forwards () ))
                     ((string_append w__131
                         ((string_append ((sep_forwards () ))
                             ((string_append w__132
                                 ((string_append ((sep_forwards () ))
                                     ((string_append w__133 ('''')))))))))))))))))))))
    | DIV ((rs2, rs1, rd, s)) =>
  reg_name_forwards rd \<bind>
    ((\<lambda> (w__134 :: string) . 
     reg_name_forwards rs1 \<bind>
       ((\<lambda> (w__135 :: string) . 
        reg_name_forwards rs2 \<bind>
          ((\<lambda> (w__136 :: string) . 
           return
             ((string_append (''div'')
                 ((string_append ((maybe_not_u_forwards s))
                     ((string_append ((spc_forwards () ))
                         ((string_append w__134
                             ((string_append ((sep_forwards () ))
                                 ((string_append w__135
                                     ((string_append ((sep_forwards () ))
                                         ((string_append w__136 ('''')))))))))))))))))))))))
    | REM ((rs2, rs1, rd, s)) =>
  reg_name_forwards rd \<bind>
    ((\<lambda> (w__137 :: string) . 
     reg_name_forwards rs1 \<bind>
       ((\<lambda> (w__138 :: string) . 
        reg_name_forwards rs2 \<bind>
          ((\<lambda> (w__139 :: string) . 
           return
             ((string_append (''rem'')
                 ((string_append ((maybe_not_u_forwards s))
                     ((string_append ((spc_forwards () ))
                         ((string_append w__137
                             ((string_append ((sep_forwards () ))
                                 ((string_append w__138
                                     ((string_append ((sep_forwards () ))
                                         ((string_append w__139 ('''')))))))))))))))))))))))
    | MULW ((rs2, rs1, rd)) =>
  if ((((( 64 :: int):: ii) = (( 64 :: int):: ii)))) then
    reg_name_forwards rd \<bind>
      ((\<lambda> (w__140 :: string) . 
       reg_name_forwards rs1 \<bind>
         ((\<lambda> (w__141 :: string) . 
          reg_name_forwards rs2 \<bind>
            ((\<lambda> (w__142 :: string) . 
             return
               ((string_append (''mulw'')
                   ((string_append ((spc_forwards () ))
                       ((string_append w__140
                           ((string_append ((sep_forwards () ))
                               ((string_append w__141
                                   ((string_append ((sep_forwards () ))
                                       ((string_append w__142 ('''')))))))))))))))))))))
  else
    assert_exp False (''Pattern match failure at unknown location'') \<then>
      exit0 () 
    | DIVW ((rs2, rs1, rd, s)) =>
  if ((((( 64 :: int):: ii) = (( 64 :: int):: ii)))) then
    reg_name_forwards rd \<bind>
      ((\<lambda> (w__145 :: string) . 
       reg_name_forwards rs1 \<bind>
         ((\<lambda> (w__146 :: string) . 
          reg_name_forwards rs2 \<bind>
            ((\<lambda> (w__147 :: string) . 
             return
               ((string_append (''div'')
                   ((string_append ((maybe_not_u_forwards s))
                       ((string_append (''w'')
                           ((string_append ((spc_forwards () ))
                               ((string_append w__145
                                   ((string_append ((sep_forwards () ))
                                       ((string_append w__146
                                           ((string_append
                                               ((sep_forwards () ))
                                               ((string_append w__147 ('''')))))))))))))))))))))))))
  else
    assert_exp False (''Pattern match failure at unknown location'') \<then>
      exit0 () 
    | REMW ((rs2, rs1, rd, s)) =>
  if ((((( 64 :: int):: ii) = (( 64 :: int):: ii)))) then
    reg_name_forwards rd \<bind>
      ((\<lambda> (w__150 :: string) . 
       reg_name_forwards rs1 \<bind>
         ((\<lambda> (w__151 :: string) . 
          reg_name_forwards rs2 \<bind>
            ((\<lambda> (w__152 :: string) . 
             return
               ((string_append (''rem'')
                   ((string_append ((maybe_not_u_forwards s))
                       ((string_append (''w'')
                           ((string_append ((spc_forwards () ))
                               ((string_append w__150
                                   ((string_append ((sep_forwards () ))
                                       ((string_append w__151
                                           ((string_append
                                               ((sep_forwards () ))
                                               ((string_append w__152 ('''')))))))))))))))))))))))))
  else
    assert_exp False (''Pattern match failure at unknown location'') \<then>
      exit0 () 
    | CSR ((csr, rs1, rd, True, op1)) =>
  reg_name_forwards rd \<bind>
    ((\<lambda> (w__155 :: string) . 
     return
       ((string_append ((csr_mnemonic_forwards op1))
           ((string_append (''i'')
               ((string_append ((spc_forwards () ))
                   ((string_append w__155
                       ((string_append ((sep_forwards () ))
                           ((string_append ((csr_name_map_forwards csr))
                               ((string_append ((sep_forwards () ))
                                   ((string_append
                                       ((decimal_string_of_bits rs1)) 
                                     ('''')))))))))))))))))))
    | CSR ((csr, rs1, rd, False, op1)) =>
  reg_name_forwards rd \<bind>
    ((\<lambda> (w__156 :: string) . 
     reg_name_forwards rs1 \<bind>
       ((\<lambda> (w__157 :: string) . 
        return
          ((string_append ((csr_mnemonic_forwards op1))
              ((string_append ((spc_forwards () ))
                  ((string_append w__156
                      ((string_append ((sep_forwards () ))
                          ((string_append ((csr_name_map_forwards csr))
                              ((string_append ((sep_forwards () ))
                                  ((string_append w__157 ('''')))))))))))))))))))
    | URET (_) => return (''uret'')
    | C_NOP_HINT (imm) =>
  return
    ((string_append (''c.nop.hint.'')
        ((string_append ((decimal_string_of_bits imm)) ('''')))))
    | C_ADDI_HINT (rsd) =>
  if (((rsd \<noteq> zreg))) then
    reg_name_forwards rsd \<bind>
      ((\<lambda> (w__158 :: string) . 
       return
         ((string_append (''c.addi.hint.'') ((string_append w__158 ('''')))))))
  else
    assert_exp False (''Pattern match failure at unknown location'') \<then>
      exit0 () 
    | C_LI_HINT (imm) =>
  return
    ((string_append (''c.li.hint.'')
        ((string_append ((decimal_string_of_bits imm)) ('''')))))
    | C_LUI_HINT (imm) =>
  if (((imm \<noteq> ( 0b000000 :: 6 Word.word)))) then
    return
      ((string_append (''c.lui.hint.'')
          ((string_append ((decimal_string_of_bits imm)) (''''))))) else
    assert_exp False (''Pattern match failure at unknown location'') \<then>
      exit0 () 
    | C_MV_HINT (rs2) =>
  if (((rs2 \<noteq> zreg))) then
    reg_name_forwards rs2 \<bind>
      ((\<lambda> (w__163 :: string) . 
       return
         ((string_append (''c.mv.hint.'') ((string_append w__163 ('''')))))))
  else
    assert_exp False (''Pattern match failure at unknown location'') \<then>
      exit0 () 
    | C_ADD_HINT (rs2) =>
  if (((rs2 \<noteq> zreg))) then
    reg_name_forwards rs2 \<bind>
      ((\<lambda> (w__166 :: string) . 
       return
         ((string_append (''c.add.hint.'') ((string_append w__166 ('''')))))))
  else
    assert_exp False (''Pattern match failure at unknown location'') \<then>
      exit0 () 
    | C_SLLI_HINT ((shamt, rsd)) =>
  if ((((((shamt = ( 0b000000 :: 6 Word.word)))) \<or> (((rsd = zreg)))))) then
    reg_name_forwards rsd \<bind>
      ((\<lambda> (w__169 :: string) . 
       return
         ((string_append (''c.slli.hint.'')
             ((string_append w__169
                 ((string_append (''.'')
                     ((string_append ((decimal_string_of_bits shamt)) ('''')))))))))))
  else
    assert_exp False (''Pattern match failure at unknown location'') \<then>
      exit0 () 
    | C_SRLI_HINT (rsd) =>
  creg_name_forwards rsd \<bind>
    ((\<lambda> (w__172 :: string) . 
     return
       ((string_append (''c.srli.hint.'') ((string_append w__172 ('''')))))))
    | C_SRAI_HINT (rsd) =>
  creg_name_forwards rsd \<bind>
    ((\<lambda> (w__173 :: string) . 
     return
       ((string_append (''c.srai.hint.'') ((string_append w__173 ('''')))))))
    | FENCE_RESERVED ((fm, pred, succ, rs, rd)) =>
  if (((((((((fm \<noteq> ( 0x0 :: 4 Word.word)))) \<and>
             (((fm \<noteq> ( 0x8 :: 4 Word.word))))))) \<or>
          ((((((rs \<noteq> ( 0b00000 :: 5 Word.word)))) \<or>
               (((rd \<noteq> ( 0b00000 :: 5 Word.word)))))))))) then
    fence_bits_forwards pred \<bind>
      ((\<lambda> (w__174 :: string) . 
       fence_bits_forwards succ \<bind>
         ((\<lambda> (w__175 :: string) . 
          reg_name_forwards rs \<bind>
            ((\<lambda> (w__176 :: string) . 
             reg_name_forwards rd \<bind>
               ((\<lambda> (w__177 :: string) . 
                return
                  ((string_append (''fence.reserved.'')
                      ((string_append w__174
                          ((string_append (''.'')
                              ((string_append w__175
                                  ((string_append (''.'')
                                      ((string_append w__176
                                          ((string_append (''.'')
                                              ((string_append w__177
                                                  ((string_append (''.'')
                                                      ((string_append
                                                          ((decimal_string_of_bits
                                                              fm)) ('''')))))))))))))))))))))))))))))
  else
    assert_exp False (''Pattern match failure at unknown location'') \<then>
      exit0 () 
    | FENCEI_RESERVED ((imm, rs, rd)) =>
  if ((((((imm \<noteq> ( 0x000 :: 12 Word.word)))) \<or>
          ((((((rs \<noteq> zreg))) \<or> (((rd \<noteq> zreg))))))))) then
    reg_name_forwards rd \<bind>
      ((\<lambda> (w__180 :: string) . 
       reg_name_forwards rs \<bind>
         ((\<lambda> (w__181 :: string) . 
          return
            ((string_append (''fence.i.reserved.'')
                ((string_append w__180
                    ((string_append (''.'')
                        ((string_append w__181
                            ((string_append (''.'')
                                ((string_append
                                    ((decimal_string_of_bits imm)) ('''')))))))))))))))))
  else
    assert_exp False (''Pattern match failure at unknown location'') \<then>
      exit0 () 
    | LOAD_FP ((imm, rs1, rd, width)) =>
  freg_name_forwards rd \<bind>
    ((\<lambda> (w__184 :: string) . 
     reg_name_forwards rs1 \<bind>
       ((\<lambda> (w__185 :: string) . 
        return
          ((string_append (''fl'')
              ((string_append ((size_mnemonic_forwards width))
                  ((string_append ((spc_forwards () ))
                      ((string_append w__184
                          ((string_append ((sep_forwards () ))
                              ((string_append ((decimal_string_of_bits imm))
                                  ((string_append ((opt_spc_forwards () ))
                                      ((string_append (''('')
                                          ((string_append
                                              ((opt_spc_forwards () ))
                                              ((string_append w__185
                                                  ((string_append
                                                      ((opt_spc_forwards () ))
                                                      ((string_append 
                                                        ('')'') ('''')))))))))))))))))))))))))))))
    | STORE_FP ((imm, rs2, rs1, width)) =>
  freg_name_forwards rs2 \<bind>
    ((\<lambda> (w__186 :: string) . 
     reg_name_forwards rs1 \<bind>
       ((\<lambda> (w__187 :: string) . 
        return
          ((string_append (''fs'')
              ((string_append ((size_mnemonic_forwards width))
                  ((string_append ((spc_forwards () ))
                      ((string_append w__186
                          ((string_append ((sep_forwards () ))
                              ((string_append ((decimal_string_of_bits imm))
                                  ((string_append ((opt_spc_forwards () ))
                                      ((string_append (''('')
                                          ((string_append
                                              ((opt_spc_forwards () ))
                                              ((string_append w__187
                                                  ((string_append
                                                      ((opt_spc_forwards () ))
                                                      ((string_append 
                                                        ('')'') ('''')))))))))))))))))))))))))))))
    | F_MADD_TYPE_S ((rs3, rs2, rs1, rm, rd, op1)) =>
  freg_name_forwards rd \<bind>
    ((\<lambda> (w__188 :: string) . 
     freg_name_forwards rs1 \<bind>
       ((\<lambda> (w__189 :: string) . 
        freg_name_forwards rs2 \<bind>
          ((\<lambda> (w__190 :: string) . 
           freg_name_forwards rs3 \<bind>
             ((\<lambda> (w__191 :: string) . 
              return
                ((string_append ((f_madd_type_mnemonic_S_forwards op1))
                    ((string_append ((spc_forwards () ))
                        ((string_append w__188
                            ((string_append ((sep_forwards () ))
                                ((string_append w__189
                                    ((string_append ((sep_forwards () ))
                                        ((string_append w__190
                                            ((string_append
                                                ((sep_forwards () ))
                                                ((string_append w__191
                                                    ((string_append
                                                        ((sep_forwards () ))
                                                        ((string_append
                                                            ((frm_mnemonic_forwards
                                                                rm)) 
                                                          ('''')))))))))))))))))))))))))))))))
    | F_BIN_RM_TYPE_S ((rs2, rs1, rm, rd, op1)) =>
  freg_name_forwards rd \<bind>
    ((\<lambda> (w__192 :: string) . 
     freg_name_forwards rs1 \<bind>
       ((\<lambda> (w__193 :: string) . 
        freg_name_forwards rs2 \<bind>
          ((\<lambda> (w__194 :: string) . 
           return
             ((string_append ((f_bin_rm_type_mnemonic_S_forwards op1))
                 ((string_append ((spc_forwards () ))
                     ((string_append w__192
                         ((string_append ((sep_forwards () ))
                             ((string_append w__193
                                 ((string_append ((sep_forwards () ))
                                     ((string_append w__194
                                         ((string_append ((sep_forwards () ))
                                             ((string_append
                                                 ((frm_mnemonic_forwards rm))
                                                 ('''')))))))))))))))))))))))))
    | F_UN_RM_TYPE_S ((rs1, rm, rd, FSQRT_S)) =>
  freg_name_forwards rd \<bind>
    ((\<lambda> (w__195 :: string) . 
     freg_name_forwards rs1 \<bind>
       ((\<lambda> (w__196 :: string) . 
        return
          ((string_append ((f_un_rm_type_mnemonic_S_forwards FSQRT_S))
              ((string_append ((spc_forwards () ))
                  ((string_append w__195
                      ((string_append ((sep_forwards () ))
                          ((string_append w__196
                              ((string_append ((sep_forwards () ))
                                  ((string_append
                                      ((frm_mnemonic_forwards rm)) ('''')))))))))))))))))))
    | F_UN_RM_TYPE_S ((rs1, rm, rd, FCVT_W_S)) =>
  reg_name_forwards rd \<bind>
    ((\<lambda> (w__197 :: string) . 
     freg_name_forwards rs1 \<bind>
       ((\<lambda> (w__198 :: string) . 
        return
          ((string_append ((f_un_rm_type_mnemonic_S_forwards FCVT_W_S))
              ((string_append ((spc_forwards () ))
                  ((string_append w__197
                      ((string_append ((sep_forwards () ))
                          ((string_append w__198
                              ((string_append ((sep_forwards () ))
                                  ((string_append
                                      ((frm_mnemonic_forwards rm)) ('''')))))))))))))))))))
    | F_UN_RM_TYPE_S ((rs1, rm, rd, FCVT_WU_S)) =>
  reg_name_forwards rd \<bind>
    ((\<lambda> (w__199 :: string) . 
     freg_name_forwards rs1 \<bind>
       ((\<lambda> (w__200 :: string) . 
        return
          ((string_append ((f_un_rm_type_mnemonic_S_forwards FCVT_WU_S))
              ((string_append ((spc_forwards () ))
                  ((string_append w__199
                      ((string_append ((sep_forwards () ))
                          ((string_append w__200
                              ((string_append ((sep_forwards () ))
                                  ((string_append
                                      ((frm_mnemonic_forwards rm)) ('''')))))))))))))))))))
    | F_UN_RM_TYPE_S ((rs1, rm, rd, FCVT_S_W)) =>
  freg_name_forwards rd \<bind>
    ((\<lambda> (w__201 :: string) . 
     reg_name_forwards rs1 \<bind>
       ((\<lambda> (w__202 :: string) . 
        return
          ((string_append ((f_un_rm_type_mnemonic_S_forwards FCVT_S_W))
              ((string_append ((spc_forwards () ))
                  ((string_append w__201
                      ((string_append ((sep_forwards () ))
                          ((string_append w__202
                              ((string_append ((sep_forwards () ))
                                  ((string_append
                                      ((frm_mnemonic_forwards rm)) ('''')))))))))))))))))))
    | F_UN_RM_TYPE_S ((rs1, rm, rd, FCVT_S_WU)) =>
  freg_name_forwards rd \<bind>
    ((\<lambda> (w__203 :: string) . 
     reg_name_forwards rs1 \<bind>
       ((\<lambda> (w__204 :: string) . 
        return
          ((string_append ((f_un_rm_type_mnemonic_S_forwards FCVT_S_WU))
              ((string_append ((spc_forwards () ))
                  ((string_append w__203
                      ((string_append ((sep_forwards () ))
                          ((string_append w__204
                              ((string_append ((sep_forwards () ))
                                  ((string_append
                                      ((frm_mnemonic_forwards rm)) ('''')))))))))))))))))))
    | F_UN_RM_TYPE_S ((rs1, rm, rd, FCVT_L_S)) =>
  reg_name_forwards rd \<bind>
    ((\<lambda> (w__205 :: string) . 
     freg_name_forwards rs1 \<bind>
       ((\<lambda> (w__206 :: string) . 
        return
          ((string_append ((f_un_rm_type_mnemonic_S_forwards FCVT_L_S))
              ((string_append ((spc_forwards () ))
                  ((string_append w__205
                      ((string_append ((sep_forwards () ))
                          ((string_append w__206
                              ((string_append ((sep_forwards () ))
                                  ((string_append
                                      ((frm_mnemonic_forwards rm)) ('''')))))))))))))))))))
    | F_UN_RM_TYPE_S ((rs1, rm, rd, FCVT_LU_S)) =>
  reg_name_forwards rd \<bind>
    ((\<lambda> (w__207 :: string) . 
     freg_name_forwards rs1 \<bind>
       ((\<lambda> (w__208 :: string) . 
        return
          ((string_append ((f_un_rm_type_mnemonic_S_forwards FCVT_LU_S))
              ((string_append ((spc_forwards () ))
                  ((string_append w__207
                      ((string_append ((sep_forwards () ))
                          ((string_append w__208
                              ((string_append ((sep_forwards () ))
                                  ((string_append
                                      ((frm_mnemonic_forwards rm)) ('''')))))))))))))))))))
    | F_UN_RM_TYPE_S ((rs1, rm, rd, FCVT_S_L)) =>
  freg_name_forwards rd \<bind>
    ((\<lambda> (w__209 :: string) . 
     reg_name_forwards rs1 \<bind>
       ((\<lambda> (w__210 :: string) . 
        return
          ((string_append ((f_un_rm_type_mnemonic_S_forwards FCVT_S_L))
              ((string_append ((spc_forwards () ))
                  ((string_append w__209
                      ((string_append ((sep_forwards () ))
                          ((string_append w__210
                              ((string_append ((sep_forwards () ))
                                  ((string_append
                                      ((frm_mnemonic_forwards rm)) ('''')))))))))))))))))))
    | F_UN_RM_TYPE_S ((rs1, rm, rd, FCVT_S_LU)) =>
  freg_name_forwards rd \<bind>
    ((\<lambda> (w__211 :: string) . 
     reg_name_forwards rs1 \<bind>
       ((\<lambda> (w__212 :: string) . 
        return
          ((string_append ((f_un_rm_type_mnemonic_S_forwards FCVT_S_LU))
              ((string_append ((spc_forwards () ))
                  ((string_append w__211
                      ((string_append ((sep_forwards () ))
                          ((string_append w__212
                              ((string_append ((sep_forwards () ))
                                  ((string_append
                                      ((frm_mnemonic_forwards rm)) ('''')))))))))))))))))))
    | F_BIN_TYPE_S ((rs2, rs1, rd, FSGNJ_S)) =>
  freg_name_forwards rd \<bind>
    ((\<lambda> (w__213 :: string) . 
     freg_name_forwards rs1 \<bind>
       ((\<lambda> (w__214 :: string) . 
        freg_name_forwards rs2 \<bind>
          ((\<lambda> (w__215 :: string) . 
           return
             ((string_append ((f_bin_type_mnemonic_S_forwards FSGNJ_S))
                 ((string_append ((spc_forwards () ))
                     ((string_append w__213
                         ((string_append ((sep_forwards () ))
                             ((string_append w__214
                                 ((string_append ((sep_forwards () ))
                                     ((string_append w__215 ('''')))))))))))))))))))))
    | F_BIN_TYPE_S ((rs2, rs1, rd, FSGNJN_S)) =>
  freg_name_forwards rd \<bind>
    ((\<lambda> (w__216 :: string) . 
     freg_name_forwards rs1 \<bind>
       ((\<lambda> (w__217 :: string) . 
        freg_name_forwards rs2 \<bind>
          ((\<lambda> (w__218 :: string) . 
           return
             ((string_append ((f_bin_type_mnemonic_S_forwards FSGNJN_S))
                 ((string_append ((spc_forwards () ))
                     ((string_append w__216
                         ((string_append ((sep_forwards () ))
                             ((string_append w__217
                                 ((string_append ((sep_forwards () ))
                                     ((string_append w__218 ('''')))))))))))))))))))))
    | F_BIN_TYPE_S ((rs2, rs1, rd, FSGNJX_S)) =>
  freg_name_forwards rd \<bind>
    ((\<lambda> (w__219 :: string) . 
     freg_name_forwards rs1 \<bind>
       ((\<lambda> (w__220 :: string) . 
        freg_name_forwards rs2 \<bind>
          ((\<lambda> (w__221 :: string) . 
           return
             ((string_append ((f_bin_type_mnemonic_S_forwards FSGNJX_S))
                 ((string_append ((spc_forwards () ))
                     ((string_append w__219
                         ((string_append ((sep_forwards () ))
                             ((string_append w__220
                                 ((string_append ((sep_forwards () ))
                                     ((string_append w__221 ('''')))))))))))))))))))))
    | F_BIN_TYPE_S ((rs2, rs1, rd, FMIN_S)) =>
  freg_name_forwards rd \<bind>
    ((\<lambda> (w__222 :: string) . 
     freg_name_forwards rs1 \<bind>
       ((\<lambda> (w__223 :: string) . 
        freg_name_forwards rs2 \<bind>
          ((\<lambda> (w__224 :: string) . 
           return
             ((string_append ((f_bin_type_mnemonic_S_forwards FMIN_S))
                 ((string_append ((spc_forwards () ))
                     ((string_append w__222
                         ((string_append ((sep_forwards () ))
                             ((string_append w__223
                                 ((string_append ((sep_forwards () ))
                                     ((string_append w__224 ('''')))))))))))))))))))))
    | F_BIN_TYPE_S ((rs2, rs1, rd, FMAX_S)) =>
  freg_name_forwards rd \<bind>
    ((\<lambda> (w__225 :: string) . 
     freg_name_forwards rs1 \<bind>
       ((\<lambda> (w__226 :: string) . 
        freg_name_forwards rs2 \<bind>
          ((\<lambda> (w__227 :: string) . 
           return
             ((string_append ((f_bin_type_mnemonic_S_forwards FMAX_S))
                 ((string_append ((spc_forwards () ))
                     ((string_append w__225
                         ((string_append ((sep_forwards () ))
                             ((string_append w__226
                                 ((string_append ((sep_forwards () ))
                                     ((string_append w__227 ('''')))))))))))))))))))))
    | F_BIN_TYPE_S ((rs2, rs1, rd, FEQ_S)) =>
  reg_name_forwards rd \<bind>
    ((\<lambda> (w__228 :: string) . 
     freg_name_forwards rs1 \<bind>
       ((\<lambda> (w__229 :: string) . 
        freg_name_forwards rs2 \<bind>
          ((\<lambda> (w__230 :: string) . 
           return
             ((string_append ((f_bin_type_mnemonic_S_forwards FEQ_S))
                 ((string_append ((spc_forwards () ))
                     ((string_append w__228
                         ((string_append ((sep_forwards () ))
                             ((string_append w__229
                                 ((string_append ((sep_forwards () ))
                                     ((string_append w__230 ('''')))))))))))))))))))))
    | F_BIN_TYPE_S ((rs2, rs1, rd, FLT_S)) =>
  reg_name_forwards rd \<bind>
    ((\<lambda> (w__231 :: string) . 
     freg_name_forwards rs1 \<bind>
       ((\<lambda> (w__232 :: string) . 
        freg_name_forwards rs2 \<bind>
          ((\<lambda> (w__233 :: string) . 
           return
             ((string_append ((f_bin_type_mnemonic_S_forwards FLT_S))
                 ((string_append ((spc_forwards () ))
                     ((string_append w__231
                         ((string_append ((sep_forwards () ))
                             ((string_append w__232
                                 ((string_append ((sep_forwards () ))
                                     ((string_append w__233 ('''')))))))))))))))))))))
    | F_BIN_TYPE_S ((rs2, rs1, rd, FLE_S)) =>
  reg_name_forwards rd \<bind>
    ((\<lambda> (w__234 :: string) . 
     freg_name_forwards rs1 \<bind>
       ((\<lambda> (w__235 :: string) . 
        freg_name_forwards rs2 \<bind>
          ((\<lambda> (w__236 :: string) . 
           return
             ((string_append ((f_bin_type_mnemonic_S_forwards FLE_S))
                 ((string_append ((spc_forwards () ))
                     ((string_append w__234
                         ((string_append ((sep_forwards () ))
                             ((string_append w__235
                                 ((string_append ((sep_forwards () ))
                                     ((string_append w__236 ('''')))))))))))))))))))))
    | F_UN_TYPE_S ((rs1, rd, FMV_X_W)) =>
  reg_name_forwards rd \<bind>
    ((\<lambda> (w__237 :: string) . 
     freg_name_forwards rs1 \<bind>
       ((\<lambda> (w__238 :: string) . 
        return
          ((string_append ((f_un_type_mnemonic_S_forwards FMV_X_W))
              ((string_append ((spc_forwards () ))
                  ((string_append w__237
                      ((string_append ((sep_forwards () ))
                          ((string_append w__238 ('''')))))))))))))))
    | F_UN_TYPE_S ((rs1, rd, FMV_W_X)) =>
  freg_name_forwards rd \<bind>
    ((\<lambda> (w__239 :: string) . 
     reg_name_forwards rs1 \<bind>
       ((\<lambda> (w__240 :: string) . 
        return
          ((string_append ((f_un_type_mnemonic_S_forwards FMV_W_X))
              ((string_append ((spc_forwards () ))
                  ((string_append w__239
                      ((string_append ((sep_forwards () ))
                          ((string_append w__240 ('''')))))))))))))))
    | F_UN_TYPE_S ((rs1, rd, FCLASS_S)) =>
  reg_name_forwards rd \<bind>
    ((\<lambda> (w__241 :: string) . 
     freg_name_forwards rs1 \<bind>
       ((\<lambda> (w__242 :: string) . 
        return
          ((string_append ((f_un_type_mnemonic_S_forwards FCLASS_S))
              ((string_append ((spc_forwards () ))
                  ((string_append w__241
                      ((string_append ((sep_forwards () ))
                          ((string_append w__242 ('''')))))))))))))))
    | C_FLWSP ((imm, rd)) =>
  if ((((( 64 :: int):: ii) = (( 32 :: int):: ii)))) then
    reg_name_forwards rd \<bind>
      ((\<lambda> (w__243 :: string) . 
       return
         ((string_append (''c.flwsp'')
             ((string_append ((spc_forwards () ))
                 ((string_append w__243
                     ((string_append ((sep_forwards () ))
                         ((string_append ((decimal_string_of_bits imm))
                             (''''))))))))))))) else
    assert_exp False (''Pattern match failure at unknown location'') \<then>
      exit0 () 
    | C_FSWSP ((uimm, rd)) =>
  if ((((( 64 :: int):: ii) = (( 32 :: int):: ii)))) then
    reg_name_forwards rd \<bind>
      ((\<lambda> (w__246 :: string) . 
       return
         ((string_append (''c.fswsp'')
             ((string_append ((spc_forwards () ))
                 ((string_append w__246
                     ((string_append ((sep_forwards () ))
                         ((string_append ((decimal_string_of_bits uimm))
                             (''''))))))))))))) else
    assert_exp False (''Pattern match failure at unknown location'') \<then>
      exit0 () 
    | C_FLW ((uimm, rsc, rdc)) =>
  if ((((( 64 :: int):: ii) = (( 32 :: int):: ii)))) then
    creg_name_forwards rdc \<bind>
      ((\<lambda> (w__249 :: string) . 
       creg_name_forwards rsc \<bind>
         ((\<lambda> (w__250 :: string) . 
          return
            ((string_append (''c.flw'')
                ((string_append ((spc_forwards () ))
                    ((string_append w__249
                        ((string_append ((sep_forwards () ))
                            ((string_append w__250
                                ((string_append ((sep_forwards () ))
                                    ((string_append
                                        ((decimal_string_of_bits
                                            ((concat_vec uimm
                                                ( 0b00 :: 2 Word.word) :: 7 Word.word))))
                                        (''''))))))))))))))))))) else
    assert_exp False (''Pattern match failure at unknown location'') \<then>
      exit0 () 
    | C_FSW ((uimm, rsc1, rsc2)) =>
  if ((((( 64 :: int):: ii) = (( 32 :: int):: ii)))) then
    creg_name_forwards rsc1 \<bind>
      ((\<lambda> (w__253 :: string) . 
       creg_name_forwards rsc2 \<bind>
         ((\<lambda> (w__254 :: string) . 
          return
            ((string_append (''c.fsw'')
                ((string_append ((spc_forwards () ))
                    ((string_append w__253
                        ((string_append ((sep_forwards () ))
                            ((string_append w__254
                                ((string_append ((sep_forwards () ))
                                    ((string_append
                                        ((decimal_string_of_bits
                                            ((concat_vec uimm
                                                ( 0b00 :: 2 Word.word) :: 7 Word.word))))
                                        (''''))))))))))))))))))) else
    assert_exp False (''Pattern match failure at unknown location'') \<then>
      exit0 () 
    | F_MADD_TYPE_D ((rs3, rs2, rs1, rm, rd, op1)) =>
  freg_name_forwards rd \<bind>
    ((\<lambda> (w__257 :: string) . 
     freg_name_forwards rs1 \<bind>
       ((\<lambda> (w__258 :: string) . 
        freg_name_forwards rs2 \<bind>
          ((\<lambda> (w__259 :: string) . 
           freg_name_forwards rs3 \<bind>
             ((\<lambda> (w__260 :: string) . 
              return
                ((string_append ((f_madd_type_mnemonic_D_forwards op1))
                    ((string_append ((spc_forwards () ))
                        ((string_append w__257
                            ((string_append ((sep_forwards () ))
                                ((string_append w__258
                                    ((string_append ((sep_forwards () ))
                                        ((string_append w__259
                                            ((string_append
                                                ((sep_forwards () ))
                                                ((string_append w__260
                                                    ((string_append
                                                        ((sep_forwards () ))
                                                        ((string_append
                                                            ((frm_mnemonic_forwards
                                                                rm)) 
                                                          ('''')))))))))))))))))))))))))))))))
    | F_BIN_RM_TYPE_D ((rs2, rs1, rm, rd, op1)) =>
  freg_name_forwards rd \<bind>
    ((\<lambda> (w__261 :: string) . 
     freg_name_forwards rs1 \<bind>
       ((\<lambda> (w__262 :: string) . 
        freg_name_forwards rs2 \<bind>
          ((\<lambda> (w__263 :: string) . 
           return
             ((string_append ((f_bin_rm_type_mnemonic_D_forwards op1))
                 ((string_append ((spc_forwards () ))
                     ((string_append w__261
                         ((string_append ((sep_forwards () ))
                             ((string_append w__262
                                 ((string_append ((sep_forwards () ))
                                     ((string_append w__263
                                         ((string_append ((sep_forwards () ))
                                             ((string_append
                                                 ((frm_mnemonic_forwards rm))
                                                 ('''')))))))))))))))))))))))))
    | F_UN_RM_TYPE_D ((rs1, rm, rd, FSQRT_D)) =>
  freg_name_forwards rd \<bind>
    ((\<lambda> (w__264 :: string) . 
     freg_name_forwards rs1 \<bind>
       ((\<lambda> (w__265 :: string) . 
        return
          ((string_append ((f_un_rm_type_mnemonic_D_forwards FSQRT_D))
              ((string_append ((spc_forwards () ))
                  ((string_append w__264
                      ((string_append ((sep_forwards () ))
                          ((string_append w__265
                              ((string_append ((sep_forwards () ))
                                  ((string_append
                                      ((frm_mnemonic_forwards rm)) ('''')))))))))))))))))))
    | F_UN_RM_TYPE_D ((rs1, rm, rd, FCVT_W_D)) =>
  reg_name_forwards rd \<bind>
    ((\<lambda> (w__266 :: string) . 
     freg_name_forwards rs1 \<bind>
       ((\<lambda> (w__267 :: string) . 
        return
          ((string_append ((f_un_rm_type_mnemonic_D_forwards FCVT_W_D))
              ((string_append ((spc_forwards () ))
                  ((string_append w__266
                      ((string_append ((sep_forwards () ))
                          ((string_append w__267
                              ((string_append ((sep_forwards () ))
                                  ((string_append
                                      ((frm_mnemonic_forwards rm)) ('''')))))))))))))))))))
    | F_UN_RM_TYPE_D ((rs1, rm, rd, FCVT_WU_D)) =>
  reg_name_forwards rd \<bind>
    ((\<lambda> (w__268 :: string) . 
     freg_name_forwards rs1 \<bind>
       ((\<lambda> (w__269 :: string) . 
        return
          ((string_append ((f_un_rm_type_mnemonic_D_forwards FCVT_WU_D))
              ((string_append ((spc_forwards () ))
                  ((string_append w__268
                      ((string_append ((sep_forwards () ))
                          ((string_append w__269
                              ((string_append ((sep_forwards () ))
                                  ((string_append
                                      ((frm_mnemonic_forwards rm)) ('''')))))))))))))))))))
    | F_UN_RM_TYPE_D ((rs1, rm, rd, FCVT_D_W)) =>
  freg_name_forwards rd \<bind>
    ((\<lambda> (w__270 :: string) . 
     reg_name_forwards rs1 \<bind>
       ((\<lambda> (w__271 :: string) . 
        return
          ((string_append ((f_un_rm_type_mnemonic_D_forwards FCVT_D_W))
              ((string_append ((spc_forwards () ))
                  ((string_append w__270
                      ((string_append ((sep_forwards () ))
                          ((string_append w__271
                              ((string_append ((sep_forwards () ))
                                  ((string_append
                                      ((frm_mnemonic_forwards rm)) ('''')))))))))))))))))))
    | F_UN_RM_TYPE_D ((rs1, rm, rd, FCVT_D_WU)) =>
  freg_name_forwards rd \<bind>
    ((\<lambda> (w__272 :: string) . 
     reg_name_forwards rs1 \<bind>
       ((\<lambda> (w__273 :: string) . 
        return
          ((string_append ((f_un_rm_type_mnemonic_D_forwards FCVT_D_WU))
              ((string_append ((spc_forwards () ))
                  ((string_append w__272
                      ((string_append ((sep_forwards () ))
                          ((string_append w__273
                              ((string_append ((sep_forwards () ))
                                  ((string_append
                                      ((frm_mnemonic_forwards rm)) ('''')))))))))))))))))))
    | F_UN_RM_TYPE_D ((rs1, rm, rd, FCVT_L_D)) =>
  reg_name_forwards rd \<bind>
    ((\<lambda> (w__274 :: string) . 
     freg_name_forwards rs1 \<bind>
       ((\<lambda> (w__275 :: string) . 
        return
          ((string_append ((f_un_rm_type_mnemonic_D_forwards FCVT_L_D))
              ((string_append ((spc_forwards () ))
                  ((string_append w__274
                      ((string_append ((sep_forwards () ))
                          ((string_append w__275
                              ((string_append ((sep_forwards () ))
                                  ((string_append
                                      ((frm_mnemonic_forwards rm)) ('''')))))))))))))))))))
    | F_UN_RM_TYPE_D ((rs1, rm, rd, FCVT_LU_D)) =>
  reg_name_forwards rd \<bind>
    ((\<lambda> (w__276 :: string) . 
     freg_name_forwards rs1 \<bind>
       ((\<lambda> (w__277 :: string) . 
        return
          ((string_append ((f_un_rm_type_mnemonic_D_forwards FCVT_LU_D))
              ((string_append ((spc_forwards () ))
                  ((string_append w__276
                      ((string_append ((sep_forwards () ))
                          ((string_append w__277
                              ((string_append ((sep_forwards () ))
                                  ((string_append
                                      ((frm_mnemonic_forwards rm)) ('''')))))))))))))))))))
    | F_UN_RM_TYPE_D ((rs1, rm, rd, FCVT_D_L)) =>
  freg_name_forwards rd \<bind>
    ((\<lambda> (w__278 :: string) . 
     reg_name_forwards rs1 \<bind>
       ((\<lambda> (w__279 :: string) . 
        return
          ((string_append ((f_un_rm_type_mnemonic_D_forwards FCVT_D_L))
              ((string_append ((spc_forwards () ))
                  ((string_append w__278
                      ((string_append ((sep_forwards () ))
                          ((string_append w__279
                              ((string_append ((sep_forwards () ))
                                  ((string_append
                                      ((frm_mnemonic_forwards rm)) ('''')))))))))))))))))))
    | F_UN_RM_TYPE_D ((rs1, rm, rd, FCVT_D_LU)) =>
  freg_name_forwards rd \<bind>
    ((\<lambda> (w__280 :: string) . 
     reg_name_forwards rs1 \<bind>
       ((\<lambda> (w__281 :: string) . 
        return
          ((string_append ((f_un_rm_type_mnemonic_D_forwards FCVT_D_LU))
              ((string_append ((spc_forwards () ))
                  ((string_append w__280
                      ((string_append ((sep_forwards () ))
                          ((string_append w__281
                              ((string_append ((sep_forwards () ))
                                  ((string_append
                                      ((frm_mnemonic_forwards rm)) ('''')))))))))))))))))))
    | F_UN_RM_TYPE_D ((rs1, rm, rd, FCVT_S_D)) =>
  freg_name_forwards rd \<bind>
    ((\<lambda> (w__282 :: string) . 
     freg_name_forwards rs1 \<bind>
       ((\<lambda> (w__283 :: string) . 
        return
          ((string_append ((f_un_rm_type_mnemonic_D_forwards FCVT_S_D))
              ((string_append ((spc_forwards () ))
                  ((string_append w__282
                      ((string_append ((sep_forwards () ))
                          ((string_append w__283
                              ((string_append ((sep_forwards () ))
                                  ((string_append
                                      ((frm_mnemonic_forwards rm)) ('''')))))))))))))))))))
    | F_UN_RM_TYPE_D ((rs1, rm, rd, FCVT_D_S)) =>
  freg_name_forwards rd \<bind>
    ((\<lambda> (w__284 :: string) . 
     freg_name_forwards rs1 \<bind>
       ((\<lambda> (w__285 :: string) . 
        return
          ((string_append ((f_un_rm_type_mnemonic_D_forwards FCVT_D_S))
              ((string_append ((spc_forwards () ))
                  ((string_append w__284
                      ((string_append ((sep_forwards () ))
                          ((string_append w__285
                              ((string_append ((sep_forwards () ))
                                  ((string_append
                                      ((frm_mnemonic_forwards rm)) ('''')))))))))))))))))))
    | F_BIN_TYPE_D ((rs2, rs1, rd, FSGNJ_D)) =>
  freg_name_forwards rd \<bind>
    ((\<lambda> (w__286 :: string) . 
     freg_name_forwards rs1 \<bind>
       ((\<lambda> (w__287 :: string) . 
        freg_name_forwards rs2 \<bind>
          ((\<lambda> (w__288 :: string) . 
           return
             ((string_append ((f_bin_type_mnemonic_D_forwards FSGNJ_D))
                 ((string_append ((spc_forwards () ))
                     ((string_append w__286
                         ((string_append ((sep_forwards () ))
                             ((string_append w__287
                                 ((string_append ((sep_forwards () ))
                                     ((string_append w__288 ('''')))))))))))))))))))))
    | F_BIN_TYPE_D ((rs2, rs1, rd, FSGNJN_D)) =>
  freg_name_forwards rd \<bind>
    ((\<lambda> (w__289 :: string) . 
     freg_name_forwards rs1 \<bind>
       ((\<lambda> (w__290 :: string) . 
        freg_name_forwards rs2 \<bind>
          ((\<lambda> (w__291 :: string) . 
           return
             ((string_append ((f_bin_type_mnemonic_D_forwards FSGNJN_D))
                 ((string_append ((spc_forwards () ))
                     ((string_append w__289
                         ((string_append ((sep_forwards () ))
                             ((string_append w__290
                                 ((string_append ((sep_forwards () ))
                                     ((string_append w__291 ('''')))))))))))))))))))))
    | F_BIN_TYPE_D ((rs2, rs1, rd, FSGNJX_D)) =>
  freg_name_forwards rd \<bind>
    ((\<lambda> (w__292 :: string) . 
     freg_name_forwards rs1 \<bind>
       ((\<lambda> (w__293 :: string) . 
        freg_name_forwards rs2 \<bind>
          ((\<lambda> (w__294 :: string) . 
           return
             ((string_append ((f_bin_type_mnemonic_D_forwards FSGNJX_D))
                 ((string_append ((spc_forwards () ))
                     ((string_append w__292
                         ((string_append ((sep_forwards () ))
                             ((string_append w__293
                                 ((string_append ((sep_forwards () ))
                                     ((string_append w__294 ('''')))))))))))))))))))))
    | F_BIN_TYPE_D ((rs2, rs1, rd, FMIN_D)) =>
  freg_name_forwards rd \<bind>
    ((\<lambda> (w__295 :: string) . 
     freg_name_forwards rs1 \<bind>
       ((\<lambda> (w__296 :: string) . 
        freg_name_forwards rs2 \<bind>
          ((\<lambda> (w__297 :: string) . 
           return
             ((string_append ((f_bin_type_mnemonic_D_forwards FMIN_D))
                 ((string_append ((spc_forwards () ))
                     ((string_append w__295
                         ((string_append ((sep_forwards () ))
                             ((string_append w__296
                                 ((string_append ((sep_forwards () ))
                                     ((string_append w__297 ('''')))))))))))))))))))))
    | F_BIN_TYPE_D ((rs2, rs1, rd, FMAX_D)) =>
  freg_name_forwards rd \<bind>
    ((\<lambda> (w__298 :: string) . 
     freg_name_forwards rs1 \<bind>
       ((\<lambda> (w__299 :: string) . 
        freg_name_forwards rs2 \<bind>
          ((\<lambda> (w__300 :: string) . 
           return
             ((string_append ((f_bin_type_mnemonic_D_forwards FMAX_D))
                 ((string_append ((spc_forwards () ))
                     ((string_append w__298
                         ((string_append ((sep_forwards () ))
                             ((string_append w__299
                                 ((string_append ((sep_forwards () ))
                                     ((string_append w__300 ('''')))))))))))))))))))))
    | F_BIN_TYPE_D ((rs2, rs1, rd, FEQ_D)) =>
  reg_name_forwards rd \<bind>
    ((\<lambda> (w__301 :: string) . 
     freg_name_forwards rs1 \<bind>
       ((\<lambda> (w__302 :: string) . 
        freg_name_forwards rs2 \<bind>
          ((\<lambda> (w__303 :: string) . 
           return
             ((string_append ((f_bin_type_mnemonic_D_forwards FEQ_D))
                 ((string_append ((spc_forwards () ))
                     ((string_append w__301
                         ((string_append ((sep_forwards () ))
                             ((string_append w__302
                                 ((string_append ((sep_forwards () ))
                                     ((string_append w__303 ('''')))))))))))))))))))))
    | F_BIN_TYPE_D ((rs2, rs1, rd, FLT_D)) =>
  reg_name_forwards rd \<bind>
    ((\<lambda> (w__304 :: string) . 
     freg_name_forwards rs1 \<bind>
       ((\<lambda> (w__305 :: string) . 
        freg_name_forwards rs2 \<bind>
          ((\<lambda> (w__306 :: string) . 
           return
             ((string_append ((f_bin_type_mnemonic_D_forwards FLT_D))
                 ((string_append ((spc_forwards () ))
                     ((string_append w__304
                         ((string_append ((sep_forwards () ))
                             ((string_append w__305
                                 ((string_append ((sep_forwards () ))
                                     ((string_append w__306 ('''')))))))))))))))))))))
    | F_BIN_TYPE_D ((rs2, rs1, rd, FLE_D)) =>
  reg_name_forwards rd \<bind>
    ((\<lambda> (w__307 :: string) . 
     freg_name_forwards rs1 \<bind>
       ((\<lambda> (w__308 :: string) . 
        freg_name_forwards rs2 \<bind>
          ((\<lambda> (w__309 :: string) . 
           return
             ((string_append ((f_bin_type_mnemonic_D_forwards FLE_D))
                 ((string_append ((spc_forwards () ))
                     ((string_append w__307
                         ((string_append ((sep_forwards () ))
                             ((string_append w__308
                                 ((string_append ((sep_forwards () ))
                                     ((string_append w__309 ('''')))))))))))))))))))))
    | F_UN_TYPE_D ((rs1, rd, FMV_X_D)) =>
  reg_name_forwards rd \<bind>
    ((\<lambda> (w__310 :: string) . 
     freg_name_forwards rs1 \<bind>
       ((\<lambda> (w__311 :: string) . 
        return
          ((string_append ((f_un_type_mnemonic_D_forwards FMV_X_D))
              ((string_append ((spc_forwards () ))
                  ((string_append w__310
                      ((string_append ((sep_forwards () ))
                          ((string_append w__311 ('''')))))))))))))))
    | F_UN_TYPE_D ((rs1, rd, FMV_D_X)) =>
  freg_name_forwards rd \<bind>
    ((\<lambda> (w__312 :: string) . 
     reg_name_forwards rs1 \<bind>
       ((\<lambda> (w__313 :: string) . 
        return
          ((string_append ((f_un_type_mnemonic_D_forwards FMV_D_X))
              ((string_append ((spc_forwards () ))
                  ((string_append w__312
                      ((string_append ((sep_forwards () ))
                          ((string_append w__313 ('''')))))))))))))))
    | F_UN_TYPE_D ((rs1, rd, FCLASS_D)) =>
  reg_name_forwards rd \<bind>
    ((\<lambda> (w__314 :: string) . 
     freg_name_forwards rs1 \<bind>
       ((\<lambda> (w__315 :: string) . 
        return
          ((string_append ((f_un_type_mnemonic_D_forwards FCLASS_D))
              ((string_append ((spc_forwards () ))
                  ((string_append w__314
                      ((string_append ((sep_forwards () ))
                          ((string_append w__315 ('''')))))))))))))))
    | C_FLDSP ((uimm, rd)) =>
  if (((((((( 64 :: int):: ii) = (( 32 :: int):: ii)))) \<or>
          ((((( 64 :: int):: ii) = (( 64 :: int):: ii))))))) then
    reg_name_forwards rd \<bind>
      ((\<lambda> (w__316 :: string) . 
       return
         ((string_append (''c.fldsp'')
             ((string_append ((spc_forwards () ))
                 ((string_append w__316
                     ((string_append ((sep_forwards () ))
                         ((string_append ((decimal_string_of_bits uimm))
                             (''''))))))))))))) else
    assert_exp False (''Pattern match failure at unknown location'') \<then>
      exit0 () 
    | C_FSDSP ((uimm, rs2)) =>
  if (((((((( 64 :: int):: ii) = (( 32 :: int):: ii)))) \<or>
          ((((( 64 :: int):: ii) = (( 64 :: int):: ii))))))) then
    reg_name_forwards rs2 \<bind>
      ((\<lambda> (w__319 :: string) . 
       return
         ((string_append (''c.fsdsp'')
             ((string_append ((spc_forwards () ))
                 ((string_append w__319
                     ((string_append ((sep_forwards () ))
                         ((string_append ((decimal_string_of_bits uimm))
                             (''''))))))))))))) else
    assert_exp False (''Pattern match failure at unknown location'') \<then>
      exit0 () 
    | C_FLD ((uimm, rsc, rdc)) =>
  if (((((((( 64 :: int):: ii) = (( 32 :: int):: ii)))) \<or>
          ((((( 64 :: int):: ii) = (( 64 :: int):: ii))))))) then
    creg_name_forwards rdc \<bind>
      ((\<lambda> (w__322 :: string) . 
       creg_name_forwards rsc \<bind>
         ((\<lambda> (w__323 :: string) . 
          return
            ((string_append (''c.fld'')
                ((string_append ((spc_forwards () ))
                    ((string_append w__322
                        ((string_append ((sep_forwards () ))
                            ((string_append w__323
                                ((string_append ((sep_forwards () ))
                                    ((string_append
                                        ((decimal_string_of_bits
                                            ((concat_vec uimm
                                                ( 0b000 :: 3 Word.word) :: 8 Word.word))))
                                        (''''))))))))))))))))))) else
    assert_exp False (''Pattern match failure at unknown location'') \<then>
      exit0 () 
    | C_FSD ((uimm, rsc1, rsc2)) =>
  if (((((((( 64 :: int):: ii) = (( 32 :: int):: ii)))) \<or>
          ((((( 64 :: int):: ii) = (( 64 :: int):: ii))))))) then
    creg_name_forwards rsc1 \<bind>
      ((\<lambda> (w__326 :: string) . 
       creg_name_forwards rsc2 \<bind>
         ((\<lambda> (w__327 :: string) . 
          return
            ((string_append (''c.fsd'')
                ((string_append ((spc_forwards () ))
                    ((string_append w__326
                        ((string_append ((sep_forwards () ))
                            ((string_append w__327
                                ((string_append ((sep_forwards () ))
                                    ((string_append
                                        ((decimal_string_of_bits
                                            ((concat_vec uimm
                                                ( 0b000 :: 3 Word.word) :: 8 Word.word))))
                                        (''''))))))))))))))))))) else
    assert_exp False (''Pattern match failure at unknown location'') \<then>
      exit0 () 
    | ILLEGAL (s) =>
  return
    ((string_append (''illegal'')
        ((string_append ((spc_forwards () ))
            ((string_append ((decimal_string_of_bits s)) ('''')))))))
    | C_ILLEGAL (s) =>
  return
    ((string_append (''c.illegal'')
        ((string_append ((spc_forwards () ))
            ((string_append ((decimal_string_of_bits s)) ('''')))))))
  )))\<close> 
  for  ast  :: " ast "


\<comment> \<open>\<open>val _s3229_ : string -> maybe (mword ty16)\<close>\<close>

definition s3229  :: \<open> string \<Rightarrow>((16)Word.word)option \<close>  where 
     \<open> s3229 s32300 = (
   (let s32310 = s32300 in
   if ((string_startswith s32310 (''c.illegal''))) then  
  (case  ((string_drop s32310 ((string_length (''c.illegal''))))) of
        s32320 =>
  (case  ((spc_matches_prefix0 s32320)) of
        Some ((_, s32330)) =>
  (case  ((string_drop s32320 s32330)) of
        s32340 =>
  (case  ((hex_bits_16_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s32340 :: (( 16 Word.word * ii)) option)) of
        Some ((s, s32350)) =>
  (let p00 = (string_drop s32340 s32350) in
  if (((p00 = ('''')))) then Some s else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s32300  :: " string "


\<comment> \<open>\<open>val _s3221_ : string -> maybe (mword ty32)\<close>\<close>

definition s3221  :: \<open> string \<Rightarrow>((32)Word.word)option \<close>  where 
     \<open> s3221 s32220 = (
   (let s32230 = s32220 in
   if ((string_startswith s32230 (''illegal''))) then  
  (case  ((string_drop s32230 ((string_length (''illegal''))))) of
        s32240 =>
  (case  ((spc_matches_prefix0 s32240)) of
        Some ((_, s32250)) =>
  (case  ((string_drop s32240 s32250)) of
        s32260 =>
  (case  ((hex_bits_32_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s32260 :: (( 32 Word.word * ii)) option)) of
        Some ((s, s32270)) =>
  (let p00 = (string_drop s32260 s32270) in
  if (((p00 = ('''')))) then Some s else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s32220  :: " string "


\<comment> \<open>\<open>val _s3205_ : string -> maybe ((mword ty3 * mword ty3 * mword ty5))\<close>\<close>

definition s3205  :: \<open> string \<Rightarrow>((3)Word.word*(3)Word.word*(5)Word.word)option \<close>  where 
     \<open> s3205 s32060 = (
   (let s32070 = s32060 in
   if ((string_startswith s32070 (''c.fsd''))) then  
  (case  ((string_drop s32070 ((string_length (''c.fsd''))))) of
        s32080 =>
  (case  ((spc_matches_prefix0 s32080)) of
        Some ((_, s32090)) =>
  (case  ((string_drop s32080 s32090)) of
        s32100 =>
  (case  ((creg_name_matches_prefix s32100 :: (( 3 Word.word * ii)) option)) of
        Some ((rsc1, s32110)) =>
  (case  ((string_drop s32100 s32110)) of
        s32120 =>
  (case  ((sep_matches_prefix s32120)) of
        Some ((_, s32130)) =>
  (case  ((string_drop s32120 s32130)) of
        s32140 =>
  (case  ((creg_name_matches_prefix s32140 :: (( 3 Word.word * ii)) option)) of
        Some ((rsc2, s32150)) =>
  (case  ((string_drop s32140 s32150)) of
        s32160 =>
  (case  ((sep_matches_prefix s32160)) of
        Some ((_, s32170)) =>
  (case  ((string_drop s32160 s32170)) of
        s32180 =>
  (case  ((hex_bits_8_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s32180 :: (( 8 Word.word * ii)) option)) of
        Some ((v__1442, s32190)) =>
  if (((((subrange_vec_dec v__1442 (( 2 :: int):: ii) (( 0 :: int):: ii)
         :: 3 Word.word)) = ( 0b000 :: 3 Word.word)))) then
    (let (uimm :: 5 Word.word) =
         ((subrange_vec_dec v__1442 (( 7 :: int):: ii) (( 3 :: int):: ii) :: 5 Word.word)) in
    (let (uimm :: 5 Word.word) =
         ((subrange_vec_dec v__1442 (( 7 :: int):: ii) (( 3 :: int):: ii) :: 5 Word.word)) in
    (let p00 = (string_drop s32180 s32190) in
    if (((p00 = ('''')))) then Some (rsc1, rsc2, uimm) else None))) else 
  None
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s32060  :: " string "


\<comment> \<open>\<open>val _s3189_ : string -> maybe ((mword ty3 * mword ty3 * mword ty5))\<close>\<close>

definition s3189  :: \<open> string \<Rightarrow>((3)Word.word*(3)Word.word*(5)Word.word)option \<close>  where 
     \<open> s3189 s31900 = (
   (let s31910 = s31900 in
   if ((string_startswith s31910 (''c.fld''))) then  
  (case  ((string_drop s31910 ((string_length (''c.fld''))))) of
        s31920 =>
  (case  ((spc_matches_prefix0 s31920)) of
        Some ((_, s31930)) =>
  (case  ((string_drop s31920 s31930)) of
        s31940 =>
  (case  ((creg_name_matches_prefix s31940 :: (( 3 Word.word * ii)) option)) of
        Some ((rdc, s31950)) =>
  (case  ((string_drop s31940 s31950)) of
        s31960 =>
  (case  ((sep_matches_prefix s31960)) of
        Some ((_, s31970)) =>
  (case  ((string_drop s31960 s31970)) of
        s31980 =>
  (case  ((creg_name_matches_prefix s31980 :: (( 3 Word.word * ii)) option)) of
        Some ((rsc, s31990)) =>
  (case  ((string_drop s31980 s31990)) of
        s32000 =>
  (case  ((sep_matches_prefix s32000)) of
        Some ((_, s32010)) =>
  (case  ((string_drop s32000 s32010)) of
        s32020 =>
  (case  ((hex_bits_8_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s32020 :: (( 8 Word.word * ii)) option)) of
        Some ((v__1444, s32030)) =>
  if (((((subrange_vec_dec v__1444 (( 2 :: int):: ii) (( 0 :: int):: ii)
         :: 3 Word.word)) = ( 0b000 :: 3 Word.word)))) then
    (let (uimm :: 5 Word.word) =
         ((subrange_vec_dec v__1444 (( 7 :: int):: ii) (( 3 :: int):: ii) :: 5 Word.word)) in
    (let (uimm :: 5 Word.word) =
         ((subrange_vec_dec v__1444 (( 7 :: int):: ii) (( 3 :: int):: ii) :: 5 Word.word)) in
    (let p00 = (string_drop s32020 s32030) in
    if (((p00 = ('''')))) then Some (rdc, rsc, uimm) else None))) else 
  None
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s31900  :: " string "


\<comment> \<open>\<open>val _s3177_ : string -> maybe ((mword ty5 * mword ty6))\<close>\<close>

definition s3177  :: \<open> string \<Rightarrow>((5)Word.word*(6)Word.word)option \<close>  where 
     \<open> s3177 s31780 = (
   (let s31790 = s31780 in
   if ((string_startswith s31790 (''c.fsdsp''))) then  
  (case  ((string_drop s31790 ((string_length (''c.fsdsp''))))) of
        s31800 =>
  (case  ((spc_matches_prefix0 s31800)) of
        Some ((_, s31810)) =>
  (case  ((string_drop s31800 s31810)) of
        s31820 =>
  (case  ((reg_name_matches_prefix s31820 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s31830)) =>
  (case  ((string_drop s31820 s31830)) of
        s31840 =>
  (case  ((sep_matches_prefix s31840)) of
        Some ((_, s31850)) =>
  (case  ((string_drop s31840 s31850)) of
        s31860 =>
  (case  ((hex_bits_6_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s31860 :: (( 6 Word.word * ii)) option)) of
        Some ((uimm, s31870)) =>
  (let p00 = (string_drop s31860 s31870) in
  if (((p00 = ('''')))) then Some (rs2, uimm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s31780  :: " string "


\<comment> \<open>\<open>val _s3165_ : string -> maybe ((mword ty5 * mword ty6))\<close>\<close>

definition s3165  :: \<open> string \<Rightarrow>((5)Word.word*(6)Word.word)option \<close>  where 
     \<open> s3165 s31660 = (
   (let s31670 = s31660 in
   if ((string_startswith s31670 (''c.fldsp''))) then  
  (case  ((string_drop s31670 ((string_length (''c.fldsp''))))) of
        s31680 =>
  (case  ((spc_matches_prefix0 s31680)) of
        Some ((_, s31690)) =>
  (case  ((string_drop s31680 s31690)) of
        s31700 =>
  (case  ((reg_name_matches_prefix s31700 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s31710)) =>
  (case  ((string_drop s31700 s31710)) of
        s31720 =>
  (case  ((sep_matches_prefix s31720)) of
        Some ((_, s31730)) =>
  (case  ((string_drop s31720 s31730)) of
        s31740 =>
  (case  ((hex_bits_6_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s31740 :: (( 6 Word.word * ii)) option)) of
        Some ((uimm, s31750)) =>
  (let p00 = (string_drop s31740 s31750) in
  if (((p00 = ('''')))) then Some (rd, uimm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s31660  :: " string "


\<comment> \<open>\<open>val _s3152_ : string -> maybe ((f_un_op_D * mword ty5 * mword ty5))\<close>\<close>

definition s3152  :: \<open> string \<Rightarrow>(f_un_op_D*(5)Word.word*(5)Word.word)option \<close>  where 
     \<open> s3152 s31540 = (
      (case  ((f_un_type_mnemonic_D_matches_prefix s31540)) of
        Some ((FCLASS_D, s31550)) => 
  (case  ((string_drop s31540 s31550)) of
        s31560 =>
  (case  ((spc_matches_prefix0 s31560)) of
        Some ((_, s31570)) =>
  (case  ((string_drop s31560 s31570)) of
        s31580 =>
  (case  ((reg_name_matches_prefix s31580 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s31590)) =>
  (case  ((string_drop s31580 s31590)) of
        s31600 =>
  (case  ((sep_matches_prefix s31600)) of
        Some ((_, s31610)) =>
  (case  ((string_drop s31600 s31610)) of
        s31620 =>
  (case  ((freg_name_matches_prefix s31620 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s31630)) =>
  (let p00 = (string_drop s31620 s31630) in
  if (((p00 = ('''')))) then Some (FCLASS_D, rd, rs1) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s31540  :: " string "


\<comment> \<open>\<open>val _s3139_ : string -> maybe ((f_un_op_D * mword ty5 * mword ty5))\<close>\<close>

definition s3139  :: \<open> string \<Rightarrow>(f_un_op_D*(5)Word.word*(5)Word.word)option \<close>  where 
     \<open> s3139 s31410 = (
      (case  ((f_un_type_mnemonic_D_matches_prefix s31410)) of
        Some ((FMV_D_X, s31420)) => 
  (case  ((string_drop s31410 s31420)) of
        s31430 =>
  (case  ((spc_matches_prefix0 s31430)) of
        Some ((_, s31440)) =>
  (case  ((string_drop s31430 s31440)) of
        s31450 =>
  (case  ((freg_name_matches_prefix s31450 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s31460)) =>
  (case  ((string_drop s31450 s31460)) of
        s31470 =>
  (case  ((sep_matches_prefix s31470)) of
        Some ((_, s31480)) =>
  (case  ((string_drop s31470 s31480)) of
        s31490 =>
  (case  ((reg_name_matches_prefix s31490 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s31500)) =>
  (let p00 = (string_drop s31490 s31500) in
  if (((p00 = ('''')))) then Some (FMV_D_X, rd, rs1) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s31410  :: " string "


\<comment> \<open>\<open>val _s3126_ : string -> maybe ((f_un_op_D * mword ty5 * mword ty5))\<close>\<close>

definition s3126  :: \<open> string \<Rightarrow>(f_un_op_D*(5)Word.word*(5)Word.word)option \<close>  where 
     \<open> s3126 s31280 = (
      (case  ((f_un_type_mnemonic_D_matches_prefix s31280)) of
        Some ((FMV_X_D, s31290)) => 
  (case  ((string_drop s31280 s31290)) of
        s31300 =>
  (case  ((spc_matches_prefix0 s31300)) of
        Some ((_, s31310)) =>
  (case  ((string_drop s31300 s31310)) of
        s31320 =>
  (case  ((reg_name_matches_prefix s31320 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s31330)) =>
  (case  ((string_drop s31320 s31330)) of
        s31340 =>
  (case  ((sep_matches_prefix s31340)) of
        Some ((_, s31350)) =>
  (case  ((string_drop s31340 s31350)) of
        s31360 =>
  (case  ((freg_name_matches_prefix s31360 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s31370)) =>
  (let p00 = (string_drop s31360 s31370) in
  if (((p00 = ('''')))) then Some (FMV_X_D, rd, rs1) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s31280  :: " string "


\<comment> \<open>\<open>val _s3109_ : string -> maybe ((f_bin_op_D * mword ty5 * mword ty5 * mword ty5))\<close>\<close>

definition s3109  :: \<open> string \<Rightarrow>(f_bin_op_D*(5)Word.word*(5)Word.word*(5)Word.word)option \<close>  where 
     \<open> s3109 s31110 = (
      (case  ((f_bin_type_mnemonic_D_matches_prefix s31110)) of
        Some ((FLE_D, s31120)) => 
  (case  ((string_drop s31110 s31120)) of
        s31130 =>
  (case  ((spc_matches_prefix0 s31130)) of
        Some ((_, s31140)) =>
  (case  ((string_drop s31130 s31140)) of
        s31150 =>
  (case  ((reg_name_matches_prefix s31150 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s31160)) =>
  (case  ((string_drop s31150 s31160)) of
        s31170 =>
  (case  ((sep_matches_prefix s31170)) of
        Some ((_, s31180)) =>
  (case  ((string_drop s31170 s31180)) of
        s31190 =>
  (case  ((freg_name_matches_prefix s31190 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s31200)) =>
  (case  ((string_drop s31190 s31200)) of
        s31210 =>
  (case  ((sep_matches_prefix s31210)) of
        Some ((_, s31220)) =>
  (case  ((string_drop s31210 s31220)) of
        s31230 =>
  (case  ((freg_name_matches_prefix s31230 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s31240)) =>
  (let p00 = (string_drop s31230 s31240) in
  if (((p00 = ('''')))) then Some (FLE_D, rd, rs1, rs2) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s31110  :: " string "


\<comment> \<open>\<open>val _s3092_ : string -> maybe ((f_bin_op_D * mword ty5 * mword ty5 * mword ty5))\<close>\<close>

definition s3092  :: \<open> string \<Rightarrow>(f_bin_op_D*(5)Word.word*(5)Word.word*(5)Word.word)option \<close>  where 
     \<open> s3092 s30940 = (
      (case  ((f_bin_type_mnemonic_D_matches_prefix s30940)) of
        Some ((FLT_D, s30950)) => 
  (case  ((string_drop s30940 s30950)) of
        s30960 =>
  (case  ((spc_matches_prefix0 s30960)) of
        Some ((_, s30970)) =>
  (case  ((string_drop s30960 s30970)) of
        s30980 =>
  (case  ((reg_name_matches_prefix s30980 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s30990)) =>
  (case  ((string_drop s30980 s30990)) of
        s31000 =>
  (case  ((sep_matches_prefix s31000)) of
        Some ((_, s31010)) =>
  (case  ((string_drop s31000 s31010)) of
        s31020 =>
  (case  ((freg_name_matches_prefix s31020 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s31030)) =>
  (case  ((string_drop s31020 s31030)) of
        s31040 =>
  (case  ((sep_matches_prefix s31040)) of
        Some ((_, s31050)) =>
  (case  ((string_drop s31040 s31050)) of
        s31060 =>
  (case  ((freg_name_matches_prefix s31060 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s31070)) =>
  (let p00 = (string_drop s31060 s31070) in
  if (((p00 = ('''')))) then Some (FLT_D, rd, rs1, rs2) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s30940  :: " string "


\<comment> \<open>\<open>val _s3075_ : string -> maybe ((f_bin_op_D * mword ty5 * mword ty5 * mword ty5))\<close>\<close>

definition s3075  :: \<open> string \<Rightarrow>(f_bin_op_D*(5)Word.word*(5)Word.word*(5)Word.word)option \<close>  where 
     \<open> s3075 s30770 = (
      (case  ((f_bin_type_mnemonic_D_matches_prefix s30770)) of
        Some ((FEQ_D, s30780)) => 
  (case  ((string_drop s30770 s30780)) of
        s30790 =>
  (case  ((spc_matches_prefix0 s30790)) of
        Some ((_, s30800)) =>
  (case  ((string_drop s30790 s30800)) of
        s30810 =>
  (case  ((reg_name_matches_prefix s30810 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s30820)) =>
  (case  ((string_drop s30810 s30820)) of
        s30830 =>
  (case  ((sep_matches_prefix s30830)) of
        Some ((_, s30840)) =>
  (case  ((string_drop s30830 s30840)) of
        s30850 =>
  (case  ((freg_name_matches_prefix s30850 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s30860)) =>
  (case  ((string_drop s30850 s30860)) of
        s30870 =>
  (case  ((sep_matches_prefix s30870)) of
        Some ((_, s30880)) =>
  (case  ((string_drop s30870 s30880)) of
        s30890 =>
  (case  ((freg_name_matches_prefix s30890 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s30900)) =>
  (let p00 = (string_drop s30890 s30900) in
  if (((p00 = ('''')))) then Some (FEQ_D, rd, rs1, rs2) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s30770  :: " string "


\<comment> \<open>\<open>val _s3058_ : string -> maybe ((f_bin_op_D * mword ty5 * mword ty5 * mword ty5))\<close>\<close>

definition s3058  :: \<open> string \<Rightarrow>(f_bin_op_D*(5)Word.word*(5)Word.word*(5)Word.word)option \<close>  where 
     \<open> s3058 s30600 = (
      (case  ((f_bin_type_mnemonic_D_matches_prefix s30600)) of
        Some ((FMAX_D, s30610)) => 
  (case  ((string_drop s30600 s30610)) of
        s30620 =>
  (case  ((spc_matches_prefix0 s30620)) of
        Some ((_, s30630)) =>
  (case  ((string_drop s30620 s30630)) of
        s30640 =>
  (case  ((freg_name_matches_prefix s30640 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s30650)) =>
  (case  ((string_drop s30640 s30650)) of
        s30660 =>
  (case  ((sep_matches_prefix s30660)) of
        Some ((_, s30670)) =>
  (case  ((string_drop s30660 s30670)) of
        s30680 =>
  (case  ((freg_name_matches_prefix s30680 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s30690)) =>
  (case  ((string_drop s30680 s30690)) of
        s30700 =>
  (case  ((sep_matches_prefix s30700)) of
        Some ((_, s30710)) =>
  (case  ((string_drop s30700 s30710)) of
        s30720 =>
  (case  ((freg_name_matches_prefix s30720 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s30730)) =>
  (let p00 = (string_drop s30720 s30730) in
  if (((p00 = ('''')))) then Some (FMAX_D, rd, rs1, rs2) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s30600  :: " string "


\<comment> \<open>\<open>val _s3041_ : string -> maybe ((f_bin_op_D * mword ty5 * mword ty5 * mword ty5))\<close>\<close>

definition s3041  :: \<open> string \<Rightarrow>(f_bin_op_D*(5)Word.word*(5)Word.word*(5)Word.word)option \<close>  where 
     \<open> s3041 s30430 = (
      (case  ((f_bin_type_mnemonic_D_matches_prefix s30430)) of
        Some ((FMIN_D, s30440)) => 
  (case  ((string_drop s30430 s30440)) of
        s30450 =>
  (case  ((spc_matches_prefix0 s30450)) of
        Some ((_, s30460)) =>
  (case  ((string_drop s30450 s30460)) of
        s30470 =>
  (case  ((freg_name_matches_prefix s30470 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s30480)) =>
  (case  ((string_drop s30470 s30480)) of
        s30490 =>
  (case  ((sep_matches_prefix s30490)) of
        Some ((_, s30500)) =>
  (case  ((string_drop s30490 s30500)) of
        s30510 =>
  (case  ((freg_name_matches_prefix s30510 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s30520)) =>
  (case  ((string_drop s30510 s30520)) of
        s30530 =>
  (case  ((sep_matches_prefix s30530)) of
        Some ((_, s30540)) =>
  (case  ((string_drop s30530 s30540)) of
        s30550 =>
  (case  ((freg_name_matches_prefix s30550 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s30560)) =>
  (let p00 = (string_drop s30550 s30560) in
  if (((p00 = ('''')))) then Some (FMIN_D, rd, rs1, rs2) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s30430  :: " string "


\<comment> \<open>\<open>val _s3024_ : string -> maybe ((f_bin_op_D * mword ty5 * mword ty5 * mword ty5))\<close>\<close>

definition s3024  :: \<open> string \<Rightarrow>(f_bin_op_D*(5)Word.word*(5)Word.word*(5)Word.word)option \<close>  where 
     \<open> s3024 s30260 = (
      (case  ((f_bin_type_mnemonic_D_matches_prefix s30260)) of
        Some ((FSGNJX_D, s30270)) => 
  (case  ((string_drop s30260 s30270)) of
        s30280 =>
  (case  ((spc_matches_prefix0 s30280)) of
        Some ((_, s30290)) =>
  (case  ((string_drop s30280 s30290)) of
        s30300 =>
  (case  ((freg_name_matches_prefix s30300 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s30310)) =>
  (case  ((string_drop s30300 s30310)) of
        s30320 =>
  (case  ((sep_matches_prefix s30320)) of
        Some ((_, s30330)) =>
  (case  ((string_drop s30320 s30330)) of
        s30340 =>
  (case  ((freg_name_matches_prefix s30340 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s30350)) =>
  (case  ((string_drop s30340 s30350)) of
        s30360 =>
  (case  ((sep_matches_prefix s30360)) of
        Some ((_, s30370)) =>
  (case  ((string_drop s30360 s30370)) of
        s30380 =>
  (case  ((freg_name_matches_prefix s30380 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s30390)) =>
  (let p00 = (string_drop s30380 s30390) in
  if (((p00 = ('''')))) then Some (FSGNJX_D, rd, rs1, rs2) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s30260  :: " string "


\<comment> \<open>\<open>val _s3007_ : string -> maybe ((f_bin_op_D * mword ty5 * mword ty5 * mword ty5))\<close>\<close>

definition s3007  :: \<open> string \<Rightarrow>(f_bin_op_D*(5)Word.word*(5)Word.word*(5)Word.word)option \<close>  where 
     \<open> s3007 s30090 = (
      (case  ((f_bin_type_mnemonic_D_matches_prefix s30090)) of
        Some ((FSGNJN_D, s30100)) => 
  (case  ((string_drop s30090 s30100)) of
        s30110 =>
  (case  ((spc_matches_prefix0 s30110)) of
        Some ((_, s30120)) =>
  (case  ((string_drop s30110 s30120)) of
        s30130 =>
  (case  ((freg_name_matches_prefix s30130 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s30140)) =>
  (case  ((string_drop s30130 s30140)) of
        s30150 =>
  (case  ((sep_matches_prefix s30150)) of
        Some ((_, s30160)) =>
  (case  ((string_drop s30150 s30160)) of
        s30170 =>
  (case  ((freg_name_matches_prefix s30170 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s30180)) =>
  (case  ((string_drop s30170 s30180)) of
        s30190 =>
  (case  ((sep_matches_prefix s30190)) of
        Some ((_, s30200)) =>
  (case  ((string_drop s30190 s30200)) of
        s30210 =>
  (case  ((freg_name_matches_prefix s30210 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s30220)) =>
  (let p00 = (string_drop s30210 s30220) in
  if (((p00 = ('''')))) then Some (FSGNJN_D, rd, rs1, rs2) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s30090  :: " string "


\<comment> \<open>\<open>val _s2990_ : string -> maybe ((f_bin_op_D * mword ty5 * mword ty5 * mword ty5))\<close>\<close>

definition s2990  :: \<open> string \<Rightarrow>(f_bin_op_D*(5)Word.word*(5)Word.word*(5)Word.word)option \<close>  where 
     \<open> s2990 s29920 = (
      (case  ((f_bin_type_mnemonic_D_matches_prefix s29920)) of
        Some ((FSGNJ_D, s29930)) => 
  (case  ((string_drop s29920 s29930)) of
        s29940 =>
  (case  ((spc_matches_prefix0 s29940)) of
        Some ((_, s29950)) =>
  (case  ((string_drop s29940 s29950)) of
        s29960 =>
  (case  ((freg_name_matches_prefix s29960 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s29970)) =>
  (case  ((string_drop s29960 s29970)) of
        s29980 =>
  (case  ((sep_matches_prefix s29980)) of
        Some ((_, s29990)) =>
  (case  ((string_drop s29980 s29990)) of
        s30000 =>
  (case  ((freg_name_matches_prefix s30000 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s30010)) =>
  (case  ((string_drop s30000 s30010)) of
        s30020 =>
  (case  ((sep_matches_prefix s30020)) of
        Some ((_, s30030)) =>
  (case  ((string_drop s30020 s30030)) of
        s30040 =>
  (case  ((freg_name_matches_prefix s30040 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s30050)) =>
  (let p00 = (string_drop s30040 s30050) in
  if (((p00 = ('''')))) then Some (FSGNJ_D, rd, rs1, rs2) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s29920  :: " string "


\<comment> \<open>\<open>val _s2973_ : string -> maybe ((f_un_rm_op_D * mword ty5 * mword ty5 * rounding_mode))\<close>\<close>

definition s2973  :: \<open> string \<Rightarrow>(f_un_rm_op_D*(5)Word.word*(5)Word.word*rounding_mode)option \<close>  where 
     \<open> s2973 s29750 = (
      (case  ((f_un_rm_type_mnemonic_D_matches_prefix s29750)) of
        Some ((FCVT_D_S, s29760)) => 
  (case  ((string_drop s29750 s29760)) of
        s29770 =>
  (case  ((spc_matches_prefix0 s29770)) of
        Some ((_, s29780)) =>
  (case  ((string_drop s29770 s29780)) of
        s29790 =>
  (case  ((freg_name_matches_prefix s29790 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s29800)) =>
  (case  ((string_drop s29790 s29800)) of
        s29810 =>
  (case  ((sep_matches_prefix s29810)) of
        Some ((_, s29820)) =>
  (case  ((string_drop s29810 s29820)) of
        s29830 =>
  (case  ((freg_name_matches_prefix s29830 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s29840)) =>
  (case  ((string_drop s29830 s29840)) of
        s29850 =>
  (case  ((sep_matches_prefix s29850)) of
        Some ((_, s29860)) =>
  (case  ((string_drop s29850 s29860)) of
        s29870 =>
  (case  ((frm_mnemonic_matches_prefix s29870)) of
        Some ((rm, s29880)) =>
  (let p00 = (string_drop s29870 s29880) in
  if (((p00 = ('''')))) then Some (FCVT_D_S, rd, rs1, rm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s29750  :: " string "


\<comment> \<open>\<open>val _s2956_ : string -> maybe ((f_un_rm_op_D * mword ty5 * mword ty5 * rounding_mode))\<close>\<close>

definition s2956  :: \<open> string \<Rightarrow>(f_un_rm_op_D*(5)Word.word*(5)Word.word*rounding_mode)option \<close>  where 
     \<open> s2956 s29580 = (
      (case  ((f_un_rm_type_mnemonic_D_matches_prefix s29580)) of
        Some ((FCVT_S_D, s29590)) => 
  (case  ((string_drop s29580 s29590)) of
        s29600 =>
  (case  ((spc_matches_prefix0 s29600)) of
        Some ((_, s29610)) =>
  (case  ((string_drop s29600 s29610)) of
        s29620 =>
  (case  ((freg_name_matches_prefix s29620 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s29630)) =>
  (case  ((string_drop s29620 s29630)) of
        s29640 =>
  (case  ((sep_matches_prefix s29640)) of
        Some ((_, s29650)) =>
  (case  ((string_drop s29640 s29650)) of
        s29660 =>
  (case  ((freg_name_matches_prefix s29660 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s29670)) =>
  (case  ((string_drop s29660 s29670)) of
        s29680 =>
  (case  ((sep_matches_prefix s29680)) of
        Some ((_, s29690)) =>
  (case  ((string_drop s29680 s29690)) of
        s29700 =>
  (case  ((frm_mnemonic_matches_prefix s29700)) of
        Some ((rm, s29710)) =>
  (let p00 = (string_drop s29700 s29710) in
  if (((p00 = ('''')))) then Some (FCVT_S_D, rd, rs1, rm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s29580  :: " string "


\<comment> \<open>\<open>val _s2939_ : string -> maybe ((f_un_rm_op_D * mword ty5 * mword ty5 * rounding_mode))\<close>\<close>

definition s2939  :: \<open> string \<Rightarrow>(f_un_rm_op_D*(5)Word.word*(5)Word.word*rounding_mode)option \<close>  where 
     \<open> s2939 s29410 = (
      (case  ((f_un_rm_type_mnemonic_D_matches_prefix s29410)) of
        Some ((FCVT_D_LU, s29420)) => 
  (case  ((string_drop s29410 s29420)) of
        s29430 =>
  (case  ((spc_matches_prefix0 s29430)) of
        Some ((_, s29440)) =>
  (case  ((string_drop s29430 s29440)) of
        s29450 =>
  (case  ((freg_name_matches_prefix s29450 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s29460)) =>
  (case  ((string_drop s29450 s29460)) of
        s29470 =>
  (case  ((sep_matches_prefix s29470)) of
        Some ((_, s29480)) =>
  (case  ((string_drop s29470 s29480)) of
        s29490 =>
  (case  ((reg_name_matches_prefix s29490 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s29500)) =>
  (case  ((string_drop s29490 s29500)) of
        s29510 =>
  (case  ((sep_matches_prefix s29510)) of
        Some ((_, s29520)) =>
  (case  ((string_drop s29510 s29520)) of
        s29530 =>
  (case  ((frm_mnemonic_matches_prefix s29530)) of
        Some ((rm, s29540)) =>
  (let p00 = (string_drop s29530 s29540) in
  if (((p00 = ('''')))) then Some (FCVT_D_LU, rd, rs1, rm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s29410  :: " string "


\<comment> \<open>\<open>val _s2922_ : string -> maybe ((f_un_rm_op_D * mword ty5 * mword ty5 * rounding_mode))\<close>\<close>

definition s2922  :: \<open> string \<Rightarrow>(f_un_rm_op_D*(5)Word.word*(5)Word.word*rounding_mode)option \<close>  where 
     \<open> s2922 s29240 = (
      (case  ((f_un_rm_type_mnemonic_D_matches_prefix s29240)) of
        Some ((FCVT_D_L, s29250)) => 
  (case  ((string_drop s29240 s29250)) of
        s29260 =>
  (case  ((spc_matches_prefix0 s29260)) of
        Some ((_, s29270)) =>
  (case  ((string_drop s29260 s29270)) of
        s29280 =>
  (case  ((freg_name_matches_prefix s29280 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s29290)) =>
  (case  ((string_drop s29280 s29290)) of
        s29300 =>
  (case  ((sep_matches_prefix s29300)) of
        Some ((_, s29310)) =>
  (case  ((string_drop s29300 s29310)) of
        s29320 =>
  (case  ((reg_name_matches_prefix s29320 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s29330)) =>
  (case  ((string_drop s29320 s29330)) of
        s29340 =>
  (case  ((sep_matches_prefix s29340)) of
        Some ((_, s29350)) =>
  (case  ((string_drop s29340 s29350)) of
        s29360 =>
  (case  ((frm_mnemonic_matches_prefix s29360)) of
        Some ((rm, s29370)) =>
  (let p00 = (string_drop s29360 s29370) in
  if (((p00 = ('''')))) then Some (FCVT_D_L, rd, rs1, rm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s29240  :: " string "


\<comment> \<open>\<open>val _s2905_ : string -> maybe ((f_un_rm_op_D * mword ty5 * mword ty5 * rounding_mode))\<close>\<close>

definition s2905  :: \<open> string \<Rightarrow>(f_un_rm_op_D*(5)Word.word*(5)Word.word*rounding_mode)option \<close>  where 
     \<open> s2905 s29070 = (
      (case  ((f_un_rm_type_mnemonic_D_matches_prefix s29070)) of
        Some ((FCVT_LU_D, s29080)) => 
  (case  ((string_drop s29070 s29080)) of
        s29090 =>
  (case  ((spc_matches_prefix0 s29090)) of
        Some ((_, s29100)) =>
  (case  ((string_drop s29090 s29100)) of
        s29110 =>
  (case  ((reg_name_matches_prefix s29110 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s29120)) =>
  (case  ((string_drop s29110 s29120)) of
        s29130 =>
  (case  ((sep_matches_prefix s29130)) of
        Some ((_, s29140)) =>
  (case  ((string_drop s29130 s29140)) of
        s29150 =>
  (case  ((freg_name_matches_prefix s29150 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s29160)) =>
  (case  ((string_drop s29150 s29160)) of
        s29170 =>
  (case  ((sep_matches_prefix s29170)) of
        Some ((_, s29180)) =>
  (case  ((string_drop s29170 s29180)) of
        s29190 =>
  (case  ((frm_mnemonic_matches_prefix s29190)) of
        Some ((rm, s29200)) =>
  (let p00 = (string_drop s29190 s29200) in
  if (((p00 = ('''')))) then Some (FCVT_LU_D, rd, rs1, rm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s29070  :: " string "


\<comment> \<open>\<open>val _s2888_ : string -> maybe ((f_un_rm_op_D * mword ty5 * mword ty5 * rounding_mode))\<close>\<close>

definition s2888  :: \<open> string \<Rightarrow>(f_un_rm_op_D*(5)Word.word*(5)Word.word*rounding_mode)option \<close>  where 
     \<open> s2888 s28900 = (
      (case  ((f_un_rm_type_mnemonic_D_matches_prefix s28900)) of
        Some ((FCVT_L_D, s28910)) => 
  (case  ((string_drop s28900 s28910)) of
        s28920 =>
  (case  ((spc_matches_prefix0 s28920)) of
        Some ((_, s28930)) =>
  (case  ((string_drop s28920 s28930)) of
        s28940 =>
  (case  ((reg_name_matches_prefix s28940 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s28950)) =>
  (case  ((string_drop s28940 s28950)) of
        s28960 =>
  (case  ((sep_matches_prefix s28960)) of
        Some ((_, s28970)) =>
  (case  ((string_drop s28960 s28970)) of
        s28980 =>
  (case  ((freg_name_matches_prefix s28980 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s28990)) =>
  (case  ((string_drop s28980 s28990)) of
        s29000 =>
  (case  ((sep_matches_prefix s29000)) of
        Some ((_, s29010)) =>
  (case  ((string_drop s29000 s29010)) of
        s29020 =>
  (case  ((frm_mnemonic_matches_prefix s29020)) of
        Some ((rm, s29030)) =>
  (let p00 = (string_drop s29020 s29030) in
  if (((p00 = ('''')))) then Some (FCVT_L_D, rd, rs1, rm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s28900  :: " string "


\<comment> \<open>\<open>val _s2871_ : string -> maybe ((f_un_rm_op_D * mword ty5 * mword ty5 * rounding_mode))\<close>\<close>

definition s2871  :: \<open> string \<Rightarrow>(f_un_rm_op_D*(5)Word.word*(5)Word.word*rounding_mode)option \<close>  where 
     \<open> s2871 s28730 = (
      (case  ((f_un_rm_type_mnemonic_D_matches_prefix s28730)) of
        Some ((FCVT_D_WU, s28740)) => 
  (case  ((string_drop s28730 s28740)) of
        s28750 =>
  (case  ((spc_matches_prefix0 s28750)) of
        Some ((_, s28760)) =>
  (case  ((string_drop s28750 s28760)) of
        s28770 =>
  (case  ((freg_name_matches_prefix s28770 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s28780)) =>
  (case  ((string_drop s28770 s28780)) of
        s28790 =>
  (case  ((sep_matches_prefix s28790)) of
        Some ((_, s28800)) =>
  (case  ((string_drop s28790 s28800)) of
        s28810 =>
  (case  ((reg_name_matches_prefix s28810 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s28820)) =>
  (case  ((string_drop s28810 s28820)) of
        s28830 =>
  (case  ((sep_matches_prefix s28830)) of
        Some ((_, s28840)) =>
  (case  ((string_drop s28830 s28840)) of
        s28850 =>
  (case  ((frm_mnemonic_matches_prefix s28850)) of
        Some ((rm, s28860)) =>
  (let p00 = (string_drop s28850 s28860) in
  if (((p00 = ('''')))) then Some (FCVT_D_WU, rd, rs1, rm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s28730  :: " string "


\<comment> \<open>\<open>val _s2854_ : string -> maybe ((f_un_rm_op_D * mword ty5 * mword ty5 * rounding_mode))\<close>\<close>

definition s2854  :: \<open> string \<Rightarrow>(f_un_rm_op_D*(5)Word.word*(5)Word.word*rounding_mode)option \<close>  where 
     \<open> s2854 s28560 = (
      (case  ((f_un_rm_type_mnemonic_D_matches_prefix s28560)) of
        Some ((FCVT_D_W, s28570)) => 
  (case  ((string_drop s28560 s28570)) of
        s28580 =>
  (case  ((spc_matches_prefix0 s28580)) of
        Some ((_, s28590)) =>
  (case  ((string_drop s28580 s28590)) of
        s28600 =>
  (case  ((freg_name_matches_prefix s28600 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s28610)) =>
  (case  ((string_drop s28600 s28610)) of
        s28620 =>
  (case  ((sep_matches_prefix s28620)) of
        Some ((_, s28630)) =>
  (case  ((string_drop s28620 s28630)) of
        s28640 =>
  (case  ((reg_name_matches_prefix s28640 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s28650)) =>
  (case  ((string_drop s28640 s28650)) of
        s28660 =>
  (case  ((sep_matches_prefix s28660)) of
        Some ((_, s28670)) =>
  (case  ((string_drop s28660 s28670)) of
        s28680 =>
  (case  ((frm_mnemonic_matches_prefix s28680)) of
        Some ((rm, s28690)) =>
  (let p00 = (string_drop s28680 s28690) in
  if (((p00 = ('''')))) then Some (FCVT_D_W, rd, rs1, rm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s28560  :: " string "


\<comment> \<open>\<open>val _s2837_ : string -> maybe ((f_un_rm_op_D * mword ty5 * mword ty5 * rounding_mode))\<close>\<close>

definition s2837  :: \<open> string \<Rightarrow>(f_un_rm_op_D*(5)Word.word*(5)Word.word*rounding_mode)option \<close>  where 
     \<open> s2837 s28390 = (
      (case  ((f_un_rm_type_mnemonic_D_matches_prefix s28390)) of
        Some ((FCVT_WU_D, s28400)) => 
  (case  ((string_drop s28390 s28400)) of
        s28410 =>
  (case  ((spc_matches_prefix0 s28410)) of
        Some ((_, s28420)) =>
  (case  ((string_drop s28410 s28420)) of
        s28430 =>
  (case  ((reg_name_matches_prefix s28430 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s28440)) =>
  (case  ((string_drop s28430 s28440)) of
        s28450 =>
  (case  ((sep_matches_prefix s28450)) of
        Some ((_, s28460)) =>
  (case  ((string_drop s28450 s28460)) of
        s28470 =>
  (case  ((freg_name_matches_prefix s28470 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s28480)) =>
  (case  ((string_drop s28470 s28480)) of
        s28490 =>
  (case  ((sep_matches_prefix s28490)) of
        Some ((_, s28500)) =>
  (case  ((string_drop s28490 s28500)) of
        s28510 =>
  (case  ((frm_mnemonic_matches_prefix s28510)) of
        Some ((rm, s28520)) =>
  (let p00 = (string_drop s28510 s28520) in
  if (((p00 = ('''')))) then Some (FCVT_WU_D, rd, rs1, rm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s28390  :: " string "


\<comment> \<open>\<open>val _s2820_ : string -> maybe ((f_un_rm_op_D * mword ty5 * mword ty5 * rounding_mode))\<close>\<close>

definition s2820  :: \<open> string \<Rightarrow>(f_un_rm_op_D*(5)Word.word*(5)Word.word*rounding_mode)option \<close>  where 
     \<open> s2820 s28220 = (
      (case  ((f_un_rm_type_mnemonic_D_matches_prefix s28220)) of
        Some ((FCVT_W_D, s28230)) => 
  (case  ((string_drop s28220 s28230)) of
        s28240 =>
  (case  ((spc_matches_prefix0 s28240)) of
        Some ((_, s28250)) =>
  (case  ((string_drop s28240 s28250)) of
        s28260 =>
  (case  ((reg_name_matches_prefix s28260 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s28270)) =>
  (case  ((string_drop s28260 s28270)) of
        s28280 =>
  (case  ((sep_matches_prefix s28280)) of
        Some ((_, s28290)) =>
  (case  ((string_drop s28280 s28290)) of
        s28300 =>
  (case  ((freg_name_matches_prefix s28300 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s28310)) =>
  (case  ((string_drop s28300 s28310)) of
        s28320 =>
  (case  ((sep_matches_prefix s28320)) of
        Some ((_, s28330)) =>
  (case  ((string_drop s28320 s28330)) of
        s28340 =>
  (case  ((frm_mnemonic_matches_prefix s28340)) of
        Some ((rm, s28350)) =>
  (let p00 = (string_drop s28340 s28350) in
  if (((p00 = ('''')))) then Some (FCVT_W_D, rd, rs1, rm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s28220  :: " string "


\<comment> \<open>\<open>val _s2803_ : string -> maybe ((f_un_rm_op_D * mword ty5 * mword ty5 * rounding_mode))\<close>\<close>

definition s2803  :: \<open> string \<Rightarrow>(f_un_rm_op_D*(5)Word.word*(5)Word.word*rounding_mode)option \<close>  where 
     \<open> s2803 s28050 = (
      (case  ((f_un_rm_type_mnemonic_D_matches_prefix s28050)) of
        Some ((FSQRT_D, s28060)) => 
  (case  ((string_drop s28050 s28060)) of
        s28070 =>
  (case  ((spc_matches_prefix0 s28070)) of
        Some ((_, s28080)) =>
  (case  ((string_drop s28070 s28080)) of
        s28090 =>
  (case  ((freg_name_matches_prefix s28090 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s28100)) =>
  (case  ((string_drop s28090 s28100)) of
        s28110 =>
  (case  ((sep_matches_prefix s28110)) of
        Some ((_, s28120)) =>
  (case  ((string_drop s28110 s28120)) of
        s28130 =>
  (case  ((freg_name_matches_prefix s28130 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s28140)) =>
  (case  ((string_drop s28130 s28140)) of
        s28150 =>
  (case  ((sep_matches_prefix s28150)) of
        Some ((_, s28160)) =>
  (case  ((string_drop s28150 s28160)) of
        s28170 =>
  (case  ((frm_mnemonic_matches_prefix s28170)) of
        Some ((rm, s28180)) =>
  (let p00 = (string_drop s28170 s28180) in
  if (((p00 = ('''')))) then Some (FSQRT_D, rd, rs1, rm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s28050  :: " string "


\<comment> \<open>\<open>val _s2782_ : string -> maybe ((f_bin_rm_op_D * mword ty5 * mword ty5 * mword ty5 * rounding_mode))\<close>\<close>

definition s2782  :: \<open> string \<Rightarrow>(f_bin_rm_op_D*(5)Word.word*(5)Word.word*(5)Word.word*rounding_mode)option \<close>  where 
     \<open> s2782 s27840 = (
      (case  ((f_bin_rm_type_mnemonic_D_matches_prefix s27840)) of
        Some ((op1, s27850)) => 
  (case  ((string_drop s27840 s27850)) of
        s27860 =>
  (case  ((spc_matches_prefix0 s27860)) of
        Some ((_, s27870)) =>
  (case  ((string_drop s27860 s27870)) of
        s27880 =>
  (case  ((freg_name_matches_prefix s27880 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s27890)) =>
  (case  ((string_drop s27880 s27890)) of
        s27900 =>
  (case  ((sep_matches_prefix s27900)) of
        Some ((_, s27910)) =>
  (case  ((string_drop s27900 s27910)) of
        s27920 =>
  (case  ((freg_name_matches_prefix s27920 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s27930)) =>
  (case  ((string_drop s27920 s27930)) of
        s27940 =>
  (case  ((sep_matches_prefix s27940)) of
        Some ((_, s27950)) =>
  (case  ((string_drop s27940 s27950)) of
        s27960 =>
  (case  ((freg_name_matches_prefix s27960 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s27970)) =>
  (case  ((string_drop s27960 s27970)) of
        s27980 =>
  (case  ((sep_matches_prefix s27980)) of
        Some ((_, s27990)) =>
  (case  ((string_drop s27980 s27990)) of
        s28000 =>
  (case  ((frm_mnemonic_matches_prefix s28000)) of
        Some ((rm, s28010)) =>
  (let p00 = (string_drop s28000 s28010) in
  if (((p00 = ('''')))) then Some (op1, rd, rs1, rs2, rm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s27840  :: " string "


\<comment> \<open>\<open>val _s2757_ : string -> maybe ((f_madd_op_D * mword ty5 * mword ty5 * mword ty5 * mword ty5 * rounding_mode))\<close>\<close>

definition s2757  :: \<open> string \<Rightarrow>(f_madd_op_D*(5)Word.word*(5)Word.word*(5)Word.word*(5)Word.word*rounding_mode)option \<close>  where 
     \<open> s2757 s27590 = (
      (case  ((f_madd_type_mnemonic_D_matches_prefix s27590)) of
        Some ((op1, s27600)) => 
  (case  ((string_drop s27590 s27600)) of
        s27610 =>
  (case  ((spc_matches_prefix0 s27610)) of
        Some ((_, s27620)) =>
  (case  ((string_drop s27610 s27620)) of
        s27630 =>
  (case  ((freg_name_matches_prefix s27630 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s27640)) =>
  (case  ((string_drop s27630 s27640)) of
        s27650 =>
  (case  ((sep_matches_prefix s27650)) of
        Some ((_, s27660)) =>
  (case  ((string_drop s27650 s27660)) of
        s27670 =>
  (case  ((freg_name_matches_prefix s27670 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s27680)) =>
  (case  ((string_drop s27670 s27680)) of
        s27690 =>
  (case  ((sep_matches_prefix s27690)) of
        Some ((_, s27700)) =>
  (case  ((string_drop s27690 s27700)) of
        s27710 =>
  (case  ((freg_name_matches_prefix s27710 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s27720)) =>
  (case  ((string_drop s27710 s27720)) of
        s27730 =>
  (case  ((sep_matches_prefix s27730)) of
        Some ((_, s27740)) =>
  (case  ((string_drop s27730 s27740)) of
        s27750 =>
  (case  ((freg_name_matches_prefix s27750 :: (( 5 Word.word * ii)) option)) of
        Some ((rs3, s27760)) =>
  (case  ((string_drop s27750 s27760)) of
        s27770 =>
  (case  ((sep_matches_prefix s27770)) of
        Some ((_, s27780)) =>
  (case  ((string_drop s27770 s27780)) of
        s27790 =>
  (case  ((frm_mnemonic_matches_prefix s27790)) of
        Some ((rm, s27800)) =>
  (let p00 = (string_drop s27790 s27800) in
  if (((p00 = ('''')))) then Some (op1, rd, rs1, rs2, rs3, rm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s27590  :: " string "


\<comment> \<open>\<open>val _s2741_ : string -> maybe ((mword ty3 * mword ty3 * mword ty5))\<close>\<close>

definition s2741  :: \<open> string \<Rightarrow>((3)Word.word*(3)Word.word*(5)Word.word)option \<close>  where 
     \<open> s2741 s27420 = (
   (let s27430 = s27420 in
   if ((string_startswith s27430 (''c.fsw''))) then  
  (case  ((string_drop s27430 ((string_length (''c.fsw''))))) of
        s27440 =>
  (case  ((spc_matches_prefix0 s27440)) of
        Some ((_, s27450)) =>
  (case  ((string_drop s27440 s27450)) of
        s27460 =>
  (case  ((creg_name_matches_prefix s27460 :: (( 3 Word.word * ii)) option)) of
        Some ((rsc1, s27470)) =>
  (case  ((string_drop s27460 s27470)) of
        s27480 =>
  (case  ((sep_matches_prefix s27480)) of
        Some ((_, s27490)) =>
  (case  ((string_drop s27480 s27490)) of
        s27500 =>
  (case  ((creg_name_matches_prefix s27500 :: (( 3 Word.word * ii)) option)) of
        Some ((rsc2, s27510)) =>
  (case  ((string_drop s27500 s27510)) of
        s27520 =>
  (case  ((sep_matches_prefix s27520)) of
        Some ((_, s27530)) =>
  (case  ((string_drop s27520 s27530)) of
        s27540 =>
  (case  ((hex_bits_7_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s27540 :: (( 7 Word.word * ii)) option)) of
        Some ((v__1446, s27550)) =>
  if (((((subrange_vec_dec v__1446 (( 1 :: int):: ii) (( 0 :: int):: ii)
         :: 2 Word.word)) = ( 0b00 :: 2 Word.word)))) then
    (let (uimm :: 5 Word.word) =
         ((subrange_vec_dec v__1446 (( 6 :: int):: ii) (( 2 :: int):: ii) :: 5 Word.word)) in
    (let (uimm :: 5 Word.word) =
         ((subrange_vec_dec v__1446 (( 6 :: int):: ii) (( 2 :: int):: ii) :: 5 Word.word)) in
    (let p00 = (string_drop s27540 s27550) in
    if (((p00 = ('''')))) then Some (rsc1, rsc2, uimm) else None))) else 
  None
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s27420  :: " string "


\<comment> \<open>\<open>val _s2725_ : string -> maybe ((mword ty3 * mword ty3 * mword ty5))\<close>\<close>

definition s2725  :: \<open> string \<Rightarrow>((3)Word.word*(3)Word.word*(5)Word.word)option \<close>  where 
     \<open> s2725 s27260 = (
   (let s27270 = s27260 in
   if ((string_startswith s27270 (''c.flw''))) then  
  (case  ((string_drop s27270 ((string_length (''c.flw''))))) of
        s27280 =>
  (case  ((spc_matches_prefix0 s27280)) of
        Some ((_, s27290)) =>
  (case  ((string_drop s27280 s27290)) of
        s27300 =>
  (case  ((creg_name_matches_prefix s27300 :: (( 3 Word.word * ii)) option)) of
        Some ((rdc, s27310)) =>
  (case  ((string_drop s27300 s27310)) of
        s27320 =>
  (case  ((sep_matches_prefix s27320)) of
        Some ((_, s27330)) =>
  (case  ((string_drop s27320 s27330)) of
        s27340 =>
  (case  ((creg_name_matches_prefix s27340 :: (( 3 Word.word * ii)) option)) of
        Some ((rsc, s27350)) =>
  (case  ((string_drop s27340 s27350)) of
        s27360 =>
  (case  ((sep_matches_prefix s27360)) of
        Some ((_, s27370)) =>
  (case  ((string_drop s27360 s27370)) of
        s27380 =>
  (case  ((hex_bits_7_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s27380 :: (( 7 Word.word * ii)) option)) of
        Some ((v__1448, s27390)) =>
  if (((((subrange_vec_dec v__1448 (( 1 :: int):: ii) (( 0 :: int):: ii)
         :: 2 Word.word)) = ( 0b00 :: 2 Word.word)))) then
    (let (uimm :: 5 Word.word) =
         ((subrange_vec_dec v__1448 (( 6 :: int):: ii) (( 2 :: int):: ii) :: 5 Word.word)) in
    (let (uimm :: 5 Word.word) =
         ((subrange_vec_dec v__1448 (( 6 :: int):: ii) (( 2 :: int):: ii) :: 5 Word.word)) in
    (let p00 = (string_drop s27380 s27390) in
    if (((p00 = ('''')))) then Some (rdc, rsc, uimm) else None))) else 
  None
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s27260  :: " string "


\<comment> \<open>\<open>val _s2713_ : string -> maybe ((mword ty5 * mword ty6))\<close>\<close>

definition s2713  :: \<open> string \<Rightarrow>((5)Word.word*(6)Word.word)option \<close>  where 
     \<open> s2713 s27140 = (
   (let s27150 = s27140 in
   if ((string_startswith s27150 (''c.fswsp''))) then  
  (case  ((string_drop s27150 ((string_length (''c.fswsp''))))) of
        s27160 =>
  (case  ((spc_matches_prefix0 s27160)) of
        Some ((_, s27170)) =>
  (case  ((string_drop s27160 s27170)) of
        s27180 =>
  (case  ((reg_name_matches_prefix s27180 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s27190)) =>
  (case  ((string_drop s27180 s27190)) of
        s27200 =>
  (case  ((sep_matches_prefix s27200)) of
        Some ((_, s27210)) =>
  (case  ((string_drop s27200 s27210)) of
        s27220 =>
  (case  ((hex_bits_6_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s27220 :: (( 6 Word.word * ii)) option)) of
        Some ((uimm, s27230)) =>
  (let p00 = (string_drop s27220 s27230) in
  if (((p00 = ('''')))) then Some (rd, uimm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s27140  :: " string "


\<comment> \<open>\<open>val _s2701_ : string -> maybe ((mword ty5 * mword ty6))\<close>\<close>

definition s2701  :: \<open> string \<Rightarrow>((5)Word.word*(6)Word.word)option \<close>  where 
     \<open> s2701 s27020 = (
   (let s27030 = s27020 in
   if ((string_startswith s27030 (''c.flwsp''))) then  
  (case  ((string_drop s27030 ((string_length (''c.flwsp''))))) of
        s27040 =>
  (case  ((spc_matches_prefix0 s27040)) of
        Some ((_, s27050)) =>
  (case  ((string_drop s27040 s27050)) of
        s27060 =>
  (case  ((reg_name_matches_prefix s27060 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s27070)) =>
  (case  ((string_drop s27060 s27070)) of
        s27080 =>
  (case  ((sep_matches_prefix s27080)) of
        Some ((_, s27090)) =>
  (case  ((string_drop s27080 s27090)) of
        s27100 =>
  (case  ((hex_bits_6_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s27100 :: (( 6 Word.word * ii)) option)) of
        Some ((imm, s27110)) =>
  (let p00 = (string_drop s27100 s27110) in
  if (((p00 = ('''')))) then Some (rd, imm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s27020  :: " string "


\<comment> \<open>\<open>val _s2688_ : string -> maybe ((f_un_op_S * mword ty5 * mword ty5))\<close>\<close>

definition s2688  :: \<open> string \<Rightarrow>(f_un_op_S*(5)Word.word*(5)Word.word)option \<close>  where 
     \<open> s2688 s26900 = (
      (case  ((f_un_type_mnemonic_S_matches_prefix s26900)) of
        Some ((FCLASS_S, s26910)) => 
  (case  ((string_drop s26900 s26910)) of
        s26920 =>
  (case  ((spc_matches_prefix0 s26920)) of
        Some ((_, s26930)) =>
  (case  ((string_drop s26920 s26930)) of
        s26940 =>
  (case  ((reg_name_matches_prefix s26940 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s26950)) =>
  (case  ((string_drop s26940 s26950)) of
        s26960 =>
  (case  ((sep_matches_prefix s26960)) of
        Some ((_, s26970)) =>
  (case  ((string_drop s26960 s26970)) of
        s26980 =>
  (case  ((freg_name_matches_prefix s26980 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s26990)) =>
  (let p00 = (string_drop s26980 s26990) in
  if (((p00 = ('''')))) then Some (FCLASS_S, rd, rs1) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s26900  :: " string "


\<comment> \<open>\<open>val _s2675_ : string -> maybe ((f_un_op_S * mword ty5 * mword ty5))\<close>\<close>

definition s2675  :: \<open> string \<Rightarrow>(f_un_op_S*(5)Word.word*(5)Word.word)option \<close>  where 
     \<open> s2675 s26770 = (
      (case  ((f_un_type_mnemonic_S_matches_prefix s26770)) of
        Some ((FMV_W_X, s26780)) => 
  (case  ((string_drop s26770 s26780)) of
        s26790 =>
  (case  ((spc_matches_prefix0 s26790)) of
        Some ((_, s26800)) =>
  (case  ((string_drop s26790 s26800)) of
        s26810 =>
  (case  ((freg_name_matches_prefix s26810 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s26820)) =>
  (case  ((string_drop s26810 s26820)) of
        s26830 =>
  (case  ((sep_matches_prefix s26830)) of
        Some ((_, s26840)) =>
  (case  ((string_drop s26830 s26840)) of
        s26850 =>
  (case  ((reg_name_matches_prefix s26850 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s26860)) =>
  (let p00 = (string_drop s26850 s26860) in
  if (((p00 = ('''')))) then Some (FMV_W_X, rd, rs1) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s26770  :: " string "


\<comment> \<open>\<open>val _s2662_ : string -> maybe ((f_un_op_S * mword ty5 * mword ty5))\<close>\<close>

definition s2662  :: \<open> string \<Rightarrow>(f_un_op_S*(5)Word.word*(5)Word.word)option \<close>  where 
     \<open> s2662 s26640 = (
      (case  ((f_un_type_mnemonic_S_matches_prefix s26640)) of
        Some ((FMV_X_W, s26650)) => 
  (case  ((string_drop s26640 s26650)) of
        s26660 =>
  (case  ((spc_matches_prefix0 s26660)) of
        Some ((_, s26670)) =>
  (case  ((string_drop s26660 s26670)) of
        s26680 =>
  (case  ((reg_name_matches_prefix s26680 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s26690)) =>
  (case  ((string_drop s26680 s26690)) of
        s26700 =>
  (case  ((sep_matches_prefix s26700)) of
        Some ((_, s26710)) =>
  (case  ((string_drop s26700 s26710)) of
        s26720 =>
  (case  ((freg_name_matches_prefix s26720 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s26730)) =>
  (let p00 = (string_drop s26720 s26730) in
  if (((p00 = ('''')))) then Some (FMV_X_W, rd, rs1) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s26640  :: " string "


\<comment> \<open>\<open>val _s2645_ : string -> maybe ((f_bin_op_S * mword ty5 * mword ty5 * mword ty5))\<close>\<close>

definition s2645  :: \<open> string \<Rightarrow>(f_bin_op_S*(5)Word.word*(5)Word.word*(5)Word.word)option \<close>  where 
     \<open> s2645 s26470 = (
      (case  ((f_bin_type_mnemonic_S_matches_prefix s26470)) of
        Some ((FLE_S, s26480)) => 
  (case  ((string_drop s26470 s26480)) of
        s26490 =>
  (case  ((spc_matches_prefix0 s26490)) of
        Some ((_, s26500)) =>
  (case  ((string_drop s26490 s26500)) of
        s26510 =>
  (case  ((reg_name_matches_prefix s26510 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s26520)) =>
  (case  ((string_drop s26510 s26520)) of
        s26530 =>
  (case  ((sep_matches_prefix s26530)) of
        Some ((_, s26540)) =>
  (case  ((string_drop s26530 s26540)) of
        s26550 =>
  (case  ((freg_name_matches_prefix s26550 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s26560)) =>
  (case  ((string_drop s26550 s26560)) of
        s26570 =>
  (case  ((sep_matches_prefix s26570)) of
        Some ((_, s26580)) =>
  (case  ((string_drop s26570 s26580)) of
        s26590 =>
  (case  ((freg_name_matches_prefix s26590 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s26600)) =>
  (let p00 = (string_drop s26590 s26600) in
  if (((p00 = ('''')))) then Some (FLE_S, rd, rs1, rs2) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s26470  :: " string "


\<comment> \<open>\<open>val _s2628_ : string -> maybe ((f_bin_op_S * mword ty5 * mword ty5 * mword ty5))\<close>\<close>

definition s2628  :: \<open> string \<Rightarrow>(f_bin_op_S*(5)Word.word*(5)Word.word*(5)Word.word)option \<close>  where 
     \<open> s2628 s26300 = (
      (case  ((f_bin_type_mnemonic_S_matches_prefix s26300)) of
        Some ((FLT_S, s26310)) => 
  (case  ((string_drop s26300 s26310)) of
        s26320 =>
  (case  ((spc_matches_prefix0 s26320)) of
        Some ((_, s26330)) =>
  (case  ((string_drop s26320 s26330)) of
        s26340 =>
  (case  ((reg_name_matches_prefix s26340 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s26350)) =>
  (case  ((string_drop s26340 s26350)) of
        s26360 =>
  (case  ((sep_matches_prefix s26360)) of
        Some ((_, s26370)) =>
  (case  ((string_drop s26360 s26370)) of
        s26380 =>
  (case  ((freg_name_matches_prefix s26380 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s26390)) =>
  (case  ((string_drop s26380 s26390)) of
        s26400 =>
  (case  ((sep_matches_prefix s26400)) of
        Some ((_, s26410)) =>
  (case  ((string_drop s26400 s26410)) of
        s26420 =>
  (case  ((freg_name_matches_prefix s26420 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s26430)) =>
  (let p00 = (string_drop s26420 s26430) in
  if (((p00 = ('''')))) then Some (FLT_S, rd, rs1, rs2) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s26300  :: " string "


\<comment> \<open>\<open>val _s2611_ : string -> maybe ((f_bin_op_S * mword ty5 * mword ty5 * mword ty5))\<close>\<close>

definition s2611  :: \<open> string \<Rightarrow>(f_bin_op_S*(5)Word.word*(5)Word.word*(5)Word.word)option \<close>  where 
     \<open> s2611 s26130 = (
      (case  ((f_bin_type_mnemonic_S_matches_prefix s26130)) of
        Some ((FEQ_S, s26140)) => 
  (case  ((string_drop s26130 s26140)) of
        s26150 =>
  (case  ((spc_matches_prefix0 s26150)) of
        Some ((_, s26160)) =>
  (case  ((string_drop s26150 s26160)) of
        s26170 =>
  (case  ((reg_name_matches_prefix s26170 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s26180)) =>
  (case  ((string_drop s26170 s26180)) of
        s26190 =>
  (case  ((sep_matches_prefix s26190)) of
        Some ((_, s26200)) =>
  (case  ((string_drop s26190 s26200)) of
        s26210 =>
  (case  ((freg_name_matches_prefix s26210 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s26220)) =>
  (case  ((string_drop s26210 s26220)) of
        s26230 =>
  (case  ((sep_matches_prefix s26230)) of
        Some ((_, s26240)) =>
  (case  ((string_drop s26230 s26240)) of
        s26250 =>
  (case  ((freg_name_matches_prefix s26250 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s26260)) =>
  (let p00 = (string_drop s26250 s26260) in
  if (((p00 = ('''')))) then Some (FEQ_S, rd, rs1, rs2) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s26130  :: " string "


\<comment> \<open>\<open>val _s2594_ : string -> maybe ((f_bin_op_S * mword ty5 * mword ty5 * mword ty5))\<close>\<close>

definition s2594  :: \<open> string \<Rightarrow>(f_bin_op_S*(5)Word.word*(5)Word.word*(5)Word.word)option \<close>  where 
     \<open> s2594 s25960 = (
      (case  ((f_bin_type_mnemonic_S_matches_prefix s25960)) of
        Some ((FMAX_S, s25970)) => 
  (case  ((string_drop s25960 s25970)) of
        s25980 =>
  (case  ((spc_matches_prefix0 s25980)) of
        Some ((_, s25990)) =>
  (case  ((string_drop s25980 s25990)) of
        s26000 =>
  (case  ((freg_name_matches_prefix s26000 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s26010)) =>
  (case  ((string_drop s26000 s26010)) of
        s26020 =>
  (case  ((sep_matches_prefix s26020)) of
        Some ((_, s26030)) =>
  (case  ((string_drop s26020 s26030)) of
        s26040 =>
  (case  ((freg_name_matches_prefix s26040 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s26050)) =>
  (case  ((string_drop s26040 s26050)) of
        s26060 =>
  (case  ((sep_matches_prefix s26060)) of
        Some ((_, s26070)) =>
  (case  ((string_drop s26060 s26070)) of
        s26080 =>
  (case  ((freg_name_matches_prefix s26080 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s26090)) =>
  (let p00 = (string_drop s26080 s26090) in
  if (((p00 = ('''')))) then Some (FMAX_S, rd, rs1, rs2) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s25960  :: " string "


\<comment> \<open>\<open>val _s2577_ : string -> maybe ((f_bin_op_S * mword ty5 * mword ty5 * mword ty5))\<close>\<close>

definition s2577  :: \<open> string \<Rightarrow>(f_bin_op_S*(5)Word.word*(5)Word.word*(5)Word.word)option \<close>  where 
     \<open> s2577 s25790 = (
      (case  ((f_bin_type_mnemonic_S_matches_prefix s25790)) of
        Some ((FMIN_S, s25800)) => 
  (case  ((string_drop s25790 s25800)) of
        s25810 =>
  (case  ((spc_matches_prefix0 s25810)) of
        Some ((_, s25820)) =>
  (case  ((string_drop s25810 s25820)) of
        s25830 =>
  (case  ((freg_name_matches_prefix s25830 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s25840)) =>
  (case  ((string_drop s25830 s25840)) of
        s25850 =>
  (case  ((sep_matches_prefix s25850)) of
        Some ((_, s25860)) =>
  (case  ((string_drop s25850 s25860)) of
        s25870 =>
  (case  ((freg_name_matches_prefix s25870 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s25880)) =>
  (case  ((string_drop s25870 s25880)) of
        s25890 =>
  (case  ((sep_matches_prefix s25890)) of
        Some ((_, s25900)) =>
  (case  ((string_drop s25890 s25900)) of
        s25910 =>
  (case  ((freg_name_matches_prefix s25910 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s25920)) =>
  (let p00 = (string_drop s25910 s25920) in
  if (((p00 = ('''')))) then Some (FMIN_S, rd, rs1, rs2) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s25790  :: " string "


\<comment> \<open>\<open>val _s2560_ : string -> maybe ((f_bin_op_S * mword ty5 * mword ty5 * mword ty5))\<close>\<close>

definition s2560  :: \<open> string \<Rightarrow>(f_bin_op_S*(5)Word.word*(5)Word.word*(5)Word.word)option \<close>  where 
     \<open> s2560 s25620 = (
      (case  ((f_bin_type_mnemonic_S_matches_prefix s25620)) of
        Some ((FSGNJX_S, s25630)) => 
  (case  ((string_drop s25620 s25630)) of
        s25640 =>
  (case  ((spc_matches_prefix0 s25640)) of
        Some ((_, s25650)) =>
  (case  ((string_drop s25640 s25650)) of
        s25660 =>
  (case  ((freg_name_matches_prefix s25660 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s25670)) =>
  (case  ((string_drop s25660 s25670)) of
        s25680 =>
  (case  ((sep_matches_prefix s25680)) of
        Some ((_, s25690)) =>
  (case  ((string_drop s25680 s25690)) of
        s25700 =>
  (case  ((freg_name_matches_prefix s25700 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s25710)) =>
  (case  ((string_drop s25700 s25710)) of
        s25720 =>
  (case  ((sep_matches_prefix s25720)) of
        Some ((_, s25730)) =>
  (case  ((string_drop s25720 s25730)) of
        s25740 =>
  (case  ((freg_name_matches_prefix s25740 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s25750)) =>
  (let p00 = (string_drop s25740 s25750) in
  if (((p00 = ('''')))) then Some (FSGNJX_S, rd, rs1, rs2) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s25620  :: " string "


\<comment> \<open>\<open>val _s2543_ : string -> maybe ((f_bin_op_S * mword ty5 * mword ty5 * mword ty5))\<close>\<close>

definition s2543  :: \<open> string \<Rightarrow>(f_bin_op_S*(5)Word.word*(5)Word.word*(5)Word.word)option \<close>  where 
     \<open> s2543 s25450 = (
      (case  ((f_bin_type_mnemonic_S_matches_prefix s25450)) of
        Some ((FSGNJN_S, s25460)) => 
  (case  ((string_drop s25450 s25460)) of
        s25470 =>
  (case  ((spc_matches_prefix0 s25470)) of
        Some ((_, s25480)) =>
  (case  ((string_drop s25470 s25480)) of
        s25490 =>
  (case  ((freg_name_matches_prefix s25490 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s25500)) =>
  (case  ((string_drop s25490 s25500)) of
        s25510 =>
  (case  ((sep_matches_prefix s25510)) of
        Some ((_, s25520)) =>
  (case  ((string_drop s25510 s25520)) of
        s25530 =>
  (case  ((freg_name_matches_prefix s25530 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s25540)) =>
  (case  ((string_drop s25530 s25540)) of
        s25550 =>
  (case  ((sep_matches_prefix s25550)) of
        Some ((_, s25560)) =>
  (case  ((string_drop s25550 s25560)) of
        s25570 =>
  (case  ((freg_name_matches_prefix s25570 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s25580)) =>
  (let p00 = (string_drop s25570 s25580) in
  if (((p00 = ('''')))) then Some (FSGNJN_S, rd, rs1, rs2) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s25450  :: " string "


\<comment> \<open>\<open>val _s2526_ : string -> maybe ((f_bin_op_S * mword ty5 * mword ty5 * mword ty5))\<close>\<close>

definition s2526  :: \<open> string \<Rightarrow>(f_bin_op_S*(5)Word.word*(5)Word.word*(5)Word.word)option \<close>  where 
     \<open> s2526 s25280 = (
      (case  ((f_bin_type_mnemonic_S_matches_prefix s25280)) of
        Some ((FSGNJ_S, s25290)) => 
  (case  ((string_drop s25280 s25290)) of
        s25300 =>
  (case  ((spc_matches_prefix0 s25300)) of
        Some ((_, s25310)) =>
  (case  ((string_drop s25300 s25310)) of
        s25320 =>
  (case  ((freg_name_matches_prefix s25320 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s25330)) =>
  (case  ((string_drop s25320 s25330)) of
        s25340 =>
  (case  ((sep_matches_prefix s25340)) of
        Some ((_, s25350)) =>
  (case  ((string_drop s25340 s25350)) of
        s25360 =>
  (case  ((freg_name_matches_prefix s25360 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s25370)) =>
  (case  ((string_drop s25360 s25370)) of
        s25380 =>
  (case  ((sep_matches_prefix s25380)) of
        Some ((_, s25390)) =>
  (case  ((string_drop s25380 s25390)) of
        s25400 =>
  (case  ((freg_name_matches_prefix s25400 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s25410)) =>
  (let p00 = (string_drop s25400 s25410) in
  if (((p00 = ('''')))) then Some (FSGNJ_S, rd, rs1, rs2) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s25280  :: " string "


\<comment> \<open>\<open>val _s2509_ : string -> maybe ((f_un_rm_op_S * mword ty5 * mword ty5 * rounding_mode))\<close>\<close>

definition s2509  :: \<open> string \<Rightarrow>(f_un_rm_op_S*(5)Word.word*(5)Word.word*rounding_mode)option \<close>  where 
     \<open> s2509 s25110 = (
      (case  ((f_un_rm_type_mnemonic_S_matches_prefix s25110)) of
        Some ((FCVT_S_LU, s25120)) => 
  (case  ((string_drop s25110 s25120)) of
        s25130 =>
  (case  ((spc_matches_prefix0 s25130)) of
        Some ((_, s25140)) =>
  (case  ((string_drop s25130 s25140)) of
        s25150 =>
  (case  ((freg_name_matches_prefix s25150 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s25160)) =>
  (case  ((string_drop s25150 s25160)) of
        s25170 =>
  (case  ((sep_matches_prefix s25170)) of
        Some ((_, s25180)) =>
  (case  ((string_drop s25170 s25180)) of
        s25190 =>
  (case  ((reg_name_matches_prefix s25190 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s25200)) =>
  (case  ((string_drop s25190 s25200)) of
        s25210 =>
  (case  ((sep_matches_prefix s25210)) of
        Some ((_, s25220)) =>
  (case  ((string_drop s25210 s25220)) of
        s25230 =>
  (case  ((frm_mnemonic_matches_prefix s25230)) of
        Some ((rm, s25240)) =>
  (let p00 = (string_drop s25230 s25240) in
  if (((p00 = ('''')))) then Some (FCVT_S_LU, rd, rs1, rm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s25110  :: " string "


\<comment> \<open>\<open>val _s2492_ : string -> maybe ((f_un_rm_op_S * mword ty5 * mword ty5 * rounding_mode))\<close>\<close>

definition s2492  :: \<open> string \<Rightarrow>(f_un_rm_op_S*(5)Word.word*(5)Word.word*rounding_mode)option \<close>  where 
     \<open> s2492 s24940 = (
      (case  ((f_un_rm_type_mnemonic_S_matches_prefix s24940)) of
        Some ((FCVT_S_L, s24950)) => 
  (case  ((string_drop s24940 s24950)) of
        s24960 =>
  (case  ((spc_matches_prefix0 s24960)) of
        Some ((_, s24970)) =>
  (case  ((string_drop s24960 s24970)) of
        s24980 =>
  (case  ((freg_name_matches_prefix s24980 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s24990)) =>
  (case  ((string_drop s24980 s24990)) of
        s25000 =>
  (case  ((sep_matches_prefix s25000)) of
        Some ((_, s25010)) =>
  (case  ((string_drop s25000 s25010)) of
        s25020 =>
  (case  ((reg_name_matches_prefix s25020 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s25030)) =>
  (case  ((string_drop s25020 s25030)) of
        s25040 =>
  (case  ((sep_matches_prefix s25040)) of
        Some ((_, s25050)) =>
  (case  ((string_drop s25040 s25050)) of
        s25060 =>
  (case  ((frm_mnemonic_matches_prefix s25060)) of
        Some ((rm, s25070)) =>
  (let p00 = (string_drop s25060 s25070) in
  if (((p00 = ('''')))) then Some (FCVT_S_L, rd, rs1, rm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s24940  :: " string "


\<comment> \<open>\<open>val _s2475_ : string -> maybe ((f_un_rm_op_S * mword ty5 * mword ty5 * rounding_mode))\<close>\<close>

definition s2475  :: \<open> string \<Rightarrow>(f_un_rm_op_S*(5)Word.word*(5)Word.word*rounding_mode)option \<close>  where 
     \<open> s2475 s24770 = (
      (case  ((f_un_rm_type_mnemonic_S_matches_prefix s24770)) of
        Some ((FCVT_LU_S, s24780)) => 
  (case  ((string_drop s24770 s24780)) of
        s24790 =>
  (case  ((spc_matches_prefix0 s24790)) of
        Some ((_, s24800)) =>
  (case  ((string_drop s24790 s24800)) of
        s24810 =>
  (case  ((reg_name_matches_prefix s24810 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s24820)) =>
  (case  ((string_drop s24810 s24820)) of
        s24830 =>
  (case  ((sep_matches_prefix s24830)) of
        Some ((_, s24840)) =>
  (case  ((string_drop s24830 s24840)) of
        s24850 =>
  (case  ((freg_name_matches_prefix s24850 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s24860)) =>
  (case  ((string_drop s24850 s24860)) of
        s24870 =>
  (case  ((sep_matches_prefix s24870)) of
        Some ((_, s24880)) =>
  (case  ((string_drop s24870 s24880)) of
        s24890 =>
  (case  ((frm_mnemonic_matches_prefix s24890)) of
        Some ((rm, s24900)) =>
  (let p00 = (string_drop s24890 s24900) in
  if (((p00 = ('''')))) then Some (FCVT_LU_S, rd, rs1, rm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s24770  :: " string "


\<comment> \<open>\<open>val _s2458_ : string -> maybe ((f_un_rm_op_S * mword ty5 * mword ty5 * rounding_mode))\<close>\<close>

definition s2458  :: \<open> string \<Rightarrow>(f_un_rm_op_S*(5)Word.word*(5)Word.word*rounding_mode)option \<close>  where 
     \<open> s2458 s24600 = (
      (case  ((f_un_rm_type_mnemonic_S_matches_prefix s24600)) of
        Some ((FCVT_L_S, s24610)) => 
  (case  ((string_drop s24600 s24610)) of
        s24620 =>
  (case  ((spc_matches_prefix0 s24620)) of
        Some ((_, s24630)) =>
  (case  ((string_drop s24620 s24630)) of
        s24640 =>
  (case  ((reg_name_matches_prefix s24640 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s24650)) =>
  (case  ((string_drop s24640 s24650)) of
        s24660 =>
  (case  ((sep_matches_prefix s24660)) of
        Some ((_, s24670)) =>
  (case  ((string_drop s24660 s24670)) of
        s24680 =>
  (case  ((freg_name_matches_prefix s24680 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s24690)) =>
  (case  ((string_drop s24680 s24690)) of
        s24700 =>
  (case  ((sep_matches_prefix s24700)) of
        Some ((_, s24710)) =>
  (case  ((string_drop s24700 s24710)) of
        s24720 =>
  (case  ((frm_mnemonic_matches_prefix s24720)) of
        Some ((rm, s24730)) =>
  (let p00 = (string_drop s24720 s24730) in
  if (((p00 = ('''')))) then Some (FCVT_L_S, rd, rs1, rm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s24600  :: " string "


\<comment> \<open>\<open>val _s2441_ : string -> maybe ((f_un_rm_op_S * mword ty5 * mword ty5 * rounding_mode))\<close>\<close>

definition s2441  :: \<open> string \<Rightarrow>(f_un_rm_op_S*(5)Word.word*(5)Word.word*rounding_mode)option \<close>  where 
     \<open> s2441 s24430 = (
      (case  ((f_un_rm_type_mnemonic_S_matches_prefix s24430)) of
        Some ((FCVT_S_WU, s24440)) => 
  (case  ((string_drop s24430 s24440)) of
        s24450 =>
  (case  ((spc_matches_prefix0 s24450)) of
        Some ((_, s24460)) =>
  (case  ((string_drop s24450 s24460)) of
        s24470 =>
  (case  ((freg_name_matches_prefix s24470 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s24480)) =>
  (case  ((string_drop s24470 s24480)) of
        s24490 =>
  (case  ((sep_matches_prefix s24490)) of
        Some ((_, s24500)) =>
  (case  ((string_drop s24490 s24500)) of
        s24510 =>
  (case  ((reg_name_matches_prefix s24510 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s24520)) =>
  (case  ((string_drop s24510 s24520)) of
        s24530 =>
  (case  ((sep_matches_prefix s24530)) of
        Some ((_, s24540)) =>
  (case  ((string_drop s24530 s24540)) of
        s24550 =>
  (case  ((frm_mnemonic_matches_prefix s24550)) of
        Some ((rm, s24560)) =>
  (let p00 = (string_drop s24550 s24560) in
  if (((p00 = ('''')))) then Some (FCVT_S_WU, rd, rs1, rm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s24430  :: " string "


\<comment> \<open>\<open>val _s2424_ : string -> maybe ((f_un_rm_op_S * mword ty5 * mword ty5 * rounding_mode))\<close>\<close>

definition s2424  :: \<open> string \<Rightarrow>(f_un_rm_op_S*(5)Word.word*(5)Word.word*rounding_mode)option \<close>  where 
     \<open> s2424 s24260 = (
      (case  ((f_un_rm_type_mnemonic_S_matches_prefix s24260)) of
        Some ((FCVT_S_W, s24270)) => 
  (case  ((string_drop s24260 s24270)) of
        s24280 =>
  (case  ((spc_matches_prefix0 s24280)) of
        Some ((_, s24290)) =>
  (case  ((string_drop s24280 s24290)) of
        s24300 =>
  (case  ((freg_name_matches_prefix s24300 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s24310)) =>
  (case  ((string_drop s24300 s24310)) of
        s24320 =>
  (case  ((sep_matches_prefix s24320)) of
        Some ((_, s24330)) =>
  (case  ((string_drop s24320 s24330)) of
        s24340 =>
  (case  ((reg_name_matches_prefix s24340 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s24350)) =>
  (case  ((string_drop s24340 s24350)) of
        s24360 =>
  (case  ((sep_matches_prefix s24360)) of
        Some ((_, s24370)) =>
  (case  ((string_drop s24360 s24370)) of
        s24380 =>
  (case  ((frm_mnemonic_matches_prefix s24380)) of
        Some ((rm, s24390)) =>
  (let p00 = (string_drop s24380 s24390) in
  if (((p00 = ('''')))) then Some (FCVT_S_W, rd, rs1, rm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s24260  :: " string "


\<comment> \<open>\<open>val _s2407_ : string -> maybe ((f_un_rm_op_S * mword ty5 * mword ty5 * rounding_mode))\<close>\<close>

definition s2407  :: \<open> string \<Rightarrow>(f_un_rm_op_S*(5)Word.word*(5)Word.word*rounding_mode)option \<close>  where 
     \<open> s2407 s24090 = (
      (case  ((f_un_rm_type_mnemonic_S_matches_prefix s24090)) of
        Some ((FCVT_WU_S, s24100)) => 
  (case  ((string_drop s24090 s24100)) of
        s24110 =>
  (case  ((spc_matches_prefix0 s24110)) of
        Some ((_, s24120)) =>
  (case  ((string_drop s24110 s24120)) of
        s24130 =>
  (case  ((reg_name_matches_prefix s24130 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s24140)) =>
  (case  ((string_drop s24130 s24140)) of
        s24150 =>
  (case  ((sep_matches_prefix s24150)) of
        Some ((_, s24160)) =>
  (case  ((string_drop s24150 s24160)) of
        s24170 =>
  (case  ((freg_name_matches_prefix s24170 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s24180)) =>
  (case  ((string_drop s24170 s24180)) of
        s24190 =>
  (case  ((sep_matches_prefix s24190)) of
        Some ((_, s24200)) =>
  (case  ((string_drop s24190 s24200)) of
        s24210 =>
  (case  ((frm_mnemonic_matches_prefix s24210)) of
        Some ((rm, s24220)) =>
  (let p00 = (string_drop s24210 s24220) in
  if (((p00 = ('''')))) then Some (FCVT_WU_S, rd, rs1, rm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s24090  :: " string "


\<comment> \<open>\<open>val _s2390_ : string -> maybe ((f_un_rm_op_S * mword ty5 * mword ty5 * rounding_mode))\<close>\<close>

definition s2390  :: \<open> string \<Rightarrow>(f_un_rm_op_S*(5)Word.word*(5)Word.word*rounding_mode)option \<close>  where 
     \<open> s2390 s23920 = (
      (case  ((f_un_rm_type_mnemonic_S_matches_prefix s23920)) of
        Some ((FCVT_W_S, s23930)) => 
  (case  ((string_drop s23920 s23930)) of
        s23940 =>
  (case  ((spc_matches_prefix0 s23940)) of
        Some ((_, s23950)) =>
  (case  ((string_drop s23940 s23950)) of
        s23960 =>
  (case  ((reg_name_matches_prefix s23960 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s23970)) =>
  (case  ((string_drop s23960 s23970)) of
        s23980 =>
  (case  ((sep_matches_prefix s23980)) of
        Some ((_, s23990)) =>
  (case  ((string_drop s23980 s23990)) of
        s24000 =>
  (case  ((freg_name_matches_prefix s24000 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s24010)) =>
  (case  ((string_drop s24000 s24010)) of
        s24020 =>
  (case  ((sep_matches_prefix s24020)) of
        Some ((_, s24030)) =>
  (case  ((string_drop s24020 s24030)) of
        s24040 =>
  (case  ((frm_mnemonic_matches_prefix s24040)) of
        Some ((rm, s24050)) =>
  (let p00 = (string_drop s24040 s24050) in
  if (((p00 = ('''')))) then Some (FCVT_W_S, rd, rs1, rm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s23920  :: " string "


\<comment> \<open>\<open>val _s2373_ : string -> maybe ((f_un_rm_op_S * mword ty5 * mword ty5 * rounding_mode))\<close>\<close>

definition s2373  :: \<open> string \<Rightarrow>(f_un_rm_op_S*(5)Word.word*(5)Word.word*rounding_mode)option \<close>  where 
     \<open> s2373 s23750 = (
      (case  ((f_un_rm_type_mnemonic_S_matches_prefix s23750)) of
        Some ((FSQRT_S, s23760)) => 
  (case  ((string_drop s23750 s23760)) of
        s23770 =>
  (case  ((spc_matches_prefix0 s23770)) of
        Some ((_, s23780)) =>
  (case  ((string_drop s23770 s23780)) of
        s23790 =>
  (case  ((freg_name_matches_prefix s23790 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s23800)) =>
  (case  ((string_drop s23790 s23800)) of
        s23810 =>
  (case  ((sep_matches_prefix s23810)) of
        Some ((_, s23820)) =>
  (case  ((string_drop s23810 s23820)) of
        s23830 =>
  (case  ((freg_name_matches_prefix s23830 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s23840)) =>
  (case  ((string_drop s23830 s23840)) of
        s23850 =>
  (case  ((sep_matches_prefix s23850)) of
        Some ((_, s23860)) =>
  (case  ((string_drop s23850 s23860)) of
        s23870 =>
  (case  ((frm_mnemonic_matches_prefix s23870)) of
        Some ((rm, s23880)) =>
  (let p00 = (string_drop s23870 s23880) in
  if (((p00 = ('''')))) then Some (FSQRT_S, rd, rs1, rm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s23750  :: " string "


\<comment> \<open>\<open>val _s2352_ : string -> maybe ((f_bin_rm_op_S * mword ty5 * mword ty5 * mword ty5 * rounding_mode))\<close>\<close>

definition s2352  :: \<open> string \<Rightarrow>(f_bin_rm_op_S*(5)Word.word*(5)Word.word*(5)Word.word*rounding_mode)option \<close>  where 
     \<open> s2352 s23540 = (
      (case  ((f_bin_rm_type_mnemonic_S_matches_prefix s23540)) of
        Some ((op1, s23550)) => 
  (case  ((string_drop s23540 s23550)) of
        s23560 =>
  (case  ((spc_matches_prefix0 s23560)) of
        Some ((_, s23570)) =>
  (case  ((string_drop s23560 s23570)) of
        s23580 =>
  (case  ((freg_name_matches_prefix s23580 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s23590)) =>
  (case  ((string_drop s23580 s23590)) of
        s23600 =>
  (case  ((sep_matches_prefix s23600)) of
        Some ((_, s23610)) =>
  (case  ((string_drop s23600 s23610)) of
        s23620 =>
  (case  ((freg_name_matches_prefix s23620 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s23630)) =>
  (case  ((string_drop s23620 s23630)) of
        s23640 =>
  (case  ((sep_matches_prefix s23640)) of
        Some ((_, s23650)) =>
  (case  ((string_drop s23640 s23650)) of
        s23660 =>
  (case  ((freg_name_matches_prefix s23660 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s23670)) =>
  (case  ((string_drop s23660 s23670)) of
        s23680 =>
  (case  ((sep_matches_prefix s23680)) of
        Some ((_, s23690)) =>
  (case  ((string_drop s23680 s23690)) of
        s23700 =>
  (case  ((frm_mnemonic_matches_prefix s23700)) of
        Some ((rm, s23710)) =>
  (let p00 = (string_drop s23700 s23710) in
  if (((p00 = ('''')))) then Some (op1, rd, rs1, rs2, rm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s23540  :: " string "


\<comment> \<open>\<open>val _s2327_ : string -> maybe ((f_madd_op_S * mword ty5 * mword ty5 * mword ty5 * mword ty5 * rounding_mode))\<close>\<close>

definition s2327  :: \<open> string \<Rightarrow>(f_madd_op_S*(5)Word.word*(5)Word.word*(5)Word.word*(5)Word.word*rounding_mode)option \<close>  where 
     \<open> s2327 s23290 = (
      (case  ((f_madd_type_mnemonic_S_matches_prefix s23290)) of
        Some ((op1, s23300)) => 
  (case  ((string_drop s23290 s23300)) of
        s23310 =>
  (case  ((spc_matches_prefix0 s23310)) of
        Some ((_, s23320)) =>
  (case  ((string_drop s23310 s23320)) of
        s23330 =>
  (case  ((freg_name_matches_prefix s23330 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s23340)) =>
  (case  ((string_drop s23330 s23340)) of
        s23350 =>
  (case  ((sep_matches_prefix s23350)) of
        Some ((_, s23360)) =>
  (case  ((string_drop s23350 s23360)) of
        s23370 =>
  (case  ((freg_name_matches_prefix s23370 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s23380)) =>
  (case  ((string_drop s23370 s23380)) of
        s23390 =>
  (case  ((sep_matches_prefix s23390)) of
        Some ((_, s23400)) =>
  (case  ((string_drop s23390 s23400)) of
        s23410 =>
  (case  ((freg_name_matches_prefix s23410 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s23420)) =>
  (case  ((string_drop s23410 s23420)) of
        s23430 =>
  (case  ((sep_matches_prefix s23430)) of
        Some ((_, s23440)) =>
  (case  ((string_drop s23430 s23440)) of
        s23450 =>
  (case  ((freg_name_matches_prefix s23450 :: (( 5 Word.word * ii)) option)) of
        Some ((rs3, s23460)) =>
  (case  ((string_drop s23450 s23460)) of
        s23470 =>
  (case  ((sep_matches_prefix s23470)) of
        Some ((_, s23480)) =>
  (case  ((string_drop s23470 s23480)) of
        s23490 =>
  (case  ((frm_mnemonic_matches_prefix s23490)) of
        Some ((rm, s23500)) =>
  (let p00 = (string_drop s23490 s23500) in
  if (((p00 = ('''')))) then Some (op1, rd, rs1, rs2, rs3, rm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s23290  :: " string "


\<comment> \<open>\<open>val _s2303_ : string -> maybe ((word_width * mword ty5 * mword ty12 * mword ty5))\<close>\<close>

definition s2303  :: \<open> string \<Rightarrow>(word_width*(5)Word.word*(12)Word.word*(5)Word.word)option \<close>  where 
     \<open> s2303 s23040 = (
   (let s23050 = s23040 in
   if ((string_startswith s23050 (''fs''))) then  
  (case  ((string_drop s23050 ((string_length (''fs''))))) of
        s23060 =>
  (case  ((size_mnemonic_matches_prefix s23060)) of
        Some ((width, s23070)) =>
  (case  ((string_drop s23060 s23070)) of
        s23080 =>
  (case  ((spc_matches_prefix0 s23080)) of
        Some ((_, s23090)) =>
  (case  ((string_drop s23080 s23090)) of
        s23100 =>
  (case  ((freg_name_matches_prefix s23100 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s23110)) =>
  (case  ((string_drop s23100 s23110)) of
        s23120 =>
  (case  ((sep_matches_prefix s23120)) of
        Some ((_, s23130)) =>
  (case  ((string_drop s23120 s23130)) of
        s23140 =>
  (case  ((hex_bits_12_matches_prefix0 s23140
          :: (( 12 Word.word * ii)) option)) of
        Some ((imm, s23150)) =>
  (case  ((string_drop s23140 s23150)) of
        s23160 =>
  (case  ((opt_spc_matches_prefix0 s23160)) of
        Some ((_, s23170)) =>
  (let s23180 = (string_drop s23160 s23170) in
  if ((string_startswith s23180 (''(''))) then
    (case  ((string_drop s23180 ((string_length (''(''))))) of
          s23190 =>
    (case  ((opt_spc_matches_prefix0 s23190)) of
          Some ((_, s23200)) =>
    (case  ((string_drop s23190 s23200)) of
          s23210 =>
    (case  ((reg_name_matches_prefix s23210 :: (( 5 Word.word * ii)) option)) of
          Some ((rs1, s23220)) =>
    (case  ((string_drop s23210 s23220)) of
          s23230 =>
    (case  ((opt_spc_matches_prefix0 s23230)) of
          Some ((_, s23240)) =>
    (let s23250 = (string_drop s23230 s23240) in
    if ((string_startswith s23250 ('')''))) then
      (let p00 = (string_drop s23250 ((string_length ('')'')))) in
      if (((p00 = ('''')))) then Some (width, rs2, imm, rs1) else None) else
      None)
      | _ => None
    )
    )
      | _ => None
    )
    )
      | _ => None
    )
    ) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s23040  :: " string "


\<comment> \<open>\<open>val _s2279_ : string -> maybe ((word_width * mword ty5 * mword ty12 * mword ty5))\<close>\<close>

definition s2279  :: \<open> string \<Rightarrow>(word_width*(5)Word.word*(12)Word.word*(5)Word.word)option \<close>  where 
     \<open> s2279 s22800 = (
   (let s22810 = s22800 in
   if ((string_startswith s22810 (''fl''))) then  
  (case  ((string_drop s22810 ((string_length (''fl''))))) of
        s22820 =>
  (case  ((size_mnemonic_matches_prefix s22820)) of
        Some ((width, s22830)) =>
  (case  ((string_drop s22820 s22830)) of
        s22840 =>
  (case  ((spc_matches_prefix0 s22840)) of
        Some ((_, s22850)) =>
  (case  ((string_drop s22840 s22850)) of
        s22860 =>
  (case  ((freg_name_matches_prefix s22860 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s22870)) =>
  (case  ((string_drop s22860 s22870)) of
        s22880 =>
  (case  ((sep_matches_prefix s22880)) of
        Some ((_, s22890)) =>
  (case  ((string_drop s22880 s22890)) of
        s22900 =>
  (case  ((hex_bits_12_matches_prefix0 s22900
          :: (( 12 Word.word * ii)) option)) of
        Some ((imm, s22910)) =>
  (case  ((string_drop s22900 s22910)) of
        s22920 =>
  (case  ((opt_spc_matches_prefix0 s22920)) of
        Some ((_, s22930)) =>
  (let s22940 = (string_drop s22920 s22930) in
  if ((string_startswith s22940 (''(''))) then
    (case  ((string_drop s22940 ((string_length (''(''))))) of
          s22950 =>
    (case  ((opt_spc_matches_prefix0 s22950)) of
          Some ((_, s22960)) =>
    (case  ((string_drop s22950 s22960)) of
          s22970 =>
    (case  ((reg_name_matches_prefix s22970 :: (( 5 Word.word * ii)) option)) of
          Some ((rs1, s22980)) =>
    (case  ((string_drop s22970 s22980)) of
          s22990 =>
    (case  ((opt_spc_matches_prefix0 s22990)) of
          Some ((_, s23000)) =>
    (let s23010 = (string_drop s22990 s23000) in
    if ((string_startswith s23010 ('')''))) then
      (let p00 = (string_drop s23010 ((string_length ('')'')))) in
      if (((p00 = ('''')))) then Some (width, rd, imm, rs1) else None) else
      None)
      | _ => None
    )
    )
      | _ => None
    )
    )
      | _ => None
    )
    ) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s22800  :: " string "


\<comment> \<open>\<open>val _s2267_ : string -> maybe ((mword ty5 * mword ty5 * mword ty12))\<close>\<close>

definition s2267  :: \<open> string \<Rightarrow>((5)Word.word*(5)Word.word*(12)Word.word)option \<close>  where 
     \<open> s2267 s22680 = (
   (let s22690 = s22680 in
   if ((string_startswith s22690 (''fence.i.reserved.''))) then  
  (case  ((string_drop s22690 ((string_length (''fence.i.reserved.''))))) of
        s22700 =>
  (case  ((reg_name_matches_prefix s22700 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s22710)) =>
  (let s22720 = (string_drop s22700 s22710) in
  if ((string_startswith s22720 (''.''))) then
    (case  ((string_drop s22720 ((string_length (''.''))))) of
          s22730 =>
    (case  ((reg_name_matches_prefix s22730 :: (( 5 Word.word * ii)) option)) of
          Some ((rs, s22740)) =>
    (let s22750 = (string_drop s22730 s22740) in
    if ((string_startswith s22750 (''.''))) then
      (case  ((string_drop s22750 ((string_length (''.''))))) of
            s22760 =>
      (case  ((hex_bits_12_matches_prefix0 s22760 :: (( 12 Word.word * ii)) option)) of
            Some ((imm, s22770)) =>
      (let p00 = (string_drop s22760 s22770) in
      if (((p00 = ('''')))) then Some (rd, rs, imm) else None)
        | _ => None
      )
      ) else None)
      | _ => None
    )
    ) else None)
    | _ => None
  )
  )
   else None))\<close> 
  for  s22680  :: " string "


\<comment> \<open>\<open>val _s2249_ : string -> maybe ((mword ty4 * mword ty4 * mword ty5 * mword ty5 * mword ty4))\<close>\<close>

definition s2249  :: \<open> string \<Rightarrow>((4)Word.word*(4)Word.word*(5)Word.word*(5)Word.word*(4)Word.word)option \<close>  where 
     \<open> s2249 s22500 = (
   (let s22510 = s22500 in
   if ((string_startswith s22510 (''fence.reserved.''))) then  
  (case  ((string_drop s22510 ((string_length (''fence.reserved.''))))) of
        s22520 =>
  (case  ((fence_bits_matches_prefix s22520 :: (( 4 Word.word * ii)) option)) of
        Some ((pred, s22530)) =>
  (let s22540 = (string_drop s22520 s22530) in
  if ((string_startswith s22540 (''.''))) then
    (case  ((string_drop s22540 ((string_length (''.''))))) of
          s22550 =>
    (case  ((fence_bits_matches_prefix s22550 :: (( 4 Word.word * ii)) option)) of
          Some ((succ, s22560)) =>
    (let s22570 = (string_drop s22550 s22560) in
    if ((string_startswith s22570 (''.''))) then
      (case  ((string_drop s22570 ((string_length (''.''))))) of
            s22580 =>
      (case  ((reg_name_matches_prefix s22580 :: (( 5 Word.word * ii)) option)) of
            Some ((rs, s22590)) =>
      (let s22600 = (string_drop s22580 s22590) in
      if ((string_startswith s22600 (''.''))) then
        (case  ((string_drop s22600 ((string_length (''.''))))) of
              s22610 =>
        (case  ((reg_name_matches_prefix s22610 :: (( 5 Word.word * ii)) option)) of
              Some ((rd, s22620)) =>
        (let s22630 = (string_drop s22610 s22620) in
        if ((string_startswith s22630 (''.''))) then
          (case  ((string_drop s22630 ((string_length (''.''))))) of
                s22640 =>
          (case  ((hex_bits_4_matches_prefix
                     instance_Sail2_values_Bitvector_Machine_word_mword_dict
                     s22640 :: (( 4 Word.word * ii)) option)) of
                Some ((fm, s22650)) =>
          (let p00 = (string_drop s22640 s22650) in
          if (((p00 = ('''')))) then Some (pred, succ, rs, rd, fm) else None)
            | _ => None
          )
          ) else None)
          | _ => None
        )
        ) else None)
        | _ => None
      )
      ) else None)
      | _ => None
    )
    ) else None)
    | _ => None
  )
  )
   else None))\<close> 
  for  s22500  :: " string "


\<comment> \<open>\<open>val _s2243_ : string -> maybe (mword ty3)\<close>\<close>

definition s2243  :: \<open> string \<Rightarrow>((3)Word.word)option \<close>  where 
     \<open> s2243 s22440 = (
   (let s22450 = s22440 in
   if ((string_startswith s22450 (''c.srai.hint.''))) then  
  (case  ((string_drop s22450 ((string_length (''c.srai.hint.''))))) of
        s22460 =>
  (case  ((creg_name_matches_prefix s22460 :: (( 3 Word.word * ii)) option)) of
        Some ((rsd, s22470)) =>
  (let p00 = (string_drop s22460 s22470) in
  if (((p00 = ('''')))) then Some rsd else None)
    | _ => None
  )
  )
   else None))\<close> 
  for  s22440  :: " string "


\<comment> \<open>\<open>val _s2237_ : string -> maybe (mword ty3)\<close>\<close>

definition s2237  :: \<open> string \<Rightarrow>((3)Word.word)option \<close>  where 
     \<open> s2237 s22380 = (
   (let s22390 = s22380 in
   if ((string_startswith s22390 (''c.srli.hint.''))) then  
  (case  ((string_drop s22390 ((string_length (''c.srli.hint.''))))) of
        s22400 =>
  (case  ((creg_name_matches_prefix s22400 :: (( 3 Word.word * ii)) option)) of
        Some ((rsd, s22410)) =>
  (let p00 = (string_drop s22400 s22410) in
  if (((p00 = ('''')))) then Some rsd else None)
    | _ => None
  )
  )
   else None))\<close> 
  for  s22380  :: " string "


\<comment> \<open>\<open>val _s2228_ : string -> maybe ((mword ty5 * mword ty6))\<close>\<close>

definition s2228  :: \<open> string \<Rightarrow>((5)Word.word*(6)Word.word)option \<close>  where 
     \<open> s2228 s22290 = (
   (let s22300 = s22290 in
   if ((string_startswith s22300 (''c.slli.hint.''))) then  
  (case  ((string_drop s22300 ((string_length (''c.slli.hint.''))))) of
        s22310 =>
  (case  ((reg_name_matches_prefix s22310 :: (( 5 Word.word * ii)) option)) of
        Some ((rsd, s22320)) =>
  (let s22330 = (string_drop s22310 s22320) in
  if ((string_startswith s22330 (''.''))) then
    (case  ((string_drop s22330 ((string_length (''.''))))) of
          s22340 =>
    (case  ((hex_bits_6_matches_prefix
               instance_Sail2_values_Bitvector_Machine_word_mword_dict 
             s22340 :: (( 6 Word.word * ii)) option)) of
          Some ((shamt, s22350)) =>
    (let p00 = (string_drop s22340 s22350) in
    if (((p00 = ('''')))) then Some (rsd, shamt) else None)
      | _ => None
    )
    ) else None)
    | _ => None
  )
  )
   else None))\<close> 
  for  s22290  :: " string "


\<comment> \<open>\<open>val _s2222_ : string -> maybe (mword ty5)\<close>\<close>

definition s2222  :: \<open> string \<Rightarrow>((5)Word.word)option \<close>  where 
     \<open> s2222 s22230 = (
   (let s22240 = s22230 in
   if ((string_startswith s22240 (''c.add.hint.''))) then  
  (case  ((string_drop s22240 ((string_length (''c.add.hint.''))))) of
        s22250 =>
  (case  ((reg_name_matches_prefix s22250 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s22260)) =>
  (let p00 = (string_drop s22250 s22260) in
  if (((p00 = ('''')))) then Some rs2 else None)
    | _ => None
  )
  )
   else None))\<close> 
  for  s22230  :: " string "


\<comment> \<open>\<open>val _s2216_ : string -> maybe (mword ty5)\<close>\<close>

definition s2216  :: \<open> string \<Rightarrow>((5)Word.word)option \<close>  where 
     \<open> s2216 s22170 = (
   (let s22180 = s22170 in
   if ((string_startswith s22180 (''c.mv.hint.''))) then  
  (case  ((string_drop s22180 ((string_length (''c.mv.hint.''))))) of
        s22190 =>
  (case  ((reg_name_matches_prefix s22190 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s22200)) =>
  (let p00 = (string_drop s22190 s22200) in
  if (((p00 = ('''')))) then Some rs2 else None)
    | _ => None
  )
  )
   else None))\<close> 
  for  s22170  :: " string "


\<comment> \<open>\<open>val _s2210_ : string -> maybe (mword ty6)\<close>\<close>

definition s2210  :: \<open> string \<Rightarrow>((6)Word.word)option \<close>  where 
     \<open> s2210 s22110 = (
   (let s22120 = s22110 in
   if ((string_startswith s22120 (''c.lui.hint.''))) then  
  (case  ((string_drop s22120 ((string_length (''c.lui.hint.''))))) of
        s22130 =>
  (case  ((hex_bits_6_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s22130 :: (( 6 Word.word * ii)) option)) of
        Some ((imm, s22140)) =>
  (let p00 = (string_drop s22130 s22140) in
  if (((p00 = ('''')))) then Some imm else None)
    | _ => None
  )
  )
   else None))\<close> 
  for  s22110  :: " string "


\<comment> \<open>\<open>val _s2204_ : string -> maybe (mword ty6)\<close>\<close>

definition s2204  :: \<open> string \<Rightarrow>((6)Word.word)option \<close>  where 
     \<open> s2204 s22050 = (
   (let s22060 = s22050 in
   if ((string_startswith s22060 (''c.li.hint.''))) then  
  (case  ((string_drop s22060 ((string_length (''c.li.hint.''))))) of
        s22070 =>
  (case  ((hex_bits_6_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s22070 :: (( 6 Word.word * ii)) option)) of
        Some ((imm, s22080)) =>
  (let p00 = (string_drop s22070 s22080) in
  if (((p00 = ('''')))) then Some imm else None)
    | _ => None
  )
  )
   else None))\<close> 
  for  s22050  :: " string "


\<comment> \<open>\<open>val _s2198_ : string -> maybe (mword ty5)\<close>\<close>

definition s2198  :: \<open> string \<Rightarrow>((5)Word.word)option \<close>  where 
     \<open> s2198 s21990 = (
   (let s22000 = s21990 in
   if ((string_startswith s22000 (''c.addi.hint.''))) then  
  (case  ((string_drop s22000 ((string_length (''c.addi.hint.''))))) of
        s22010 =>
  (case  ((reg_name_matches_prefix s22010 :: (( 5 Word.word * ii)) option)) of
        Some ((rsd, s22020)) =>
  (let p00 = (string_drop s22010 s22020) in
  if (((p00 = ('''')))) then Some rsd else None)
    | _ => None
  )
  )
   else None))\<close> 
  for  s21990  :: " string "


\<comment> \<open>\<open>val _s2192_ : string -> maybe (mword ty6)\<close>\<close>

definition s2192  :: \<open> string \<Rightarrow>((6)Word.word)option \<close>  where 
     \<open> s2192 s21930 = (
   (let s21940 = s21930 in
   if ((string_startswith s21940 (''c.nop.hint.''))) then  
  (case  ((string_drop s21940 ((string_length (''c.nop.hint.''))))) of
        s21950 =>
  (case  ((hex_bits_6_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s21950 :: (( 6 Word.word * ii)) option)) of
        Some ((imm, s21960)) =>
  (let p00 = (string_drop s21950 s21960) in
  if (((p00 = ('''')))) then Some imm else None)
    | _ => None
  )
  )
   else None))\<close> 
  for  s21930  :: " string "


\<comment> \<open>\<open>val _s2175_ : string -> maybe ((csrop * mword ty5 * mword ty12 * mword ty5))\<close>\<close>

definition s2175  :: \<open> string \<Rightarrow>(csrop*(5)Word.word*(12)Word.word*(5)Word.word)option \<close>  where 
     \<open> s2175 s21770 = (
      (case  ((csr_mnemonic_matches_prefix s21770)) of
        Some ((op1, s21780)) => 
  (case  ((string_drop s21770 s21780)) of
        s21790 =>
  (case  ((spc_matches_prefix0 s21790)) of
        Some ((_, s21800)) =>
  (case  ((string_drop s21790 s21800)) of
        s21810 =>
  (case  ((reg_name_matches_prefix s21810 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s21820)) =>
  (case  ((string_drop s21810 s21820)) of
        s21830 =>
  (case  ((sep_matches_prefix s21830)) of
        Some ((_, s21840)) =>
  (case  ((string_drop s21830 s21840)) of
        s21850 =>
  (case  ((csr_name_map_matches_prefix s21850
          :: (( 12 Word.word * ii)) option)) of
        Some ((csr, s21860)) =>
  (case  ((string_drop s21850 s21860)) of
        s21870 =>
  (case  ((sep_matches_prefix s21870)) of
        Some ((_, s21880)) =>
  (case  ((string_drop s21870 s21880)) of
        s21890 =>
  (case  ((reg_name_matches_prefix s21890 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s21900)) =>
  (let p00 = (string_drop s21890 s21900) in
  if (((p00 = ('''')))) then Some (op1, rd, csr, rs1) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s21770  :: " string "


\<comment> \<open>\<open>val _s2157_ : string -> maybe ((csrop * mword ty5 * mword ty12 * mword ty5))\<close>\<close>

definition s2157  :: \<open> string \<Rightarrow>(csrop*(5)Word.word*(12)Word.word*(5)Word.word)option \<close>  where 
     \<open> s2157 s21590 = (
      (case  ((csr_mnemonic_matches_prefix s21590)) of
        Some ((op1, s21600)) =>
         (let s21610 = (string_drop s21590 s21600) in
         if ((string_startswith s21610 (''i''))) then  
  (case  ((string_drop s21610 ((string_length (''i''))))) of
        s21620 =>
  (case  ((spc_matches_prefix0 s21620)) of
        Some ((_, s21630)) =>
  (case  ((string_drop s21620 s21630)) of
        s21640 =>
  (case  ((reg_name_matches_prefix s21640 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s21650)) =>
  (case  ((string_drop s21640 s21650)) of
        s21660 =>
  (case  ((sep_matches_prefix s21660)) of
        Some ((_, s21670)) =>
  (case  ((string_drop s21660 s21670)) of
        s21680 =>
  (case  ((csr_name_map_matches_prefix s21680
          :: (( 12 Word.word * ii)) option)) of
        Some ((csr, s21690)) =>
  (case  ((string_drop s21680 s21690)) of
        s21700 =>
  (case  ((sep_matches_prefix s21700)) of
        Some ((_, s21710)) =>
  (case  ((string_drop s21700 s21710)) of
        s21720 =>
  (case  ((hex_bits_5_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s21720 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s21730)) =>
  (let p00 = (string_drop s21720 s21730) in
  if (((p00 = ('''')))) then Some (op1, rd, csr, rs1) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
         else None)
      | _ => None
      ))\<close> 
  for  s21590  :: " string "


\<comment> \<open>\<open>val _s2138_ : string -> maybe ((bool * mword ty5 * mword ty5 * mword ty5))\<close>\<close>

definition s2138  :: \<open> string \<Rightarrow>(bool*(5)Word.word*(5)Word.word*(5)Word.word)option \<close>  where 
     \<open> s2138 s21390 = (
   (let s21400 = s21390 in
   if ((string_startswith s21400 (''rem''))) then  
  (case  ((string_drop s21400 ((string_length (''rem''))))) of
        s21410 =>
  (case  ((maybe_not_u_matches_prefix s21410)) of
        Some ((s, s21420)) =>
  (let s21430 = (string_drop s21410 s21420) in
  if ((string_startswith s21430 (''w''))) then
    (case  ((string_drop s21430 ((string_length (''w''))))) of
          s21440 =>
    (case  ((spc_matches_prefix0 s21440)) of
          Some ((_, s21450)) =>
    (case  ((string_drop s21440 s21450)) of
          s21460 =>
    (case  ((reg_name_matches_prefix s21460 :: (( 5 Word.word * ii)) option)) of
          Some ((rd, s21470)) =>
    (case  ((string_drop s21460 s21470)) of
          s21480 =>
    (case  ((sep_matches_prefix s21480)) of
          Some ((_, s21490)) =>
    (case  ((string_drop s21480 s21490)) of
          s21500 =>
    (case  ((reg_name_matches_prefix s21500 :: (( 5 Word.word * ii)) option)) of
          Some ((rs1, s21510)) =>
    (case  ((string_drop s21500 s21510)) of
          s21520 =>
    (case  ((sep_matches_prefix s21520)) of
          Some ((_, s21530)) =>
    (case  ((string_drop s21520 s21530)) of
          s21540 =>
    (case  ((reg_name_matches_prefix s21540 :: (( 5 Word.word * ii)) option)) of
          Some ((rs2, s21550)) =>
    (let p00 = (string_drop s21540 s21550) in
    if (((p00 = ('''')))) then Some (s, rd, rs1, rs2) else None)
      | _ => None
    )
    )
      | _ => None
    )
    )
      | _ => None
    )
    )
      | _ => None
    )
    )
      | _ => None
    )
    )
      | _ => None
    )
    ) else None)
    | _ => None
  )
  )
   else None))\<close> 
  for  s21390  :: " string "


\<comment> \<open>\<open>val _s2119_ : string -> maybe ((bool * mword ty5 * mword ty5 * mword ty5))\<close>\<close>

definition s2119  :: \<open> string \<Rightarrow>(bool*(5)Word.word*(5)Word.word*(5)Word.word)option \<close>  where 
     \<open> s2119 s21200 = (
   (let s21210 = s21200 in
   if ((string_startswith s21210 (''div''))) then  
  (case  ((string_drop s21210 ((string_length (''div''))))) of
        s21220 =>
  (case  ((maybe_not_u_matches_prefix s21220)) of
        Some ((s, s21230)) =>
  (let s21240 = (string_drop s21220 s21230) in
  if ((string_startswith s21240 (''w''))) then
    (case  ((string_drop s21240 ((string_length (''w''))))) of
          s21250 =>
    (case  ((spc_matches_prefix0 s21250)) of
          Some ((_, s21260)) =>
    (case  ((string_drop s21250 s21260)) of
          s21270 =>
    (case  ((reg_name_matches_prefix s21270 :: (( 5 Word.word * ii)) option)) of
          Some ((rd, s21280)) =>
    (case  ((string_drop s21270 s21280)) of
          s21290 =>
    (case  ((sep_matches_prefix s21290)) of
          Some ((_, s21300)) =>
    (case  ((string_drop s21290 s21300)) of
          s21310 =>
    (case  ((reg_name_matches_prefix s21310 :: (( 5 Word.word * ii)) option)) of
          Some ((rs1, s21320)) =>
    (case  ((string_drop s21310 s21320)) of
          s21330 =>
    (case  ((sep_matches_prefix s21330)) of
          Some ((_, s21340)) =>
    (case  ((string_drop s21330 s21340)) of
          s21350 =>
    (case  ((reg_name_matches_prefix s21350 :: (( 5 Word.word * ii)) option)) of
          Some ((rs2, s21360)) =>
    (let p00 = (string_drop s21350 s21360) in
    if (((p00 = ('''')))) then Some (s, rd, rs1, rs2) else None)
      | _ => None
    )
    )
      | _ => None
    )
    )
      | _ => None
    )
    )
      | _ => None
    )
    )
      | _ => None
    )
    )
      | _ => None
    )
    ) else None)
    | _ => None
  )
  )
   else None))\<close> 
  for  s21200  :: " string "


\<comment> \<open>\<open>val _s2103_ : string -> maybe ((mword ty5 * mword ty5 * mword ty5))\<close>\<close>

definition s2103  :: \<open> string \<Rightarrow>((5)Word.word*(5)Word.word*(5)Word.word)option \<close>  where 
     \<open> s2103 s21040 = (
   (let s21050 = s21040 in
   if ((string_startswith s21050 (''mulw''))) then  
  (case  ((string_drop s21050 ((string_length (''mulw''))))) of
        s21060 =>
  (case  ((spc_matches_prefix0 s21060)) of
        Some ((_, s21070)) =>
  (case  ((string_drop s21060 s21070)) of
        s21080 =>
  (case  ((reg_name_matches_prefix s21080 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s21090)) =>
  (case  ((string_drop s21080 s21090)) of
        s21100 =>
  (case  ((sep_matches_prefix s21100)) of
        Some ((_, s21110)) =>
  (case  ((string_drop s21100 s21110)) of
        s21120 =>
  (case  ((reg_name_matches_prefix s21120 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s21130)) =>
  (case  ((string_drop s21120 s21130)) of
        s21140 =>
  (case  ((sep_matches_prefix s21140)) of
        Some ((_, s21150)) =>
  (case  ((string_drop s21140 s21150)) of
        s21160 =>
  (case  ((reg_name_matches_prefix s21160 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s21170)) =>
  (let p00 = (string_drop s21160 s21170) in
  if (((p00 = ('''')))) then Some (rd, rs1, rs2) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s21040  :: " string "


\<comment> \<open>\<open>val _s2085_ : string -> maybe ((bool * mword ty5 * mword ty5 * mword ty5))\<close>\<close>

definition s2085  :: \<open> string \<Rightarrow>(bool*(5)Word.word*(5)Word.word*(5)Word.word)option \<close>  where 
     \<open> s2085 s20860 = (
   (let s20870 = s20860 in
   if ((string_startswith s20870 (''rem''))) then  
  (case  ((string_drop s20870 ((string_length (''rem''))))) of
        s20880 =>
  (case  ((maybe_not_u_matches_prefix s20880)) of
        Some ((s, s20890)) =>
  (case  ((string_drop s20880 s20890)) of
        s20900 =>
  (case  ((spc_matches_prefix0 s20900)) of
        Some ((_, s20910)) =>
  (case  ((string_drop s20900 s20910)) of
        s20920 =>
  (case  ((reg_name_matches_prefix s20920 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s20930)) =>
  (case  ((string_drop s20920 s20930)) of
        s20940 =>
  (case  ((sep_matches_prefix s20940)) of
        Some ((_, s20950)) =>
  (case  ((string_drop s20940 s20950)) of
        s20960 =>
  (case  ((reg_name_matches_prefix s20960 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s20970)) =>
  (case  ((string_drop s20960 s20970)) of
        s20980 =>
  (case  ((sep_matches_prefix s20980)) of
        Some ((_, s20990)) =>
  (case  ((string_drop s20980 s20990)) of
        s21000 =>
  (case  ((reg_name_matches_prefix s21000 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s21010)) =>
  (let p00 = (string_drop s21000 s21010) in
  if (((p00 = ('''')))) then Some (s, rd, rs1, rs2) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s20860  :: " string "


\<comment> \<open>\<open>val _s2067_ : string -> maybe ((bool * mword ty5 * mword ty5 * mword ty5))\<close>\<close>

definition s2067  :: \<open> string \<Rightarrow>(bool*(5)Word.word*(5)Word.word*(5)Word.word)option \<close>  where 
     \<open> s2067 s20680 = (
   (let s20690 = s20680 in
   if ((string_startswith s20690 (''div''))) then  
  (case  ((string_drop s20690 ((string_length (''div''))))) of
        s20700 =>
  (case  ((maybe_not_u_matches_prefix s20700)) of
        Some ((s, s20710)) =>
  (case  ((string_drop s20700 s20710)) of
        s20720 =>
  (case  ((spc_matches_prefix0 s20720)) of
        Some ((_, s20730)) =>
  (case  ((string_drop s20720 s20730)) of
        s20740 =>
  (case  ((reg_name_matches_prefix s20740 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s20750)) =>
  (case  ((string_drop s20740 s20750)) of
        s20760 =>
  (case  ((sep_matches_prefix s20760)) of
        Some ((_, s20770)) =>
  (case  ((string_drop s20760 s20770)) of
        s20780 =>
  (case  ((reg_name_matches_prefix s20780 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s20790)) =>
  (case  ((string_drop s20780 s20790)) of
        s20800 =>
  (case  ((sep_matches_prefix s20800)) of
        Some ((_, s20810)) =>
  (case  ((string_drop s20800 s20810)) of
        s20820 =>
  (case  ((reg_name_matches_prefix s20820 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s20830)) =>
  (let p00 = (string_drop s20820 s20830) in
  if (((p00 = ('''')))) then Some (s, rd, rs1, rs2) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s20680  :: " string "


\<comment> \<open>\<open>val _s2050_ : string -> maybe ((bool * bool * bool * mword ty5 * mword ty5 * mword ty5))\<close>\<close>

definition s2050  :: \<open> string \<Rightarrow>(bool*bool*bool*(5)Word.word*(5)Word.word*(5)Word.word)option \<close>  where 
     \<open> s2050 s20520 = (
      (case  ((mul_mnemonic_matches_prefix s20520)) of
        Some (((high, signed1, signed2), s20530)) => 
  (case  ((string_drop s20520 s20530)) of
        s20540 =>
  (case  ((spc_matches_prefix0 s20540)) of
        Some ((_, s20550)) =>
  (case  ((string_drop s20540 s20550)) of
        s20560 =>
  (case  ((reg_name_matches_prefix s20560 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s20570)) =>
  (case  ((string_drop s20560 s20570)) of
        s20580 =>
  (case  ((sep_matches_prefix s20580)) of
        Some ((_, s20590)) =>
  (case  ((string_drop s20580 s20590)) of
        s20600 =>
  (case  ((reg_name_matches_prefix s20600 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s20610)) =>
  (case  ((string_drop s20600 s20610)) of
        s20620 =>
  (case  ((sep_matches_prefix s20620)) of
        Some ((_, s20630)) =>
  (case  ((string_drop s20620 s20630)) of
        s20640 =>
  (case  ((reg_name_matches_prefix s20640 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s20650)) =>
  (let p00 = (string_drop s20640 s20650) in
  if (((p00 = ('''')))) then Some (high, signed1, signed2, rd, rs1, rs2) else
    None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s20520  :: " string "


\<comment> \<open>\<open>val _s2038_ : string -> maybe ((mword ty5 * mword ty5))\<close>\<close>

definition s2038  :: \<open> string \<Rightarrow>((5)Word.word*(5)Word.word)option \<close>  where 
     \<open> s2038 s20390 = (
   (let s20400 = s20390 in
   if ((string_startswith s20400 (''c.add''))) then  
  (case  ((string_drop s20400 ((string_length (''c.add''))))) of
        s20410 =>
  (case  ((spc_matches_prefix0 s20410)) of
        Some ((_, s20420)) =>
  (case  ((string_drop s20410 s20420)) of
        s20430 =>
  (case  ((reg_name_matches_prefix s20430 :: (( 5 Word.word * ii)) option)) of
        Some ((rsd, s20440)) =>
  (case  ((string_drop s20430 s20440)) of
        s20450 =>
  (case  ((sep_matches_prefix s20450)) of
        Some ((_, s20460)) =>
  (case  ((string_drop s20450 s20460)) of
        s20470 =>
  (case  ((reg_name_matches_prefix s20470 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s20480)) =>
  (let p00 = (string_drop s20470 s20480) in
  if (((p00 = ('''')))) then Some (rsd, rs2) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s20390  :: " string "


\<comment> \<open>\<open>val _s2026_ : string -> maybe ((mword ty5 * mword ty5))\<close>\<close>

definition s2026  :: \<open> string \<Rightarrow>((5)Word.word*(5)Word.word)option \<close>  where 
     \<open> s2026 s20270 = (
   (let s20280 = s20270 in
   if ((string_startswith s20280 (''c.mv''))) then  
  (case  ((string_drop s20280 ((string_length (''c.mv''))))) of
        s20290 =>
  (case  ((spc_matches_prefix0 s20290)) of
        Some ((_, s20300)) =>
  (case  ((string_drop s20290 s20300)) of
        s20310 =>
  (case  ((reg_name_matches_prefix s20310 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s20320)) =>
  (case  ((string_drop s20310 s20320)) of
        s20330 =>
  (case  ((sep_matches_prefix s20330)) of
        Some ((_, s20340)) =>
  (case  ((string_drop s20330 s20340)) of
        s20350 =>
  (case  ((reg_name_matches_prefix s20350 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s20360)) =>
  (let p00 = (string_drop s20350 s20360) in
  if (((p00 = ('''')))) then Some (rd, rs2) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s20270  :: " string "


\<comment> \<open>\<open>val _s2018_ : string -> maybe (mword ty5)\<close>\<close>

definition s2018  :: \<open> string \<Rightarrow>((5)Word.word)option \<close>  where 
     \<open> s2018 s20190 = (
   (let s20200 = s20190 in
   if ((string_startswith s20200 (''c.jalr''))) then  
  (case  ((string_drop s20200 ((string_length (''c.jalr''))))) of
        s20210 =>
  (case  ((spc_matches_prefix0 s20210)) of
        Some ((_, s20220)) =>
  (case  ((string_drop s20210 s20220)) of
        s20230 =>
  (case  ((reg_name_matches_prefix s20230 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s20240)) =>
  (let p00 = (string_drop s20230 s20240) in
  if (((p00 = ('''')))) then Some rs1 else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s20190  :: " string "


\<comment> \<open>\<open>val _s2010_ : string -> maybe (mword ty5)\<close>\<close>

definition s2010  :: \<open> string \<Rightarrow>((5)Word.word)option \<close>  where 
     \<open> s2010 s20110 = (
   (let s20120 = s20110 in
   if ((string_startswith s20120 (''c.jr''))) then  
  (case  ((string_drop s20120 ((string_length (''c.jr''))))) of
        s20130 =>
  (case  ((spc_matches_prefix0 s20130)) of
        Some ((_, s20140)) =>
  (case  ((string_drop s20130 s20140)) of
        s20150 =>
  (case  ((reg_name_matches_prefix s20150 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s20160)) =>
  (let p00 = (string_drop s20150 s20160) in
  if (((p00 = ('''')))) then Some rs1 else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s20110  :: " string "


\<comment> \<open>\<open>val _s1998_ : string -> maybe ((mword ty5 * mword ty6))\<close>\<close>

definition s1998  :: \<open> string \<Rightarrow>((5)Word.word*(6)Word.word)option \<close>  where 
     \<open> s1998 s19990 = (
   (let s20000 = s19990 in
   if ((string_startswith s20000 (''c.sdsp''))) then  
  (case  ((string_drop s20000 ((string_length (''c.sdsp''))))) of
        s20010 =>
  (case  ((spc_matches_prefix0 s20010)) of
        Some ((_, s20020)) =>
  (case  ((string_drop s20010 s20020)) of
        s20030 =>
  (case  ((reg_name_matches_prefix s20030 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s20040)) =>
  (case  ((string_drop s20030 s20040)) of
        s20050 =>
  (case  ((sep_matches_prefix s20050)) of
        Some ((_, s20060)) =>
  (case  ((string_drop s20050 s20060)) of
        s20070 =>
  (case  ((hex_bits_6_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s20070 :: (( 6 Word.word * ii)) option)) of
        Some ((uimm, s20080)) =>
  (let p00 = (string_drop s20070 s20080) in
  if (((p00 = ('''')))) then Some (rs2, uimm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s19990  :: " string "


\<comment> \<open>\<open>val _s1986_ : string -> maybe ((mword ty5 * mword ty6))\<close>\<close>

definition s1986  :: \<open> string \<Rightarrow>((5)Word.word*(6)Word.word)option \<close>  where 
     \<open> s1986 s19870 = (
   (let s19880 = s19870 in
   if ((string_startswith s19880 (''c.swsp''))) then  
  (case  ((string_drop s19880 ((string_length (''c.swsp''))))) of
        s19890 =>
  (case  ((spc_matches_prefix0 s19890)) of
        Some ((_, s19900)) =>
  (case  ((string_drop s19890 s19900)) of
        s19910 =>
  (case  ((reg_name_matches_prefix s19910 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s19920)) =>
  (case  ((string_drop s19910 s19920)) of
        s19930 =>
  (case  ((sep_matches_prefix s19930)) of
        Some ((_, s19940)) =>
  (case  ((string_drop s19930 s19940)) of
        s19950 =>
  (case  ((hex_bits_6_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s19950 :: (( 6 Word.word * ii)) option)) of
        Some ((uimm, s19960)) =>
  (let p00 = (string_drop s19950 s19960) in
  if (((p00 = ('''')))) then Some (rd, uimm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s19870  :: " string "


\<comment> \<open>\<open>val _s1974_ : string -> maybe ((mword ty5 * mword ty6))\<close>\<close>

definition s1974  :: \<open> string \<Rightarrow>((5)Word.word*(6)Word.word)option \<close>  where 
     \<open> s1974 s19750 = (
   (let s19760 = s19750 in
   if ((string_startswith s19760 (''c.ldsp''))) then  
  (case  ((string_drop s19760 ((string_length (''c.ldsp''))))) of
        s19770 =>
  (case  ((spc_matches_prefix0 s19770)) of
        Some ((_, s19780)) =>
  (case  ((string_drop s19770 s19780)) of
        s19790 =>
  (case  ((reg_name_matches_prefix s19790 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s19800)) =>
  (case  ((string_drop s19790 s19800)) of
        s19810 =>
  (case  ((sep_matches_prefix s19810)) of
        Some ((_, s19820)) =>
  (case  ((string_drop s19810 s19820)) of
        s19830 =>
  (case  ((hex_bits_6_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s19830 :: (( 6 Word.word * ii)) option)) of
        Some ((uimm, s19840)) =>
  (let p00 = (string_drop s19830 s19840) in
  if (((p00 = ('''')))) then Some (rd, uimm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s19750  :: " string "


\<comment> \<open>\<open>val _s1962_ : string -> maybe ((mword ty5 * mword ty6))\<close>\<close>

definition s1962  :: \<open> string \<Rightarrow>((5)Word.word*(6)Word.word)option \<close>  where 
     \<open> s1962 s19630 = (
   (let s19640 = s19630 in
   if ((string_startswith s19640 (''c.lwsp''))) then  
  (case  ((string_drop s19640 ((string_length (''c.lwsp''))))) of
        s19650 =>
  (case  ((spc_matches_prefix0 s19650)) of
        Some ((_, s19660)) =>
  (case  ((string_drop s19650 s19660)) of
        s19670 =>
  (case  ((reg_name_matches_prefix s19670 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s19680)) =>
  (case  ((string_drop s19670 s19680)) of
        s19690 =>
  (case  ((sep_matches_prefix s19690)) of
        Some ((_, s19700)) =>
  (case  ((string_drop s19690 s19700)) of
        s19710 =>
  (case  ((hex_bits_6_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s19710 :: (( 6 Word.word * ii)) option)) of
        Some ((uimm, s19720)) =>
  (let p00 = (string_drop s19710 s19720) in
  if (((p00 = ('''')))) then Some (rd, uimm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s19630  :: " string "


\<comment> \<open>\<open>val _s1950_ : string -> maybe ((mword ty5 * mword ty6))\<close>\<close>

definition s1950  :: \<open> string \<Rightarrow>((5)Word.word*(6)Word.word)option \<close>  where 
     \<open> s1950 s19510 = (
   (let s19520 = s19510 in
   if ((string_startswith s19520 (''c.slli''))) then  
  (case  ((string_drop s19520 ((string_length (''c.slli''))))) of
        s19530 =>
  (case  ((spc_matches_prefix0 s19530)) of
        Some ((_, s19540)) =>
  (case  ((string_drop s19530 s19540)) of
        s19550 =>
  (case  ((reg_name_matches_prefix s19550 :: (( 5 Word.word * ii)) option)) of
        Some ((rsd, s19560)) =>
  (case  ((string_drop s19550 s19560)) of
        s19570 =>
  (case  ((sep_matches_prefix s19570)) of
        Some ((_, s19580)) =>
  (case  ((string_drop s19570 s19580)) of
        s19590 =>
  (case  ((hex_bits_6_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s19590 :: (( 6 Word.word * ii)) option)) of
        Some ((shamt, s19600)) =>
  (let p00 = (string_drop s19590 s19600) in
  if (((p00 = ('''')))) then Some (rsd, shamt) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s19510  :: " string "


\<comment> \<open>\<open>val _s1938_ : string -> maybe ((mword ty3 * mword ty8))\<close>\<close>

definition s1938  :: \<open> string \<Rightarrow>((3)Word.word*(8)Word.word)option \<close>  where 
     \<open> s1938 s19390 = (
   (let s19400 = s19390 in
   if ((string_startswith s19400 (''c.bnez''))) then  
  (case  ((string_drop s19400 ((string_length (''c.bnez''))))) of
        s19410 =>
  (case  ((spc_matches_prefix0 s19410)) of
        Some ((_, s19420)) =>
  (case  ((string_drop s19410 s19420)) of
        s19430 =>
  (case  ((creg_name_matches_prefix s19430 :: (( 3 Word.word * ii)) option)) of
        Some ((rs, s19440)) =>
  (case  ((string_drop s19430 s19440)) of
        s19450 =>
  (case  ((sep_matches_prefix s19450)) of
        Some ((_, s19460)) =>
  (case  ((string_drop s19450 s19460)) of
        s19470 =>
  (case  ((hex_bits_8_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s19470 :: (( 8 Word.word * ii)) option)) of
        Some ((imm, s19480)) =>
  (let p00 = (string_drop s19470 s19480) in
  if (((p00 = ('''')))) then Some (rs, imm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s19390  :: " string "


\<comment> \<open>\<open>val _s1926_ : string -> maybe ((mword ty3 * mword ty8))\<close>\<close>

definition s1926  :: \<open> string \<Rightarrow>((3)Word.word*(8)Word.word)option \<close>  where 
     \<open> s1926 s19270 = (
   (let s19280 = s19270 in
   if ((string_startswith s19280 (''c.beqz''))) then  
  (case  ((string_drop s19280 ((string_length (''c.beqz''))))) of
        s19290 =>
  (case  ((spc_matches_prefix0 s19290)) of
        Some ((_, s19300)) =>
  (case  ((string_drop s19290 s19300)) of
        s19310 =>
  (case  ((creg_name_matches_prefix s19310 :: (( 3 Word.word * ii)) option)) of
        Some ((rs, s19320)) =>
  (case  ((string_drop s19310 s19320)) of
        s19330 =>
  (case  ((sep_matches_prefix s19330)) of
        Some ((_, s19340)) =>
  (case  ((string_drop s19330 s19340)) of
        s19350 =>
  (case  ((hex_bits_8_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s19350 :: (( 8 Word.word * ii)) option)) of
        Some ((imm, s19360)) =>
  (let p00 = (string_drop s19350 s19360) in
  if (((p00 = ('''')))) then Some (rs, imm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s19270  :: " string "


\<comment> \<open>\<open>val _s1918_ : string -> maybe (mword ty11)\<close>\<close>

definition s1918  :: \<open> string \<Rightarrow>((11)Word.word)option \<close>  where 
     \<open> s1918 s19190 = (
   (let s19200 = s19190 in
   if ((string_startswith s19200 (''c.j''))) then  
  (case  ((string_drop s19200 ((string_length (''c.j''))))) of
        s19210 =>
  (case  ((spc_matches_prefix0 s19210)) of
        Some ((_, s19220)) =>
  (case  ((string_drop s19210 s19220)) of
        s19230 =>
  (case  ((hex_bits_11_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s19230 :: (( 11 Word.word * ii)) option)) of
        Some ((imm, s19240)) =>
  (let p00 = (string_drop s19230 s19240) in
  if (((p00 = ('''')))) then Some imm else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s19190  :: " string "


\<comment> \<open>\<open>val _s1906_ : string -> maybe ((mword ty3 * mword ty3))\<close>\<close>

definition s1906  :: \<open> string \<Rightarrow>((3)Word.word*(3)Word.word)option \<close>  where 
     \<open> s1906 s19070 = (
   (let s19080 = s19070 in
   if ((string_startswith s19080 (''c.addw''))) then  
  (case  ((string_drop s19080 ((string_length (''c.addw''))))) of
        s19090 =>
  (case  ((spc_matches_prefix0 s19090)) of
        Some ((_, s19100)) =>
  (case  ((string_drop s19090 s19100)) of
        s19110 =>
  (case  ((creg_name_matches_prefix s19110 :: (( 3 Word.word * ii)) option)) of
        Some ((rsd, s19120)) =>
  (case  ((string_drop s19110 s19120)) of
        s19130 =>
  (case  ((sep_matches_prefix s19130)) of
        Some ((_, s19140)) =>
  (case  ((string_drop s19130 s19140)) of
        s19150 =>
  (case  ((creg_name_matches_prefix s19150 :: (( 3 Word.word * ii)) option)) of
        Some ((rs2, s19160)) =>
  (let p00 = (string_drop s19150 s19160) in
  if (((p00 = ('''')))) then Some (rsd, rs2) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s19070  :: " string "


\<comment> \<open>\<open>val _s1894_ : string -> maybe ((mword ty3 * mword ty3))\<close>\<close>

definition s1894  :: \<open> string \<Rightarrow>((3)Word.word*(3)Word.word)option \<close>  where 
     \<open> s1894 s18950 = (
   (let s18960 = s18950 in
   if ((string_startswith s18960 (''c.subw''))) then  
  (case  ((string_drop s18960 ((string_length (''c.subw''))))) of
        s18970 =>
  (case  ((spc_matches_prefix0 s18970)) of
        Some ((_, s18980)) =>
  (case  ((string_drop s18970 s18980)) of
        s18990 =>
  (case  ((creg_name_matches_prefix s18990 :: (( 3 Word.word * ii)) option)) of
        Some ((rsd, s19000)) =>
  (case  ((string_drop s18990 s19000)) of
        s19010 =>
  (case  ((sep_matches_prefix s19010)) of
        Some ((_, s19020)) =>
  (case  ((string_drop s19010 s19020)) of
        s19030 =>
  (case  ((creg_name_matches_prefix s19030 :: (( 3 Word.word * ii)) option)) of
        Some ((rs2, s19040)) =>
  (let p00 = (string_drop s19030 s19040) in
  if (((p00 = ('''')))) then Some (rsd, rs2) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s18950  :: " string "


\<comment> \<open>\<open>val _s1882_ : string -> maybe ((mword ty3 * mword ty3))\<close>\<close>

definition s1882  :: \<open> string \<Rightarrow>((3)Word.word*(3)Word.word)option \<close>  where 
     \<open> s1882 s18830 = (
   (let s18840 = s18830 in
   if ((string_startswith s18840 (''c.and''))) then  
  (case  ((string_drop s18840 ((string_length (''c.and''))))) of
        s18850 =>
  (case  ((spc_matches_prefix0 s18850)) of
        Some ((_, s18860)) =>
  (case  ((string_drop s18850 s18860)) of
        s18870 =>
  (case  ((creg_name_matches_prefix s18870 :: (( 3 Word.word * ii)) option)) of
        Some ((rsd, s18880)) =>
  (case  ((string_drop s18870 s18880)) of
        s18890 =>
  (case  ((sep_matches_prefix s18890)) of
        Some ((_, s18900)) =>
  (case  ((string_drop s18890 s18900)) of
        s18910 =>
  (case  ((creg_name_matches_prefix s18910 :: (( 3 Word.word * ii)) option)) of
        Some ((rs2, s18920)) =>
  (let p00 = (string_drop s18910 s18920) in
  if (((p00 = ('''')))) then Some (rsd, rs2) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s18830  :: " string "


\<comment> \<open>\<open>val _s1870_ : string -> maybe ((mword ty3 * mword ty3))\<close>\<close>

definition s1870  :: \<open> string \<Rightarrow>((3)Word.word*(3)Word.word)option \<close>  where 
     \<open> s1870 s18710 = (
   (let s18720 = s18710 in
   if ((string_startswith s18720 (''c.or''))) then  
  (case  ((string_drop s18720 ((string_length (''c.or''))))) of
        s18730 =>
  (case  ((spc_matches_prefix0 s18730)) of
        Some ((_, s18740)) =>
  (case  ((string_drop s18730 s18740)) of
        s18750 =>
  (case  ((creg_name_matches_prefix s18750 :: (( 3 Word.word * ii)) option)) of
        Some ((rsd, s18760)) =>
  (case  ((string_drop s18750 s18760)) of
        s18770 =>
  (case  ((sep_matches_prefix s18770)) of
        Some ((_, s18780)) =>
  (case  ((string_drop s18770 s18780)) of
        s18790 =>
  (case  ((creg_name_matches_prefix s18790 :: (( 3 Word.word * ii)) option)) of
        Some ((rs2, s18800)) =>
  (let p00 = (string_drop s18790 s18800) in
  if (((p00 = ('''')))) then Some (rsd, rs2) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s18710  :: " string "


\<comment> \<open>\<open>val _s1858_ : string -> maybe ((mword ty3 * mword ty3))\<close>\<close>

definition s1858  :: \<open> string \<Rightarrow>((3)Word.word*(3)Word.word)option \<close>  where 
     \<open> s1858 s18590 = (
   (let s18600 = s18590 in
   if ((string_startswith s18600 (''c.xor''))) then  
  (case  ((string_drop s18600 ((string_length (''c.xor''))))) of
        s18610 =>
  (case  ((spc_matches_prefix0 s18610)) of
        Some ((_, s18620)) =>
  (case  ((string_drop s18610 s18620)) of
        s18630 =>
  (case  ((creg_name_matches_prefix s18630 :: (( 3 Word.word * ii)) option)) of
        Some ((rsd, s18640)) =>
  (case  ((string_drop s18630 s18640)) of
        s18650 =>
  (case  ((sep_matches_prefix s18650)) of
        Some ((_, s18660)) =>
  (case  ((string_drop s18650 s18660)) of
        s18670 =>
  (case  ((creg_name_matches_prefix s18670 :: (( 3 Word.word * ii)) option)) of
        Some ((rs2, s18680)) =>
  (let p00 = (string_drop s18670 s18680) in
  if (((p00 = ('''')))) then Some (rsd, rs2) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s18590  :: " string "


\<comment> \<open>\<open>val _s1846_ : string -> maybe ((mword ty3 * mword ty3))\<close>\<close>

definition s1846  :: \<open> string \<Rightarrow>((3)Word.word*(3)Word.word)option \<close>  where 
     \<open> s1846 s18470 = (
   (let s18480 = s18470 in
   if ((string_startswith s18480 (''c.sub''))) then  
  (case  ((string_drop s18480 ((string_length (''c.sub''))))) of
        s18490 =>
  (case  ((spc_matches_prefix0 s18490)) of
        Some ((_, s18500)) =>
  (case  ((string_drop s18490 s18500)) of
        s18510 =>
  (case  ((creg_name_matches_prefix s18510 :: (( 3 Word.word * ii)) option)) of
        Some ((rsd, s18520)) =>
  (case  ((string_drop s18510 s18520)) of
        s18530 =>
  (case  ((sep_matches_prefix s18530)) of
        Some ((_, s18540)) =>
  (case  ((string_drop s18530 s18540)) of
        s18550 =>
  (case  ((creg_name_matches_prefix s18550 :: (( 3 Word.word * ii)) option)) of
        Some ((rs2, s18560)) =>
  (let p00 = (string_drop s18550 s18560) in
  if (((p00 = ('''')))) then Some (rsd, rs2) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s18470  :: " string "


\<comment> \<open>\<open>val _s1834_ : string -> maybe ((mword ty3 * mword ty6))\<close>\<close>

definition s1834  :: \<open> string \<Rightarrow>((3)Word.word*(6)Word.word)option \<close>  where 
     \<open> s1834 s18350 = (
   (let s18360 = s18350 in
   if ((string_startswith s18360 (''c.andi''))) then  
  (case  ((string_drop s18360 ((string_length (''c.andi''))))) of
        s18370 =>
  (case  ((spc_matches_prefix0 s18370)) of
        Some ((_, s18380)) =>
  (case  ((string_drop s18370 s18380)) of
        s18390 =>
  (case  ((creg_name_matches_prefix s18390 :: (( 3 Word.word * ii)) option)) of
        Some ((rsd, s18400)) =>
  (case  ((string_drop s18390 s18400)) of
        s18410 =>
  (case  ((sep_matches_prefix s18410)) of
        Some ((_, s18420)) =>
  (case  ((string_drop s18410 s18420)) of
        s18430 =>
  (case  ((hex_bits_6_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s18430 :: (( 6 Word.word * ii)) option)) of
        Some ((imm, s18440)) =>
  (let p00 = (string_drop s18430 s18440) in
  if (((p00 = ('''')))) then Some (rsd, imm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s18350  :: " string "


\<comment> \<open>\<open>val _s1822_ : string -> maybe ((mword ty3 * mword ty6))\<close>\<close>

definition s1822  :: \<open> string \<Rightarrow>((3)Word.word*(6)Word.word)option \<close>  where 
     \<open> s1822 s18230 = (
   (let s18240 = s18230 in
   if ((string_startswith s18240 (''c.srai''))) then  
  (case  ((string_drop s18240 ((string_length (''c.srai''))))) of
        s18250 =>
  (case  ((spc_matches_prefix0 s18250)) of
        Some ((_, s18260)) =>
  (case  ((string_drop s18250 s18260)) of
        s18270 =>
  (case  ((creg_name_matches_prefix s18270 :: (( 3 Word.word * ii)) option)) of
        Some ((rsd, s18280)) =>
  (case  ((string_drop s18270 s18280)) of
        s18290 =>
  (case  ((sep_matches_prefix s18290)) of
        Some ((_, s18300)) =>
  (case  ((string_drop s18290 s18300)) of
        s18310 =>
  (case  ((hex_bits_6_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s18310 :: (( 6 Word.word * ii)) option)) of
        Some ((shamt, s18320)) =>
  (let p00 = (string_drop s18310 s18320) in
  if (((p00 = ('''')))) then Some (rsd, shamt) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s18230  :: " string "


\<comment> \<open>\<open>val _s1810_ : string -> maybe ((mword ty3 * mword ty6))\<close>\<close>

definition s1810  :: \<open> string \<Rightarrow>((3)Word.word*(6)Word.word)option \<close>  where 
     \<open> s1810 s18110 = (
   (let s18120 = s18110 in
   if ((string_startswith s18120 (''c.srli''))) then  
  (case  ((string_drop s18120 ((string_length (''c.srli''))))) of
        s18130 =>
  (case  ((spc_matches_prefix0 s18130)) of
        Some ((_, s18140)) =>
  (case  ((string_drop s18130 s18140)) of
        s18150 =>
  (case  ((creg_name_matches_prefix s18150 :: (( 3 Word.word * ii)) option)) of
        Some ((rsd, s18160)) =>
  (case  ((string_drop s18150 s18160)) of
        s18170 =>
  (case  ((sep_matches_prefix s18170)) of
        Some ((_, s18180)) =>
  (case  ((string_drop s18170 s18180)) of
        s18190 =>
  (case  ((hex_bits_6_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s18190 :: (( 6 Word.word * ii)) option)) of
        Some ((shamt, s18200)) =>
  (let p00 = (string_drop s18190 s18200) in
  if (((p00 = ('''')))) then Some (rsd, shamt) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s18110  :: " string "


\<comment> \<open>\<open>val _s1798_ : string -> maybe ((mword ty5 * mword ty6))\<close>\<close>

definition s1798  :: \<open> string \<Rightarrow>((5)Word.word*(6)Word.word)option \<close>  where 
     \<open> s1798 s17990 = (
   (let s18000 = s17990 in
   if ((string_startswith s18000 (''c.lui''))) then  
  (case  ((string_drop s18000 ((string_length (''c.lui''))))) of
        s18010 =>
  (case  ((spc_matches_prefix0 s18010)) of
        Some ((_, s18020)) =>
  (case  ((string_drop s18010 s18020)) of
        s18030 =>
  (case  ((reg_name_matches_prefix s18030 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s18040)) =>
  (case  ((string_drop s18030 s18040)) of
        s18050 =>
  (case  ((sep_matches_prefix s18050)) of
        Some ((_, s18060)) =>
  (case  ((string_drop s18050 s18060)) of
        s18070 =>
  (case  ((hex_bits_6_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s18070 :: (( 6 Word.word * ii)) option)) of
        Some ((imm, s18080)) =>
  (let p00 = (string_drop s18070 s18080) in
  if (((p00 = ('''')))) then Some (rd, imm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s17990  :: " string "


\<comment> \<open>\<open>val _s1790_ : string -> maybe (mword ty6)\<close>\<close>

definition s1790  :: \<open> string \<Rightarrow>((6)Word.word)option \<close>  where 
     \<open> s1790 s17910 = (
   (let s17920 = s17910 in
   if ((string_startswith s17920 (''c.addi16sp''))) then  
  (case  ((string_drop s17920 ((string_length (''c.addi16sp''))))) of
        s17930 =>
  (case  ((spc_matches_prefix0 s17930)) of
        Some ((_, s17940)) =>
  (case  ((string_drop s17930 s17940)) of
        s17950 =>
  (case  ((hex_bits_6_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s17950 :: (( 6 Word.word * ii)) option)) of
        Some ((imm, s17960)) =>
  (let p00 = (string_drop s17950 s17960) in
  if (((p00 = ('''')))) then Some imm else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s17910  :: " string "


\<comment> \<open>\<open>val _s1778_ : string -> maybe ((mword ty5 * mword ty6))\<close>\<close>

definition s1778  :: \<open> string \<Rightarrow>((5)Word.word*(6)Word.word)option \<close>  where 
     \<open> s1778 s17790 = (
   (let s17800 = s17790 in
   if ((string_startswith s17800 (''c.li''))) then  
  (case  ((string_drop s17800 ((string_length (''c.li''))))) of
        s17810 =>
  (case  ((spc_matches_prefix0 s17810)) of
        Some ((_, s17820)) =>
  (case  ((string_drop s17810 s17820)) of
        s17830 =>
  (case  ((reg_name_matches_prefix s17830 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s17840)) =>
  (case  ((string_drop s17830 s17840)) of
        s17850 =>
  (case  ((sep_matches_prefix s17850)) of
        Some ((_, s17860)) =>
  (case  ((string_drop s17850 s17860)) of
        s17870 =>
  (case  ((hex_bits_6_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s17870 :: (( 6 Word.word * ii)) option)) of
        Some ((imm, s17880)) =>
  (let p00 = (string_drop s17870 s17880) in
  if (((p00 = ('''')))) then Some (rd, imm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s17790  :: " string "


\<comment> \<open>\<open>val _s1766_ : string -> maybe ((mword ty5 * mword ty6))\<close>\<close>

definition s1766  :: \<open> string \<Rightarrow>((5)Word.word*(6)Word.word)option \<close>  where 
     \<open> s1766 s17670 = (
   (let s17680 = s17670 in
   if ((string_startswith s17680 (''c.addiw''))) then  
  (case  ((string_drop s17680 ((string_length (''c.addiw''))))) of
        s17690 =>
  (case  ((spc_matches_prefix0 s17690)) of
        Some ((_, s17700)) =>
  (case  ((string_drop s17690 s17700)) of
        s17710 =>
  (case  ((reg_name_matches_prefix s17710 :: (( 5 Word.word * ii)) option)) of
        Some ((rsd, s17720)) =>
  (case  ((string_drop s17710 s17720)) of
        s17730 =>
  (case  ((sep_matches_prefix s17730)) of
        Some ((_, s17740)) =>
  (case  ((string_drop s17730 s17740)) of
        s17750 =>
  (case  ((hex_bits_6_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s17750 :: (( 6 Word.word * ii)) option)) of
        Some ((imm, s17760)) =>
  (let p00 = (string_drop s17750 s17760) in
  if (((p00 = ('''')))) then Some (rsd, imm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s17670  :: " string "


\<comment> \<open>\<open>val _s1758_ : string -> maybe (mword ty11)\<close>\<close>

definition s1758  :: \<open> string \<Rightarrow>((11)Word.word)option \<close>  where 
     \<open> s1758 s17590 = (
   (let s17600 = s17590 in
   if ((string_startswith s17600 (''c.jal''))) then  
  (case  ((string_drop s17600 ((string_length (''c.jal''))))) of
        s17610 =>
  (case  ((spc_matches_prefix0 s17610)) of
        Some ((_, s17620)) =>
  (case  ((string_drop s17610 s17620)) of
        s17630 =>
  (case  ((hex_bits_12_matches_prefix0 s17630 :: (( 12 Word.word * ii)) option)) of
        Some ((v__1450, s17640)) =>
  if (((((subrange_vec_dec v__1450 (( 0 :: int):: ii) (( 0 :: int):: ii) :: 1 Word.word))
          = ( 0b0 :: 1 Word.word)))) then
    (let (imm :: 11 Word.word) = ((subrange_vec_dec v__1450
                                     (( 11 :: int):: ii) (( 1 :: int):: ii) :: 11 Word.word)) in
    (let (imm :: 11 Word.word) = ((subrange_vec_dec v__1450
                                     (( 11 :: int):: ii) (( 1 :: int):: ii) :: 11 Word.word)) in
    (let p00 = (string_drop s17630 s17640) in
    if (((p00 = ('''')))) then Some imm else None))) else None
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s17590  :: " string "


\<comment> \<open>\<open>val _s1746_ : string -> maybe ((mword ty5 * mword ty6))\<close>\<close>

definition s1746  :: \<open> string \<Rightarrow>((5)Word.word*(6)Word.word)option \<close>  where 
     \<open> s1746 s17470 = (
   (let s17480 = s17470 in
   if ((string_startswith s17480 (''c.addi''))) then  
  (case  ((string_drop s17480 ((string_length (''c.addi''))))) of
        s17490 =>
  (case  ((spc_matches_prefix0 s17490)) of
        Some ((_, s17500)) =>
  (case  ((string_drop s17490 s17500)) of
        s17510 =>
  (case  ((reg_name_matches_prefix s17510 :: (( 5 Word.word * ii)) option)) of
        Some ((rsd, s17520)) =>
  (case  ((string_drop s17510 s17520)) of
        s17530 =>
  (case  ((sep_matches_prefix s17530)) of
        Some ((_, s17540)) =>
  (case  ((string_drop s17530 s17540)) of
        s17550 =>
  (case  ((hex_bits_6_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s17550 :: (( 6 Word.word * ii)) option)) of
        Some ((nzi, s17560)) =>
  (let p00 = (string_drop s17550 s17560) in
  if (((p00 = ('''')))) then Some (rsd, nzi) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s17470  :: " string "


\<comment> \<open>\<open>val _s1730_ : string -> maybe ((mword ty3 * mword ty3 * mword ty5))\<close>\<close>

definition s1730  :: \<open> string \<Rightarrow>((3)Word.word*(3)Word.word*(5)Word.word)option \<close>  where 
     \<open> s1730 s17310 = (
   (let s17320 = s17310 in
   if ((string_startswith s17320 (''c.sd''))) then  
  (case  ((string_drop s17320 ((string_length (''c.sd''))))) of
        s17330 =>
  (case  ((spc_matches_prefix0 s17330)) of
        Some ((_, s17340)) =>
  (case  ((string_drop s17330 s17340)) of
        s17350 =>
  (case  ((creg_name_matches_prefix s17350 :: (( 3 Word.word * ii)) option)) of
        Some ((rsc1, s17360)) =>
  (case  ((string_drop s17350 s17360)) of
        s17370 =>
  (case  ((sep_matches_prefix s17370)) of
        Some ((_, s17380)) =>
  (case  ((string_drop s17370 s17380)) of
        s17390 =>
  (case  ((creg_name_matches_prefix s17390 :: (( 3 Word.word * ii)) option)) of
        Some ((rsc2, s17400)) =>
  (case  ((string_drop s17390 s17400)) of
        s17410 =>
  (case  ((sep_matches_prefix s17410)) of
        Some ((_, s17420)) =>
  (case  ((string_drop s17410 s17420)) of
        s17430 =>
  (case  ((hex_bits_8_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s17430 :: (( 8 Word.word * ii)) option)) of
        Some ((v__1452, s17440)) =>
  if (((((subrange_vec_dec v__1452 (( 2 :: int):: ii) (( 0 :: int):: ii)
         :: 3 Word.word)) = ( 0b000 :: 3 Word.word)))) then
    (let (uimm :: 5 Word.word) =
         ((subrange_vec_dec v__1452 (( 7 :: int):: ii) (( 3 :: int):: ii) :: 5 Word.word)) in
    (let (uimm :: 5 Word.word) =
         ((subrange_vec_dec v__1452 (( 7 :: int):: ii) (( 3 :: int):: ii) :: 5 Word.word)) in
    (let p00 = (string_drop s17430 s17440) in
    if (((p00 = ('''')))) then Some (rsc1, rsc2, uimm) else None))) else 
  None
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s17310  :: " string "


\<comment> \<open>\<open>val _s1714_ : string -> maybe ((mword ty3 * mword ty3 * mword ty5))\<close>\<close>

definition s1714  :: \<open> string \<Rightarrow>((3)Word.word*(3)Word.word*(5)Word.word)option \<close>  where 
     \<open> s1714 s17150 = (
   (let s17160 = s17150 in
   if ((string_startswith s17160 (''c.sw''))) then  
  (case  ((string_drop s17160 ((string_length (''c.sw''))))) of
        s17170 =>
  (case  ((spc_matches_prefix0 s17170)) of
        Some ((_, s17180)) =>
  (case  ((string_drop s17170 s17180)) of
        s17190 =>
  (case  ((creg_name_matches_prefix s17190 :: (( 3 Word.word * ii)) option)) of
        Some ((rsc1, s17200)) =>
  (case  ((string_drop s17190 s17200)) of
        s17210 =>
  (case  ((sep_matches_prefix s17210)) of
        Some ((_, s17220)) =>
  (case  ((string_drop s17210 s17220)) of
        s17230 =>
  (case  ((creg_name_matches_prefix s17230 :: (( 3 Word.word * ii)) option)) of
        Some ((rsc2, s17240)) =>
  (case  ((string_drop s17230 s17240)) of
        s17250 =>
  (case  ((sep_matches_prefix s17250)) of
        Some ((_, s17260)) =>
  (case  ((string_drop s17250 s17260)) of
        s17270 =>
  (case  ((hex_bits_7_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s17270 :: (( 7 Word.word * ii)) option)) of
        Some ((v__1454, s17280)) =>
  if (((((subrange_vec_dec v__1454 (( 1 :: int):: ii) (( 0 :: int):: ii)
         :: 2 Word.word)) = ( 0b00 :: 2 Word.word)))) then
    (let (uimm :: 5 Word.word) =
         ((subrange_vec_dec v__1454 (( 6 :: int):: ii) (( 2 :: int):: ii) :: 5 Word.word)) in
    (let (uimm :: 5 Word.word) =
         ((subrange_vec_dec v__1454 (( 6 :: int):: ii) (( 2 :: int):: ii) :: 5 Word.word)) in
    (let p00 = (string_drop s17270 s17280) in
    if (((p00 = ('''')))) then Some (rsc1, rsc2, uimm) else None))) else 
  None
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s17150  :: " string "


\<comment> \<open>\<open>val _s1698_ : string -> maybe ((mword ty3 * mword ty3 * mword ty5))\<close>\<close>

definition s1698  :: \<open> string \<Rightarrow>((3)Word.word*(3)Word.word*(5)Word.word)option \<close>  where 
     \<open> s1698 s16990 = (
   (let s17000 = s16990 in
   if ((string_startswith s17000 (''c.ld''))) then  
  (case  ((string_drop s17000 ((string_length (''c.ld''))))) of
        s17010 =>
  (case  ((spc_matches_prefix0 s17010)) of
        Some ((_, s17020)) =>
  (case  ((string_drop s17010 s17020)) of
        s17030 =>
  (case  ((creg_name_matches_prefix s17030 :: (( 3 Word.word * ii)) option)) of
        Some ((rdc, s17040)) =>
  (case  ((string_drop s17030 s17040)) of
        s17050 =>
  (case  ((sep_matches_prefix s17050)) of
        Some ((_, s17060)) =>
  (case  ((string_drop s17050 s17060)) of
        s17070 =>
  (case  ((creg_name_matches_prefix s17070 :: (( 3 Word.word * ii)) option)) of
        Some ((rsc, s17080)) =>
  (case  ((string_drop s17070 s17080)) of
        s17090 =>
  (case  ((sep_matches_prefix s17090)) of
        Some ((_, s17100)) =>
  (case  ((string_drop s17090 s17100)) of
        s17110 =>
  (case  ((hex_bits_8_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s17110 :: (( 8 Word.word * ii)) option)) of
        Some ((v__1456, s17120)) =>
  if (((((subrange_vec_dec v__1456 (( 2 :: int):: ii) (( 0 :: int):: ii)
         :: 3 Word.word)) = ( 0b000 :: 3 Word.word)))) then
    (let (uimm :: 5 Word.word) =
         ((subrange_vec_dec v__1456 (( 7 :: int):: ii) (( 3 :: int):: ii) :: 5 Word.word)) in
    (let (uimm :: 5 Word.word) =
         ((subrange_vec_dec v__1456 (( 7 :: int):: ii) (( 3 :: int):: ii) :: 5 Word.word)) in
    (let p00 = (string_drop s17110 s17120) in
    if (((p00 = ('''')))) then Some (rdc, rsc, uimm) else None))) else 
  None
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s16990  :: " string "


\<comment> \<open>\<open>val _s1682_ : string -> maybe ((mword ty3 * mword ty3 * mword ty5))\<close>\<close>

definition s1682  :: \<open> string \<Rightarrow>((3)Word.word*(3)Word.word*(5)Word.word)option \<close>  where 
     \<open> s1682 s16830 = (
   (let s16840 = s16830 in
   if ((string_startswith s16840 (''c.lw''))) then  
  (case  ((string_drop s16840 ((string_length (''c.lw''))))) of
        s16850 =>
  (case  ((spc_matches_prefix0 s16850)) of
        Some ((_, s16860)) =>
  (case  ((string_drop s16850 s16860)) of
        s16870 =>
  (case  ((creg_name_matches_prefix s16870 :: (( 3 Word.word * ii)) option)) of
        Some ((rdc, s16880)) =>
  (case  ((string_drop s16870 s16880)) of
        s16890 =>
  (case  ((sep_matches_prefix s16890)) of
        Some ((_, s16900)) =>
  (case  ((string_drop s16890 s16900)) of
        s16910 =>
  (case  ((creg_name_matches_prefix s16910 :: (( 3 Word.word * ii)) option)) of
        Some ((rsc, s16920)) =>
  (case  ((string_drop s16910 s16920)) of
        s16930 =>
  (case  ((sep_matches_prefix s16930)) of
        Some ((_, s16940)) =>
  (case  ((string_drop s16930 s16940)) of
        s16950 =>
  (case  ((hex_bits_7_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s16950 :: (( 7 Word.word * ii)) option)) of
        Some ((v__1458, s16960)) =>
  if (((((subrange_vec_dec v__1458 (( 1 :: int):: ii) (( 0 :: int):: ii)
         :: 2 Word.word)) = ( 0b00 :: 2 Word.word)))) then
    (let (uimm :: 5 Word.word) =
         ((subrange_vec_dec v__1458 (( 6 :: int):: ii) (( 2 :: int):: ii) :: 5 Word.word)) in
    (let (uimm :: 5 Word.word) =
         ((subrange_vec_dec v__1458 (( 6 :: int):: ii) (( 2 :: int):: ii) :: 5 Word.word)) in
    (let p00 = (string_drop s16950 s16960) in
    if (((p00 = ('''')))) then Some (rdc, rsc, uimm) else None))) else 
  None
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s16830  :: " string "


\<comment> \<open>\<open>val _s1670_ : string -> maybe ((mword ty3 * mword ty8))\<close>\<close>

definition s1670  :: \<open> string \<Rightarrow>((3)Word.word*(8)Word.word)option \<close>  where 
     \<open> s1670 s16710 = (
   (let s16720 = s16710 in
   if ((string_startswith s16720 (''c.addi4spn''))) then  
  (case  ((string_drop s16720 ((string_length (''c.addi4spn''))))) of
        s16730 =>
  (case  ((spc_matches_prefix0 s16730)) of
        Some ((_, s16740)) =>
  (case  ((string_drop s16730 s16740)) of
        s16750 =>
  (case  ((creg_name_matches_prefix s16750 :: (( 3 Word.word * ii)) option)) of
        Some ((rdc, s16760)) =>
  (case  ((string_drop s16750 s16760)) of
        s16770 =>
  (case  ((sep_matches_prefix s16770)) of
        Some ((_, s16780)) =>
  (case  ((string_drop s16770 s16780)) of
        s16790 =>
  (case  ((hex_bits_10_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s16790 :: (( 10 Word.word * ii)) option)) of
        Some ((v__1460, s16800)) =>
  if (((((subrange_vec_dec v__1460 (( 1 :: int):: ii) (( 0 :: int):: ii) :: 2 Word.word))
          = ( 0b00 :: 2 Word.word)))) then
    (let (nzimm :: 8 Word.word) =
         ((subrange_vec_dec v__1460 (( 9 :: int):: ii) (( 2 :: int):: ii) :: 8 Word.word)) in
    (let (nzimm :: 8 Word.word) =
         ((subrange_vec_dec v__1460 (( 9 :: int):: ii) (( 2 :: int):: ii) :: 8 Word.word)) in
    (let p00 = (string_drop s16790 s16800) in
    if (((p00 = ('''')))) then Some (rdc, nzimm) else None))) else None
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s16710  :: " string "


\<comment> \<open>\<open>val _s1644_ : string -> maybe ((amoop * word_width * bool * bool * mword ty5 * mword ty5 * mword ty5))\<close>\<close>

definition s1644  :: \<open> string \<Rightarrow>(amoop*word_width*bool*bool*(5)Word.word*(5)Word.word*(5)Word.word)option \<close>  where 
     \<open> s1644 s16460 = (
      (case  ((amo_mnemonic_matches_prefix s16460)) of
        Some ((op1, s16470)) =>
         (let s16480 = (string_drop s16460 s16470) in
         if ((string_startswith s16480 (''.''))) then  
  (case  ((string_drop s16480 ((string_length (''.''))))) of
        s16490 =>
  (case  ((size_mnemonic_matches_prefix s16490)) of
        Some ((width, s16500)) =>
  (case  ((string_drop s16490 s16500)) of
        s16510 =>
  (case  ((maybe_aq_matches_prefix s16510)) of
        Some ((aq, s16520)) =>
  (case  ((string_drop s16510 s16520)) of
        s16530 =>
  (case  ((maybe_rl_matches_prefix s16530)) of
        Some ((rl, s16540)) =>
  (case  ((string_drop s16530 s16540)) of
        s16550 =>
  (case  ((spc_matches_prefix0 s16550)) of
        Some ((_, s16560)) =>
  (case  ((string_drop s16550 s16560)) of
        s16570 =>
  (case  ((reg_name_matches_prefix s16570 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s16580)) =>
  (case  ((string_drop s16570 s16580)) of
        s16590 =>
  (case  ((sep_matches_prefix s16590)) of
        Some ((_, s16600)) =>
  (case  ((string_drop s16590 s16600)) of
        s16610 =>
  (case  ((reg_name_matches_prefix s16610 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s16620)) =>
  (case  ((string_drop s16610 s16620)) of
        s16630 =>
  (case  ((sep_matches_prefix s16630)) of
        Some ((_, s16640)) =>
  (let s16650 = (string_drop s16630 s16640) in
  if ((string_startswith s16650 (''(''))) then
    (case  ((string_drop s16650 ((string_length (''(''))))) of
          s16660 =>
    (case  ((reg_name_matches_prefix s16660 :: (( 5 Word.word * ii)) option)) of
          Some ((rs1, s16670)) =>
    (let s16680 = (string_drop s16660 s16670) in
    if ((string_startswith s16680 ('')''))) then
      (let p00 = (string_drop s16680 ((string_length ('')'')))) in
      if (((p00 = ('''')))) then Some (op1, width, aq, rl, rd, rs2, rs1) else
        None) else None)
      | _ => None
    )
    ) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
         else None)
      | _ => None
      ))\<close> 
  for  s16460  :: " string "


\<comment> \<open>\<open>val _s1622_ : string -> maybe ((word_width * bool * bool * mword ty5 * mword ty5 * mword ty5))\<close>\<close>

definition s1622  :: \<open> string \<Rightarrow>(word_width*bool*bool*(5)Word.word*(5)Word.word*(5)Word.word)option \<close>  where 
     \<open> s1622 s16230 = (
   (let s16240 = s16230 in
   if ((string_startswith s16240 (''sc.''))) then  
  (case  ((string_drop s16240 ((string_length (''sc.''))))) of
        s16250 =>
  (case  ((size_mnemonic_matches_prefix s16250)) of
        Some ((size1, s16260)) =>
  (case  ((string_drop s16250 s16260)) of
        s16270 =>
  (case  ((maybe_aq_matches_prefix s16270)) of
        Some ((aq, s16280)) =>
  (case  ((string_drop s16270 s16280)) of
        s16290 =>
  (case  ((maybe_rl_matches_prefix s16290)) of
        Some ((rl, s16300)) =>
  (case  ((string_drop s16290 s16300)) of
        s16310 =>
  (case  ((spc_matches_prefix0 s16310)) of
        Some ((_, s16320)) =>
  (case  ((string_drop s16310 s16320)) of
        s16330 =>
  (case  ((reg_name_matches_prefix s16330 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s16340)) =>
  (case  ((string_drop s16330 s16340)) of
        s16350 =>
  (case  ((sep_matches_prefix s16350)) of
        Some ((_, s16360)) =>
  (case  ((string_drop s16350 s16360)) of
        s16370 =>
  (case  ((reg_name_matches_prefix s16370 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s16380)) =>
  (case  ((string_drop s16370 s16380)) of
        s16390 =>
  (case  ((sep_matches_prefix s16390)) of
        Some ((_, s16400)) =>
  (case  ((string_drop s16390 s16400)) of
        s16410 =>
  (case  ((reg_name_matches_prefix s16410 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s16420)) =>
  (let p00 = (string_drop s16410 s16420) in
  if (((p00 = ('''')))) then Some (size1, aq, rl, rd, rs1, rs2) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s16230  :: " string "


\<comment> \<open>\<open>val _s1604_ : string -> maybe ((word_width * bool * bool * mword ty5 * mword ty5))\<close>\<close>

definition s1604  :: \<open> string \<Rightarrow>(word_width*bool*bool*(5)Word.word*(5)Word.word)option \<close>  where 
     \<open> s1604 s16050 = (
   (let s16060 = s16050 in
   if ((string_startswith s16060 (''lr.''))) then  
  (case  ((string_drop s16060 ((string_length (''lr.''))))) of
        s16070 =>
  (case  ((size_mnemonic_matches_prefix s16070)) of
        Some ((size1, s16080)) =>
  (case  ((string_drop s16070 s16080)) of
        s16090 =>
  (case  ((maybe_aq_matches_prefix s16090)) of
        Some ((aq, s16100)) =>
  (case  ((string_drop s16090 s16100)) of
        s16110 =>
  (case  ((maybe_rl_matches_prefix s16110)) of
        Some ((rl, s16120)) =>
  (case  ((string_drop s16110 s16120)) of
        s16130 =>
  (case  ((spc_matches_prefix0 s16130)) of
        Some ((_, s16140)) =>
  (case  ((string_drop s16130 s16140)) of
        s16150 =>
  (case  ((reg_name_matches_prefix s16150 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s16160)) =>
  (case  ((string_drop s16150 s16160)) of
        s16170 =>
  (case  ((sep_matches_prefix s16170)) of
        Some ((_, s16180)) =>
  (case  ((string_drop s16170 s16180)) of
        s16190 =>
  (case  ((reg_name_matches_prefix s16190 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s16200)) =>
  (let p00 = (string_drop s16190 s16200) in
  if (((p00 = ('''')))) then Some (size1, aq, rl, rd, rs1) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s16050  :: " string "


\<comment> \<open>\<open>val _s1592_ : string -> maybe ((mword ty5 * mword ty5))\<close>\<close>

definition s1592  :: \<open> string \<Rightarrow>((5)Word.word*(5)Word.word)option \<close>  where 
     \<open> s1592 s15930 = (
   (let s15940 = s15930 in
   if ((string_startswith s15940 (''sfence.vma''))) then  
  (case  ((string_drop s15940 ((string_length (''sfence.vma''))))) of
        s15950 =>
  (case  ((spc_matches_prefix0 s15950)) of
        Some ((_, s15960)) =>
  (case  ((string_drop s15950 s15960)) of
        s15970 =>
  (case  ((reg_name_matches_prefix s15970 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s15980)) =>
  (case  ((string_drop s15970 s15980)) of
        s15990 =>
  (case  ((sep_matches_prefix s15990)) of
        Some ((_, s16000)) =>
  (case  ((string_drop s15990 s16000)) of
        s16010 =>
  (case  ((reg_name_matches_prefix s16010 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s16020)) =>
  (let p00 = (string_drop s16010 s16020) in
  if (((p00 = ('''')))) then Some (rs1, rs2) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s15930  :: " string "


\<comment> \<open>\<open>val _s1580_ : string -> maybe ((mword ty4 * mword ty4))\<close>\<close>

definition s1580  :: \<open> string \<Rightarrow>((4)Word.word*(4)Word.word)option \<close>  where 
     \<open> s1580 s15810 = (
   (let s15820 = s15810 in
   if ((string_startswith s15820 (''fence.tso''))) then  
  (case  ((string_drop s15820 ((string_length (''fence.tso''))))) of
        s15830 =>
  (case  ((spc_matches_prefix0 s15830)) of
        Some ((_, s15840)) =>
  (case  ((string_drop s15830 s15840)) of
        s15850 =>
  (case  ((fence_bits_matches_prefix s15850 :: (( 4 Word.word * ii)) option)) of
        Some ((pred, s15860)) =>
  (case  ((string_drop s15850 s15860)) of
        s15870 =>
  (case  ((sep_matches_prefix s15870)) of
        Some ((_, s15880)) =>
  (case  ((string_drop s15870 s15880)) of
        s15890 =>
  (case  ((fence_bits_matches_prefix s15890 :: (( 4 Word.word * ii)) option)) of
        Some ((succ, s15900)) =>
  (let p00 = (string_drop s15890 s15900) in
  if (((p00 = ('''')))) then Some (pred, succ) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s15810  :: " string "


\<comment> \<open>\<open>val _s1568_ : string -> maybe ((mword ty4 * mword ty4))\<close>\<close>

definition s1568  :: \<open> string \<Rightarrow>((4)Word.word*(4)Word.word)option \<close>  where 
     \<open> s1568 s15690 = (
   (let s15700 = s15690 in
   if ((string_startswith s15700 (''fence''))) then  
  (case  ((string_drop s15700 ((string_length (''fence''))))) of
        s15710 =>
  (case  ((spc_matches_prefix0 s15710)) of
        Some ((_, s15720)) =>
  (case  ((string_drop s15710 s15720)) of
        s15730 =>
  (case  ((fence_bits_matches_prefix s15730 :: (( 4 Word.word * ii)) option)) of
        Some ((pred, s15740)) =>
  (case  ((string_drop s15730 s15740)) of
        s15750 =>
  (case  ((sep_matches_prefix s15750)) of
        Some ((_, s15760)) =>
  (case  ((string_drop s15750 s15760)) of
        s15770 =>
  (case  ((fence_bits_matches_prefix s15770 :: (( 4 Word.word * ii)) option)) of
        Some ((succ, s15780)) =>
  (let p00 = (string_drop s15770 s15780) in
  if (((p00 = ('''')))) then Some (pred, succ) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s15690  :: " string "


\<comment> \<open>\<open>val _s1551_ : string -> maybe ((sopw * mword ty5 * mword ty5 * mword ty5))\<close>\<close>

definition s1551  :: \<open> string \<Rightarrow>(sopw*(5)Word.word*(5)Word.word*(5)Word.word)option \<close>  where 
     \<open> s1551 s15530 = (
      (case  ((shiftiwop_mnemonic_matches_prefix s15530)) of
        Some ((op1, s15540)) => 
  (case  ((string_drop s15530 s15540)) of
        s15550 =>
  (case  ((spc_matches_prefix0 s15550)) of
        Some ((_, s15560)) =>
  (case  ((string_drop s15550 s15560)) of
        s15570 =>
  (case  ((reg_name_matches_prefix s15570 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s15580)) =>
  (case  ((string_drop s15570 s15580)) of
        s15590 =>
  (case  ((sep_matches_prefix s15590)) of
        Some ((_, s15600)) =>
  (case  ((string_drop s15590 s15600)) of
        s15610 =>
  (case  ((reg_name_matches_prefix s15610 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s15620)) =>
  (case  ((string_drop s15610 s15620)) of
        s15630 =>
  (case  ((sep_matches_prefix s15630)) of
        Some ((_, s15640)) =>
  (case  ((string_drop s15630 s15640)) of
        s15650 =>
  (case  ((hex_bits_5_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s15650 :: (( 5 Word.word * ii)) option)) of
        Some ((shamt, s15660)) =>
  (let p00 = (string_drop s15650 s15660) in
  if (((p00 = ('''')))) then Some (op1, rd, rs1, shamt) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s15530  :: " string "


\<comment> \<open>\<open>val _s1534_ : string -> maybe ((ropw * mword ty5 * mword ty5 * mword ty5))\<close>\<close>

definition s1534  :: \<open> string \<Rightarrow>(ropw*(5)Word.word*(5)Word.word*(5)Word.word)option \<close>  where 
     \<open> s1534 s15360 = (
      (case  ((rtypew_mnemonic_matches_prefix s15360)) of
        Some ((op1, s15370)) => 
  (case  ((string_drop s15360 s15370)) of
        s15380 =>
  (case  ((spc_matches_prefix0 s15380)) of
        Some ((_, s15390)) =>
  (case  ((string_drop s15380 s15390)) of
        s15400 =>
  (case  ((reg_name_matches_prefix s15400 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s15410)) =>
  (case  ((string_drop s15400 s15410)) of
        s15420 =>
  (case  ((sep_matches_prefix s15420)) of
        Some ((_, s15430)) =>
  (case  ((string_drop s15420 s15430)) of
        s15440 =>
  (case  ((reg_name_matches_prefix s15440 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s15450)) =>
  (case  ((string_drop s15440 s15450)) of
        s15460 =>
  (case  ((sep_matches_prefix s15460)) of
        Some ((_, s15470)) =>
  (case  ((string_drop s15460 s15470)) of
        s15480 =>
  (case  ((reg_name_matches_prefix s15480 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s15490)) =>
  (let p00 = (string_drop s15480 s15490) in
  if (((p00 = ('''')))) then Some (op1, rd, rs1, rs2) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s15360  :: " string "


\<comment> \<open>\<open>val _s1517_ : string -> maybe ((sop * mword ty5 * mword ty5 * mword ty5))\<close>\<close>

definition s1517  :: \<open> string \<Rightarrow>(sop*(5)Word.word*(5)Word.word*(5)Word.word)option \<close>  where 
     \<open> s1517 s15190 = (
      (case  ((shiftw_mnemonic_matches_prefix s15190)) of
        Some ((op1, s15200)) => 
  (case  ((string_drop s15190 s15200)) of
        s15210 =>
  (case  ((spc_matches_prefix0 s15210)) of
        Some ((_, s15220)) =>
  (case  ((string_drop s15210 s15220)) of
        s15230 =>
  (case  ((reg_name_matches_prefix s15230 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s15240)) =>
  (case  ((string_drop s15230 s15240)) of
        s15250 =>
  (case  ((sep_matches_prefix s15250)) of
        Some ((_, s15260)) =>
  (case  ((string_drop s15250 s15260)) of
        s15270 =>
  (case  ((reg_name_matches_prefix s15270 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s15280)) =>
  (case  ((string_drop s15270 s15280)) of
        s15290 =>
  (case  ((sep_matches_prefix s15290)) of
        Some ((_, s15300)) =>
  (case  ((string_drop s15290 s15300)) of
        s15310 =>
  (case  ((hex_bits_5_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s15310 :: (( 5 Word.word * ii)) option)) of
        Some ((shamt, s15320)) =>
  (let p00 = (string_drop s15310 s15320) in
  if (((p00 = ('''')))) then Some (op1, rd, rs1, shamt) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s15190  :: " string "


\<comment> \<open>\<open>val _s1501_ : string -> maybe ((mword ty5 * mword ty5 * mword ty12))\<close>\<close>

definition s1501  :: \<open> string \<Rightarrow>((5)Word.word*(5)Word.word*(12)Word.word)option \<close>  where 
     \<open> s1501 s15020 = (
   (let s15030 = s15020 in
   if ((string_startswith s15030 (''addiw''))) then  
  (case  ((string_drop s15030 ((string_length (''addiw''))))) of
        s15040 =>
  (case  ((spc_matches_prefix0 s15040)) of
        Some ((_, s15050)) =>
  (case  ((string_drop s15040 s15050)) of
        s15060 =>
  (case  ((reg_name_matches_prefix s15060 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s15070)) =>
  (case  ((string_drop s15060 s15070)) of
        s15080 =>
  (case  ((sep_matches_prefix s15080)) of
        Some ((_, s15090)) =>
  (case  ((string_drop s15080 s15090)) of
        s15100 =>
  (case  ((reg_name_matches_prefix s15100 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s15110)) =>
  (case  ((string_drop s15100 s15110)) of
        s15120 =>
  (case  ((sep_matches_prefix s15120)) of
        Some ((_, s15130)) =>
  (case  ((string_drop s15120 s15130)) of
        s15140 =>
  (case  ((hex_bits_12_matches_prefix0 s15140
          :: (( 12 Word.word * ii)) option)) of
        Some ((imm, s15150)) =>
  (let p00 = (string_drop s15140 s15150) in
  if (((p00 = ('''')))) then Some (rd, rs1, imm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s15020  :: " string "


\<comment> \<open>\<open>val _s1473_ : string -> maybe ((word_width * bool * bool * mword ty5 * mword ty12 * mword ty5))\<close>\<close>

definition s1473  :: \<open> string \<Rightarrow>(word_width*bool*bool*(5)Word.word*(12)Word.word*(5)Word.word)option \<close>  where 
     \<open> s1473 s14740 = (
   (let s14750 = s14740 in
   if ((string_startswith s14750 (''s''))) then  
  (case  ((string_drop s14750 ((string_length (''s''))))) of
        s14760 =>
  (case  ((size_mnemonic_matches_prefix s14760)) of
        Some ((size1, s14770)) =>
  (case  ((string_drop s14760 s14770)) of
        s14780 =>
  (case  ((maybe_aq_matches_prefix s14780)) of
        Some ((aq, s14790)) =>
  (case  ((string_drop s14780 s14790)) of
        s14800 =>
  (case  ((maybe_rl_matches_prefix s14800)) of
        Some ((rl, s14810)) =>
  (case  ((string_drop s14800 s14810)) of
        s14820 =>
  (case  ((spc_matches_prefix0 s14820)) of
        Some ((_, s14830)) =>
  (case  ((string_drop s14820 s14830)) of
        s14840 =>
  (case  ((reg_name_matches_prefix s14840 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s14850)) =>
  (case  ((string_drop s14840 s14850)) of
        s14860 =>
  (case  ((sep_matches_prefix s14860)) of
        Some ((_, s14870)) =>
  (case  ((string_drop s14860 s14870)) of
        s14880 =>
  (case  ((hex_bits_12_matches_prefix0 s14880
          :: (( 12 Word.word * ii)) option)) of
        Some ((imm, s14890)) =>
  (case  ((string_drop s14880 s14890)) of
        s14900 =>
  (case  ((opt_spc_matches_prefix0 s14900)) of
        Some ((_, s14910)) =>
  (let s14920 = (string_drop s14900 s14910) in
  if ((string_startswith s14920 (''(''))) then
    (case  ((string_drop s14920 ((string_length (''(''))))) of
          s14930 =>
    (case  ((opt_spc_matches_prefix0 s14930)) of
          Some ((_, s14940)) =>
    (case  ((string_drop s14930 s14940)) of
          s14950 =>
    (case  ((reg_name_matches_prefix s14950 :: (( 5 Word.word * ii)) option)) of
          Some ((rs1, s14960)) =>
    (case  ((string_drop s14950 s14960)) of
          s14970 =>
    (case  ((opt_spc_matches_prefix0 s14970)) of
          Some ((_, s14980)) =>
    (let s14990 = (string_drop s14970 s14980) in
    if ((string_startswith s14990 ('')''))) then
      (let p00 = (string_drop s14990 ((string_length ('')'')))) in
      if (((p00 = ('''')))) then Some (size1, aq, rl, rs2, imm, rs1) else
        None) else None)
      | _ => None
    )
    )
      | _ => None
    )
    )
      | _ => None
    )
    ) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s14740  :: " string "


\<comment> \<open>\<open>val _s1443_ : string -> maybe ((word_width * bool * bool * bool * mword ty5 * mword ty12 * mword ty5))\<close>\<close>

definition s1443  :: \<open> string \<Rightarrow>(word_width*bool*bool*bool*(5)Word.word*(12)Word.word*(5)Word.word)option \<close>  where 
     \<open> s1443 s14440 = (
   (let s14450 = s14440 in
   if ((string_startswith s14450 (''l''))) then  
  (case  ((string_drop s14450 ((string_length (''l''))))) of
        s14460 =>
  (case  ((size_mnemonic_matches_prefix s14460)) of
        Some ((size1, s14470)) =>
  (case  ((string_drop s14460 s14470)) of
        s14480 =>
  (case  ((maybe_u_matches_prefix s14480)) of
        Some ((is_unsigned, s14490)) =>
  (case  ((string_drop s14480 s14490)) of
        s14500 =>
  (case  ((maybe_aq_matches_prefix s14500)) of
        Some ((aq, s14510)) =>
  (case  ((string_drop s14500 s14510)) of
        s14520 =>
  (case  ((maybe_rl_matches_prefix s14520)) of
        Some ((rl, s14530)) =>
  (case  ((string_drop s14520 s14530)) of
        s14540 =>
  (case  ((spc_matches_prefix0 s14540)) of
        Some ((_, s14550)) =>
  (case  ((string_drop s14540 s14550)) of
        s14560 =>
  (case  ((reg_name_matches_prefix s14560 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s14570)) =>
  (case  ((string_drop s14560 s14570)) of
        s14580 =>
  (case  ((sep_matches_prefix s14580)) of
        Some ((_, s14590)) =>
  (case  ((string_drop s14580 s14590)) of
        s14600 =>
  (case  ((hex_bits_12_matches_prefix0 s14600
          :: (( 12 Word.word * ii)) option)) of
        Some ((imm, s14610)) =>
  (case  ((string_drop s14600 s14610)) of
        s14620 =>
  (case  ((opt_spc_matches_prefix0 s14620)) of
        Some ((_, s14630)) =>
  (let s14640 = (string_drop s14620 s14630) in
  if ((string_startswith s14640 (''(''))) then
    (case  ((string_drop s14640 ((string_length (''(''))))) of
          s14650 =>
    (case  ((opt_spc_matches_prefix0 s14650)) of
          Some ((_, s14660)) =>
    (case  ((string_drop s14650 s14660)) of
          s14670 =>
    (case  ((reg_name_matches_prefix s14670 :: (( 5 Word.word * ii)) option)) of
          Some ((rs1, s14680)) =>
    (case  ((string_drop s14670 s14680)) of
          s14690 =>
    (case  ((opt_spc_matches_prefix0 s14690)) of
          Some ((_, s14700)) =>
    (let s14710 = (string_drop s14690 s14700) in
    if ((string_startswith s14710 ('')''))) then
      (let p00 = (string_drop s14710 ((string_length ('')'')))) in
      if (((p00 = ('''')))) then
        Some (size1, is_unsigned, aq, rl, rd, imm, rs1) else None) else 
    None)
      | _ => None
    )
    )
      | _ => None
    )
    )
      | _ => None
    )
    ) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s14440  :: " string "


\<comment> \<open>\<open>val _s1426_ : string -> maybe ((rop * mword ty5 * mword ty5 * mword ty5))\<close>\<close>

definition s1426  :: \<open> string \<Rightarrow>(rop*(5)Word.word*(5)Word.word*(5)Word.word)option \<close>  where 
     \<open> s1426 s14280 = (
      (case  ((rtype_mnemonic_matches_prefix s14280)) of
        Some ((op1, s14290)) => 
  (case  ((string_drop s14280 s14290)) of
        s14300 =>
  (case  ((spc_matches_prefix0 s14300)) of
        Some ((_, s14310)) =>
  (case  ((string_drop s14300 s14310)) of
        s14320 =>
  (case  ((reg_name_matches_prefix s14320 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s14330)) =>
  (case  ((string_drop s14320 s14330)) of
        s14340 =>
  (case  ((sep_matches_prefix s14340)) of
        Some ((_, s14350)) =>
  (case  ((string_drop s14340 s14350)) of
        s14360 =>
  (case  ((reg_name_matches_prefix s14360 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s14370)) =>
  (case  ((string_drop s14360 s14370)) of
        s14380 =>
  (case  ((sep_matches_prefix s14380)) of
        Some ((_, s14390)) =>
  (case  ((string_drop s14380 s14390)) of
        s14400 =>
  (case  ((reg_name_matches_prefix s14400 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s14410)) =>
  (let p00 = (string_drop s14400 s14410) in
  if (((p00 = ('''')))) then Some (op1, rd, rs1, rs2) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s14280  :: " string "


\<comment> \<open>\<open>val _s1409_ : string -> maybe ((sop * mword ty5 * mword ty5 * mword ty6))\<close>\<close>

definition s1409  :: \<open> string \<Rightarrow>(sop*(5)Word.word*(5)Word.word*(6)Word.word)option \<close>  where 
     \<open> s1409 s14110 = (
      (case  ((shiftiop_mnemonic_matches_prefix s14110)) of
        Some ((op1, s14120)) => 
  (case  ((string_drop s14110 s14120)) of
        s14130 =>
  (case  ((spc_matches_prefix0 s14130)) of
        Some ((_, s14140)) =>
  (case  ((string_drop s14130 s14140)) of
        s14150 =>
  (case  ((reg_name_matches_prefix s14150 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s14160)) =>
  (case  ((string_drop s14150 s14160)) of
        s14170 =>
  (case  ((sep_matches_prefix s14170)) of
        Some ((_, s14180)) =>
  (case  ((string_drop s14170 s14180)) of
        s14190 =>
  (case  ((reg_name_matches_prefix s14190 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s14200)) =>
  (case  ((string_drop s14190 s14200)) of
        s14210 =>
  (case  ((sep_matches_prefix s14210)) of
        Some ((_, s14220)) =>
  (case  ((string_drop s14210 s14220)) of
        s14230 =>
  (case  ((hex_bits_6_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s14230 :: (( 6 Word.word * ii)) option)) of
        Some ((shamt, s14240)) =>
  (let p00 = (string_drop s14230 s14240) in
  if (((p00 = ('''')))) then Some (op1, rd, rs1, shamt) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s14110  :: " string "


\<comment> \<open>\<open>val _s1392_ : string -> maybe ((iop * mword ty5 * mword ty5 * mword ty12))\<close>\<close>

definition s1392  :: \<open> string \<Rightarrow>(iop*(5)Word.word*(5)Word.word*(12)Word.word)option \<close>  where 
     \<open> s1392 s13940 = (
      (case  ((itype_mnemonic_matches_prefix s13940)) of
        Some ((op1, s13950)) => 
  (case  ((string_drop s13940 s13950)) of
        s13960 =>
  (case  ((spc_matches_prefix0 s13960)) of
        Some ((_, s13970)) =>
  (case  ((string_drop s13960 s13970)) of
        s13980 =>
  (case  ((reg_name_matches_prefix s13980 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s13990)) =>
  (case  ((string_drop s13980 s13990)) of
        s14000 =>
  (case  ((sep_matches_prefix s14000)) of
        Some ((_, s14010)) =>
  (case  ((string_drop s14000 s14010)) of
        s14020 =>
  (case  ((reg_name_matches_prefix s14020 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s14030)) =>
  (case  ((string_drop s14020 s14030)) of
        s14040 =>
  (case  ((sep_matches_prefix s14040)) of
        Some ((_, s14050)) =>
  (case  ((string_drop s14040 s14050)) of
        s14060 =>
  (case  ((hex_bits_12_matches_prefix0 s14060
          :: (( 12 Word.word * ii)) option)) of
        Some ((imm, s14070)) =>
  (let p00 = (string_drop s14060 s14070) in
  if (((p00 = ('''')))) then Some (op1, rd, rs1, imm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s13940  :: " string "


\<comment> \<open>\<open>val _s1375_ : string -> maybe ((bop * mword ty5 * mword ty5 * mword ty13))\<close>\<close>

definition s1375  :: \<open> string \<Rightarrow>(bop*(5)Word.word*(5)Word.word*(13)Word.word)option \<close>  where 
     \<open> s1375 s13770 = (
      (case  ((btype_mnemonic_matches_prefix s13770)) of
        Some ((op1, s13780)) => 
  (case  ((string_drop s13770 s13780)) of
        s13790 =>
  (case  ((spc_matches_prefix0 s13790)) of
        Some ((_, s13800)) =>
  (case  ((string_drop s13790 s13800)) of
        s13810 =>
  (case  ((reg_name_matches_prefix s13810 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s13820)) =>
  (case  ((string_drop s13810 s13820)) of
        s13830 =>
  (case  ((sep_matches_prefix s13830)) of
        Some ((_, s13840)) =>
  (case  ((string_drop s13830 s13840)) of
        s13850 =>
  (case  ((reg_name_matches_prefix s13850 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s13860)) =>
  (case  ((string_drop s13850 s13860)) of
        s13870 =>
  (case  ((sep_matches_prefix s13870)) of
        Some ((_, s13880)) =>
  (case  ((string_drop s13870 s13880)) of
        s13890 =>
  (case  ((hex_bits_13_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s13890 :: (( 13 Word.word * ii)) option)) of
        Some ((imm, s13900)) =>
  (let p00 = (string_drop s13890 s13900) in
  if (((p00 = ('''')))) then Some (op1, rs1, rs2, imm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s13770  :: " string "


\<comment> \<open>\<open>val _s1359_ : string -> maybe ((mword ty5 * mword ty5 * mword ty12))\<close>\<close>

definition s1359  :: \<open> string \<Rightarrow>((5)Word.word*(5)Word.word*(12)Word.word)option \<close>  where 
     \<open> s1359 s13600 = (
   (let s13610 = s13600 in
   if ((string_startswith s13610 (''jalr''))) then  
  (case  ((string_drop s13610 ((string_length (''jalr''))))) of
        s13620 =>
  (case  ((spc_matches_prefix0 s13620)) of
        Some ((_, s13630)) =>
  (case  ((string_drop s13620 s13630)) of
        s13640 =>
  (case  ((reg_name_matches_prefix s13640 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s13650)) =>
  (case  ((string_drop s13640 s13650)) of
        s13660 =>
  (case  ((sep_matches_prefix s13660)) of
        Some ((_, s13670)) =>
  (case  ((string_drop s13660 s13670)) of
        s13680 =>
  (case  ((reg_name_matches_prefix s13680 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s13690)) =>
  (case  ((string_drop s13680 s13690)) of
        s13700 =>
  (case  ((sep_matches_prefix s13700)) of
        Some ((_, s13710)) =>
  (case  ((string_drop s13700 s13710)) of
        s13720 =>
  (case  ((hex_bits_12_matches_prefix0 s13720
          :: (( 12 Word.word * ii)) option)) of
        Some ((imm, s13730)) =>
  (let p00 = (string_drop s13720 s13730) in
  if (((p00 = ('''')))) then Some (rd, rs1, imm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s13600  :: " string "


\<comment> \<open>\<open>val _s1347_ : string -> maybe ((mword ty5 * mword ty21))\<close>\<close>

definition s1347  :: \<open> string \<Rightarrow>((5)Word.word*(21)Word.word)option \<close>  where 
     \<open> s1347 s13480 = (
   (let s13490 = s13480 in
   if ((string_startswith s13490 (''jal''))) then  
  (case  ((string_drop s13490 ((string_length (''jal''))))) of
        s13500 =>
  (case  ((spc_matches_prefix0 s13500)) of
        Some ((_, s13510)) =>
  (case  ((string_drop s13500 s13510)) of
        s13520 =>
  (case  ((reg_name_matches_prefix s13520 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s13530)) =>
  (case  ((string_drop s13520 s13530)) of
        s13540 =>
  (case  ((sep_matches_prefix s13540)) of
        Some ((_, s13550)) =>
  (case  ((string_drop s13540 s13550)) of
        s13560 =>
  (case  ((hex_bits_21_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s13560 :: (( 21 Word.word * ii)) option)) of
        Some ((imm, s13570)) =>
  (let p00 = (string_drop s13560 s13570) in
  if (((p00 = ('''')))) then Some (rd, imm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s13480  :: " string "


\<comment> \<open>\<open>val _s1334_ : string -> maybe ((uop * mword ty5 * mword ty20))\<close>\<close>

definition s1334  :: \<open> string \<Rightarrow>(uop*(5)Word.word*(20)Word.word)option \<close>  where 
     \<open> s1334 s13360 = (
      (case  ((utype_mnemonic_matches_prefix s13360)) of
        Some ((op1, s13370)) => 
  (case  ((string_drop s13360 s13370)) of
        s13380 =>
  (case  ((spc_matches_prefix0 s13380)) of
        Some ((_, s13390)) =>
  (case  ((string_drop s13380 s13390)) of
        s13400 =>
  (case  ((reg_name_matches_prefix s13400 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s13410)) =>
  (case  ((string_drop s13400 s13410)) of
        s13420 =>
  (case  ((sep_matches_prefix s13420)) of
        Some ((_, s13430)) =>
  (case  ((string_drop s13420 s13430)) of
        s13440 =>
  (case  ((hex_bits_20_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s13440 :: (( 20 Word.word * ii)) option)) of
        Some ((imm, s13450)) =>
  (let p00 = (string_drop s13440 s13450) in
  if (((p00 = ('''')))) then Some (op1, rd, imm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s13360  :: " string "


definition assembly_backwards  :: \<open> string \<Rightarrow>((register_value),(ast),(exception))monad \<close>  where 
     \<open> assembly_backwards arg1 = (
   (let s13460 = arg1 in
   if ((case  ((s1334 s13460  ::  ((uop *  5 Word.word *  20 Word.word))option)) of
       Some ((op1, rd, imm)) => True
     | _ => False
     )) then  (case  (s1334 s13460 :: (( uop * 5 Word.word * 20 Word.word)) option) of
     (Some ((op1, rd, imm))) =>
 return (UTYPE (imm, rd, op1))
 )
   else if ((case  ((s1347 s13460  ::  (( 5 Word.word *  21 Word.word))option)) of
       Some ((rd, imm)) => True
     | _ => False
     )) then  (case  (s1347 s13460 :: (( 5 Word.word * 21 Word.word)) option) of
     (Some ((rd, imm))) =>
 return (RISCV_JAL (imm, rd))
 )
   else if ((case  ((s1359 s13460  ::  (( 5 Word.word *  5 Word.word *  12 Word.word))option)) of
       Some ((rd, rs1, imm)) => True
     | _ => False
     )) then  (case  (s1359 s13460 :: (( 5 Word.word * 5 Word.word * 12 Word.word)) option) of
     (Some ((rd, rs1, imm))) =>
 return (RISCV_JALR (imm, rs1, rd))
 )
   else if ((case  ((s1375 s13460  ::  ((bop *  5 Word.word *  5 Word.word *  13 Word.word))option)) of
       Some ((op1, rs1, rs2, imm)) => True
     | _ => False
     )) then  (case 
 (s1375 s13460 :: (( bop * 5 Word.word * 5 Word.word * 13 Word.word)) option) of
     (Some ((op1, rs1, rs2, imm))) =>
 return (BTYPE (imm, rs2, rs1, op1))
 )
   else if ((case  ((s1392 s13460  ::  ((iop *  5 Word.word *  5 Word.word *  12 Word.word))option)) of
       Some ((op1, rd, rs1, imm)) => True
     | _ => False
     )) then  (case 
 (s1392 s13460 :: (( iop * 5 Word.word * 5 Word.word * 12 Word.word)) option) of
     (Some ((op1, rd, rs1, imm))) =>
 return (ITYPE (imm, rs1, rd, op1))
 )
   else if ((case  ((s1409 s13460  ::  ((sop *  5 Word.word *  5 Word.word *  6 Word.word))option)) of
       Some ((op1, rd, rs1, shamt)) => True
     | _ => False
     )) then  (case 
 (s1409 s13460 :: (( sop * 5 Word.word * 5 Word.word * 6 Word.word)) option) of
     (Some ((op1, rd, rs1, shamt))) =>
 return (SHIFTIOP (shamt, rs1, rd, op1))
 )
   else if ((case  ((s1426 s13460  ::  ((rop *  5 Word.word *  5 Word.word *  5 Word.word))option)) of
       Some ((op1, rd, rs1, rs2)) => True
     | _ => False
     )) then  (case 
 (s1426 s13460 :: (( rop * 5 Word.word * 5 Word.word * 5 Word.word)) option) of
     (Some ((op1, rd, rs1, rs2))) =>
 return (RTYPE (rs2, rs1, rd, op1))
 )
   else if ((case  ((s1443 s13460
                     ::  ((word_width * bool * bool * bool *  5 Word.word *  12 Word.word *  5 Word.word))option)) of
       Some ((size1, is_unsigned, aq, rl, rd, imm, rs1)) => True
     | _ => False
     )) then  (case 
 (s1443 s13460
 :: (( word_width * bool * bool * bool * 5 Word.word * 12 Word.word * 5 Word.word)) option) of
     (Some ((size1, is_unsigned, aq, rl, rd, imm, rs1))) =>
 return (LOAD (imm, rs1, rd, is_unsigned, size1, aq, rl))
 )
   else if ((case  ((s1473 s13460
                     ::  ((word_width * bool * bool *  5 Word.word *  12 Word.word *  5 Word.word))option)) of
       Some ((size1, aq, rl, rs2, imm, rs1)) => True
     | _ => False
     )) then  (case 
 (s1473 s13460 :: (( word_width * bool * bool * 5 Word.word * 12 Word.word * 5 Word.word)) option) of
     (Some ((size1, aq, rl, rs2, imm, rs1))) =>
 return (STORE (imm, rs2, rs1, size1, aq, rl))
 )
   else if ((case  ((s1501 s13460  ::  (( 5 Word.word *  5 Word.word *  12 Word.word))option)) of
       Some ((rd, rs1, imm)) => ((( 64 :: int)::ii) = (( 64 :: int)::ii))
     | _ => False
     )) then  (case  (s1501 s13460 :: (( 5 Word.word * 5 Word.word * 12 Word.word)) option) of
     (Some ((rd, rs1, imm))) =>
 return (ADDIW (imm, rs1, rd))
 )
   else if ((case  ((s1517 s13460  ::  ((sop *  5 Word.word *  5 Word.word *  5 Word.word))option)) of
       Some ((op1, rd, rs1, shamt)) => ((( 64 :: int)::ii) = (( 64 :: int)::ii))
     | _ => False
     )) then  (case 
 (s1517 s13460 :: (( sop * 5 Word.word * 5 Word.word * 5 Word.word)) option) of
     (Some ((op1, rd, rs1, shamt))) =>
 return (SHIFTW (shamt, rs1, rd, op1))
 )
   else if ((case  ((s1534 s13460  ::  ((ropw *  5 Word.word *  5 Word.word *  5 Word.word))option)) of
       Some ((op1, rd, rs1, rs2)) => ((( 64 :: int)::ii) = (( 64 :: int)::ii))
     | _ => False
     )) then  (case 
 (s1534 s13460 :: (( ropw * 5 Word.word * 5 Word.word * 5 Word.word)) option) of
     (Some ((op1, rd, rs1, rs2))) =>
 return (RTYPEW (rs2, rs1, rd, op1))
 )
   else if ((case  ((s1551 s13460  ::  ((sopw *  5 Word.word *  5 Word.word *  5 Word.word))option)) of
       Some ((op1, rd, rs1, shamt)) => ((( 64 :: int)::ii) = (( 64 :: int)::ii))
     | _ => False
     )) then  (case 
 (s1551 s13460 :: (( sopw * 5 Word.word * 5 Word.word * 5 Word.word)) option) of
     (Some ((op1, rd, rs1, shamt))) =>
 return (SHIFTIWOP (shamt, rs1, rd, op1))
 )
   else if ((case  ((s1568 s13460  ::  (( 4 Word.word *  4 Word.word))option)) of
       Some ((pred, succ)) => True
     | _ => False
     )) then  (case  (s1568 s13460 :: (( 4 Word.word * 4 Word.word)) option) of
     (Some ((pred, succ))) =>
 return (FENCE (pred, succ))
 )
   else if ((case  ((s1580 s13460  ::  (( 4 Word.word *  4 Word.word))option)) of
       Some ((pred, succ)) => True
     | _ => False
     )) then  (case  (s1580 s13460 :: (( 4 Word.word * 4 Word.word)) option) of
     (Some ((pred, succ))) =>
 return (FENCE_TSO (pred, succ))
 )
   else if (((s13460 = (''fence.i'')))) then return (FENCEI () )
   else if (((s13460 = (''ecall'')))) then return (ECALL () )
   else if (((s13460 = (''mret'')))) then return (MRET () )
   else if (((s13460 = (''sret'')))) then return (SRET () )
   else if (((s13460 = (''ebreak'')))) then return (EBREAK () )
   else if (((s13460 = (''wfi'')))) then return (WFI () )
   else if ((case  ((s1592 s13460  ::  (( 5 Word.word *  5 Word.word))option)) of
       Some ((rs1, rs2)) => True
     | _ => False
     )) then  (case  (s1592 s13460 :: (( 5 Word.word * 5 Word.word)) option) of
     (Some ((rs1, rs2))) =>
 return (SFENCE_VMA (rs1, rs2))
 )
   else if ((case  ((s1604 s13460  ::  ((word_width * bool * bool *  5 Word.word *  5 Word.word))option)) of
       Some ((size1, aq, rl, rd, rs1)) => True
     | _ => False
     )) then  (case 
 (s1604 s13460 :: (( word_width * bool * bool * 5 Word.word * 5 Word.word)) option) of
     (Some ((size1, aq, rl, rd, rs1))) =>
 return (LOADRES (aq, rl, rs1, size1, rd))
 )
   else if ((case  ((s1622 s13460
                     ::  ((word_width * bool * bool *  5 Word.word *  5 Word.word *  5 Word.word))option)) of
       Some ((size1, aq, rl, rd, rs1, rs2)) => True
     | _ => False
     )) then  (case 
 (s1622 s13460 :: (( word_width * bool * bool * 5 Word.word * 5 Word.word * 5 Word.word)) option) of
     (Some ((size1, aq, rl, rd, rs1, rs2))) =>
 return (STORECON (aq, rl, rs2, rs1, size1, rd))
 )
   else if ((case  ((s1644 s13460
                     ::  ((amoop * word_width * bool * bool *  5 Word.word *  5 Word.word *  5 Word.word))option)) of
       Some ((op1, width, aq, rl, rd, rs2, rs1)) => True
     | _ => False
     )) then  (case 
 (s1644 s13460
 :: (( amoop * word_width * bool * bool * 5 Word.word * 5 Word.word * 5 Word.word)) option) of
     (Some ((op1, width, aq, rl, rd, rs2, rs1))) =>
 return (AMO (op1, aq, rl, rs2, rs1, width, rd))
 )
   else if (((s13460 = (''c.nop'')))) then return (C_NOP () )
   else if ((case  ((s1670 s13460  ::  (( 3 Word.word *  8 Word.word))option)) of
       Some ((rdc, nzimm)) => (nzimm \<noteq> ( 0x00 ::  8 Word.word))
     | _ => False
     )) then  (case  (s1670 s13460 :: (( 3 Word.word * 8 Word.word)) option) of
     (Some ((rdc, nzimm))) =>
 return (C_ADDI4SPN (rdc, nzimm))
 )
   else if ((case  ((s1682 s13460  ::  (( 3 Word.word *  3 Word.word *  5 Word.word))option)) of
       Some ((rdc, rsc, uimm)) => True
     | _ => False
     )) then  (case 
 (s1682 s13460 :: (( 3 Word.word * 3 Word.word * 5 Word.word)) option) of
     (Some ((rdc, rsc, uimm))) =>
 return (C_LW (uimm, rsc, rdc))
 )
   else if ((case  ((s1698 s13460  ::  (( 3 Word.word *  3 Word.word *  5 Word.word))option)) of
       Some ((rdc, rsc, uimm)) => ((( 64 :: int)::ii) = (( 64 :: int)::ii))
     | _ => False
     )) then  (case 
 (s1698 s13460 :: (( 3 Word.word * 3 Word.word * 5 Word.word)) option) of
     (Some ((rdc, rsc, uimm))) =>
 return (C_LD (uimm, rsc, rdc))
 )
   else if ((case  ((s1714 s13460  ::  (( 3 Word.word *  3 Word.word *  5 Word.word))option)) of
       Some ((rsc1, rsc2, uimm)) => True
     | _ => False
     )) then  (case 
 (s1714 s13460 :: (( 3 Word.word * 3 Word.word * 5 Word.word)) option) of
     (Some ((rsc1, rsc2, uimm))) =>
 return (C_SW (uimm, rsc1, rsc2))
 )
   else if ((case  ((s1730 s13460  ::  (( 3 Word.word *  3 Word.word *  5 Word.word))option)) of
       Some ((rsc1, rsc2, uimm)) => ((( 64 :: int)::ii) = (( 64 :: int)::ii))
     | _ => False
     )) then  (case 
 (s1730 s13460 :: (( 3 Word.word * 3 Word.word * 5 Word.word)) option) of
     (Some ((rsc1, rsc2, uimm))) =>
 return (C_SD (uimm, rsc1, rsc2))
 )
   else if ((case  ((s1746 s13460  ::  (( 5 Word.word *  6 Word.word))option)) of
       Some ((rsd, nzi)) => ((((nzi \<noteq> ( 0b000000 ::  6 Word.word)))) \<and> (((rsd \<noteq> zreg))))
     | _ => False
     )) then  (case  (s1746 s13460 :: (( 5 Word.word * 6 Word.word)) option) of
     (Some ((rsd, nzi))) =>
 return (C_ADDI (nzi, rsd))
 )
   else if ((case  ((s1758 s13460  ::  ( 11 Word.word)option)) of
       Some (imm) => ((( 64 :: int)::ii) = (( 32 :: int)::ii))
     | _ => False
     )) then  (case  (s1758 s13460 :: ( 11 Word.word) option) of
     (Some (imm)) =>
 return (C_JAL imm)
 )
   else if ((case  ((s1766 s13460  ::  (( 5 Word.word *  6 Word.word))option)) of
       Some ((rsd, imm)) => ((( 64 :: int)::ii) = (( 64 :: int)::ii))
     | _ => False
     )) then  (case  (s1766 s13460 :: (( 5 Word.word * 6 Word.word)) option) of
     (Some ((rsd, imm))) =>
 return (C_ADDIW (imm, rsd))
 )
   else if ((case  ((s1778 s13460  ::  (( 5 Word.word *  6 Word.word))option)) of
       Some ((rd, imm)) => (rd \<noteq> zreg)
     | _ => False
     )) then  (case  (s1778 s13460 :: (( 5 Word.word * 6 Word.word)) option) of
     (Some ((rd, imm))) =>
 return (C_LI (imm, rd))
 )
   else if ((case  ((s1790 s13460  ::  ( 6 Word.word)option)) of
       Some (imm) => (imm \<noteq> ( 0b000000 ::  6 Word.word))
     | _ => False
     )) then  (case  (s1790 s13460 :: ( 6 Word.word) option) of
     (Some (imm)) =>
 return (C_ADDI16SP imm)
 )
   else if ((case  ((s1798 s13460  ::  (( 5 Word.word *  6 Word.word))option)) of
       Some ((rd, imm)) =>
        ((((rd \<noteq> zreg))) \<and> ((((((rd \<noteq> sp))) \<and> (((imm \<noteq> ( 0b000000 ::  6 Word.word))))))))
     | _ => False
     )) then  (case  (s1798 s13460 :: (( 5 Word.word * 6 Word.word)) option) of
     (Some ((rd, imm))) =>
 return (C_LUI (imm, rd))
 )
   else if ((case  ((s1810 s13460  ::  (( 3 Word.word *  6 Word.word))option)) of
       Some ((rsd, shamt)) => (shamt \<noteq> ( 0b000000 ::  6 Word.word))
     | _ => False
     )) then  (case  (s1810 s13460 :: (( 3 Word.word * 6 Word.word)) option) of
     (Some ((rsd, shamt))) =>
 return (C_SRLI (shamt, rsd))
 )
   else if ((case  ((s1822 s13460  ::  (( 3 Word.word *  6 Word.word))option)) of
       Some ((rsd, shamt)) => (shamt \<noteq> ( 0b000000 ::  6 Word.word))
     | _ => False
     )) then  (case  (s1822 s13460 :: (( 3 Word.word * 6 Word.word)) option) of
     (Some ((rsd, shamt))) =>
 return (C_SRAI (shamt, rsd))
 )
   else if ((case  ((s1834 s13460  ::  (( 3 Word.word *  6 Word.word))option)) of
       Some ((rsd, imm)) => True
     | _ => False
     )) then  (case  (s1834 s13460 :: (( 3 Word.word * 6 Word.word)) option) of
     (Some ((rsd, imm))) =>
 return (C_ANDI (imm, rsd))
 )
   else if ((case  ((s1846 s13460  ::  (( 3 Word.word *  3 Word.word))option)) of
       Some ((rsd, rs2)) => True
     | _ => False
     )) then  (case  (s1846 s13460 :: (( 3 Word.word * 3 Word.word)) option) of
     (Some ((rsd, rs2))) =>
 return (C_SUB (rsd, rs2))
 )
   else if ((case  ((s1858 s13460  ::  (( 3 Word.word *  3 Word.word))option)) of
       Some ((rsd, rs2)) => True
     | _ => False
     )) then  (case  (s1858 s13460 :: (( 3 Word.word * 3 Word.word)) option) of
     (Some ((rsd, rs2))) =>
 return (C_XOR (rsd, rs2))
 )
   else if ((case  ((s1870 s13460  ::  (( 3 Word.word *  3 Word.word))option)) of
       Some ((rsd, rs2)) => True
     | _ => False
     )) then  (case  (s1870 s13460 :: (( 3 Word.word * 3 Word.word)) option) of
     (Some ((rsd, rs2))) =>
 return (C_OR (rsd, rs2))
 )
   else if ((case  ((s1882 s13460  ::  (( 3 Word.word *  3 Word.word))option)) of
       Some ((rsd, rs2)) => True
     | _ => False
     )) then  (case  (s1882 s13460 :: (( 3 Word.word * 3 Word.word)) option) of
     (Some ((rsd, rs2))) =>
 return (C_AND (rsd, rs2))
 )
   else if ((case  ((s1894 s13460  ::  (( 3 Word.word *  3 Word.word))option)) of
       Some ((rsd, rs2)) => ((( 64 :: int)::ii) = (( 64 :: int)::ii))
     | _ => False
     )) then  (case  (s1894 s13460 :: (( 3 Word.word * 3 Word.word)) option) of
     (Some ((rsd, rs2))) =>
 return (C_SUBW (rsd, rs2))
 )
   else if ((case  ((s1906 s13460  ::  (( 3 Word.word *  3 Word.word))option)) of
       Some ((rsd, rs2)) => ((( 64 :: int)::ii) = (( 64 :: int)::ii))
     | _ => False
     )) then  (case  (s1906 s13460 :: (( 3 Word.word * 3 Word.word)) option) of
     (Some ((rsd, rs2))) =>
 return (C_ADDW (rsd, rs2))
 )
   else if ((case  ((s1918 s13460  ::  ( 11 Word.word)option)) of
       Some (imm) => True
     | _ => False
     )) then  (case  (s1918 s13460 :: ( 11 Word.word) option) of
     (Some (imm)) =>
 return (C_J imm)
 )
   else if ((case  ((s1926 s13460  ::  (( 3 Word.word *  8 Word.word))option)) of
       Some ((rs, imm)) => True
     | _ => False
     )) then  (case  (s1926 s13460 :: (( 3 Word.word * 8 Word.word)) option) of
     (Some ((rs, imm))) =>
 return (C_BEQZ (imm, rs))
 )
   else if ((case  ((s1938 s13460  ::  (( 3 Word.word *  8 Word.word))option)) of
       Some ((rs, imm)) => True
     | _ => False
     )) then  (case  (s1938 s13460 :: (( 3 Word.word * 8 Word.word)) option) of
     (Some ((rs, imm))) =>
 return (C_BNEZ (imm, rs))
 )
   else if ((case  ((s1950 s13460  ::  (( 5 Word.word *  6 Word.word))option)) of
       Some ((rsd, shamt)) => ((((shamt \<noteq> ( 0b000000 ::  6 Word.word)))) \<and> (((rsd \<noteq> zreg))))
     | _ => False
     )) then  (case  (s1950 s13460 :: (( 5 Word.word * 6 Word.word)) option) of
     (Some ((rsd, shamt))) =>
 return (C_SLLI (shamt, rsd))
 )
   else if ((case  ((s1962 s13460  ::  (( 5 Word.word *  6 Word.word))option)) of
       Some ((rd, uimm)) => (rd \<noteq> zreg)
     | _ => False
     )) then  (case  (s1962 s13460 :: (( 5 Word.word * 6 Word.word)) option) of
     (Some ((rd, uimm))) =>
 return (C_LWSP (uimm, rd))
 )
   else if ((case  ((s1974 s13460  ::  (( 5 Word.word *  6 Word.word))option)) of
       Some ((rd, uimm)) => ((((rd \<noteq> zreg))) \<and> ((((( 64 :: int)::ii) = (( 64 :: int)::ii)))))
     | _ => False
     )) then  (case  (s1974 s13460 :: (( 5 Word.word * 6 Word.word)) option) of
     (Some ((rd, uimm))) =>
 return (C_LDSP (uimm, rd))
 )
   else if ((case  ((s1986 s13460  ::  (( 5 Word.word *  6 Word.word))option)) of
       Some ((rd, uimm)) => True
     | _ => False
     )) then  (case  (s1986 s13460 :: (( 5 Word.word * 6 Word.word)) option) of
     (Some ((rd, uimm))) =>
 return (C_SWSP (uimm, rd))
 )
   else if ((case  ((s1998 s13460  ::  (( 5 Word.word *  6 Word.word))option)) of
       Some ((rs2, uimm)) => ((( 64 :: int)::ii) = (( 64 :: int)::ii))
     | _ => False
     )) then  (case  (s1998 s13460 :: (( 5 Word.word * 6 Word.word)) option) of
     (Some ((rs2, uimm))) =>
 return (C_SDSP (uimm, rs2))
 )
   else if ((case  ((s2010 s13460  ::  ( 5 Word.word)option)) of
       Some (rs1) => (rs1 \<noteq> zreg)
     | _ => False
     )) then  (case  (s2010 s13460 :: ( 5 Word.word) option) of
     (Some (rs1)) =>
 return (C_JR rs1)
 )
   else if ((case  ((s2018 s13460  ::  ( 5 Word.word)option)) of
       Some (rs1) => (rs1 \<noteq> zreg)
     | _ => False
     )) then  (case  (s2018 s13460 :: ( 5 Word.word) option) of
     (Some (rs1)) =>
 return (C_JALR rs1)
 )
   else if ((case  ((s2026 s13460  ::  (( 5 Word.word *  5 Word.word))option)) of
       Some ((rd, rs2)) => ((((rd \<noteq> zreg))) \<and> (((rs2 \<noteq> zreg))))
     | _ => False
     )) then  (case  (s2026 s13460 :: (( 5 Word.word * 5 Word.word)) option) of
     (Some ((rd, rs2))) =>
 return (C_MV (rd, rs2))
 )
   else if (((s13460 = (''c.ebreak'')))) then return (C_EBREAK () )
   else if ((case  ((s2038 s13460  ::  (( 5 Word.word *  5 Word.word))option)) of
       Some ((rsd, rs2)) => ((((rsd \<noteq> zreg))) \<and> (((rs2 \<noteq> zreg))))
     | _ => False
     )) then  (case  (s2038 s13460 :: (( 5 Word.word * 5 Word.word)) option) of
     (Some ((rsd, rs2))) =>
 return (C_ADD (rsd, rs2))
 )
   else if ((case  ((s2050 s13460
                     ::  ((bool * bool * bool *  5 Word.word *  5 Word.word *  5 Word.word))option)) of
       Some ((high, signed1, signed2, rd, rs1, rs2)) => True
     | _ => False
     )) then  (case 
 (s2050 s13460 :: (( bool * bool * bool * 5 Word.word * 5 Word.word * 5 Word.word)) option) of
     (Some ((high, signed1, signed2, rd, rs1, rs2))) =>
 return (MUL (rs2, rs1, rd, high, signed1, signed2))
 )
   else if ((case  ((s2067 s13460  ::  ((bool *  5 Word.word *  5 Word.word *  5 Word.word))option)) of
       Some ((s, rd, rs1, rs2)) => True
     | _ => False
     )) then  (case 
 (s2067 s13460 :: (( bool * 5 Word.word * 5 Word.word * 5 Word.word)) option) of
     (Some ((s, rd, rs1, rs2))) =>
 return (DIV (rs2, rs1, rd, s))
 )
   else if ((case  ((s2085 s13460  ::  ((bool *  5 Word.word *  5 Word.word *  5 Word.word))option)) of
       Some ((s, rd, rs1, rs2)) => True
     | _ => False
     )) then  (case 
 (s2085 s13460 :: (( bool * 5 Word.word * 5 Word.word * 5 Word.word)) option) of
     (Some ((s, rd, rs1, rs2))) =>
 return (REM (rs2, rs1, rd, s))
 )
   else if ((case  ((s2103 s13460  ::  (( 5 Word.word *  5 Word.word *  5 Word.word))option)) of
       Some ((rd, rs1, rs2)) => ((( 64 :: int)::ii) = (( 64 :: int)::ii))
     | _ => False
     )) then  (case  (s2103 s13460 :: (( 5 Word.word * 5 Word.word * 5 Word.word)) option) of
     (Some ((rd, rs1, rs2))) =>
 return (MULW (rs2, rs1, rd))
 )
   else if ((case  ((s2119 s13460  ::  ((bool *  5 Word.word *  5 Word.word *  5 Word.word))option)) of
       Some ((s, rd, rs1, rs2)) => ((( 64 :: int)::ii) = (( 64 :: int)::ii))
     | _ => False
     )) then  (case 
 (s2119 s13460 :: (( bool * 5 Word.word * 5 Word.word * 5 Word.word)) option) of
     (Some ((s, rd, rs1, rs2))) =>
 return (DIVW (rs2, rs1, rd, s))
 )
   else if ((case  ((s2138 s13460  ::  ((bool *  5 Word.word *  5 Word.word *  5 Word.word))option)) of
       Some ((s, rd, rs1, rs2)) => ((( 64 :: int)::ii) = (( 64 :: int)::ii))
     | _ => False
     )) then  (case 
 (s2138 s13460 :: (( bool * 5 Word.word * 5 Word.word * 5 Word.word)) option) of
     (Some ((s, rd, rs1, rs2))) =>
 return (REMW (rs2, rs1, rd, s))
 )
   else if ((case  ((s2157 s13460  ::  ((csrop *  5 Word.word *  12 Word.word *  5 Word.word))option)) of
       Some ((op1, rd, csr, rs1)) => True
     | _ => False
     )) then  (case 
 (s2157 s13460 :: (( csrop * 5 Word.word * 12 Word.word * 5 Word.word)) option) of
     (Some ((op1, rd, csr, rs1))) =>
 return (CSR (csr, rs1, rd, True, op1))
 )
   else if ((case  ((s2175 s13460  ::  ((csrop *  5 Word.word *  12 Word.word *  5 Word.word))option)) of
       Some ((op1, rd, csr, rs1)) => True
     | _ => False
     )) then  (case 
 (s2175 s13460 :: (( csrop * 5 Word.word * 12 Word.word * 5 Word.word)) option) of
     (Some ((op1, rd, csr, rs1))) =>
 return (CSR (csr, rs1, rd, False, op1))
 )
   else if (((s13460 = (''uret'')))) then return (URET () )
   else if ((case  ((s2192 s13460  ::  ( 6 Word.word)option)) of
       Some (imm) => True
     | _ => False
     )) then  (case  (s2192 s13460 :: ( 6 Word.word) option) of
     (Some (imm)) =>
 return (C_NOP_HINT imm)
 )
   else if ((case  ((s2198 s13460  ::  ( 5 Word.word)option)) of
       Some (rsd) => (rsd \<noteq> zreg)
     | _ => False
     )) then  (case  (s2198 s13460 :: ( 5 Word.word) option) of
     (Some (rsd)) =>
 return (C_ADDI_HINT rsd)
 )
   else if ((case  ((s2204 s13460  ::  ( 6 Word.word)option)) of
       Some (imm) => True
     | _ => False
     )) then  (case  (s2204 s13460 :: ( 6 Word.word) option) of
     (Some (imm)) =>
 return (C_LI_HINT imm)
 )
   else if ((case  ((s2210 s13460  ::  ( 6 Word.word)option)) of
       Some (imm) => (imm \<noteq> ( 0b000000 ::  6 Word.word))
     | _ => False
     )) then  (case  (s2210 s13460 :: ( 6 Word.word) option) of
     (Some (imm)) =>
 return (C_LUI_HINT imm)
 )
   else if ((case  ((s2216 s13460  ::  ( 5 Word.word)option)) of
       Some (rs2) => (rs2 \<noteq> zreg)
     | _ => False
     )) then  (case  (s2216 s13460 :: ( 5 Word.word) option) of
     (Some (rs2)) =>
 return (C_MV_HINT rs2)
 )
   else if ((case  ((s2222 s13460  ::  ( 5 Word.word)option)) of
       Some (rs2) => (rs2 \<noteq> zreg)
     | _ => False
     )) then  (case  (s2222 s13460 :: ( 5 Word.word) option) of
     (Some (rs2)) =>
 return (C_ADD_HINT rs2)
 )
   else if ((case  ((s2228 s13460  ::  (( 5 Word.word *  6 Word.word))option)) of
       Some ((rsd, shamt)) => ((((shamt = ( 0b000000 ::  6 Word.word)))) \<or> (((rsd = zreg))))
     | _ => False
     )) then  (case  (s2228 s13460 :: (( 5 Word.word * 6 Word.word)) option) of
     (Some ((rsd, shamt))) =>
 return (C_SLLI_HINT (shamt, rsd))
 )
   else if ((case  ((s2237 s13460  ::  ( 3 Word.word)option)) of
       Some (rsd) => True
     | _ => False
     )) then  (case  (s2237 s13460 :: ( 3 Word.word) option) of
     (Some (rsd)) =>
 return (C_SRLI_HINT rsd)
 )
   else if ((case  ((s2243 s13460  ::  ( 3 Word.word)option)) of
       Some (rsd) => True
     | _ => False
     )) then  (case  (s2243 s13460 :: ( 3 Word.word) option) of
     (Some (rsd)) =>
 return (C_SRAI_HINT rsd)
 )
   else if ((case  ((s2249 s13460
                     ::  (( 4 Word.word *  4 Word.word *  5 Word.word *  5 Word.word *  4 Word.word))option)) of
       Some ((pred, succ, rs, rd, fm)) =>
        (((((((fm \<noteq> ( 0x0 ::  4 Word.word)))) \<and> (((fm \<noteq> ( 0x8 ::  4 Word.word))))))) \<or> ((((((rs \<noteq> ( 0b00000 ::  5 Word.word)))) \<or> (((rd \<noteq> ( 0b00000 ::  5 Word.word))))))))
     | _ => False
     )) then  (case 
 (s2249 s13460 :: (( 4 Word.word * 4 Word.word * 5 Word.word * 5 Word.word * 4 Word.word)) option) of
     (Some ((pred, succ, rs, rd, fm))) =>
 return (FENCE_RESERVED (fm, pred, succ, rs, rd))
 )
   else if ((case  ((s2267 s13460  ::  (( 5 Word.word *  5 Word.word *  12 Word.word))option)) of
       Some ((rd, rs, imm)) =>
        ((((imm \<noteq> ( 0x000 ::  12 Word.word)))) \<or> ((((((rs \<noteq> zreg))) \<or> (((rd \<noteq> zreg)))))))
     | _ => False
     )) then  (case  (s2267 s13460 :: (( 5 Word.word * 5 Word.word * 12 Word.word)) option) of
     (Some ((rd, rs, imm))) =>
 return (FENCEI_RESERVED (imm, rs, rd))
 )
   else if ((case  ((s2279 s13460  ::  ((word_width *  5 Word.word *  12 Word.word *  5 Word.word))option)) of
       Some ((width, rd, imm, rs1)) => True
     | _ => False
     )) then  (case 
 (s2279 s13460 :: (( word_width * 5 Word.word * 12 Word.word * 5 Word.word)) option) of
     (Some ((width, rd, imm, rs1))) =>
 return (LOAD_FP (imm, rs1, rd, width))
 )
   else if ((case  ((s2303 s13460  ::  ((word_width *  5 Word.word *  12 Word.word *  5 Word.word))option)) of
       Some ((width, rs2, imm, rs1)) => True
     | _ => False
     )) then  (case 
 (s2303 s13460 :: (( word_width * 5 Word.word * 12 Word.word * 5 Word.word)) option) of
     (Some ((width, rs2, imm, rs1))) =>
 return (STORE_FP (imm, rs2, rs1, width))
 )
   else if ((case  ((s2327 s13460
                     ::  ((f_madd_op_S *  5 Word.word *  5 Word.word *  5 Word.word *  5 Word.word * rounding_mode))option)) of
       Some ((op1, rd, rs1, rs2, rs3, rm)) => True
     | _ => False
     )) then  (case 
 (s2327 s13460
 :: (( f_madd_op_S * 5 Word.word * 5 Word.word * 5 Word.word * 5 Word.word * rounding_mode)) option) of
     (Some ((op1, rd, rs1, rs2, rs3, rm))) =>
 return (F_MADD_TYPE_S (rs3, rs2, rs1, rm, rd, op1))
 )
   else if ((case  ((s2352 s13460
                     ::  ((f_bin_rm_op_S *  5 Word.word *  5 Word.word *  5 Word.word * rounding_mode))option)) of
       Some ((op1, rd, rs1, rs2, rm)) => True
     | _ => False
     )) then  (case 
 (s2352 s13460
 :: (( f_bin_rm_op_S * 5 Word.word * 5 Word.word * 5 Word.word * rounding_mode)) option) of
     (Some ((op1, rd, rs1, rs2, rm))) =>
 return (F_BIN_RM_TYPE_S (rs2, rs1, rm, rd, op1))
 )
   else if ((case  ((s2373 s13460
                     ::  ((f_un_rm_op_S *  5 Word.word *  5 Word.word * rounding_mode))option)) of
       Some ((FSQRT_S, rd, rs1, rm)) => True
     | _ => False
     )) then  (case 
 (s2373 s13460 :: (( f_un_rm_op_S * 5 Word.word * 5 Word.word * rounding_mode)) option) of
     (Some ((FSQRT_S, rd, rs1, rm))) =>
 return (F_UN_RM_TYPE_S (rs1, rm, rd, FSQRT_S))
 )
   else if ((case  ((s2390 s13460
                     ::  ((f_un_rm_op_S *  5 Word.word *  5 Word.word * rounding_mode))option)) of
       Some ((FCVT_W_S, rd, rs1, rm)) => True
     | _ => False
     )) then  (case 
 (s2390 s13460 :: (( f_un_rm_op_S * 5 Word.word * 5 Word.word * rounding_mode)) option) of
     (Some ((FCVT_W_S, rd, rs1, rm))) =>
 return (F_UN_RM_TYPE_S (rs1, rm, rd, FCVT_W_S))
 )
   else if ((case  ((s2407 s13460
                     ::  ((f_un_rm_op_S *  5 Word.word *  5 Word.word * rounding_mode))option)) of
       Some ((FCVT_WU_S, rd, rs1, rm)) => True
     | _ => False
     )) then  (case 
 (s2407 s13460 :: (( f_un_rm_op_S * 5 Word.word * 5 Word.word * rounding_mode)) option) of
     (Some ((FCVT_WU_S, rd, rs1, rm))) =>
 return (F_UN_RM_TYPE_S (rs1, rm, rd, FCVT_WU_S))
 )
   else if ((case  ((s2424 s13460
                     ::  ((f_un_rm_op_S *  5 Word.word *  5 Word.word * rounding_mode))option)) of
       Some ((FCVT_S_W, rd, rs1, rm)) => True
     | _ => False
     )) then  (case 
 (s2424 s13460 :: (( f_un_rm_op_S * 5 Word.word * 5 Word.word * rounding_mode)) option) of
     (Some ((FCVT_S_W, rd, rs1, rm))) =>
 return (F_UN_RM_TYPE_S (rs1, rm, rd, FCVT_S_W))
 )
   else if ((case  ((s2441 s13460
                     ::  ((f_un_rm_op_S *  5 Word.word *  5 Word.word * rounding_mode))option)) of
       Some ((FCVT_S_WU, rd, rs1, rm)) => True
     | _ => False
     )) then  (case 
 (s2441 s13460 :: (( f_un_rm_op_S * 5 Word.word * 5 Word.word * rounding_mode)) option) of
     (Some ((FCVT_S_WU, rd, rs1, rm))) =>
 return (F_UN_RM_TYPE_S (rs1, rm, rd, FCVT_S_WU))
 )
   else if ((case  ((s2458 s13460
                     ::  ((f_un_rm_op_S *  5 Word.word *  5 Word.word * rounding_mode))option)) of
       Some ((FCVT_L_S, rd, rs1, rm)) => True
     | _ => False
     )) then  (case 
 (s2458 s13460 :: (( f_un_rm_op_S * 5 Word.word * 5 Word.word * rounding_mode)) option) of
     (Some ((FCVT_L_S, rd, rs1, rm))) =>
 return (F_UN_RM_TYPE_S (rs1, rm, rd, FCVT_L_S))
 )
   else if ((case  ((s2475 s13460
                     ::  ((f_un_rm_op_S *  5 Word.word *  5 Word.word * rounding_mode))option)) of
       Some ((FCVT_LU_S, rd, rs1, rm)) => True
     | _ => False
     )) then  (case 
 (s2475 s13460 :: (( f_un_rm_op_S * 5 Word.word * 5 Word.word * rounding_mode)) option) of
     (Some ((FCVT_LU_S, rd, rs1, rm))) =>
 return (F_UN_RM_TYPE_S (rs1, rm, rd, FCVT_LU_S))
 )
   else if ((case  ((s2492 s13460
                     ::  ((f_un_rm_op_S *  5 Word.word *  5 Word.word * rounding_mode))option)) of
       Some ((FCVT_S_L, rd, rs1, rm)) => True
     | _ => False
     )) then  (case 
 (s2492 s13460 :: (( f_un_rm_op_S * 5 Word.word * 5 Word.word * rounding_mode)) option) of
     (Some ((FCVT_S_L, rd, rs1, rm))) =>
 return (F_UN_RM_TYPE_S (rs1, rm, rd, FCVT_S_L))
 )
   else if ((case  ((s2509 s13460
                     ::  ((f_un_rm_op_S *  5 Word.word *  5 Word.word * rounding_mode))option)) of
       Some ((FCVT_S_LU, rd, rs1, rm)) => True
     | _ => False
     )) then  (case 
 (s2509 s13460 :: (( f_un_rm_op_S * 5 Word.word * 5 Word.word * rounding_mode)) option) of
     (Some ((FCVT_S_LU, rd, rs1, rm))) =>
 return (F_UN_RM_TYPE_S (rs1, rm, rd, FCVT_S_LU))
 )
   else if ((case  ((s2526 s13460  ::  ((f_bin_op_S *  5 Word.word *  5 Word.word *  5 Word.word))option)) of
       Some ((FSGNJ_S, rd, rs1, rs2)) => True
     | _ => False
     )) then  (case 
 (s2526 s13460 :: (( f_bin_op_S * 5 Word.word * 5 Word.word * 5 Word.word)) option) of
     (Some ((FSGNJ_S, rd, rs1, rs2))) =>
 return (F_BIN_TYPE_S (rs2, rs1, rd, FSGNJ_S))
 )
   else if ((case  ((s2543 s13460  ::  ((f_bin_op_S *  5 Word.word *  5 Word.word *  5 Word.word))option)) of
       Some ((FSGNJN_S, rd, rs1, rs2)) => True
     | _ => False
     )) then  (case 
 (s2543 s13460 :: (( f_bin_op_S * 5 Word.word * 5 Word.word * 5 Word.word)) option) of
     (Some ((FSGNJN_S, rd, rs1, rs2))) =>
 return (F_BIN_TYPE_S (rs2, rs1, rd, FSGNJN_S))
 )
   else if ((case  ((s2560 s13460  ::  ((f_bin_op_S *  5 Word.word *  5 Word.word *  5 Word.word))option)) of
       Some ((FSGNJX_S, rd, rs1, rs2)) => True
     | _ => False
     )) then  (case 
 (s2560 s13460 :: (( f_bin_op_S * 5 Word.word * 5 Word.word * 5 Word.word)) option) of
     (Some ((FSGNJX_S, rd, rs1, rs2))) =>
 return (F_BIN_TYPE_S (rs2, rs1, rd, FSGNJX_S))
 )
   else if ((case  ((s2577 s13460  ::  ((f_bin_op_S *  5 Word.word *  5 Word.word *  5 Word.word))option)) of
       Some ((FMIN_S, rd, rs1, rs2)) => True
     | _ => False
     )) then  (case 
 (s2577 s13460 :: (( f_bin_op_S * 5 Word.word * 5 Word.word * 5 Word.word)) option) of
     (Some ((FMIN_S, rd, rs1, rs2))) =>
 return (F_BIN_TYPE_S (rs2, rs1, rd, FMIN_S))
 )
   else if ((case  ((s2594 s13460  ::  ((f_bin_op_S *  5 Word.word *  5 Word.word *  5 Word.word))option)) of
       Some ((FMAX_S, rd, rs1, rs2)) => True
     | _ => False
     )) then  (case 
 (s2594 s13460 :: (( f_bin_op_S * 5 Word.word * 5 Word.word * 5 Word.word)) option) of
     (Some ((FMAX_S, rd, rs1, rs2))) =>
 return (F_BIN_TYPE_S (rs2, rs1, rd, FMAX_S))
 )
   else if ((case  ((s2611 s13460  ::  ((f_bin_op_S *  5 Word.word *  5 Word.word *  5 Word.word))option)) of
       Some ((FEQ_S, rd, rs1, rs2)) => True
     | _ => False
     )) then  (case 
 (s2611 s13460 :: (( f_bin_op_S * 5 Word.word * 5 Word.word * 5 Word.word)) option) of
     (Some ((FEQ_S, rd, rs1, rs2))) =>
 return (F_BIN_TYPE_S (rs2, rs1, rd, FEQ_S))
 )
   else if ((case  ((s2628 s13460  ::  ((f_bin_op_S *  5 Word.word *  5 Word.word *  5 Word.word))option)) of
       Some ((FLT_S, rd, rs1, rs2)) => True
     | _ => False
     )) then  (case 
 (s2628 s13460 :: (( f_bin_op_S * 5 Word.word * 5 Word.word * 5 Word.word)) option) of
     (Some ((FLT_S, rd, rs1, rs2))) =>
 return (F_BIN_TYPE_S (rs2, rs1, rd, FLT_S))
 )
   else if ((case  ((s2645 s13460  ::  ((f_bin_op_S *  5 Word.word *  5 Word.word *  5 Word.word))option)) of
       Some ((FLE_S, rd, rs1, rs2)) => True
     | _ => False
     )) then  (case 
 (s2645 s13460 :: (( f_bin_op_S * 5 Word.word * 5 Word.word * 5 Word.word)) option) of
     (Some ((FLE_S, rd, rs1, rs2))) =>
 return (F_BIN_TYPE_S (rs2, rs1, rd, FLE_S))
 )
   else if ((case  ((s2662 s13460  ::  ((f_un_op_S *  5 Word.word *  5 Word.word))option)) of
       Some ((FMV_X_W, rd, rs1)) => True
     | _ => False
     )) then  (case 
 (s2662 s13460 :: (( f_un_op_S * 5 Word.word * 5 Word.word)) option) of
     (Some ((FMV_X_W, rd, rs1))) =>
 return (F_UN_TYPE_S (rs1, rd, FMV_X_W))
 )
   else if ((case  ((s2675 s13460  ::  ((f_un_op_S *  5 Word.word *  5 Word.word))option)) of
       Some ((FMV_W_X, rd, rs1)) => True
     | _ => False
     )) then  (case 
 (s2675 s13460 :: (( f_un_op_S * 5 Word.word * 5 Word.word)) option) of
     (Some ((FMV_W_X, rd, rs1))) =>
 return (F_UN_TYPE_S (rs1, rd, FMV_W_X))
 )
   else if ((case  ((s2688 s13460  ::  ((f_un_op_S *  5 Word.word *  5 Word.word))option)) of
       Some ((FCLASS_S, rd, rs1)) => True
     | _ => False
     )) then  (case 
 (s2688 s13460 :: (( f_un_op_S * 5 Word.word * 5 Word.word)) option) of
     (Some ((FCLASS_S, rd, rs1))) =>
 return (F_UN_TYPE_S (rs1, rd, FCLASS_S))
 )
   else if ((case  ((s2701 s13460  ::  (( 5 Word.word *  6 Word.word))option)) of
       Some ((rd, imm)) => ((( 64 :: int)::ii) = (( 32 :: int)::ii))
     | _ => False
     )) then  (case  (s2701 s13460 :: (( 5 Word.word * 6 Word.word)) option) of
     (Some ((rd, imm))) =>
 return (C_FLWSP (imm, rd))
 )
   else if ((case  ((s2713 s13460  ::  (( 5 Word.word *  6 Word.word))option)) of
       Some ((rd, uimm)) => ((( 64 :: int)::ii) = (( 32 :: int)::ii))
     | _ => False
     )) then  (case  (s2713 s13460 :: (( 5 Word.word * 6 Word.word)) option) of
     (Some ((rd, uimm))) =>
 return (C_FSWSP (uimm, rd))
 )
   else if ((case  ((s2725 s13460  ::  (( 3 Word.word *  3 Word.word *  5 Word.word))option)) of
       Some ((rdc, rsc, uimm)) => ((( 64 :: int)::ii) = (( 32 :: int)::ii))
     | _ => False
     )) then  (case 
 (s2725 s13460 :: (( 3 Word.word * 3 Word.word * 5 Word.word)) option) of
     (Some ((rdc, rsc, uimm))) =>
 return (C_FLW (uimm, rsc, rdc))
 )
   else if ((case  ((s2741 s13460  ::  (( 3 Word.word *  3 Word.word *  5 Word.word))option)) of
       Some ((rsc1, rsc2, uimm)) => ((( 64 :: int)::ii) = (( 32 :: int)::ii))
     | _ => False
     )) then  (case 
 (s2741 s13460 :: (( 3 Word.word * 3 Word.word * 5 Word.word)) option) of
     (Some ((rsc1, rsc2, uimm))) =>
 return (C_FSW (uimm, rsc1, rsc2))
 )
   else if ((case  ((s2757 s13460
                     ::  ((f_madd_op_D *  5 Word.word *  5 Word.word *  5 Word.word *  5 Word.word * rounding_mode))option)) of
       Some ((op1, rd, rs1, rs2, rs3, rm)) => True
     | _ => False
     )) then  (case 
 (s2757 s13460
 :: (( f_madd_op_D * 5 Word.word * 5 Word.word * 5 Word.word * 5 Word.word * rounding_mode)) option) of
     (Some ((op1, rd, rs1, rs2, rs3, rm))) =>
 return (F_MADD_TYPE_D (rs3, rs2, rs1, rm, rd, op1))
 )
   else if ((case  ((s2782 s13460
                     ::  ((f_bin_rm_op_D *  5 Word.word *  5 Word.word *  5 Word.word * rounding_mode))option)) of
       Some ((op1, rd, rs1, rs2, rm)) => True
     | _ => False
     )) then  (case 
 (s2782 s13460
 :: (( f_bin_rm_op_D * 5 Word.word * 5 Word.word * 5 Word.word * rounding_mode)) option) of
     (Some ((op1, rd, rs1, rs2, rm))) =>
 return (F_BIN_RM_TYPE_D (rs2, rs1, rm, rd, op1))
 )
   else if ((case  ((s2803 s13460
                     ::  ((f_un_rm_op_D *  5 Word.word *  5 Word.word * rounding_mode))option)) of
       Some ((FSQRT_D, rd, rs1, rm)) => True
     | _ => False
     )) then  (case 
 (s2803 s13460 :: (( f_un_rm_op_D * 5 Word.word * 5 Word.word * rounding_mode)) option) of
     (Some ((FSQRT_D, rd, rs1, rm))) =>
 return (F_UN_RM_TYPE_D (rs1, rm, rd, FSQRT_D))
 )
   else if ((case  ((s2820 s13460
                     ::  ((f_un_rm_op_D *  5 Word.word *  5 Word.word * rounding_mode))option)) of
       Some ((FCVT_W_D, rd, rs1, rm)) => True
     | _ => False
     )) then  (case 
 (s2820 s13460 :: (( f_un_rm_op_D * 5 Word.word * 5 Word.word * rounding_mode)) option) of
     (Some ((FCVT_W_D, rd, rs1, rm))) =>
 return (F_UN_RM_TYPE_D (rs1, rm, rd, FCVT_W_D))
 )
   else if ((case  ((s2837 s13460
                     ::  ((f_un_rm_op_D *  5 Word.word *  5 Word.word * rounding_mode))option)) of
       Some ((FCVT_WU_D, rd, rs1, rm)) => True
     | _ => False
     )) then  (case 
 (s2837 s13460 :: (( f_un_rm_op_D * 5 Word.word * 5 Word.word * rounding_mode)) option) of
     (Some ((FCVT_WU_D, rd, rs1, rm))) =>
 return (F_UN_RM_TYPE_D (rs1, rm, rd, FCVT_WU_D))
 )
   else if ((case  ((s2854 s13460
                     ::  ((f_un_rm_op_D *  5 Word.word *  5 Word.word * rounding_mode))option)) of
       Some ((FCVT_D_W, rd, rs1, rm)) => True
     | _ => False
     )) then  (case 
 (s2854 s13460 :: (( f_un_rm_op_D * 5 Word.word * 5 Word.word * rounding_mode)) option) of
     (Some ((FCVT_D_W, rd, rs1, rm))) =>
 return (F_UN_RM_TYPE_D (rs1, rm, rd, FCVT_D_W))
 )
   else if ((case  ((s2871 s13460
                     ::  ((f_un_rm_op_D *  5 Word.word *  5 Word.word * rounding_mode))option)) of
       Some ((FCVT_D_WU, rd, rs1, rm)) => True
     | _ => False
     )) then  (case 
 (s2871 s13460 :: (( f_un_rm_op_D * 5 Word.word * 5 Word.word * rounding_mode)) option) of
     (Some ((FCVT_D_WU, rd, rs1, rm))) =>
 return (F_UN_RM_TYPE_D (rs1, rm, rd, FCVT_D_WU))
 )
   else if ((case  ((s2888 s13460
                     ::  ((f_un_rm_op_D *  5 Word.word *  5 Word.word * rounding_mode))option)) of
       Some ((FCVT_L_D, rd, rs1, rm)) => True
     | _ => False
     )) then  (case 
 (s2888 s13460 :: (( f_un_rm_op_D * 5 Word.word * 5 Word.word * rounding_mode)) option) of
     (Some ((FCVT_L_D, rd, rs1, rm))) =>
 return (F_UN_RM_TYPE_D (rs1, rm, rd, FCVT_L_D))
 )
   else if ((case  ((s2905 s13460
                     ::  ((f_un_rm_op_D *  5 Word.word *  5 Word.word * rounding_mode))option)) of
       Some ((FCVT_LU_D, rd, rs1, rm)) => True
     | _ => False
     )) then  (case 
 (s2905 s13460 :: (( f_un_rm_op_D * 5 Word.word * 5 Word.word * rounding_mode)) option) of
     (Some ((FCVT_LU_D, rd, rs1, rm))) =>
 return (F_UN_RM_TYPE_D (rs1, rm, rd, FCVT_LU_D))
 )
   else if ((case  ((s2922 s13460
                     ::  ((f_un_rm_op_D *  5 Word.word *  5 Word.word * rounding_mode))option)) of
       Some ((FCVT_D_L, rd, rs1, rm)) => True
     | _ => False
     )) then  (case 
 (s2922 s13460 :: (( f_un_rm_op_D * 5 Word.word * 5 Word.word * rounding_mode)) option) of
     (Some ((FCVT_D_L, rd, rs1, rm))) =>
 return (F_UN_RM_TYPE_D (rs1, rm, rd, FCVT_D_L))
 )
   else if ((case  ((s2939 s13460
                     ::  ((f_un_rm_op_D *  5 Word.word *  5 Word.word * rounding_mode))option)) of
       Some ((FCVT_D_LU, rd, rs1, rm)) => True
     | _ => False
     )) then  (case 
 (s2939 s13460 :: (( f_un_rm_op_D * 5 Word.word * 5 Word.word * rounding_mode)) option) of
     (Some ((FCVT_D_LU, rd, rs1, rm))) =>
 return (F_UN_RM_TYPE_D (rs1, rm, rd, FCVT_D_LU))
 )
   else if ((case  ((s2956 s13460
                     ::  ((f_un_rm_op_D *  5 Word.word *  5 Word.word * rounding_mode))option)) of
       Some ((FCVT_S_D, rd, rs1, rm)) => True
     | _ => False
     )) then  (case 
 (s2956 s13460 :: (( f_un_rm_op_D * 5 Word.word * 5 Word.word * rounding_mode)) option) of
     (Some ((FCVT_S_D, rd, rs1, rm))) =>
 return (F_UN_RM_TYPE_D (rs1, rm, rd, FCVT_S_D))
 )
   else if ((case  ((s2973 s13460
                     ::  ((f_un_rm_op_D *  5 Word.word *  5 Word.word * rounding_mode))option)) of
       Some ((FCVT_D_S, rd, rs1, rm)) => True
     | _ => False
     )) then  (case 
 (s2973 s13460 :: (( f_un_rm_op_D * 5 Word.word * 5 Word.word * rounding_mode)) option) of
     (Some ((FCVT_D_S, rd, rs1, rm))) =>
 return (F_UN_RM_TYPE_D (rs1, rm, rd, FCVT_D_S))
 )
   else if ((case  ((s2990 s13460  ::  ((f_bin_op_D *  5 Word.word *  5 Word.word *  5 Word.word))option)) of
       Some ((FSGNJ_D, rd, rs1, rs2)) => True
     | _ => False
     )) then  (case 
 (s2990 s13460 :: (( f_bin_op_D * 5 Word.word * 5 Word.word * 5 Word.word)) option) of
     (Some ((FSGNJ_D, rd, rs1, rs2))) =>
 return (F_BIN_TYPE_D (rs2, rs1, rd, FSGNJ_D))
 )
   else if ((case  ((s3007 s13460  ::  ((f_bin_op_D *  5 Word.word *  5 Word.word *  5 Word.word))option)) of
       Some ((FSGNJN_D, rd, rs1, rs2)) => True
     | _ => False
     )) then  (case 
 (s3007 s13460 :: (( f_bin_op_D * 5 Word.word * 5 Word.word * 5 Word.word)) option) of
     (Some ((FSGNJN_D, rd, rs1, rs2))) =>
 return (F_BIN_TYPE_D (rs2, rs1, rd, FSGNJN_D))
 )
   else if ((case  ((s3024 s13460  ::  ((f_bin_op_D *  5 Word.word *  5 Word.word *  5 Word.word))option)) of
       Some ((FSGNJX_D, rd, rs1, rs2)) => True
     | _ => False
     )) then  (case 
 (s3024 s13460 :: (( f_bin_op_D * 5 Word.word * 5 Word.word * 5 Word.word)) option) of
     (Some ((FSGNJX_D, rd, rs1, rs2))) =>
 return (F_BIN_TYPE_D (rs2, rs1, rd, FSGNJX_D))
 )
   else if ((case  ((s3041 s13460  ::  ((f_bin_op_D *  5 Word.word *  5 Word.word *  5 Word.word))option)) of
       Some ((FMIN_D, rd, rs1, rs2)) => True
     | _ => False
     )) then  (case 
 (s3041 s13460 :: (( f_bin_op_D * 5 Word.word * 5 Word.word * 5 Word.word)) option) of
     (Some ((FMIN_D, rd, rs1, rs2))) =>
 return (F_BIN_TYPE_D (rs2, rs1, rd, FMIN_D))
 )
   else if ((case  ((s3058 s13460  ::  ((f_bin_op_D *  5 Word.word *  5 Word.word *  5 Word.word))option)) of
       Some ((FMAX_D, rd, rs1, rs2)) => True
     | _ => False
     )) then  (case 
 (s3058 s13460 :: (( f_bin_op_D * 5 Word.word * 5 Word.word * 5 Word.word)) option) of
     (Some ((FMAX_D, rd, rs1, rs2))) =>
 return (F_BIN_TYPE_D (rs2, rs1, rd, FMAX_D))
 )
   else if ((case  ((s3075 s13460  ::  ((f_bin_op_D *  5 Word.word *  5 Word.word *  5 Word.word))option)) of
       Some ((FEQ_D, rd, rs1, rs2)) => True
     | _ => False
     )) then  (case 
 (s3075 s13460 :: (( f_bin_op_D * 5 Word.word * 5 Word.word * 5 Word.word)) option) of
     (Some ((FEQ_D, rd, rs1, rs2))) =>
 return (F_BIN_TYPE_D (rs2, rs1, rd, FEQ_D))
 )
   else if ((case  ((s3092 s13460  ::  ((f_bin_op_D *  5 Word.word *  5 Word.word *  5 Word.word))option)) of
       Some ((FLT_D, rd, rs1, rs2)) => True
     | _ => False
     )) then  (case 
 (s3092 s13460 :: (( f_bin_op_D * 5 Word.word * 5 Word.word * 5 Word.word)) option) of
     (Some ((FLT_D, rd, rs1, rs2))) =>
 return (F_BIN_TYPE_D (rs2, rs1, rd, FLT_D))
 )
   else if ((case  ((s3109 s13460  ::  ((f_bin_op_D *  5 Word.word *  5 Word.word *  5 Word.word))option)) of
       Some ((FLE_D, rd, rs1, rs2)) => True
     | _ => False
     )) then  (case 
 (s3109 s13460 :: (( f_bin_op_D * 5 Word.word * 5 Word.word * 5 Word.word)) option) of
     (Some ((FLE_D, rd, rs1, rs2))) =>
 return (F_BIN_TYPE_D (rs2, rs1, rd, FLE_D))
 )
   else if ((case  ((s3126 s13460  ::  ((f_un_op_D *  5 Word.word *  5 Word.word))option)) of
       Some ((FMV_X_D, rd, rs1)) => True
     | _ => False
     )) then  (case 
 (s3126 s13460 :: (( f_un_op_D * 5 Word.word * 5 Word.word)) option) of
     (Some ((FMV_X_D, rd, rs1))) =>
 return (F_UN_TYPE_D (rs1, rd, FMV_X_D))
 )
   else if ((case  ((s3139 s13460  ::  ((f_un_op_D *  5 Word.word *  5 Word.word))option)) of
       Some ((FMV_D_X, rd, rs1)) => True
     | _ => False
     )) then  (case 
 (s3139 s13460 :: (( f_un_op_D * 5 Word.word * 5 Word.word)) option) of
     (Some ((FMV_D_X, rd, rs1))) =>
 return (F_UN_TYPE_D (rs1, rd, FMV_D_X))
 )
   else if ((case  ((s3152 s13460  ::  ((f_un_op_D *  5 Word.word *  5 Word.word))option)) of
       Some ((FCLASS_D, rd, rs1)) => True
     | _ => False
     )) then  (case 
 (s3152 s13460 :: (( f_un_op_D * 5 Word.word * 5 Word.word)) option) of
     (Some ((FCLASS_D, rd, rs1))) =>
 return (F_UN_TYPE_D (rs1, rd, FCLASS_D))
 )
   else if ((case  ((s3165 s13460  ::  (( 5 Word.word *  6 Word.word))option)) of
       Some ((rd, uimm)) => (((((( 64 :: int)::ii) = (( 32 :: int)::ii)))) \<or> ((((( 64 :: int)::ii) = (( 64 :: int)::ii)))))
     | _ => False
     )) then  (case  (s3165 s13460 :: (( 5 Word.word * 6 Word.word)) option) of
     (Some ((rd, uimm))) =>
 return (C_FLDSP (uimm, rd))
 )
   else if ((case  ((s3177 s13460  ::  (( 5 Word.word *  6 Word.word))option)) of
       Some ((rs2, uimm)) => (((((( 64 :: int)::ii) = (( 32 :: int)::ii)))) \<or> ((((( 64 :: int)::ii) = (( 64 :: int)::ii)))))
     | _ => False
     )) then  (case  (s3177 s13460 :: (( 5 Word.word * 6 Word.word)) option) of
     (Some ((rs2, uimm))) =>
 return (C_FSDSP (uimm, rs2))
 )
   else if ((case  ((s3189 s13460  ::  (( 3 Word.word *  3 Word.word *  5 Word.word))option)) of
       Some ((rdc, rsc, uimm)) => (((((( 64 :: int)::ii) = (( 32 :: int)::ii)))) \<or> ((((( 64 :: int)::ii) = (( 64 :: int)::ii)))))
     | _ => False
     )) then  (case 
 (s3189 s13460 :: (( 3 Word.word * 3 Word.word * 5 Word.word)) option) of
     (Some ((rdc, rsc, uimm))) =>
 return (C_FLD (uimm, rsc, rdc))
 )
   else if ((case  ((s3205 s13460  ::  (( 3 Word.word *  3 Word.word *  5 Word.word))option)) of
       Some ((rsc1, rsc2, uimm)) => (((((( 64 :: int)::ii) = (( 32 :: int)::ii)))) \<or> ((((( 64 :: int)::ii) = (( 64 :: int)::ii)))))
     | _ => False
     )) then  (case 
 (s3205 s13460 :: (( 3 Word.word * 3 Word.word * 5 Word.word)) option) of
     (Some ((rsc1, rsc2, uimm))) =>
 return (C_FSD (uimm, rsc1, rsc2))
 )
   else if ((case  ((s3221 s13460  ::  ( 32 Word.word)option)) of   Some (s) => True | _ => False ))
   then  (case  (s3221 s13460 :: ( 32 Word.word) option) of
     (Some (s)) =>
 return (ILLEGAL s)
 )
   else if ((case  ((s3229 s13460  ::  ( 16 Word.word)option)) of   Some (s) => True | _ => False ))
   then  (case  (s3229 s13460 :: ( 16 Word.word) option) of
     (Some (s)) =>
 return (C_ILLEGAL s)
 )
   else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))\<close> 
  for  arg1  :: " string "


definition assembly_forwards_matches  :: \<open> ast \<Rightarrow> bool \<close>  where 
     \<open> assembly_forwards_matches ast = (
   (let arg1 = ast in  
  (case  arg1 of
        UTYPE ((imm, rd, op1)) => True
    | RISCV_JAL ((imm, rd)) => True
    | RISCV_JALR ((imm, rs1, rd)) => True
    | BTYPE ((imm, rs2, rs1, op1)) => True
    | ITYPE ((imm, rs1, rd, op1)) => True
    | SHIFTIOP ((shamt, rs1, rd, op1)) => True
    | RTYPE ((rs2, rs1, rd, op1)) => True
    | LOAD ((imm, rs1, rd, is_unsigned, size1, aq, rl)) => True
    | STORE ((imm, rs2, rs1, size1, aq, rl)) => True
    | ADDIW ((imm, rs1, rd)) =>
  if ((((( 64 :: int):: ii) = (( 64 :: int):: ii)))) then True else False
    | SHIFTW ((shamt, rs1, rd, op1)) =>
  if ((((( 64 :: int):: ii) = (( 64 :: int):: ii)))) then True else False
    | RTYPEW ((rs2, rs1, rd, op1)) =>
  if ((((( 64 :: int):: ii) = (( 64 :: int):: ii)))) then True else False
    | SHIFTIWOP ((shamt, rs1, rd, op1)) =>
  if ((((( 64 :: int):: ii) = (( 64 :: int):: ii)))) then True else False
    | FENCE ((pred, succ)) => True
    | FENCE_TSO ((pred, succ)) => True
    | FENCEI (_) => True
    | ECALL (_) => True
    | MRET (_) => True
    | SRET (_) => True
    | EBREAK (_) => True
    | WFI (_) => True
    | SFENCE_VMA ((rs1, rs2)) => True
    | LOADRES ((aq, rl, rs1, size1, rd)) => True
    | STORECON ((aq, rl, rs2, rs1, size1, rd)) => True
    | AMO ((op1, aq, rl, rs2, rs1, width, rd)) => True
    | C_NOP (_) => True
    | C_ADDI4SPN ((rdc, nzimm)) =>
  if (((nzimm \<noteq> ( 0x00 :: 8 Word.word)))) then True else False
    | C_LW ((uimm, rsc, rdc)) => True
    | C_LD ((uimm, rsc, rdc)) =>
  if ((((( 64 :: int):: ii) = (( 64 :: int):: ii)))) then True else False
    | C_SW ((uimm, rsc1, rsc2)) => True
    | C_SD ((uimm, rsc1, rsc2)) =>
  if ((((( 64 :: int):: ii) = (( 64 :: int):: ii)))) then True else False
    | C_ADDI ((nzi, rsd)) =>
  if ((((((nzi \<noteq> ( 0b000000 :: 6 Word.word)))) \<and>
          (((rsd \<noteq> zreg)))))) then True else False
    | C_JAL (imm) =>
  if ((((( 64 :: int):: ii) = (( 32 :: int):: ii)))) then True else False
    | C_ADDIW ((imm, rsd)) =>
  if ((((( 64 :: int):: ii) = (( 64 :: int):: ii)))) then True else False
    | C_LI ((imm, rd)) =>
  if (((rd \<noteq> zreg))) then True else False
    | C_ADDI16SP (imm) =>
  if (((imm \<noteq> ( 0b000000 :: 6 Word.word)))) then True else False
    | C_LUI ((imm, rd)) =>
  if ((((((rd \<noteq> zreg))) \<and>
          ((((((rd \<noteq> sp))) \<and>
               (((imm \<noteq> ( 0b000000 :: 6 Word.word)))))))))) then 
  True else False
    | C_SRLI ((shamt, rsd)) =>
  if (((shamt \<noteq> ( 0b000000 :: 6 Word.word)))) then True else False
    | C_SRAI ((shamt, rsd)) =>
  if (((shamt \<noteq> ( 0b000000 :: 6 Word.word)))) then True else False
    | C_ANDI ((imm, rsd)) => True
    | C_SUB ((rsd, rs2)) => True
    | C_XOR ((rsd, rs2)) => True
    | C_OR ((rsd, rs2)) => True
    | C_AND ((rsd, rs2)) => True
    | C_SUBW ((rsd, rs2)) =>
  if ((((( 64 :: int):: ii) = (( 64 :: int):: ii)))) then True else False
    | C_ADDW ((rsd, rs2)) =>
  if ((((( 64 :: int):: ii) = (( 64 :: int):: ii)))) then True else False
    | C_J (imm) => True
    | C_BEQZ ((imm, rs)) => True
    | C_BNEZ ((imm, rs)) => True
    | C_SLLI ((shamt, rsd)) =>
  if ((((((shamt \<noteq> ( 0b000000 :: 6 Word.word)))) \<and>
          (((rsd \<noteq> zreg)))))) then True else False
    | C_LWSP ((uimm, rd)) =>
  if (((rd \<noteq> zreg))) then True else False
    | C_LDSP ((uimm, rd)) =>
  if ((((((rd \<noteq> zreg))) \<and>
          ((((( 64 :: int):: ii) = (( 64 :: int):: ii))))))) then True else
    False
    | C_SWSP ((uimm, rd)) => True
    | C_SDSP ((uimm, rs2)) =>
  if ((((( 64 :: int):: ii) = (( 64 :: int):: ii)))) then True else False
    | C_JR (rs1) =>
  if (((rs1 \<noteq> zreg))) then True else False
    | C_JALR (rs1) =>
  if (((rs1 \<noteq> zreg))) then True else False
    | C_MV ((rd, rs2)) =>
  if ((((((rd \<noteq> zreg))) \<and> (((rs2 \<noteq> zreg)))))) then 
  True else False
    | C_EBREAK (_) => True
    | C_ADD ((rsd, rs2)) =>
  if ((((((rsd \<noteq> zreg))) \<and> (((rs2 \<noteq> zreg)))))) then 
  True else False
    | MUL ((rs2, rs1, rd, high, signed1, signed2)) => True
    | DIV ((rs2, rs1, rd, s)) => True
    | REM ((rs2, rs1, rd, s)) => True
    | MULW ((rs2, rs1, rd)) =>
  if ((((( 64 :: int):: ii) = (( 64 :: int):: ii)))) then True else False
    | DIVW ((rs2, rs1, rd, s)) =>
  if ((((( 64 :: int):: ii) = (( 64 :: int):: ii)))) then True else False
    | REMW ((rs2, rs1, rd, s)) =>
  if ((((( 64 :: int):: ii) = (( 64 :: int):: ii)))) then True else False
    | CSR ((csr, rs1, rd, True, op1)) => True
    | CSR ((csr, rs1, rd, False, op1)) => True
    | URET (_) => True
    | C_NOP_HINT (imm) => True
    | C_ADDI_HINT (rsd) =>
  if (((rsd \<noteq> zreg))) then True else False
    | C_LI_HINT (imm) => True
    | C_LUI_HINT (imm) =>
  if (((imm \<noteq> ( 0b000000 :: 6 Word.word)))) then True else False
    | C_MV_HINT (rs2) =>
  if (((rs2 \<noteq> zreg))) then True else False
    | C_ADD_HINT (rs2) =>
  if (((rs2 \<noteq> zreg))) then True else False
    | C_SLLI_HINT ((shamt, rsd)) =>
  if ((((((shamt = ( 0b000000 :: 6 Word.word)))) \<or> (((rsd = zreg)))))) then
    True else False
    | C_SRLI_HINT (rsd) => True
    | C_SRAI_HINT (rsd) => True
    | FENCE_RESERVED ((fm, pred, succ, rs, rd)) =>
  if (((((((((fm \<noteq> ( 0x0 :: 4 Word.word)))) \<and>
             (((fm \<noteq> ( 0x8 :: 4 Word.word))))))) \<or>
          ((((((rs \<noteq> ( 0b00000 :: 5 Word.word)))) \<or>
               (((rd \<noteq> ( 0b00000 :: 5 Word.word)))))))))) then 
  True else False
    | FENCEI_RESERVED ((imm, rs, rd)) =>
  if ((((((imm \<noteq> ( 0x000 :: 12 Word.word)))) \<or>
          ((((((rs \<noteq> zreg))) \<or> (((rd \<noteq> zreg))))))))) then
    True else False
    | LOAD_FP ((imm, rs1, rd, width)) => True
    | STORE_FP ((imm, rs2, rs1, width)) => True
    | F_MADD_TYPE_S ((rs3, rs2, rs1, rm, rd, op1)) => True
    | F_BIN_RM_TYPE_S ((rs2, rs1, rm, rd, op1)) => True
    | F_UN_RM_TYPE_S ((rs1, rm, rd, FSQRT_S)) => True
    | F_UN_RM_TYPE_S ((rs1, rm, rd, FCVT_W_S)) => True
    | F_UN_RM_TYPE_S ((rs1, rm, rd, FCVT_WU_S)) => True
    | F_UN_RM_TYPE_S ((rs1, rm, rd, FCVT_S_W)) => True
    | F_UN_RM_TYPE_S ((rs1, rm, rd, FCVT_S_WU)) => True
    | F_UN_RM_TYPE_S ((rs1, rm, rd, FCVT_L_S)) => True
    | F_UN_RM_TYPE_S ((rs1, rm, rd, FCVT_LU_S)) => True
    | F_UN_RM_TYPE_S ((rs1, rm, rd, FCVT_S_L)) => True
    | F_UN_RM_TYPE_S ((rs1, rm, rd, FCVT_S_LU)) => True
    | F_BIN_TYPE_S ((rs2, rs1, rd, FSGNJ_S)) => True
    | F_BIN_TYPE_S ((rs2, rs1, rd, FSGNJN_S)) => True
    | F_BIN_TYPE_S ((rs2, rs1, rd, FSGNJX_S)) => True
    | F_BIN_TYPE_S ((rs2, rs1, rd, FMIN_S)) => True
    | F_BIN_TYPE_S ((rs2, rs1, rd, FMAX_S)) => True
    | F_BIN_TYPE_S ((rs2, rs1, rd, FEQ_S)) => True
    | F_BIN_TYPE_S ((rs2, rs1, rd, FLT_S)) => True
    | F_BIN_TYPE_S ((rs2, rs1, rd, FLE_S)) => True
    | F_UN_TYPE_S ((rs1, rd, FMV_X_W)) => True
    | F_UN_TYPE_S ((rs1, rd, FMV_W_X)) => True
    | F_UN_TYPE_S ((rs1, rd, FCLASS_S)) => True
    | C_FLWSP ((imm, rd)) =>
  if ((((( 64 :: int):: ii) = (( 32 :: int):: ii)))) then True else False
    | C_FSWSP ((uimm, rd)) =>
  if ((((( 64 :: int):: ii) = (( 32 :: int):: ii)))) then True else False
    | C_FLW ((uimm, rsc, rdc)) =>
  if ((((( 64 :: int):: ii) = (( 32 :: int):: ii)))) then True else False
    | C_FSW ((uimm, rsc1, rsc2)) =>
  if ((((( 64 :: int):: ii) = (( 32 :: int):: ii)))) then True else False
    | F_MADD_TYPE_D ((rs3, rs2, rs1, rm, rd, op1)) => True
    | F_BIN_RM_TYPE_D ((rs2, rs1, rm, rd, op1)) => True
    | F_UN_RM_TYPE_D ((rs1, rm, rd, FSQRT_D)) => True
    | F_UN_RM_TYPE_D ((rs1, rm, rd, FCVT_W_D)) => True
    | F_UN_RM_TYPE_D ((rs1, rm, rd, FCVT_WU_D)) => True
    | F_UN_RM_TYPE_D ((rs1, rm, rd, FCVT_D_W)) => True
    | F_UN_RM_TYPE_D ((rs1, rm, rd, FCVT_D_WU)) => True
    | F_UN_RM_TYPE_D ((rs1, rm, rd, FCVT_L_D)) => True
    | F_UN_RM_TYPE_D ((rs1, rm, rd, FCVT_LU_D)) => True
    | F_UN_RM_TYPE_D ((rs1, rm, rd, FCVT_D_L)) => True
    | F_UN_RM_TYPE_D ((rs1, rm, rd, FCVT_D_LU)) => True
    | F_UN_RM_TYPE_D ((rs1, rm, rd, FCVT_S_D)) => True
    | F_UN_RM_TYPE_D ((rs1, rm, rd, FCVT_D_S)) => True
    | F_BIN_TYPE_D ((rs2, rs1, rd, FSGNJ_D)) => True
    | F_BIN_TYPE_D ((rs2, rs1, rd, FSGNJN_D)) => True
    | F_BIN_TYPE_D ((rs2, rs1, rd, FSGNJX_D)) => True
    | F_BIN_TYPE_D ((rs2, rs1, rd, FMIN_D)) => True
    | F_BIN_TYPE_D ((rs2, rs1, rd, FMAX_D)) => True
    | F_BIN_TYPE_D ((rs2, rs1, rd, FEQ_D)) => True
    | F_BIN_TYPE_D ((rs2, rs1, rd, FLT_D)) => True
    | F_BIN_TYPE_D ((rs2, rs1, rd, FLE_D)) => True
    | F_UN_TYPE_D ((rs1, rd, FMV_X_D)) => True
    | F_UN_TYPE_D ((rs1, rd, FMV_D_X)) => True
    | F_UN_TYPE_D ((rs1, rd, FCLASS_D)) => True
    | C_FLDSP ((uimm, rd)) =>
  if (((((((( 64 :: int):: ii) = (( 32 :: int):: ii)))) \<or>
          ((((( 64 :: int):: ii) = (( 64 :: int):: ii))))))) then True else
    False
    | C_FSDSP ((uimm, rs2)) =>
  if (((((((( 64 :: int):: ii) = (( 32 :: int):: ii)))) \<or>
          ((((( 64 :: int):: ii) = (( 64 :: int):: ii))))))) then True else
    False
    | C_FLD ((uimm, rsc, rdc)) =>
  if (((((((( 64 :: int):: ii) = (( 32 :: int):: ii)))) \<or>
          ((((( 64 :: int):: ii) = (( 64 :: int):: ii))))))) then True else
    False
    | C_FSD ((uimm, rsc1, rsc2)) =>
  if (((((((( 64 :: int):: ii) = (( 32 :: int):: ii)))) \<or>
          ((((( 64 :: int):: ii) = (( 64 :: int):: ii))))))) then True else
    False
    | ILLEGAL (s) => True
    | C_ILLEGAL (s) => True
  )))\<close> 
  for  ast  :: " ast "


\<comment> \<open>\<open>val _s5132_ : string -> maybe (mword ty16)\<close>\<close>

definition s5132  :: \<open> string \<Rightarrow>((16)Word.word)option \<close>  where 
     \<open> s5132 s51330 = (
   (let s51340 = s51330 in
   if ((string_startswith s51340 (''c.illegal''))) then  
  (case  ((string_drop s51340 ((string_length (''c.illegal''))))) of
        s51350 =>
  (case  ((spc_matches_prefix0 s51350)) of
        Some ((_, s51360)) =>
  (case  ((string_drop s51350 s51360)) of
        s51370 =>
  (case  ((hex_bits_16_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s51370 :: (( 16 Word.word * ii)) option)) of
        Some ((s, s51380)) =>
  (let p00 = (string_drop s51370 s51380) in
  if (((p00 = ('''')))) then Some s else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s51330  :: " string "


\<comment> \<open>\<open>val _s5124_ : string -> maybe (mword ty32)\<close>\<close>

definition s5124  :: \<open> string \<Rightarrow>((32)Word.word)option \<close>  where 
     \<open> s5124 s51250 = (
   (let s51260 = s51250 in
   if ((string_startswith s51260 (''illegal''))) then  
  (case  ((string_drop s51260 ((string_length (''illegal''))))) of
        s51270 =>
  (case  ((spc_matches_prefix0 s51270)) of
        Some ((_, s51280)) =>
  (case  ((string_drop s51270 s51280)) of
        s51290 =>
  (case  ((hex_bits_32_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s51290 :: (( 32 Word.word * ii)) option)) of
        Some ((s, s51300)) =>
  (let p00 = (string_drop s51290 s51300) in
  if (((p00 = ('''')))) then Some s else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s51250  :: " string "


\<comment> \<open>\<open>val _s5108_ : string -> maybe ((mword ty3 * mword ty3 * mword ty5))\<close>\<close>

definition s5108  :: \<open> string \<Rightarrow>((3)Word.word*(3)Word.word*(5)Word.word)option \<close>  where 
     \<open> s5108 s51090 = (
   (let s51100 = s51090 in
   if ((string_startswith s51100 (''c.fsd''))) then  
  (case  ((string_drop s51100 ((string_length (''c.fsd''))))) of
        s51110 =>
  (case  ((spc_matches_prefix0 s51110)) of
        Some ((_, s51120)) =>
  (case  ((string_drop s51110 s51120)) of
        s51130 =>
  (case  ((creg_name_matches_prefix s51130 :: (( 3 Word.word * ii)) option)) of
        Some ((rsc1, s51140)) =>
  (case  ((string_drop s51130 s51140)) of
        s51150 =>
  (case  ((sep_matches_prefix s51150)) of
        Some ((_, s51160)) =>
  (case  ((string_drop s51150 s51160)) of
        s51170 =>
  (case  ((creg_name_matches_prefix s51170 :: (( 3 Word.word * ii)) option)) of
        Some ((rsc2, s51180)) =>
  (case  ((string_drop s51170 s51180)) of
        s51190 =>
  (case  ((sep_matches_prefix s51190)) of
        Some ((_, s51200)) =>
  (case  ((string_drop s51190 s51200)) of
        s51210 =>
  (case  ((hex_bits_8_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s51210 :: (( 8 Word.word * ii)) option)) of
        Some ((v__1462, s51220)) =>
  if (((((subrange_vec_dec v__1462 (( 2 :: int):: ii) (( 0 :: int):: ii)
         :: 3 Word.word)) = ( 0b000 :: 3 Word.word)))) then
    (let (uimm :: 5 Word.word) =
         ((subrange_vec_dec v__1462 (( 7 :: int):: ii) (( 3 :: int):: ii) :: 5 Word.word)) in
    (let (uimm :: 5 Word.word) =
         ((subrange_vec_dec v__1462 (( 7 :: int):: ii) (( 3 :: int):: ii) :: 5 Word.word)) in
    (let p00 = (string_drop s51210 s51220) in
    if (((p00 = ('''')))) then Some (rsc1, rsc2, uimm) else None))) else 
  None
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s51090  :: " string "


\<comment> \<open>\<open>val _s5092_ : string -> maybe ((mword ty3 * mword ty3 * mword ty5))\<close>\<close>

definition s5092  :: \<open> string \<Rightarrow>((3)Word.word*(3)Word.word*(5)Word.word)option \<close>  where 
     \<open> s5092 s50930 = (
   (let s50940 = s50930 in
   if ((string_startswith s50940 (''c.fld''))) then  
  (case  ((string_drop s50940 ((string_length (''c.fld''))))) of
        s50950 =>
  (case  ((spc_matches_prefix0 s50950)) of
        Some ((_, s50960)) =>
  (case  ((string_drop s50950 s50960)) of
        s50970 =>
  (case  ((creg_name_matches_prefix s50970 :: (( 3 Word.word * ii)) option)) of
        Some ((rdc, s50980)) =>
  (case  ((string_drop s50970 s50980)) of
        s50990 =>
  (case  ((sep_matches_prefix s50990)) of
        Some ((_, s51000)) =>
  (case  ((string_drop s50990 s51000)) of
        s51010 =>
  (case  ((creg_name_matches_prefix s51010 :: (( 3 Word.word * ii)) option)) of
        Some ((rsc, s51020)) =>
  (case  ((string_drop s51010 s51020)) of
        s51030 =>
  (case  ((sep_matches_prefix s51030)) of
        Some ((_, s51040)) =>
  (case  ((string_drop s51030 s51040)) of
        s51050 =>
  (case  ((hex_bits_8_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s51050 :: (( 8 Word.word * ii)) option)) of
        Some ((v__1464, s51060)) =>
  if (((((subrange_vec_dec v__1464 (( 2 :: int):: ii) (( 0 :: int):: ii)
         :: 3 Word.word)) = ( 0b000 :: 3 Word.word)))) then
    (let (uimm :: 5 Word.word) =
         ((subrange_vec_dec v__1464 (( 7 :: int):: ii) (( 3 :: int):: ii) :: 5 Word.word)) in
    (let (uimm :: 5 Word.word) =
         ((subrange_vec_dec v__1464 (( 7 :: int):: ii) (( 3 :: int):: ii) :: 5 Word.word)) in
    (let p00 = (string_drop s51050 s51060) in
    if (((p00 = ('''')))) then Some (rdc, rsc, uimm) else None))) else 
  None
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s50930  :: " string "


\<comment> \<open>\<open>val _s5080_ : string -> maybe ((mword ty5 * mword ty6))\<close>\<close>

definition s5080  :: \<open> string \<Rightarrow>((5)Word.word*(6)Word.word)option \<close>  where 
     \<open> s5080 s50810 = (
   (let s50820 = s50810 in
   if ((string_startswith s50820 (''c.fsdsp''))) then  
  (case  ((string_drop s50820 ((string_length (''c.fsdsp''))))) of
        s50830 =>
  (case  ((spc_matches_prefix0 s50830)) of
        Some ((_, s50840)) =>
  (case  ((string_drop s50830 s50840)) of
        s50850 =>
  (case  ((reg_name_matches_prefix s50850 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s50860)) =>
  (case  ((string_drop s50850 s50860)) of
        s50870 =>
  (case  ((sep_matches_prefix s50870)) of
        Some ((_, s50880)) =>
  (case  ((string_drop s50870 s50880)) of
        s50890 =>
  (case  ((hex_bits_6_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s50890 :: (( 6 Word.word * ii)) option)) of
        Some ((uimm, s50900)) =>
  (let p00 = (string_drop s50890 s50900) in
  if (((p00 = ('''')))) then Some (rs2, uimm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s50810  :: " string "


\<comment> \<open>\<open>val _s5068_ : string -> maybe ((mword ty5 * mword ty6))\<close>\<close>

definition s5068  :: \<open> string \<Rightarrow>((5)Word.word*(6)Word.word)option \<close>  where 
     \<open> s5068 s50690 = (
   (let s50700 = s50690 in
   if ((string_startswith s50700 (''c.fldsp''))) then  
  (case  ((string_drop s50700 ((string_length (''c.fldsp''))))) of
        s50710 =>
  (case  ((spc_matches_prefix0 s50710)) of
        Some ((_, s50720)) =>
  (case  ((string_drop s50710 s50720)) of
        s50730 =>
  (case  ((reg_name_matches_prefix s50730 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s50740)) =>
  (case  ((string_drop s50730 s50740)) of
        s50750 =>
  (case  ((sep_matches_prefix s50750)) of
        Some ((_, s50760)) =>
  (case  ((string_drop s50750 s50760)) of
        s50770 =>
  (case  ((hex_bits_6_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s50770 :: (( 6 Word.word * ii)) option)) of
        Some ((uimm, s50780)) =>
  (let p00 = (string_drop s50770 s50780) in
  if (((p00 = ('''')))) then Some (rd, uimm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s50690  :: " string "


\<comment> \<open>\<open>val _s5055_ : string -> maybe ((f_un_op_D * mword ty5 * mword ty5))\<close>\<close>

definition s5055  :: \<open> string \<Rightarrow>(f_un_op_D*(5)Word.word*(5)Word.word)option \<close>  where 
     \<open> s5055 s50570 = (
      (case  ((f_un_type_mnemonic_D_matches_prefix s50570)) of
        Some ((FCLASS_D, s50580)) => 
  (case  ((string_drop s50570 s50580)) of
        s50590 =>
  (case  ((spc_matches_prefix0 s50590)) of
        Some ((_, s50600)) =>
  (case  ((string_drop s50590 s50600)) of
        s50610 =>
  (case  ((reg_name_matches_prefix s50610 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s50620)) =>
  (case  ((string_drop s50610 s50620)) of
        s50630 =>
  (case  ((sep_matches_prefix s50630)) of
        Some ((_, s50640)) =>
  (case  ((string_drop s50630 s50640)) of
        s50650 =>
  (case  ((freg_name_matches_prefix s50650 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s50660)) =>
  (let p00 = (string_drop s50650 s50660) in
  if (((p00 = ('''')))) then Some (FCLASS_D, rd, rs1) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s50570  :: " string "


\<comment> \<open>\<open>val _s5042_ : string -> maybe ((f_un_op_D * mword ty5 * mword ty5))\<close>\<close>

definition s5042  :: \<open> string \<Rightarrow>(f_un_op_D*(5)Word.word*(5)Word.word)option \<close>  where 
     \<open> s5042 s50440 = (
      (case  ((f_un_type_mnemonic_D_matches_prefix s50440)) of
        Some ((FMV_D_X, s50450)) => 
  (case  ((string_drop s50440 s50450)) of
        s50460 =>
  (case  ((spc_matches_prefix0 s50460)) of
        Some ((_, s50470)) =>
  (case  ((string_drop s50460 s50470)) of
        s50480 =>
  (case  ((freg_name_matches_prefix s50480 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s50490)) =>
  (case  ((string_drop s50480 s50490)) of
        s50500 =>
  (case  ((sep_matches_prefix s50500)) of
        Some ((_, s50510)) =>
  (case  ((string_drop s50500 s50510)) of
        s50520 =>
  (case  ((reg_name_matches_prefix s50520 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s50530)) =>
  (let p00 = (string_drop s50520 s50530) in
  if (((p00 = ('''')))) then Some (FMV_D_X, rd, rs1) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s50440  :: " string "


\<comment> \<open>\<open>val _s5029_ : string -> maybe ((f_un_op_D * mword ty5 * mword ty5))\<close>\<close>

definition s5029  :: \<open> string \<Rightarrow>(f_un_op_D*(5)Word.word*(5)Word.word)option \<close>  where 
     \<open> s5029 s50310 = (
      (case  ((f_un_type_mnemonic_D_matches_prefix s50310)) of
        Some ((FMV_X_D, s50320)) => 
  (case  ((string_drop s50310 s50320)) of
        s50330 =>
  (case  ((spc_matches_prefix0 s50330)) of
        Some ((_, s50340)) =>
  (case  ((string_drop s50330 s50340)) of
        s50350 =>
  (case  ((reg_name_matches_prefix s50350 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s50360)) =>
  (case  ((string_drop s50350 s50360)) of
        s50370 =>
  (case  ((sep_matches_prefix s50370)) of
        Some ((_, s50380)) =>
  (case  ((string_drop s50370 s50380)) of
        s50390 =>
  (case  ((freg_name_matches_prefix s50390 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s50400)) =>
  (let p00 = (string_drop s50390 s50400) in
  if (((p00 = ('''')))) then Some (FMV_X_D, rd, rs1) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s50310  :: " string "


\<comment> \<open>\<open>val _s5012_ : string -> maybe ((f_bin_op_D * mword ty5 * mword ty5 * mword ty5))\<close>\<close>

definition s5012  :: \<open> string \<Rightarrow>(f_bin_op_D*(5)Word.word*(5)Word.word*(5)Word.word)option \<close>  where 
     \<open> s5012 s50140 = (
      (case  ((f_bin_type_mnemonic_D_matches_prefix s50140)) of
        Some ((FLE_D, s50150)) => 
  (case  ((string_drop s50140 s50150)) of
        s50160 =>
  (case  ((spc_matches_prefix0 s50160)) of
        Some ((_, s50170)) =>
  (case  ((string_drop s50160 s50170)) of
        s50180 =>
  (case  ((reg_name_matches_prefix s50180 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s50190)) =>
  (case  ((string_drop s50180 s50190)) of
        s50200 =>
  (case  ((sep_matches_prefix s50200)) of
        Some ((_, s50210)) =>
  (case  ((string_drop s50200 s50210)) of
        s50220 =>
  (case  ((freg_name_matches_prefix s50220 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s50230)) =>
  (case  ((string_drop s50220 s50230)) of
        s50240 =>
  (case  ((sep_matches_prefix s50240)) of
        Some ((_, s50250)) =>
  (case  ((string_drop s50240 s50250)) of
        s50260 =>
  (case  ((freg_name_matches_prefix s50260 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s50270)) =>
  (let p00 = (string_drop s50260 s50270) in
  if (((p00 = ('''')))) then Some (FLE_D, rd, rs1, rs2) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s50140  :: " string "


\<comment> \<open>\<open>val _s4995_ : string -> maybe ((f_bin_op_D * mword ty5 * mword ty5 * mword ty5))\<close>\<close>

definition s4995  :: \<open> string \<Rightarrow>(f_bin_op_D*(5)Word.word*(5)Word.word*(5)Word.word)option \<close>  where 
     \<open> s4995 s49970 = (
      (case  ((f_bin_type_mnemonic_D_matches_prefix s49970)) of
        Some ((FLT_D, s49980)) => 
  (case  ((string_drop s49970 s49980)) of
        s49990 =>
  (case  ((spc_matches_prefix0 s49990)) of
        Some ((_, s50000)) =>
  (case  ((string_drop s49990 s50000)) of
        s50010 =>
  (case  ((reg_name_matches_prefix s50010 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s50020)) =>
  (case  ((string_drop s50010 s50020)) of
        s50030 =>
  (case  ((sep_matches_prefix s50030)) of
        Some ((_, s50040)) =>
  (case  ((string_drop s50030 s50040)) of
        s50050 =>
  (case  ((freg_name_matches_prefix s50050 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s50060)) =>
  (case  ((string_drop s50050 s50060)) of
        s50070 =>
  (case  ((sep_matches_prefix s50070)) of
        Some ((_, s50080)) =>
  (case  ((string_drop s50070 s50080)) of
        s50090 =>
  (case  ((freg_name_matches_prefix s50090 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s50100)) =>
  (let p00 = (string_drop s50090 s50100) in
  if (((p00 = ('''')))) then Some (FLT_D, rd, rs1, rs2) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s49970  :: " string "


\<comment> \<open>\<open>val _s4978_ : string -> maybe ((f_bin_op_D * mword ty5 * mword ty5 * mword ty5))\<close>\<close>

definition s4978  :: \<open> string \<Rightarrow>(f_bin_op_D*(5)Word.word*(5)Word.word*(5)Word.word)option \<close>  where 
     \<open> s4978 s49800 = (
      (case  ((f_bin_type_mnemonic_D_matches_prefix s49800)) of
        Some ((FEQ_D, s49810)) => 
  (case  ((string_drop s49800 s49810)) of
        s49820 =>
  (case  ((spc_matches_prefix0 s49820)) of
        Some ((_, s49830)) =>
  (case  ((string_drop s49820 s49830)) of
        s49840 =>
  (case  ((reg_name_matches_prefix s49840 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s49850)) =>
  (case  ((string_drop s49840 s49850)) of
        s49860 =>
  (case  ((sep_matches_prefix s49860)) of
        Some ((_, s49870)) =>
  (case  ((string_drop s49860 s49870)) of
        s49880 =>
  (case  ((freg_name_matches_prefix s49880 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s49890)) =>
  (case  ((string_drop s49880 s49890)) of
        s49900 =>
  (case  ((sep_matches_prefix s49900)) of
        Some ((_, s49910)) =>
  (case  ((string_drop s49900 s49910)) of
        s49920 =>
  (case  ((freg_name_matches_prefix s49920 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s49930)) =>
  (let p00 = (string_drop s49920 s49930) in
  if (((p00 = ('''')))) then Some (FEQ_D, rd, rs1, rs2) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s49800  :: " string "


\<comment> \<open>\<open>val _s4961_ : string -> maybe ((f_bin_op_D * mword ty5 * mword ty5 * mword ty5))\<close>\<close>

definition s4961  :: \<open> string \<Rightarrow>(f_bin_op_D*(5)Word.word*(5)Word.word*(5)Word.word)option \<close>  where 
     \<open> s4961 s49630 = (
      (case  ((f_bin_type_mnemonic_D_matches_prefix s49630)) of
        Some ((FMAX_D, s49640)) => 
  (case  ((string_drop s49630 s49640)) of
        s49650 =>
  (case  ((spc_matches_prefix0 s49650)) of
        Some ((_, s49660)) =>
  (case  ((string_drop s49650 s49660)) of
        s49670 =>
  (case  ((freg_name_matches_prefix s49670 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s49680)) =>
  (case  ((string_drop s49670 s49680)) of
        s49690 =>
  (case  ((sep_matches_prefix s49690)) of
        Some ((_, s49700)) =>
  (case  ((string_drop s49690 s49700)) of
        s49710 =>
  (case  ((freg_name_matches_prefix s49710 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s49720)) =>
  (case  ((string_drop s49710 s49720)) of
        s49730 =>
  (case  ((sep_matches_prefix s49730)) of
        Some ((_, s49740)) =>
  (case  ((string_drop s49730 s49740)) of
        s49750 =>
  (case  ((freg_name_matches_prefix s49750 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s49760)) =>
  (let p00 = (string_drop s49750 s49760) in
  if (((p00 = ('''')))) then Some (FMAX_D, rd, rs1, rs2) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s49630  :: " string "


\<comment> \<open>\<open>val _s4944_ : string -> maybe ((f_bin_op_D * mword ty5 * mword ty5 * mword ty5))\<close>\<close>

definition s4944  :: \<open> string \<Rightarrow>(f_bin_op_D*(5)Word.word*(5)Word.word*(5)Word.word)option \<close>  where 
     \<open> s4944 s49460 = (
      (case  ((f_bin_type_mnemonic_D_matches_prefix s49460)) of
        Some ((FMIN_D, s49470)) => 
  (case  ((string_drop s49460 s49470)) of
        s49480 =>
  (case  ((spc_matches_prefix0 s49480)) of
        Some ((_, s49490)) =>
  (case  ((string_drop s49480 s49490)) of
        s49500 =>
  (case  ((freg_name_matches_prefix s49500 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s49510)) =>
  (case  ((string_drop s49500 s49510)) of
        s49520 =>
  (case  ((sep_matches_prefix s49520)) of
        Some ((_, s49530)) =>
  (case  ((string_drop s49520 s49530)) of
        s49540 =>
  (case  ((freg_name_matches_prefix s49540 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s49550)) =>
  (case  ((string_drop s49540 s49550)) of
        s49560 =>
  (case  ((sep_matches_prefix s49560)) of
        Some ((_, s49570)) =>
  (case  ((string_drop s49560 s49570)) of
        s49580 =>
  (case  ((freg_name_matches_prefix s49580 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s49590)) =>
  (let p00 = (string_drop s49580 s49590) in
  if (((p00 = ('''')))) then Some (FMIN_D, rd, rs1, rs2) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s49460  :: " string "


\<comment> \<open>\<open>val _s4927_ : string -> maybe ((f_bin_op_D * mword ty5 * mword ty5 * mword ty5))\<close>\<close>

definition s4927  :: \<open> string \<Rightarrow>(f_bin_op_D*(5)Word.word*(5)Word.word*(5)Word.word)option \<close>  where 
     \<open> s4927 s49290 = (
      (case  ((f_bin_type_mnemonic_D_matches_prefix s49290)) of
        Some ((FSGNJX_D, s49300)) => 
  (case  ((string_drop s49290 s49300)) of
        s49310 =>
  (case  ((spc_matches_prefix0 s49310)) of
        Some ((_, s49320)) =>
  (case  ((string_drop s49310 s49320)) of
        s49330 =>
  (case  ((freg_name_matches_prefix s49330 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s49340)) =>
  (case  ((string_drop s49330 s49340)) of
        s49350 =>
  (case  ((sep_matches_prefix s49350)) of
        Some ((_, s49360)) =>
  (case  ((string_drop s49350 s49360)) of
        s49370 =>
  (case  ((freg_name_matches_prefix s49370 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s49380)) =>
  (case  ((string_drop s49370 s49380)) of
        s49390 =>
  (case  ((sep_matches_prefix s49390)) of
        Some ((_, s49400)) =>
  (case  ((string_drop s49390 s49400)) of
        s49410 =>
  (case  ((freg_name_matches_prefix s49410 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s49420)) =>
  (let p00 = (string_drop s49410 s49420) in
  if (((p00 = ('''')))) then Some (FSGNJX_D, rd, rs1, rs2) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s49290  :: " string "


\<comment> \<open>\<open>val _s4910_ : string -> maybe ((f_bin_op_D * mword ty5 * mword ty5 * mword ty5))\<close>\<close>

definition s4910  :: \<open> string \<Rightarrow>(f_bin_op_D*(5)Word.word*(5)Word.word*(5)Word.word)option \<close>  where 
     \<open> s4910 s49120 = (
      (case  ((f_bin_type_mnemonic_D_matches_prefix s49120)) of
        Some ((FSGNJN_D, s49130)) => 
  (case  ((string_drop s49120 s49130)) of
        s49140 =>
  (case  ((spc_matches_prefix0 s49140)) of
        Some ((_, s49150)) =>
  (case  ((string_drop s49140 s49150)) of
        s49160 =>
  (case  ((freg_name_matches_prefix s49160 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s49170)) =>
  (case  ((string_drop s49160 s49170)) of
        s49180 =>
  (case  ((sep_matches_prefix s49180)) of
        Some ((_, s49190)) =>
  (case  ((string_drop s49180 s49190)) of
        s49200 =>
  (case  ((freg_name_matches_prefix s49200 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s49210)) =>
  (case  ((string_drop s49200 s49210)) of
        s49220 =>
  (case  ((sep_matches_prefix s49220)) of
        Some ((_, s49230)) =>
  (case  ((string_drop s49220 s49230)) of
        s49240 =>
  (case  ((freg_name_matches_prefix s49240 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s49250)) =>
  (let p00 = (string_drop s49240 s49250) in
  if (((p00 = ('''')))) then Some (FSGNJN_D, rd, rs1, rs2) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s49120  :: " string "


\<comment> \<open>\<open>val _s4893_ : string -> maybe ((f_bin_op_D * mword ty5 * mword ty5 * mword ty5))\<close>\<close>

definition s4893  :: \<open> string \<Rightarrow>(f_bin_op_D*(5)Word.word*(5)Word.word*(5)Word.word)option \<close>  where 
     \<open> s4893 s48950 = (
      (case  ((f_bin_type_mnemonic_D_matches_prefix s48950)) of
        Some ((FSGNJ_D, s48960)) => 
  (case  ((string_drop s48950 s48960)) of
        s48970 =>
  (case  ((spc_matches_prefix0 s48970)) of
        Some ((_, s48980)) =>
  (case  ((string_drop s48970 s48980)) of
        s48990 =>
  (case  ((freg_name_matches_prefix s48990 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s49000)) =>
  (case  ((string_drop s48990 s49000)) of
        s49010 =>
  (case  ((sep_matches_prefix s49010)) of
        Some ((_, s49020)) =>
  (case  ((string_drop s49010 s49020)) of
        s49030 =>
  (case  ((freg_name_matches_prefix s49030 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s49040)) =>
  (case  ((string_drop s49030 s49040)) of
        s49050 =>
  (case  ((sep_matches_prefix s49050)) of
        Some ((_, s49060)) =>
  (case  ((string_drop s49050 s49060)) of
        s49070 =>
  (case  ((freg_name_matches_prefix s49070 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s49080)) =>
  (let p00 = (string_drop s49070 s49080) in
  if (((p00 = ('''')))) then Some (FSGNJ_D, rd, rs1, rs2) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s48950  :: " string "


\<comment> \<open>\<open>val _s4876_ : string -> maybe ((f_un_rm_op_D * mword ty5 * mword ty5 * rounding_mode))\<close>\<close>

definition s4876  :: \<open> string \<Rightarrow>(f_un_rm_op_D*(5)Word.word*(5)Word.word*rounding_mode)option \<close>  where 
     \<open> s4876 s48780 = (
      (case  ((f_un_rm_type_mnemonic_D_matches_prefix s48780)) of
        Some ((FCVT_D_S, s48790)) => 
  (case  ((string_drop s48780 s48790)) of
        s48800 =>
  (case  ((spc_matches_prefix0 s48800)) of
        Some ((_, s48810)) =>
  (case  ((string_drop s48800 s48810)) of
        s48820 =>
  (case  ((freg_name_matches_prefix s48820 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s48830)) =>
  (case  ((string_drop s48820 s48830)) of
        s48840 =>
  (case  ((sep_matches_prefix s48840)) of
        Some ((_, s48850)) =>
  (case  ((string_drop s48840 s48850)) of
        s48860 =>
  (case  ((freg_name_matches_prefix s48860 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s48870)) =>
  (case  ((string_drop s48860 s48870)) of
        s48880 =>
  (case  ((sep_matches_prefix s48880)) of
        Some ((_, s48890)) =>
  (case  ((string_drop s48880 s48890)) of
        s48900 =>
  (case  ((frm_mnemonic_matches_prefix s48900)) of
        Some ((rm, s48910)) =>
  (let p00 = (string_drop s48900 s48910) in
  if (((p00 = ('''')))) then Some (FCVT_D_S, rd, rs1, rm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s48780  :: " string "


\<comment> \<open>\<open>val _s4859_ : string -> maybe ((f_un_rm_op_D * mword ty5 * mword ty5 * rounding_mode))\<close>\<close>

definition s4859  :: \<open> string \<Rightarrow>(f_un_rm_op_D*(5)Word.word*(5)Word.word*rounding_mode)option \<close>  where 
     \<open> s4859 s48610 = (
      (case  ((f_un_rm_type_mnemonic_D_matches_prefix s48610)) of
        Some ((FCVT_S_D, s48620)) => 
  (case  ((string_drop s48610 s48620)) of
        s48630 =>
  (case  ((spc_matches_prefix0 s48630)) of
        Some ((_, s48640)) =>
  (case  ((string_drop s48630 s48640)) of
        s48650 =>
  (case  ((freg_name_matches_prefix s48650 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s48660)) =>
  (case  ((string_drop s48650 s48660)) of
        s48670 =>
  (case  ((sep_matches_prefix s48670)) of
        Some ((_, s48680)) =>
  (case  ((string_drop s48670 s48680)) of
        s48690 =>
  (case  ((freg_name_matches_prefix s48690 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s48700)) =>
  (case  ((string_drop s48690 s48700)) of
        s48710 =>
  (case  ((sep_matches_prefix s48710)) of
        Some ((_, s48720)) =>
  (case  ((string_drop s48710 s48720)) of
        s48730 =>
  (case  ((frm_mnemonic_matches_prefix s48730)) of
        Some ((rm, s48740)) =>
  (let p00 = (string_drop s48730 s48740) in
  if (((p00 = ('''')))) then Some (FCVT_S_D, rd, rs1, rm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s48610  :: " string "


\<comment> \<open>\<open>val _s4842_ : string -> maybe ((f_un_rm_op_D * mword ty5 * mword ty5 * rounding_mode))\<close>\<close>

definition s4842  :: \<open> string \<Rightarrow>(f_un_rm_op_D*(5)Word.word*(5)Word.word*rounding_mode)option \<close>  where 
     \<open> s4842 s48440 = (
      (case  ((f_un_rm_type_mnemonic_D_matches_prefix s48440)) of
        Some ((FCVT_D_LU, s48450)) => 
  (case  ((string_drop s48440 s48450)) of
        s48460 =>
  (case  ((spc_matches_prefix0 s48460)) of
        Some ((_, s48470)) =>
  (case  ((string_drop s48460 s48470)) of
        s48480 =>
  (case  ((freg_name_matches_prefix s48480 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s48490)) =>
  (case  ((string_drop s48480 s48490)) of
        s48500 =>
  (case  ((sep_matches_prefix s48500)) of
        Some ((_, s48510)) =>
  (case  ((string_drop s48500 s48510)) of
        s48520 =>
  (case  ((reg_name_matches_prefix s48520 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s48530)) =>
  (case  ((string_drop s48520 s48530)) of
        s48540 =>
  (case  ((sep_matches_prefix s48540)) of
        Some ((_, s48550)) =>
  (case  ((string_drop s48540 s48550)) of
        s48560 =>
  (case  ((frm_mnemonic_matches_prefix s48560)) of
        Some ((rm, s48570)) =>
  (let p00 = (string_drop s48560 s48570) in
  if (((p00 = ('''')))) then Some (FCVT_D_LU, rd, rs1, rm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s48440  :: " string "


\<comment> \<open>\<open>val _s4825_ : string -> maybe ((f_un_rm_op_D * mword ty5 * mword ty5 * rounding_mode))\<close>\<close>

definition s4825  :: \<open> string \<Rightarrow>(f_un_rm_op_D*(5)Word.word*(5)Word.word*rounding_mode)option \<close>  where 
     \<open> s4825 s48270 = (
      (case  ((f_un_rm_type_mnemonic_D_matches_prefix s48270)) of
        Some ((FCVT_D_L, s48280)) => 
  (case  ((string_drop s48270 s48280)) of
        s48290 =>
  (case  ((spc_matches_prefix0 s48290)) of
        Some ((_, s48300)) =>
  (case  ((string_drop s48290 s48300)) of
        s48310 =>
  (case  ((freg_name_matches_prefix s48310 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s48320)) =>
  (case  ((string_drop s48310 s48320)) of
        s48330 =>
  (case  ((sep_matches_prefix s48330)) of
        Some ((_, s48340)) =>
  (case  ((string_drop s48330 s48340)) of
        s48350 =>
  (case  ((reg_name_matches_prefix s48350 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s48360)) =>
  (case  ((string_drop s48350 s48360)) of
        s48370 =>
  (case  ((sep_matches_prefix s48370)) of
        Some ((_, s48380)) =>
  (case  ((string_drop s48370 s48380)) of
        s48390 =>
  (case  ((frm_mnemonic_matches_prefix s48390)) of
        Some ((rm, s48400)) =>
  (let p00 = (string_drop s48390 s48400) in
  if (((p00 = ('''')))) then Some (FCVT_D_L, rd, rs1, rm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s48270  :: " string "


\<comment> \<open>\<open>val _s4808_ : string -> maybe ((f_un_rm_op_D * mword ty5 * mword ty5 * rounding_mode))\<close>\<close>

definition s4808  :: \<open> string \<Rightarrow>(f_un_rm_op_D*(5)Word.word*(5)Word.word*rounding_mode)option \<close>  where 
     \<open> s4808 s48100 = (
      (case  ((f_un_rm_type_mnemonic_D_matches_prefix s48100)) of
        Some ((FCVT_LU_D, s48110)) => 
  (case  ((string_drop s48100 s48110)) of
        s48120 =>
  (case  ((spc_matches_prefix0 s48120)) of
        Some ((_, s48130)) =>
  (case  ((string_drop s48120 s48130)) of
        s48140 =>
  (case  ((reg_name_matches_prefix s48140 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s48150)) =>
  (case  ((string_drop s48140 s48150)) of
        s48160 =>
  (case  ((sep_matches_prefix s48160)) of
        Some ((_, s48170)) =>
  (case  ((string_drop s48160 s48170)) of
        s48180 =>
  (case  ((freg_name_matches_prefix s48180 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s48190)) =>
  (case  ((string_drop s48180 s48190)) of
        s48200 =>
  (case  ((sep_matches_prefix s48200)) of
        Some ((_, s48210)) =>
  (case  ((string_drop s48200 s48210)) of
        s48220 =>
  (case  ((frm_mnemonic_matches_prefix s48220)) of
        Some ((rm, s48230)) =>
  (let p00 = (string_drop s48220 s48230) in
  if (((p00 = ('''')))) then Some (FCVT_LU_D, rd, rs1, rm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s48100  :: " string "


\<comment> \<open>\<open>val _s4791_ : string -> maybe ((f_un_rm_op_D * mword ty5 * mword ty5 * rounding_mode))\<close>\<close>

definition s4791  :: \<open> string \<Rightarrow>(f_un_rm_op_D*(5)Word.word*(5)Word.word*rounding_mode)option \<close>  where 
     \<open> s4791 s47930 = (
      (case  ((f_un_rm_type_mnemonic_D_matches_prefix s47930)) of
        Some ((FCVT_L_D, s47940)) => 
  (case  ((string_drop s47930 s47940)) of
        s47950 =>
  (case  ((spc_matches_prefix0 s47950)) of
        Some ((_, s47960)) =>
  (case  ((string_drop s47950 s47960)) of
        s47970 =>
  (case  ((reg_name_matches_prefix s47970 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s47980)) =>
  (case  ((string_drop s47970 s47980)) of
        s47990 =>
  (case  ((sep_matches_prefix s47990)) of
        Some ((_, s48000)) =>
  (case  ((string_drop s47990 s48000)) of
        s48010 =>
  (case  ((freg_name_matches_prefix s48010 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s48020)) =>
  (case  ((string_drop s48010 s48020)) of
        s48030 =>
  (case  ((sep_matches_prefix s48030)) of
        Some ((_, s48040)) =>
  (case  ((string_drop s48030 s48040)) of
        s48050 =>
  (case  ((frm_mnemonic_matches_prefix s48050)) of
        Some ((rm, s48060)) =>
  (let p00 = (string_drop s48050 s48060) in
  if (((p00 = ('''')))) then Some (FCVT_L_D, rd, rs1, rm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s47930  :: " string "


\<comment> \<open>\<open>val _s4774_ : string -> maybe ((f_un_rm_op_D * mword ty5 * mword ty5 * rounding_mode))\<close>\<close>

definition s4774  :: \<open> string \<Rightarrow>(f_un_rm_op_D*(5)Word.word*(5)Word.word*rounding_mode)option \<close>  where 
     \<open> s4774 s47760 = (
      (case  ((f_un_rm_type_mnemonic_D_matches_prefix s47760)) of
        Some ((FCVT_D_WU, s47770)) => 
  (case  ((string_drop s47760 s47770)) of
        s47780 =>
  (case  ((spc_matches_prefix0 s47780)) of
        Some ((_, s47790)) =>
  (case  ((string_drop s47780 s47790)) of
        s47800 =>
  (case  ((freg_name_matches_prefix s47800 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s47810)) =>
  (case  ((string_drop s47800 s47810)) of
        s47820 =>
  (case  ((sep_matches_prefix s47820)) of
        Some ((_, s47830)) =>
  (case  ((string_drop s47820 s47830)) of
        s47840 =>
  (case  ((reg_name_matches_prefix s47840 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s47850)) =>
  (case  ((string_drop s47840 s47850)) of
        s47860 =>
  (case  ((sep_matches_prefix s47860)) of
        Some ((_, s47870)) =>
  (case  ((string_drop s47860 s47870)) of
        s47880 =>
  (case  ((frm_mnemonic_matches_prefix s47880)) of
        Some ((rm, s47890)) =>
  (let p00 = (string_drop s47880 s47890) in
  if (((p00 = ('''')))) then Some (FCVT_D_WU, rd, rs1, rm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s47760  :: " string "


\<comment> \<open>\<open>val _s4757_ : string -> maybe ((f_un_rm_op_D * mword ty5 * mword ty5 * rounding_mode))\<close>\<close>

definition s4757  :: \<open> string \<Rightarrow>(f_un_rm_op_D*(5)Word.word*(5)Word.word*rounding_mode)option \<close>  where 
     \<open> s4757 s47590 = (
      (case  ((f_un_rm_type_mnemonic_D_matches_prefix s47590)) of
        Some ((FCVT_D_W, s47600)) => 
  (case  ((string_drop s47590 s47600)) of
        s47610 =>
  (case  ((spc_matches_prefix0 s47610)) of
        Some ((_, s47620)) =>
  (case  ((string_drop s47610 s47620)) of
        s47630 =>
  (case  ((freg_name_matches_prefix s47630 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s47640)) =>
  (case  ((string_drop s47630 s47640)) of
        s47650 =>
  (case  ((sep_matches_prefix s47650)) of
        Some ((_, s47660)) =>
  (case  ((string_drop s47650 s47660)) of
        s47670 =>
  (case  ((reg_name_matches_prefix s47670 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s47680)) =>
  (case  ((string_drop s47670 s47680)) of
        s47690 =>
  (case  ((sep_matches_prefix s47690)) of
        Some ((_, s47700)) =>
  (case  ((string_drop s47690 s47700)) of
        s47710 =>
  (case  ((frm_mnemonic_matches_prefix s47710)) of
        Some ((rm, s47720)) =>
  (let p00 = (string_drop s47710 s47720) in
  if (((p00 = ('''')))) then Some (FCVT_D_W, rd, rs1, rm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s47590  :: " string "


\<comment> \<open>\<open>val _s4740_ : string -> maybe ((f_un_rm_op_D * mword ty5 * mword ty5 * rounding_mode))\<close>\<close>

definition s4740  :: \<open> string \<Rightarrow>(f_un_rm_op_D*(5)Word.word*(5)Word.word*rounding_mode)option \<close>  where 
     \<open> s4740 s47420 = (
      (case  ((f_un_rm_type_mnemonic_D_matches_prefix s47420)) of
        Some ((FCVT_WU_D, s47430)) => 
  (case  ((string_drop s47420 s47430)) of
        s47440 =>
  (case  ((spc_matches_prefix0 s47440)) of
        Some ((_, s47450)) =>
  (case  ((string_drop s47440 s47450)) of
        s47460 =>
  (case  ((reg_name_matches_prefix s47460 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s47470)) =>
  (case  ((string_drop s47460 s47470)) of
        s47480 =>
  (case  ((sep_matches_prefix s47480)) of
        Some ((_, s47490)) =>
  (case  ((string_drop s47480 s47490)) of
        s47500 =>
  (case  ((freg_name_matches_prefix s47500 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s47510)) =>
  (case  ((string_drop s47500 s47510)) of
        s47520 =>
  (case  ((sep_matches_prefix s47520)) of
        Some ((_, s47530)) =>
  (case  ((string_drop s47520 s47530)) of
        s47540 =>
  (case  ((frm_mnemonic_matches_prefix s47540)) of
        Some ((rm, s47550)) =>
  (let p00 = (string_drop s47540 s47550) in
  if (((p00 = ('''')))) then Some (FCVT_WU_D, rd, rs1, rm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s47420  :: " string "


\<comment> \<open>\<open>val _s4723_ : string -> maybe ((f_un_rm_op_D * mword ty5 * mword ty5 * rounding_mode))\<close>\<close>

definition s4723  :: \<open> string \<Rightarrow>(f_un_rm_op_D*(5)Word.word*(5)Word.word*rounding_mode)option \<close>  where 
     \<open> s4723 s47250 = (
      (case  ((f_un_rm_type_mnemonic_D_matches_prefix s47250)) of
        Some ((FCVT_W_D, s47260)) => 
  (case  ((string_drop s47250 s47260)) of
        s47270 =>
  (case  ((spc_matches_prefix0 s47270)) of
        Some ((_, s47280)) =>
  (case  ((string_drop s47270 s47280)) of
        s47290 =>
  (case  ((reg_name_matches_prefix s47290 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s47300)) =>
  (case  ((string_drop s47290 s47300)) of
        s47310 =>
  (case  ((sep_matches_prefix s47310)) of
        Some ((_, s47320)) =>
  (case  ((string_drop s47310 s47320)) of
        s47330 =>
  (case  ((freg_name_matches_prefix s47330 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s47340)) =>
  (case  ((string_drop s47330 s47340)) of
        s47350 =>
  (case  ((sep_matches_prefix s47350)) of
        Some ((_, s47360)) =>
  (case  ((string_drop s47350 s47360)) of
        s47370 =>
  (case  ((frm_mnemonic_matches_prefix s47370)) of
        Some ((rm, s47380)) =>
  (let p00 = (string_drop s47370 s47380) in
  if (((p00 = ('''')))) then Some (FCVT_W_D, rd, rs1, rm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s47250  :: " string "


\<comment> \<open>\<open>val _s4706_ : string -> maybe ((f_un_rm_op_D * mword ty5 * mword ty5 * rounding_mode))\<close>\<close>

definition s4706  :: \<open> string \<Rightarrow>(f_un_rm_op_D*(5)Word.word*(5)Word.word*rounding_mode)option \<close>  where 
     \<open> s4706 s47080 = (
      (case  ((f_un_rm_type_mnemonic_D_matches_prefix s47080)) of
        Some ((FSQRT_D, s47090)) => 
  (case  ((string_drop s47080 s47090)) of
        s47100 =>
  (case  ((spc_matches_prefix0 s47100)) of
        Some ((_, s47110)) =>
  (case  ((string_drop s47100 s47110)) of
        s47120 =>
  (case  ((freg_name_matches_prefix s47120 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s47130)) =>
  (case  ((string_drop s47120 s47130)) of
        s47140 =>
  (case  ((sep_matches_prefix s47140)) of
        Some ((_, s47150)) =>
  (case  ((string_drop s47140 s47150)) of
        s47160 =>
  (case  ((freg_name_matches_prefix s47160 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s47170)) =>
  (case  ((string_drop s47160 s47170)) of
        s47180 =>
  (case  ((sep_matches_prefix s47180)) of
        Some ((_, s47190)) =>
  (case  ((string_drop s47180 s47190)) of
        s47200 =>
  (case  ((frm_mnemonic_matches_prefix s47200)) of
        Some ((rm, s47210)) =>
  (let p00 = (string_drop s47200 s47210) in
  if (((p00 = ('''')))) then Some (FSQRT_D, rd, rs1, rm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s47080  :: " string "


\<comment> \<open>\<open>val _s4685_ : string -> maybe ((f_bin_rm_op_D * mword ty5 * mword ty5 * mword ty5 * rounding_mode))\<close>\<close>

definition s4685  :: \<open> string \<Rightarrow>(f_bin_rm_op_D*(5)Word.word*(5)Word.word*(5)Word.word*rounding_mode)option \<close>  where 
     \<open> s4685 s46870 = (
      (case  ((f_bin_rm_type_mnemonic_D_matches_prefix s46870)) of
        Some ((op1, s46880)) => 
  (case  ((string_drop s46870 s46880)) of
        s46890 =>
  (case  ((spc_matches_prefix0 s46890)) of
        Some ((_, s46900)) =>
  (case  ((string_drop s46890 s46900)) of
        s46910 =>
  (case  ((freg_name_matches_prefix s46910 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s46920)) =>
  (case  ((string_drop s46910 s46920)) of
        s46930 =>
  (case  ((sep_matches_prefix s46930)) of
        Some ((_, s46940)) =>
  (case  ((string_drop s46930 s46940)) of
        s46950 =>
  (case  ((freg_name_matches_prefix s46950 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s46960)) =>
  (case  ((string_drop s46950 s46960)) of
        s46970 =>
  (case  ((sep_matches_prefix s46970)) of
        Some ((_, s46980)) =>
  (case  ((string_drop s46970 s46980)) of
        s46990 =>
  (case  ((freg_name_matches_prefix s46990 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s47000)) =>
  (case  ((string_drop s46990 s47000)) of
        s47010 =>
  (case  ((sep_matches_prefix s47010)) of
        Some ((_, s47020)) =>
  (case  ((string_drop s47010 s47020)) of
        s47030 =>
  (case  ((frm_mnemonic_matches_prefix s47030)) of
        Some ((rm, s47040)) =>
  (let p00 = (string_drop s47030 s47040) in
  if (((p00 = ('''')))) then Some (op1, rd, rs1, rs2, rm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s46870  :: " string "


\<comment> \<open>\<open>val _s4660_ : string -> maybe ((f_madd_op_D * mword ty5 * mword ty5 * mword ty5 * mword ty5 * rounding_mode))\<close>\<close>

definition s4660  :: \<open> string \<Rightarrow>(f_madd_op_D*(5)Word.word*(5)Word.word*(5)Word.word*(5)Word.word*rounding_mode)option \<close>  where 
     \<open> s4660 s46620 = (
      (case  ((f_madd_type_mnemonic_D_matches_prefix s46620)) of
        Some ((op1, s46630)) => 
  (case  ((string_drop s46620 s46630)) of
        s46640 =>
  (case  ((spc_matches_prefix0 s46640)) of
        Some ((_, s46650)) =>
  (case  ((string_drop s46640 s46650)) of
        s46660 =>
  (case  ((freg_name_matches_prefix s46660 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s46670)) =>
  (case  ((string_drop s46660 s46670)) of
        s46680 =>
  (case  ((sep_matches_prefix s46680)) of
        Some ((_, s46690)) =>
  (case  ((string_drop s46680 s46690)) of
        s46700 =>
  (case  ((freg_name_matches_prefix s46700 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s46710)) =>
  (case  ((string_drop s46700 s46710)) of
        s46720 =>
  (case  ((sep_matches_prefix s46720)) of
        Some ((_, s46730)) =>
  (case  ((string_drop s46720 s46730)) of
        s46740 =>
  (case  ((freg_name_matches_prefix s46740 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s46750)) =>
  (case  ((string_drop s46740 s46750)) of
        s46760 =>
  (case  ((sep_matches_prefix s46760)) of
        Some ((_, s46770)) =>
  (case  ((string_drop s46760 s46770)) of
        s46780 =>
  (case  ((freg_name_matches_prefix s46780 :: (( 5 Word.word * ii)) option)) of
        Some ((rs3, s46790)) =>
  (case  ((string_drop s46780 s46790)) of
        s46800 =>
  (case  ((sep_matches_prefix s46800)) of
        Some ((_, s46810)) =>
  (case  ((string_drop s46800 s46810)) of
        s46820 =>
  (case  ((frm_mnemonic_matches_prefix s46820)) of
        Some ((rm, s46830)) =>
  (let p00 = (string_drop s46820 s46830) in
  if (((p00 = ('''')))) then Some (op1, rd, rs1, rs2, rs3, rm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s46620  :: " string "


\<comment> \<open>\<open>val _s4644_ : string -> maybe ((mword ty3 * mword ty3 * mword ty5))\<close>\<close>

definition s4644  :: \<open> string \<Rightarrow>((3)Word.word*(3)Word.word*(5)Word.word)option \<close>  where 
     \<open> s4644 s46450 = (
   (let s46460 = s46450 in
   if ((string_startswith s46460 (''c.fsw''))) then  
  (case  ((string_drop s46460 ((string_length (''c.fsw''))))) of
        s46470 =>
  (case  ((spc_matches_prefix0 s46470)) of
        Some ((_, s46480)) =>
  (case  ((string_drop s46470 s46480)) of
        s46490 =>
  (case  ((creg_name_matches_prefix s46490 :: (( 3 Word.word * ii)) option)) of
        Some ((rsc1, s46500)) =>
  (case  ((string_drop s46490 s46500)) of
        s46510 =>
  (case  ((sep_matches_prefix s46510)) of
        Some ((_, s46520)) =>
  (case  ((string_drop s46510 s46520)) of
        s46530 =>
  (case  ((creg_name_matches_prefix s46530 :: (( 3 Word.word * ii)) option)) of
        Some ((rsc2, s46540)) =>
  (case  ((string_drop s46530 s46540)) of
        s46550 =>
  (case  ((sep_matches_prefix s46550)) of
        Some ((_, s46560)) =>
  (case  ((string_drop s46550 s46560)) of
        s46570 =>
  (case  ((hex_bits_7_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s46570 :: (( 7 Word.word * ii)) option)) of
        Some ((v__1466, s46580)) =>
  if (((((subrange_vec_dec v__1466 (( 1 :: int):: ii) (( 0 :: int):: ii)
         :: 2 Word.word)) = ( 0b00 :: 2 Word.word)))) then
    (let (uimm :: 5 Word.word) =
         ((subrange_vec_dec v__1466 (( 6 :: int):: ii) (( 2 :: int):: ii) :: 5 Word.word)) in
    (let (uimm :: 5 Word.word) =
         ((subrange_vec_dec v__1466 (( 6 :: int):: ii) (( 2 :: int):: ii) :: 5 Word.word)) in
    (let p00 = (string_drop s46570 s46580) in
    if (((p00 = ('''')))) then Some (rsc1, rsc2, uimm) else None))) else 
  None
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s46450  :: " string "


\<comment> \<open>\<open>val _s4628_ : string -> maybe ((mword ty3 * mword ty3 * mword ty5))\<close>\<close>

definition s4628  :: \<open> string \<Rightarrow>((3)Word.word*(3)Word.word*(5)Word.word)option \<close>  where 
     \<open> s4628 s46290 = (
   (let s46300 = s46290 in
   if ((string_startswith s46300 (''c.flw''))) then  
  (case  ((string_drop s46300 ((string_length (''c.flw''))))) of
        s46310 =>
  (case  ((spc_matches_prefix0 s46310)) of
        Some ((_, s46320)) =>
  (case  ((string_drop s46310 s46320)) of
        s46330 =>
  (case  ((creg_name_matches_prefix s46330 :: (( 3 Word.word * ii)) option)) of
        Some ((rdc, s46340)) =>
  (case  ((string_drop s46330 s46340)) of
        s46350 =>
  (case  ((sep_matches_prefix s46350)) of
        Some ((_, s46360)) =>
  (case  ((string_drop s46350 s46360)) of
        s46370 =>
  (case  ((creg_name_matches_prefix s46370 :: (( 3 Word.word * ii)) option)) of
        Some ((rsc, s46380)) =>
  (case  ((string_drop s46370 s46380)) of
        s46390 =>
  (case  ((sep_matches_prefix s46390)) of
        Some ((_, s46400)) =>
  (case  ((string_drop s46390 s46400)) of
        s46410 =>
  (case  ((hex_bits_7_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s46410 :: (( 7 Word.word * ii)) option)) of
        Some ((v__1468, s46420)) =>
  if (((((subrange_vec_dec v__1468 (( 1 :: int):: ii) (( 0 :: int):: ii)
         :: 2 Word.word)) = ( 0b00 :: 2 Word.word)))) then
    (let (uimm :: 5 Word.word) =
         ((subrange_vec_dec v__1468 (( 6 :: int):: ii) (( 2 :: int):: ii) :: 5 Word.word)) in
    (let (uimm :: 5 Word.word) =
         ((subrange_vec_dec v__1468 (( 6 :: int):: ii) (( 2 :: int):: ii) :: 5 Word.word)) in
    (let p00 = (string_drop s46410 s46420) in
    if (((p00 = ('''')))) then Some (rdc, rsc, uimm) else None))) else 
  None
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s46290  :: " string "


\<comment> \<open>\<open>val _s4616_ : string -> maybe ((mword ty5 * mword ty6))\<close>\<close>

definition s4616  :: \<open> string \<Rightarrow>((5)Word.word*(6)Word.word)option \<close>  where 
     \<open> s4616 s46170 = (
   (let s46180 = s46170 in
   if ((string_startswith s46180 (''c.fswsp''))) then  
  (case  ((string_drop s46180 ((string_length (''c.fswsp''))))) of
        s46190 =>
  (case  ((spc_matches_prefix0 s46190)) of
        Some ((_, s46200)) =>
  (case  ((string_drop s46190 s46200)) of
        s46210 =>
  (case  ((reg_name_matches_prefix s46210 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s46220)) =>
  (case  ((string_drop s46210 s46220)) of
        s46230 =>
  (case  ((sep_matches_prefix s46230)) of
        Some ((_, s46240)) =>
  (case  ((string_drop s46230 s46240)) of
        s46250 =>
  (case  ((hex_bits_6_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s46250 :: (( 6 Word.word * ii)) option)) of
        Some ((uimm, s46260)) =>
  (let p00 = (string_drop s46250 s46260) in
  if (((p00 = ('''')))) then Some (rd, uimm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s46170  :: " string "


\<comment> \<open>\<open>val _s4604_ : string -> maybe ((mword ty5 * mword ty6))\<close>\<close>

definition s4604  :: \<open> string \<Rightarrow>((5)Word.word*(6)Word.word)option \<close>  where 
     \<open> s4604 s46050 = (
   (let s46060 = s46050 in
   if ((string_startswith s46060 (''c.flwsp''))) then  
  (case  ((string_drop s46060 ((string_length (''c.flwsp''))))) of
        s46070 =>
  (case  ((spc_matches_prefix0 s46070)) of
        Some ((_, s46080)) =>
  (case  ((string_drop s46070 s46080)) of
        s46090 =>
  (case  ((reg_name_matches_prefix s46090 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s46100)) =>
  (case  ((string_drop s46090 s46100)) of
        s46110 =>
  (case  ((sep_matches_prefix s46110)) of
        Some ((_, s46120)) =>
  (case  ((string_drop s46110 s46120)) of
        s46130 =>
  (case  ((hex_bits_6_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s46130 :: (( 6 Word.word * ii)) option)) of
        Some ((imm, s46140)) =>
  (let p00 = (string_drop s46130 s46140) in
  if (((p00 = ('''')))) then Some (rd, imm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s46050  :: " string "


\<comment> \<open>\<open>val _s4591_ : string -> maybe ((f_un_op_S * mword ty5 * mword ty5))\<close>\<close>

definition s4591  :: \<open> string \<Rightarrow>(f_un_op_S*(5)Word.word*(5)Word.word)option \<close>  where 
     \<open> s4591 s45930 = (
      (case  ((f_un_type_mnemonic_S_matches_prefix s45930)) of
        Some ((FCLASS_S, s45940)) => 
  (case  ((string_drop s45930 s45940)) of
        s45950 =>
  (case  ((spc_matches_prefix0 s45950)) of
        Some ((_, s45960)) =>
  (case  ((string_drop s45950 s45960)) of
        s45970 =>
  (case  ((reg_name_matches_prefix s45970 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s45980)) =>
  (case  ((string_drop s45970 s45980)) of
        s45990 =>
  (case  ((sep_matches_prefix s45990)) of
        Some ((_, s46000)) =>
  (case  ((string_drop s45990 s46000)) of
        s46010 =>
  (case  ((freg_name_matches_prefix s46010 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s46020)) =>
  (let p00 = (string_drop s46010 s46020) in
  if (((p00 = ('''')))) then Some (FCLASS_S, rd, rs1) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s45930  :: " string "


\<comment> \<open>\<open>val _s4578_ : string -> maybe ((f_un_op_S * mword ty5 * mword ty5))\<close>\<close>

definition s4578  :: \<open> string \<Rightarrow>(f_un_op_S*(5)Word.word*(5)Word.word)option \<close>  where 
     \<open> s4578 s45800 = (
      (case  ((f_un_type_mnemonic_S_matches_prefix s45800)) of
        Some ((FMV_W_X, s45810)) => 
  (case  ((string_drop s45800 s45810)) of
        s45820 =>
  (case  ((spc_matches_prefix0 s45820)) of
        Some ((_, s45830)) =>
  (case  ((string_drop s45820 s45830)) of
        s45840 =>
  (case  ((freg_name_matches_prefix s45840 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s45850)) =>
  (case  ((string_drop s45840 s45850)) of
        s45860 =>
  (case  ((sep_matches_prefix s45860)) of
        Some ((_, s45870)) =>
  (case  ((string_drop s45860 s45870)) of
        s45880 =>
  (case  ((reg_name_matches_prefix s45880 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s45890)) =>
  (let p00 = (string_drop s45880 s45890) in
  if (((p00 = ('''')))) then Some (FMV_W_X, rd, rs1) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s45800  :: " string "


\<comment> \<open>\<open>val _s4565_ : string -> maybe ((f_un_op_S * mword ty5 * mword ty5))\<close>\<close>

definition s4565  :: \<open> string \<Rightarrow>(f_un_op_S*(5)Word.word*(5)Word.word)option \<close>  where 
     \<open> s4565 s45670 = (
      (case  ((f_un_type_mnemonic_S_matches_prefix s45670)) of
        Some ((FMV_X_W, s45680)) => 
  (case  ((string_drop s45670 s45680)) of
        s45690 =>
  (case  ((spc_matches_prefix0 s45690)) of
        Some ((_, s45700)) =>
  (case  ((string_drop s45690 s45700)) of
        s45710 =>
  (case  ((reg_name_matches_prefix s45710 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s45720)) =>
  (case  ((string_drop s45710 s45720)) of
        s45730 =>
  (case  ((sep_matches_prefix s45730)) of
        Some ((_, s45740)) =>
  (case  ((string_drop s45730 s45740)) of
        s45750 =>
  (case  ((freg_name_matches_prefix s45750 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s45760)) =>
  (let p00 = (string_drop s45750 s45760) in
  if (((p00 = ('''')))) then Some (FMV_X_W, rd, rs1) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s45670  :: " string "


\<comment> \<open>\<open>val _s4548_ : string -> maybe ((f_bin_op_S * mword ty5 * mword ty5 * mword ty5))\<close>\<close>

definition s4548  :: \<open> string \<Rightarrow>(f_bin_op_S*(5)Word.word*(5)Word.word*(5)Word.word)option \<close>  where 
     \<open> s4548 s45500 = (
      (case  ((f_bin_type_mnemonic_S_matches_prefix s45500)) of
        Some ((FLE_S, s45510)) => 
  (case  ((string_drop s45500 s45510)) of
        s45520 =>
  (case  ((spc_matches_prefix0 s45520)) of
        Some ((_, s45530)) =>
  (case  ((string_drop s45520 s45530)) of
        s45540 =>
  (case  ((reg_name_matches_prefix s45540 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s45550)) =>
  (case  ((string_drop s45540 s45550)) of
        s45560 =>
  (case  ((sep_matches_prefix s45560)) of
        Some ((_, s45570)) =>
  (case  ((string_drop s45560 s45570)) of
        s45580 =>
  (case  ((freg_name_matches_prefix s45580 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s45590)) =>
  (case  ((string_drop s45580 s45590)) of
        s45600 =>
  (case  ((sep_matches_prefix s45600)) of
        Some ((_, s45610)) =>
  (case  ((string_drop s45600 s45610)) of
        s45620 =>
  (case  ((freg_name_matches_prefix s45620 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s45630)) =>
  (let p00 = (string_drop s45620 s45630) in
  if (((p00 = ('''')))) then Some (FLE_S, rd, rs1, rs2) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s45500  :: " string "


\<comment> \<open>\<open>val _s4531_ : string -> maybe ((f_bin_op_S * mword ty5 * mword ty5 * mword ty5))\<close>\<close>

definition s4531  :: \<open> string \<Rightarrow>(f_bin_op_S*(5)Word.word*(5)Word.word*(5)Word.word)option \<close>  where 
     \<open> s4531 s45330 = (
      (case  ((f_bin_type_mnemonic_S_matches_prefix s45330)) of
        Some ((FLT_S, s45340)) => 
  (case  ((string_drop s45330 s45340)) of
        s45350 =>
  (case  ((spc_matches_prefix0 s45350)) of
        Some ((_, s45360)) =>
  (case  ((string_drop s45350 s45360)) of
        s45370 =>
  (case  ((reg_name_matches_prefix s45370 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s45380)) =>
  (case  ((string_drop s45370 s45380)) of
        s45390 =>
  (case  ((sep_matches_prefix s45390)) of
        Some ((_, s45400)) =>
  (case  ((string_drop s45390 s45400)) of
        s45410 =>
  (case  ((freg_name_matches_prefix s45410 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s45420)) =>
  (case  ((string_drop s45410 s45420)) of
        s45430 =>
  (case  ((sep_matches_prefix s45430)) of
        Some ((_, s45440)) =>
  (case  ((string_drop s45430 s45440)) of
        s45450 =>
  (case  ((freg_name_matches_prefix s45450 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s45460)) =>
  (let p00 = (string_drop s45450 s45460) in
  if (((p00 = ('''')))) then Some (FLT_S, rd, rs1, rs2) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s45330  :: " string "


\<comment> \<open>\<open>val _s4514_ : string -> maybe ((f_bin_op_S * mword ty5 * mword ty5 * mword ty5))\<close>\<close>

definition s4514  :: \<open> string \<Rightarrow>(f_bin_op_S*(5)Word.word*(5)Word.word*(5)Word.word)option \<close>  where 
     \<open> s4514 s45160 = (
      (case  ((f_bin_type_mnemonic_S_matches_prefix s45160)) of
        Some ((FEQ_S, s45170)) => 
  (case  ((string_drop s45160 s45170)) of
        s45180 =>
  (case  ((spc_matches_prefix0 s45180)) of
        Some ((_, s45190)) =>
  (case  ((string_drop s45180 s45190)) of
        s45200 =>
  (case  ((reg_name_matches_prefix s45200 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s45210)) =>
  (case  ((string_drop s45200 s45210)) of
        s45220 =>
  (case  ((sep_matches_prefix s45220)) of
        Some ((_, s45230)) =>
  (case  ((string_drop s45220 s45230)) of
        s45240 =>
  (case  ((freg_name_matches_prefix s45240 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s45250)) =>
  (case  ((string_drop s45240 s45250)) of
        s45260 =>
  (case  ((sep_matches_prefix s45260)) of
        Some ((_, s45270)) =>
  (case  ((string_drop s45260 s45270)) of
        s45280 =>
  (case  ((freg_name_matches_prefix s45280 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s45290)) =>
  (let p00 = (string_drop s45280 s45290) in
  if (((p00 = ('''')))) then Some (FEQ_S, rd, rs1, rs2) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s45160  :: " string "


\<comment> \<open>\<open>val _s4497_ : string -> maybe ((f_bin_op_S * mword ty5 * mword ty5 * mword ty5))\<close>\<close>

definition s4497  :: \<open> string \<Rightarrow>(f_bin_op_S*(5)Word.word*(5)Word.word*(5)Word.word)option \<close>  where 
     \<open> s4497 s44990 = (
      (case  ((f_bin_type_mnemonic_S_matches_prefix s44990)) of
        Some ((FMAX_S, s45000)) => 
  (case  ((string_drop s44990 s45000)) of
        s45010 =>
  (case  ((spc_matches_prefix0 s45010)) of
        Some ((_, s45020)) =>
  (case  ((string_drop s45010 s45020)) of
        s45030 =>
  (case  ((freg_name_matches_prefix s45030 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s45040)) =>
  (case  ((string_drop s45030 s45040)) of
        s45050 =>
  (case  ((sep_matches_prefix s45050)) of
        Some ((_, s45060)) =>
  (case  ((string_drop s45050 s45060)) of
        s45070 =>
  (case  ((freg_name_matches_prefix s45070 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s45080)) =>
  (case  ((string_drop s45070 s45080)) of
        s45090 =>
  (case  ((sep_matches_prefix s45090)) of
        Some ((_, s45100)) =>
  (case  ((string_drop s45090 s45100)) of
        s45110 =>
  (case  ((freg_name_matches_prefix s45110 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s45120)) =>
  (let p00 = (string_drop s45110 s45120) in
  if (((p00 = ('''')))) then Some (FMAX_S, rd, rs1, rs2) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s44990  :: " string "


\<comment> \<open>\<open>val _s4480_ : string -> maybe ((f_bin_op_S * mword ty5 * mword ty5 * mword ty5))\<close>\<close>

definition s4480  :: \<open> string \<Rightarrow>(f_bin_op_S*(5)Word.word*(5)Word.word*(5)Word.word)option \<close>  where 
     \<open> s4480 s44820 = (
      (case  ((f_bin_type_mnemonic_S_matches_prefix s44820)) of
        Some ((FMIN_S, s44830)) => 
  (case  ((string_drop s44820 s44830)) of
        s44840 =>
  (case  ((spc_matches_prefix0 s44840)) of
        Some ((_, s44850)) =>
  (case  ((string_drop s44840 s44850)) of
        s44860 =>
  (case  ((freg_name_matches_prefix s44860 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s44870)) =>
  (case  ((string_drop s44860 s44870)) of
        s44880 =>
  (case  ((sep_matches_prefix s44880)) of
        Some ((_, s44890)) =>
  (case  ((string_drop s44880 s44890)) of
        s44900 =>
  (case  ((freg_name_matches_prefix s44900 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s44910)) =>
  (case  ((string_drop s44900 s44910)) of
        s44920 =>
  (case  ((sep_matches_prefix s44920)) of
        Some ((_, s44930)) =>
  (case  ((string_drop s44920 s44930)) of
        s44940 =>
  (case  ((freg_name_matches_prefix s44940 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s44950)) =>
  (let p00 = (string_drop s44940 s44950) in
  if (((p00 = ('''')))) then Some (FMIN_S, rd, rs1, rs2) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s44820  :: " string "


\<comment> \<open>\<open>val _s4463_ : string -> maybe ((f_bin_op_S * mword ty5 * mword ty5 * mword ty5))\<close>\<close>

definition s4463  :: \<open> string \<Rightarrow>(f_bin_op_S*(5)Word.word*(5)Word.word*(5)Word.word)option \<close>  where 
     \<open> s4463 s44650 = (
      (case  ((f_bin_type_mnemonic_S_matches_prefix s44650)) of
        Some ((FSGNJX_S, s44660)) => 
  (case  ((string_drop s44650 s44660)) of
        s44670 =>
  (case  ((spc_matches_prefix0 s44670)) of
        Some ((_, s44680)) =>
  (case  ((string_drop s44670 s44680)) of
        s44690 =>
  (case  ((freg_name_matches_prefix s44690 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s44700)) =>
  (case  ((string_drop s44690 s44700)) of
        s44710 =>
  (case  ((sep_matches_prefix s44710)) of
        Some ((_, s44720)) =>
  (case  ((string_drop s44710 s44720)) of
        s44730 =>
  (case  ((freg_name_matches_prefix s44730 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s44740)) =>
  (case  ((string_drop s44730 s44740)) of
        s44750 =>
  (case  ((sep_matches_prefix s44750)) of
        Some ((_, s44760)) =>
  (case  ((string_drop s44750 s44760)) of
        s44770 =>
  (case  ((freg_name_matches_prefix s44770 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s44780)) =>
  (let p00 = (string_drop s44770 s44780) in
  if (((p00 = ('''')))) then Some (FSGNJX_S, rd, rs1, rs2) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s44650  :: " string "


\<comment> \<open>\<open>val _s4446_ : string -> maybe ((f_bin_op_S * mword ty5 * mword ty5 * mword ty5))\<close>\<close>

definition s4446  :: \<open> string \<Rightarrow>(f_bin_op_S*(5)Word.word*(5)Word.word*(5)Word.word)option \<close>  where 
     \<open> s4446 s44480 = (
      (case  ((f_bin_type_mnemonic_S_matches_prefix s44480)) of
        Some ((FSGNJN_S, s44490)) => 
  (case  ((string_drop s44480 s44490)) of
        s44500 =>
  (case  ((spc_matches_prefix0 s44500)) of
        Some ((_, s44510)) =>
  (case  ((string_drop s44500 s44510)) of
        s44520 =>
  (case  ((freg_name_matches_prefix s44520 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s44530)) =>
  (case  ((string_drop s44520 s44530)) of
        s44540 =>
  (case  ((sep_matches_prefix s44540)) of
        Some ((_, s44550)) =>
  (case  ((string_drop s44540 s44550)) of
        s44560 =>
  (case  ((freg_name_matches_prefix s44560 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s44570)) =>
  (case  ((string_drop s44560 s44570)) of
        s44580 =>
  (case  ((sep_matches_prefix s44580)) of
        Some ((_, s44590)) =>
  (case  ((string_drop s44580 s44590)) of
        s44600 =>
  (case  ((freg_name_matches_prefix s44600 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s44610)) =>
  (let p00 = (string_drop s44600 s44610) in
  if (((p00 = ('''')))) then Some (FSGNJN_S, rd, rs1, rs2) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s44480  :: " string "


\<comment> \<open>\<open>val _s4429_ : string -> maybe ((f_bin_op_S * mword ty5 * mword ty5 * mword ty5))\<close>\<close>

definition s4429  :: \<open> string \<Rightarrow>(f_bin_op_S*(5)Word.word*(5)Word.word*(5)Word.word)option \<close>  where 
     \<open> s4429 s44310 = (
      (case  ((f_bin_type_mnemonic_S_matches_prefix s44310)) of
        Some ((FSGNJ_S, s44320)) => 
  (case  ((string_drop s44310 s44320)) of
        s44330 =>
  (case  ((spc_matches_prefix0 s44330)) of
        Some ((_, s44340)) =>
  (case  ((string_drop s44330 s44340)) of
        s44350 =>
  (case  ((freg_name_matches_prefix s44350 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s44360)) =>
  (case  ((string_drop s44350 s44360)) of
        s44370 =>
  (case  ((sep_matches_prefix s44370)) of
        Some ((_, s44380)) =>
  (case  ((string_drop s44370 s44380)) of
        s44390 =>
  (case  ((freg_name_matches_prefix s44390 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s44400)) =>
  (case  ((string_drop s44390 s44400)) of
        s44410 =>
  (case  ((sep_matches_prefix s44410)) of
        Some ((_, s44420)) =>
  (case  ((string_drop s44410 s44420)) of
        s44430 =>
  (case  ((freg_name_matches_prefix s44430 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s44440)) =>
  (let p00 = (string_drop s44430 s44440) in
  if (((p00 = ('''')))) then Some (FSGNJ_S, rd, rs1, rs2) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s44310  :: " string "


\<comment> \<open>\<open>val _s4412_ : string -> maybe ((f_un_rm_op_S * mword ty5 * mword ty5 * rounding_mode))\<close>\<close>

definition s4412  :: \<open> string \<Rightarrow>(f_un_rm_op_S*(5)Word.word*(5)Word.word*rounding_mode)option \<close>  where 
     \<open> s4412 s44140 = (
      (case  ((f_un_rm_type_mnemonic_S_matches_prefix s44140)) of
        Some ((FCVT_S_LU, s44150)) => 
  (case  ((string_drop s44140 s44150)) of
        s44160 =>
  (case  ((spc_matches_prefix0 s44160)) of
        Some ((_, s44170)) =>
  (case  ((string_drop s44160 s44170)) of
        s44180 =>
  (case  ((freg_name_matches_prefix s44180 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s44190)) =>
  (case  ((string_drop s44180 s44190)) of
        s44200 =>
  (case  ((sep_matches_prefix s44200)) of
        Some ((_, s44210)) =>
  (case  ((string_drop s44200 s44210)) of
        s44220 =>
  (case  ((reg_name_matches_prefix s44220 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s44230)) =>
  (case  ((string_drop s44220 s44230)) of
        s44240 =>
  (case  ((sep_matches_prefix s44240)) of
        Some ((_, s44250)) =>
  (case  ((string_drop s44240 s44250)) of
        s44260 =>
  (case  ((frm_mnemonic_matches_prefix s44260)) of
        Some ((rm, s44270)) =>
  (let p00 = (string_drop s44260 s44270) in
  if (((p00 = ('''')))) then Some (FCVT_S_LU, rd, rs1, rm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s44140  :: " string "


\<comment> \<open>\<open>val _s4395_ : string -> maybe ((f_un_rm_op_S * mword ty5 * mword ty5 * rounding_mode))\<close>\<close>

definition s4395  :: \<open> string \<Rightarrow>(f_un_rm_op_S*(5)Word.word*(5)Word.word*rounding_mode)option \<close>  where 
     \<open> s4395 s43970 = (
      (case  ((f_un_rm_type_mnemonic_S_matches_prefix s43970)) of
        Some ((FCVT_S_L, s43980)) => 
  (case  ((string_drop s43970 s43980)) of
        s43990 =>
  (case  ((spc_matches_prefix0 s43990)) of
        Some ((_, s44000)) =>
  (case  ((string_drop s43990 s44000)) of
        s44010 =>
  (case  ((freg_name_matches_prefix s44010 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s44020)) =>
  (case  ((string_drop s44010 s44020)) of
        s44030 =>
  (case  ((sep_matches_prefix s44030)) of
        Some ((_, s44040)) =>
  (case  ((string_drop s44030 s44040)) of
        s44050 =>
  (case  ((reg_name_matches_prefix s44050 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s44060)) =>
  (case  ((string_drop s44050 s44060)) of
        s44070 =>
  (case  ((sep_matches_prefix s44070)) of
        Some ((_, s44080)) =>
  (case  ((string_drop s44070 s44080)) of
        s44090 =>
  (case  ((frm_mnemonic_matches_prefix s44090)) of
        Some ((rm, s44100)) =>
  (let p00 = (string_drop s44090 s44100) in
  if (((p00 = ('''')))) then Some (FCVT_S_L, rd, rs1, rm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s43970  :: " string "


\<comment> \<open>\<open>val _s4378_ : string -> maybe ((f_un_rm_op_S * mword ty5 * mword ty5 * rounding_mode))\<close>\<close>

definition s4378  :: \<open> string \<Rightarrow>(f_un_rm_op_S*(5)Word.word*(5)Word.word*rounding_mode)option \<close>  where 
     \<open> s4378 s43800 = (
      (case  ((f_un_rm_type_mnemonic_S_matches_prefix s43800)) of
        Some ((FCVT_LU_S, s43810)) => 
  (case  ((string_drop s43800 s43810)) of
        s43820 =>
  (case  ((spc_matches_prefix0 s43820)) of
        Some ((_, s43830)) =>
  (case  ((string_drop s43820 s43830)) of
        s43840 =>
  (case  ((reg_name_matches_prefix s43840 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s43850)) =>
  (case  ((string_drop s43840 s43850)) of
        s43860 =>
  (case  ((sep_matches_prefix s43860)) of
        Some ((_, s43870)) =>
  (case  ((string_drop s43860 s43870)) of
        s43880 =>
  (case  ((freg_name_matches_prefix s43880 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s43890)) =>
  (case  ((string_drop s43880 s43890)) of
        s43900 =>
  (case  ((sep_matches_prefix s43900)) of
        Some ((_, s43910)) =>
  (case  ((string_drop s43900 s43910)) of
        s43920 =>
  (case  ((frm_mnemonic_matches_prefix s43920)) of
        Some ((rm, s43930)) =>
  (let p00 = (string_drop s43920 s43930) in
  if (((p00 = ('''')))) then Some (FCVT_LU_S, rd, rs1, rm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s43800  :: " string "


\<comment> \<open>\<open>val _s4361_ : string -> maybe ((f_un_rm_op_S * mword ty5 * mword ty5 * rounding_mode))\<close>\<close>

definition s4361  :: \<open> string \<Rightarrow>(f_un_rm_op_S*(5)Word.word*(5)Word.word*rounding_mode)option \<close>  where 
     \<open> s4361 s43630 = (
      (case  ((f_un_rm_type_mnemonic_S_matches_prefix s43630)) of
        Some ((FCVT_L_S, s43640)) => 
  (case  ((string_drop s43630 s43640)) of
        s43650 =>
  (case  ((spc_matches_prefix0 s43650)) of
        Some ((_, s43660)) =>
  (case  ((string_drop s43650 s43660)) of
        s43670 =>
  (case  ((reg_name_matches_prefix s43670 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s43680)) =>
  (case  ((string_drop s43670 s43680)) of
        s43690 =>
  (case  ((sep_matches_prefix s43690)) of
        Some ((_, s43700)) =>
  (case  ((string_drop s43690 s43700)) of
        s43710 =>
  (case  ((freg_name_matches_prefix s43710 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s43720)) =>
  (case  ((string_drop s43710 s43720)) of
        s43730 =>
  (case  ((sep_matches_prefix s43730)) of
        Some ((_, s43740)) =>
  (case  ((string_drop s43730 s43740)) of
        s43750 =>
  (case  ((frm_mnemonic_matches_prefix s43750)) of
        Some ((rm, s43760)) =>
  (let p00 = (string_drop s43750 s43760) in
  if (((p00 = ('''')))) then Some (FCVT_L_S, rd, rs1, rm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s43630  :: " string "


\<comment> \<open>\<open>val _s4344_ : string -> maybe ((f_un_rm_op_S * mword ty5 * mword ty5 * rounding_mode))\<close>\<close>

definition s4344  :: \<open> string \<Rightarrow>(f_un_rm_op_S*(5)Word.word*(5)Word.word*rounding_mode)option \<close>  where 
     \<open> s4344 s43460 = (
      (case  ((f_un_rm_type_mnemonic_S_matches_prefix s43460)) of
        Some ((FCVT_S_WU, s43470)) => 
  (case  ((string_drop s43460 s43470)) of
        s43480 =>
  (case  ((spc_matches_prefix0 s43480)) of
        Some ((_, s43490)) =>
  (case  ((string_drop s43480 s43490)) of
        s43500 =>
  (case  ((freg_name_matches_prefix s43500 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s43510)) =>
  (case  ((string_drop s43500 s43510)) of
        s43520 =>
  (case  ((sep_matches_prefix s43520)) of
        Some ((_, s43530)) =>
  (case  ((string_drop s43520 s43530)) of
        s43540 =>
  (case  ((reg_name_matches_prefix s43540 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s43550)) =>
  (case  ((string_drop s43540 s43550)) of
        s43560 =>
  (case  ((sep_matches_prefix s43560)) of
        Some ((_, s43570)) =>
  (case  ((string_drop s43560 s43570)) of
        s43580 =>
  (case  ((frm_mnemonic_matches_prefix s43580)) of
        Some ((rm, s43590)) =>
  (let p00 = (string_drop s43580 s43590) in
  if (((p00 = ('''')))) then Some (FCVT_S_WU, rd, rs1, rm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s43460  :: " string "


\<comment> \<open>\<open>val _s4327_ : string -> maybe ((f_un_rm_op_S * mword ty5 * mword ty5 * rounding_mode))\<close>\<close>

definition s4327  :: \<open> string \<Rightarrow>(f_un_rm_op_S*(5)Word.word*(5)Word.word*rounding_mode)option \<close>  where 
     \<open> s4327 s43290 = (
      (case  ((f_un_rm_type_mnemonic_S_matches_prefix s43290)) of
        Some ((FCVT_S_W, s43300)) => 
  (case  ((string_drop s43290 s43300)) of
        s43310 =>
  (case  ((spc_matches_prefix0 s43310)) of
        Some ((_, s43320)) =>
  (case  ((string_drop s43310 s43320)) of
        s43330 =>
  (case  ((freg_name_matches_prefix s43330 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s43340)) =>
  (case  ((string_drop s43330 s43340)) of
        s43350 =>
  (case  ((sep_matches_prefix s43350)) of
        Some ((_, s43360)) =>
  (case  ((string_drop s43350 s43360)) of
        s43370 =>
  (case  ((reg_name_matches_prefix s43370 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s43380)) =>
  (case  ((string_drop s43370 s43380)) of
        s43390 =>
  (case  ((sep_matches_prefix s43390)) of
        Some ((_, s43400)) =>
  (case  ((string_drop s43390 s43400)) of
        s43410 =>
  (case  ((frm_mnemonic_matches_prefix s43410)) of
        Some ((rm, s43420)) =>
  (let p00 = (string_drop s43410 s43420) in
  if (((p00 = ('''')))) then Some (FCVT_S_W, rd, rs1, rm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s43290  :: " string "


\<comment> \<open>\<open>val _s4310_ : string -> maybe ((f_un_rm_op_S * mword ty5 * mword ty5 * rounding_mode))\<close>\<close>

definition s4310  :: \<open> string \<Rightarrow>(f_un_rm_op_S*(5)Word.word*(5)Word.word*rounding_mode)option \<close>  where 
     \<open> s4310 s43120 = (
      (case  ((f_un_rm_type_mnemonic_S_matches_prefix s43120)) of
        Some ((FCVT_WU_S, s43130)) => 
  (case  ((string_drop s43120 s43130)) of
        s43140 =>
  (case  ((spc_matches_prefix0 s43140)) of
        Some ((_, s43150)) =>
  (case  ((string_drop s43140 s43150)) of
        s43160 =>
  (case  ((reg_name_matches_prefix s43160 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s43170)) =>
  (case  ((string_drop s43160 s43170)) of
        s43180 =>
  (case  ((sep_matches_prefix s43180)) of
        Some ((_, s43190)) =>
  (case  ((string_drop s43180 s43190)) of
        s43200 =>
  (case  ((freg_name_matches_prefix s43200 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s43210)) =>
  (case  ((string_drop s43200 s43210)) of
        s43220 =>
  (case  ((sep_matches_prefix s43220)) of
        Some ((_, s43230)) =>
  (case  ((string_drop s43220 s43230)) of
        s43240 =>
  (case  ((frm_mnemonic_matches_prefix s43240)) of
        Some ((rm, s43250)) =>
  (let p00 = (string_drop s43240 s43250) in
  if (((p00 = ('''')))) then Some (FCVT_WU_S, rd, rs1, rm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s43120  :: " string "


\<comment> \<open>\<open>val _s4293_ : string -> maybe ((f_un_rm_op_S * mword ty5 * mword ty5 * rounding_mode))\<close>\<close>

definition s4293  :: \<open> string \<Rightarrow>(f_un_rm_op_S*(5)Word.word*(5)Word.word*rounding_mode)option \<close>  where 
     \<open> s4293 s42950 = (
      (case  ((f_un_rm_type_mnemonic_S_matches_prefix s42950)) of
        Some ((FCVT_W_S, s42960)) => 
  (case  ((string_drop s42950 s42960)) of
        s42970 =>
  (case  ((spc_matches_prefix0 s42970)) of
        Some ((_, s42980)) =>
  (case  ((string_drop s42970 s42980)) of
        s42990 =>
  (case  ((reg_name_matches_prefix s42990 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s43000)) =>
  (case  ((string_drop s42990 s43000)) of
        s43010 =>
  (case  ((sep_matches_prefix s43010)) of
        Some ((_, s43020)) =>
  (case  ((string_drop s43010 s43020)) of
        s43030 =>
  (case  ((freg_name_matches_prefix s43030 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s43040)) =>
  (case  ((string_drop s43030 s43040)) of
        s43050 =>
  (case  ((sep_matches_prefix s43050)) of
        Some ((_, s43060)) =>
  (case  ((string_drop s43050 s43060)) of
        s43070 =>
  (case  ((frm_mnemonic_matches_prefix s43070)) of
        Some ((rm, s43080)) =>
  (let p00 = (string_drop s43070 s43080) in
  if (((p00 = ('''')))) then Some (FCVT_W_S, rd, rs1, rm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s42950  :: " string "


\<comment> \<open>\<open>val _s4276_ : string -> maybe ((f_un_rm_op_S * mword ty5 * mword ty5 * rounding_mode))\<close>\<close>

definition s4276  :: \<open> string \<Rightarrow>(f_un_rm_op_S*(5)Word.word*(5)Word.word*rounding_mode)option \<close>  where 
     \<open> s4276 s42780 = (
      (case  ((f_un_rm_type_mnemonic_S_matches_prefix s42780)) of
        Some ((FSQRT_S, s42790)) => 
  (case  ((string_drop s42780 s42790)) of
        s42800 =>
  (case  ((spc_matches_prefix0 s42800)) of
        Some ((_, s42810)) =>
  (case  ((string_drop s42800 s42810)) of
        s42820 =>
  (case  ((freg_name_matches_prefix s42820 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s42830)) =>
  (case  ((string_drop s42820 s42830)) of
        s42840 =>
  (case  ((sep_matches_prefix s42840)) of
        Some ((_, s42850)) =>
  (case  ((string_drop s42840 s42850)) of
        s42860 =>
  (case  ((freg_name_matches_prefix s42860 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s42870)) =>
  (case  ((string_drop s42860 s42870)) of
        s42880 =>
  (case  ((sep_matches_prefix s42880)) of
        Some ((_, s42890)) =>
  (case  ((string_drop s42880 s42890)) of
        s42900 =>
  (case  ((frm_mnemonic_matches_prefix s42900)) of
        Some ((rm, s42910)) =>
  (let p00 = (string_drop s42900 s42910) in
  if (((p00 = ('''')))) then Some (FSQRT_S, rd, rs1, rm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s42780  :: " string "


\<comment> \<open>\<open>val _s4255_ : string -> maybe ((f_bin_rm_op_S * mword ty5 * mword ty5 * mword ty5 * rounding_mode))\<close>\<close>

definition s4255  :: \<open> string \<Rightarrow>(f_bin_rm_op_S*(5)Word.word*(5)Word.word*(5)Word.word*rounding_mode)option \<close>  where 
     \<open> s4255 s42570 = (
      (case  ((f_bin_rm_type_mnemonic_S_matches_prefix s42570)) of
        Some ((op1, s42580)) => 
  (case  ((string_drop s42570 s42580)) of
        s42590 =>
  (case  ((spc_matches_prefix0 s42590)) of
        Some ((_, s42600)) =>
  (case  ((string_drop s42590 s42600)) of
        s42610 =>
  (case  ((freg_name_matches_prefix s42610 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s42620)) =>
  (case  ((string_drop s42610 s42620)) of
        s42630 =>
  (case  ((sep_matches_prefix s42630)) of
        Some ((_, s42640)) =>
  (case  ((string_drop s42630 s42640)) of
        s42650 =>
  (case  ((freg_name_matches_prefix s42650 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s42660)) =>
  (case  ((string_drop s42650 s42660)) of
        s42670 =>
  (case  ((sep_matches_prefix s42670)) of
        Some ((_, s42680)) =>
  (case  ((string_drop s42670 s42680)) of
        s42690 =>
  (case  ((freg_name_matches_prefix s42690 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s42700)) =>
  (case  ((string_drop s42690 s42700)) of
        s42710 =>
  (case  ((sep_matches_prefix s42710)) of
        Some ((_, s42720)) =>
  (case  ((string_drop s42710 s42720)) of
        s42730 =>
  (case  ((frm_mnemonic_matches_prefix s42730)) of
        Some ((rm, s42740)) =>
  (let p00 = (string_drop s42730 s42740) in
  if (((p00 = ('''')))) then Some (op1, rd, rs1, rs2, rm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s42570  :: " string "


\<comment> \<open>\<open>val _s4230_ : string -> maybe ((f_madd_op_S * mword ty5 * mword ty5 * mword ty5 * mword ty5 * rounding_mode))\<close>\<close>

definition s4230  :: \<open> string \<Rightarrow>(f_madd_op_S*(5)Word.word*(5)Word.word*(5)Word.word*(5)Word.word*rounding_mode)option \<close>  where 
     \<open> s4230 s42320 = (
      (case  ((f_madd_type_mnemonic_S_matches_prefix s42320)) of
        Some ((op1, s42330)) => 
  (case  ((string_drop s42320 s42330)) of
        s42340 =>
  (case  ((spc_matches_prefix0 s42340)) of
        Some ((_, s42350)) =>
  (case  ((string_drop s42340 s42350)) of
        s42360 =>
  (case  ((freg_name_matches_prefix s42360 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s42370)) =>
  (case  ((string_drop s42360 s42370)) of
        s42380 =>
  (case  ((sep_matches_prefix s42380)) of
        Some ((_, s42390)) =>
  (case  ((string_drop s42380 s42390)) of
        s42400 =>
  (case  ((freg_name_matches_prefix s42400 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s42410)) =>
  (case  ((string_drop s42400 s42410)) of
        s42420 =>
  (case  ((sep_matches_prefix s42420)) of
        Some ((_, s42430)) =>
  (case  ((string_drop s42420 s42430)) of
        s42440 =>
  (case  ((freg_name_matches_prefix s42440 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s42450)) =>
  (case  ((string_drop s42440 s42450)) of
        s42460 =>
  (case  ((sep_matches_prefix s42460)) of
        Some ((_, s42470)) =>
  (case  ((string_drop s42460 s42470)) of
        s42480 =>
  (case  ((freg_name_matches_prefix s42480 :: (( 5 Word.word * ii)) option)) of
        Some ((rs3, s42490)) =>
  (case  ((string_drop s42480 s42490)) of
        s42500 =>
  (case  ((sep_matches_prefix s42500)) of
        Some ((_, s42510)) =>
  (case  ((string_drop s42500 s42510)) of
        s42520 =>
  (case  ((frm_mnemonic_matches_prefix s42520)) of
        Some ((rm, s42530)) =>
  (let p00 = (string_drop s42520 s42530) in
  if (((p00 = ('''')))) then Some (op1, rd, rs1, rs2, rs3, rm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s42320  :: " string "


\<comment> \<open>\<open>val _s4206_ : string -> maybe ((word_width * mword ty5 * mword ty12 * mword ty5))\<close>\<close>

definition s4206  :: \<open> string \<Rightarrow>(word_width*(5)Word.word*(12)Word.word*(5)Word.word)option \<close>  where 
     \<open> s4206 s42070 = (
   (let s42080 = s42070 in
   if ((string_startswith s42080 (''fs''))) then  
  (case  ((string_drop s42080 ((string_length (''fs''))))) of
        s42090 =>
  (case  ((size_mnemonic_matches_prefix s42090)) of
        Some ((width, s42100)) =>
  (case  ((string_drop s42090 s42100)) of
        s42110 =>
  (case  ((spc_matches_prefix0 s42110)) of
        Some ((_, s42120)) =>
  (case  ((string_drop s42110 s42120)) of
        s42130 =>
  (case  ((freg_name_matches_prefix s42130 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s42140)) =>
  (case  ((string_drop s42130 s42140)) of
        s42150 =>
  (case  ((sep_matches_prefix s42150)) of
        Some ((_, s42160)) =>
  (case  ((string_drop s42150 s42160)) of
        s42170 =>
  (case  ((hex_bits_12_matches_prefix0 s42170
          :: (( 12 Word.word * ii)) option)) of
        Some ((imm, s42180)) =>
  (case  ((string_drop s42170 s42180)) of
        s42190 =>
  (case  ((opt_spc_matches_prefix0 s42190)) of
        Some ((_, s42200)) =>
  (let s42210 = (string_drop s42190 s42200) in
  if ((string_startswith s42210 (''(''))) then
    (case  ((string_drop s42210 ((string_length (''(''))))) of
          s42220 =>
    (case  ((opt_spc_matches_prefix0 s42220)) of
          Some ((_, s42230)) =>
    (case  ((string_drop s42220 s42230)) of
          s42240 =>
    (case  ((reg_name_matches_prefix s42240 :: (( 5 Word.word * ii)) option)) of
          Some ((rs1, s42250)) =>
    (case  ((string_drop s42240 s42250)) of
          s42260 =>
    (case  ((opt_spc_matches_prefix0 s42260)) of
          Some ((_, s42270)) =>
    (let s42280 = (string_drop s42260 s42270) in
    if ((string_startswith s42280 ('')''))) then
      (let p00 = (string_drop s42280 ((string_length ('')'')))) in
      if (((p00 = ('''')))) then Some (width, rs2, imm, rs1) else None) else
      None)
      | _ => None
    )
    )
      | _ => None
    )
    )
      | _ => None
    )
    ) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s42070  :: " string "


\<comment> \<open>\<open>val _s4182_ : string -> maybe ((word_width * mword ty5 * mword ty12 * mword ty5))\<close>\<close>

definition s4182  :: \<open> string \<Rightarrow>(word_width*(5)Word.word*(12)Word.word*(5)Word.word)option \<close>  where 
     \<open> s4182 s41830 = (
   (let s41840 = s41830 in
   if ((string_startswith s41840 (''fl''))) then  
  (case  ((string_drop s41840 ((string_length (''fl''))))) of
        s41850 =>
  (case  ((size_mnemonic_matches_prefix s41850)) of
        Some ((width, s41860)) =>
  (case  ((string_drop s41850 s41860)) of
        s41870 =>
  (case  ((spc_matches_prefix0 s41870)) of
        Some ((_, s41880)) =>
  (case  ((string_drop s41870 s41880)) of
        s41890 =>
  (case  ((freg_name_matches_prefix s41890 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s41900)) =>
  (case  ((string_drop s41890 s41900)) of
        s41910 =>
  (case  ((sep_matches_prefix s41910)) of
        Some ((_, s41920)) =>
  (case  ((string_drop s41910 s41920)) of
        s41930 =>
  (case  ((hex_bits_12_matches_prefix0 s41930
          :: (( 12 Word.word * ii)) option)) of
        Some ((imm, s41940)) =>
  (case  ((string_drop s41930 s41940)) of
        s41950 =>
  (case  ((opt_spc_matches_prefix0 s41950)) of
        Some ((_, s41960)) =>
  (let s41970 = (string_drop s41950 s41960) in
  if ((string_startswith s41970 (''(''))) then
    (case  ((string_drop s41970 ((string_length (''(''))))) of
          s41980 =>
    (case  ((opt_spc_matches_prefix0 s41980)) of
          Some ((_, s41990)) =>
    (case  ((string_drop s41980 s41990)) of
          s42000 =>
    (case  ((reg_name_matches_prefix s42000 :: (( 5 Word.word * ii)) option)) of
          Some ((rs1, s42010)) =>
    (case  ((string_drop s42000 s42010)) of
          s42020 =>
    (case  ((opt_spc_matches_prefix0 s42020)) of
          Some ((_, s42030)) =>
    (let s42040 = (string_drop s42020 s42030) in
    if ((string_startswith s42040 ('')''))) then
      (let p00 = (string_drop s42040 ((string_length ('')'')))) in
      if (((p00 = ('''')))) then Some (width, rd, imm, rs1) else None) else
      None)
      | _ => None
    )
    )
      | _ => None
    )
    )
      | _ => None
    )
    ) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s41830  :: " string "


\<comment> \<open>\<open>val _s4170_ : string -> maybe ((mword ty5 * mword ty5 * mword ty12))\<close>\<close>

definition s4170  :: \<open> string \<Rightarrow>((5)Word.word*(5)Word.word*(12)Word.word)option \<close>  where 
     \<open> s4170 s41710 = (
   (let s41720 = s41710 in
   if ((string_startswith s41720 (''fence.i.reserved.''))) then  
  (case  ((string_drop s41720 ((string_length (''fence.i.reserved.''))))) of
        s41730 =>
  (case  ((reg_name_matches_prefix s41730 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s41740)) =>
  (let s41750 = (string_drop s41730 s41740) in
  if ((string_startswith s41750 (''.''))) then
    (case  ((string_drop s41750 ((string_length (''.''))))) of
          s41760 =>
    (case  ((reg_name_matches_prefix s41760 :: (( 5 Word.word * ii)) option)) of
          Some ((rs, s41770)) =>
    (let s41780 = (string_drop s41760 s41770) in
    if ((string_startswith s41780 (''.''))) then
      (case  ((string_drop s41780 ((string_length (''.''))))) of
            s41790 =>
      (case  ((hex_bits_12_matches_prefix0 s41790 :: (( 12 Word.word * ii)) option)) of
            Some ((imm, s41800)) =>
      (let p00 = (string_drop s41790 s41800) in
      if (((p00 = ('''')))) then Some (rd, rs, imm) else None)
        | _ => None
      )
      ) else None)
      | _ => None
    )
    ) else None)
    | _ => None
  )
  )
   else None))\<close> 
  for  s41710  :: " string "


\<comment> \<open>\<open>val _s4152_ : string -> maybe ((mword ty4 * mword ty4 * mword ty5 * mword ty5 * mword ty4))\<close>\<close>

definition s4152  :: \<open> string \<Rightarrow>((4)Word.word*(4)Word.word*(5)Word.word*(5)Word.word*(4)Word.word)option \<close>  where 
     \<open> s4152 s41530 = (
   (let s41540 = s41530 in
   if ((string_startswith s41540 (''fence.reserved.''))) then  
  (case  ((string_drop s41540 ((string_length (''fence.reserved.''))))) of
        s41550 =>
  (case  ((fence_bits_matches_prefix s41550 :: (( 4 Word.word * ii)) option)) of
        Some ((pred, s41560)) =>
  (let s41570 = (string_drop s41550 s41560) in
  if ((string_startswith s41570 (''.''))) then
    (case  ((string_drop s41570 ((string_length (''.''))))) of
          s41580 =>
    (case  ((fence_bits_matches_prefix s41580 :: (( 4 Word.word * ii)) option)) of
          Some ((succ, s41590)) =>
    (let s41600 = (string_drop s41580 s41590) in
    if ((string_startswith s41600 (''.''))) then
      (case  ((string_drop s41600 ((string_length (''.''))))) of
            s41610 =>
      (case  ((reg_name_matches_prefix s41610 :: (( 5 Word.word * ii)) option)) of
            Some ((rs, s41620)) =>
      (let s41630 = (string_drop s41610 s41620) in
      if ((string_startswith s41630 (''.''))) then
        (case  ((string_drop s41630 ((string_length (''.''))))) of
              s41640 =>
        (case  ((reg_name_matches_prefix s41640 :: (( 5 Word.word * ii)) option)) of
              Some ((rd, s41650)) =>
        (let s41660 = (string_drop s41640 s41650) in
        if ((string_startswith s41660 (''.''))) then
          (case  ((string_drop s41660 ((string_length (''.''))))) of
                s41670 =>
          (case  ((hex_bits_4_matches_prefix
                     instance_Sail2_values_Bitvector_Machine_word_mword_dict
                     s41670 :: (( 4 Word.word * ii)) option)) of
                Some ((fm, s41680)) =>
          (let p00 = (string_drop s41670 s41680) in
          if (((p00 = ('''')))) then Some (pred, succ, rs, rd, fm) else None)
            | _ => None
          )
          ) else None)
          | _ => None
        )
        ) else None)
        | _ => None
      )
      ) else None)
      | _ => None
    )
    ) else None)
    | _ => None
  )
  )
   else None))\<close> 
  for  s41530  :: " string "


\<comment> \<open>\<open>val _s4146_ : string -> maybe (mword ty3)\<close>\<close>

definition s4146  :: \<open> string \<Rightarrow>((3)Word.word)option \<close>  where 
     \<open> s4146 s41470 = (
   (let s41480 = s41470 in
   if ((string_startswith s41480 (''c.srai.hint.''))) then  
  (case  ((string_drop s41480 ((string_length (''c.srai.hint.''))))) of
        s41490 =>
  (case  ((creg_name_matches_prefix s41490 :: (( 3 Word.word * ii)) option)) of
        Some ((rsd, s41500)) =>
  (let p00 = (string_drop s41490 s41500) in
  if (((p00 = ('''')))) then Some rsd else None)
    | _ => None
  )
  )
   else None))\<close> 
  for  s41470  :: " string "


\<comment> \<open>\<open>val _s4140_ : string -> maybe (mword ty3)\<close>\<close>

definition s4140  :: \<open> string \<Rightarrow>((3)Word.word)option \<close>  where 
     \<open> s4140 s41410 = (
   (let s41420 = s41410 in
   if ((string_startswith s41420 (''c.srli.hint.''))) then  
  (case  ((string_drop s41420 ((string_length (''c.srli.hint.''))))) of
        s41430 =>
  (case  ((creg_name_matches_prefix s41430 :: (( 3 Word.word * ii)) option)) of
        Some ((rsd, s41440)) =>
  (let p00 = (string_drop s41430 s41440) in
  if (((p00 = ('''')))) then Some rsd else None)
    | _ => None
  )
  )
   else None))\<close> 
  for  s41410  :: " string "


\<comment> \<open>\<open>val _s4131_ : string -> maybe ((mword ty5 * mword ty6))\<close>\<close>

definition s4131  :: \<open> string \<Rightarrow>((5)Word.word*(6)Word.word)option \<close>  where 
     \<open> s4131 s41320 = (
   (let s41330 = s41320 in
   if ((string_startswith s41330 (''c.slli.hint.''))) then  
  (case  ((string_drop s41330 ((string_length (''c.slli.hint.''))))) of
        s41340 =>
  (case  ((reg_name_matches_prefix s41340 :: (( 5 Word.word * ii)) option)) of
        Some ((rsd, s41350)) =>
  (let s41360 = (string_drop s41340 s41350) in
  if ((string_startswith s41360 (''.''))) then
    (case  ((string_drop s41360 ((string_length (''.''))))) of
          s41370 =>
    (case  ((hex_bits_6_matches_prefix
               instance_Sail2_values_Bitvector_Machine_word_mword_dict 
             s41370 :: (( 6 Word.word * ii)) option)) of
          Some ((shamt, s41380)) =>
    (let p00 = (string_drop s41370 s41380) in
    if (((p00 = ('''')))) then Some (rsd, shamt) else None)
      | _ => None
    )
    ) else None)
    | _ => None
  )
  )
   else None))\<close> 
  for  s41320  :: " string "


\<comment> \<open>\<open>val _s4125_ : string -> maybe (mword ty5)\<close>\<close>

definition s4125  :: \<open> string \<Rightarrow>((5)Word.word)option \<close>  where 
     \<open> s4125 s41260 = (
   (let s41270 = s41260 in
   if ((string_startswith s41270 (''c.add.hint.''))) then  
  (case  ((string_drop s41270 ((string_length (''c.add.hint.''))))) of
        s41280 =>
  (case  ((reg_name_matches_prefix s41280 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s41290)) =>
  (let p00 = (string_drop s41280 s41290) in
  if (((p00 = ('''')))) then Some rs2 else None)
    | _ => None
  )
  )
   else None))\<close> 
  for  s41260  :: " string "


\<comment> \<open>\<open>val _s4119_ : string -> maybe (mword ty5)\<close>\<close>

definition s4119  :: \<open> string \<Rightarrow>((5)Word.word)option \<close>  where 
     \<open> s4119 s41200 = (
   (let s41210 = s41200 in
   if ((string_startswith s41210 (''c.mv.hint.''))) then  
  (case  ((string_drop s41210 ((string_length (''c.mv.hint.''))))) of
        s41220 =>
  (case  ((reg_name_matches_prefix s41220 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s41230)) =>
  (let p00 = (string_drop s41220 s41230) in
  if (((p00 = ('''')))) then Some rs2 else None)
    | _ => None
  )
  )
   else None))\<close> 
  for  s41200  :: " string "


\<comment> \<open>\<open>val _s4113_ : string -> maybe (mword ty6)\<close>\<close>

definition s4113  :: \<open> string \<Rightarrow>((6)Word.word)option \<close>  where 
     \<open> s4113 s41140 = (
   (let s41150 = s41140 in
   if ((string_startswith s41150 (''c.lui.hint.''))) then  
  (case  ((string_drop s41150 ((string_length (''c.lui.hint.''))))) of
        s41160 =>
  (case  ((hex_bits_6_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s41160 :: (( 6 Word.word * ii)) option)) of
        Some ((imm, s41170)) =>
  (let p00 = (string_drop s41160 s41170) in
  if (((p00 = ('''')))) then Some imm else None)
    | _ => None
  )
  )
   else None))\<close> 
  for  s41140  :: " string "


\<comment> \<open>\<open>val _s4107_ : string -> maybe (mword ty6)\<close>\<close>

definition s4107  :: \<open> string \<Rightarrow>((6)Word.word)option \<close>  where 
     \<open> s4107 s41080 = (
   (let s41090 = s41080 in
   if ((string_startswith s41090 (''c.li.hint.''))) then  
  (case  ((string_drop s41090 ((string_length (''c.li.hint.''))))) of
        s41100 =>
  (case  ((hex_bits_6_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s41100 :: (( 6 Word.word * ii)) option)) of
        Some ((imm, s41110)) =>
  (let p00 = (string_drop s41100 s41110) in
  if (((p00 = ('''')))) then Some imm else None)
    | _ => None
  )
  )
   else None))\<close> 
  for  s41080  :: " string "


\<comment> \<open>\<open>val _s4101_ : string -> maybe (mword ty5)\<close>\<close>

definition s4101  :: \<open> string \<Rightarrow>((5)Word.word)option \<close>  where 
     \<open> s4101 s41020 = (
   (let s41030 = s41020 in
   if ((string_startswith s41030 (''c.addi.hint.''))) then  
  (case  ((string_drop s41030 ((string_length (''c.addi.hint.''))))) of
        s41040 =>
  (case  ((reg_name_matches_prefix s41040 :: (( 5 Word.word * ii)) option)) of
        Some ((rsd, s41050)) =>
  (let p00 = (string_drop s41040 s41050) in
  if (((p00 = ('''')))) then Some rsd else None)
    | _ => None
  )
  )
   else None))\<close> 
  for  s41020  :: " string "


\<comment> \<open>\<open>val _s4095_ : string -> maybe (mword ty6)\<close>\<close>

definition s4095  :: \<open> string \<Rightarrow>((6)Word.word)option \<close>  where 
     \<open> s4095 s40960 = (
   (let s40970 = s40960 in
   if ((string_startswith s40970 (''c.nop.hint.''))) then  
  (case  ((string_drop s40970 ((string_length (''c.nop.hint.''))))) of
        s40980 =>
  (case  ((hex_bits_6_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s40980 :: (( 6 Word.word * ii)) option)) of
        Some ((imm, s40990)) =>
  (let p00 = (string_drop s40980 s40990) in
  if (((p00 = ('''')))) then Some imm else None)
    | _ => None
  )
  )
   else None))\<close> 
  for  s40960  :: " string "


\<comment> \<open>\<open>val _s4078_ : string -> maybe ((csrop * mword ty5 * mword ty12 * mword ty5))\<close>\<close>

definition s4078  :: \<open> string \<Rightarrow>(csrop*(5)Word.word*(12)Word.word*(5)Word.word)option \<close>  where 
     \<open> s4078 s40800 = (
      (case  ((csr_mnemonic_matches_prefix s40800)) of
        Some ((op1, s40810)) => 
  (case  ((string_drop s40800 s40810)) of
        s40820 =>
  (case  ((spc_matches_prefix0 s40820)) of
        Some ((_, s40830)) =>
  (case  ((string_drop s40820 s40830)) of
        s40840 =>
  (case  ((reg_name_matches_prefix s40840 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s40850)) =>
  (case  ((string_drop s40840 s40850)) of
        s40860 =>
  (case  ((sep_matches_prefix s40860)) of
        Some ((_, s40870)) =>
  (case  ((string_drop s40860 s40870)) of
        s40880 =>
  (case  ((csr_name_map_matches_prefix s40880
          :: (( 12 Word.word * ii)) option)) of
        Some ((csr, s40890)) =>
  (case  ((string_drop s40880 s40890)) of
        s40900 =>
  (case  ((sep_matches_prefix s40900)) of
        Some ((_, s40910)) =>
  (case  ((string_drop s40900 s40910)) of
        s40920 =>
  (case  ((reg_name_matches_prefix s40920 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s40930)) =>
  (let p00 = (string_drop s40920 s40930) in
  if (((p00 = ('''')))) then Some (op1, rd, csr, rs1) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s40800  :: " string "


\<comment> \<open>\<open>val _s4060_ : string -> maybe ((csrop * mword ty5 * mword ty12 * mword ty5))\<close>\<close>

definition s4060  :: \<open> string \<Rightarrow>(csrop*(5)Word.word*(12)Word.word*(5)Word.word)option \<close>  where 
     \<open> s4060 s40620 = (
      (case  ((csr_mnemonic_matches_prefix s40620)) of
        Some ((op1, s40630)) =>
         (let s40640 = (string_drop s40620 s40630) in
         if ((string_startswith s40640 (''i''))) then  
  (case  ((string_drop s40640 ((string_length (''i''))))) of
        s40650 =>
  (case  ((spc_matches_prefix0 s40650)) of
        Some ((_, s40660)) =>
  (case  ((string_drop s40650 s40660)) of
        s40670 =>
  (case  ((reg_name_matches_prefix s40670 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s40680)) =>
  (case  ((string_drop s40670 s40680)) of
        s40690 =>
  (case  ((sep_matches_prefix s40690)) of
        Some ((_, s40700)) =>
  (case  ((string_drop s40690 s40700)) of
        s40710 =>
  (case  ((csr_name_map_matches_prefix s40710
          :: (( 12 Word.word * ii)) option)) of
        Some ((csr, s40720)) =>
  (case  ((string_drop s40710 s40720)) of
        s40730 =>
  (case  ((sep_matches_prefix s40730)) of
        Some ((_, s40740)) =>
  (case  ((string_drop s40730 s40740)) of
        s40750 =>
  (case  ((hex_bits_5_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s40750 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s40760)) =>
  (let p00 = (string_drop s40750 s40760) in
  if (((p00 = ('''')))) then Some (op1, rd, csr, rs1) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
         else None)
      | _ => None
      ))\<close> 
  for  s40620  :: " string "


\<comment> \<open>\<open>val _s4041_ : string -> maybe ((bool * mword ty5 * mword ty5 * mword ty5))\<close>\<close>

definition s4041  :: \<open> string \<Rightarrow>(bool*(5)Word.word*(5)Word.word*(5)Word.word)option \<close>  where 
     \<open> s4041 s40420 = (
   (let s40430 = s40420 in
   if ((string_startswith s40430 (''rem''))) then  
  (case  ((string_drop s40430 ((string_length (''rem''))))) of
        s40440 =>
  (case  ((maybe_not_u_matches_prefix s40440)) of
        Some ((s, s40450)) =>
  (let s40460 = (string_drop s40440 s40450) in
  if ((string_startswith s40460 (''w''))) then
    (case  ((string_drop s40460 ((string_length (''w''))))) of
          s40470 =>
    (case  ((spc_matches_prefix0 s40470)) of
          Some ((_, s40480)) =>
    (case  ((string_drop s40470 s40480)) of
          s40490 =>
    (case  ((reg_name_matches_prefix s40490 :: (( 5 Word.word * ii)) option)) of
          Some ((rd, s40500)) =>
    (case  ((string_drop s40490 s40500)) of
          s40510 =>
    (case  ((sep_matches_prefix s40510)) of
          Some ((_, s40520)) =>
    (case  ((string_drop s40510 s40520)) of
          s40530 =>
    (case  ((reg_name_matches_prefix s40530 :: (( 5 Word.word * ii)) option)) of
          Some ((rs1, s40540)) =>
    (case  ((string_drop s40530 s40540)) of
          s40550 =>
    (case  ((sep_matches_prefix s40550)) of
          Some ((_, s40560)) =>
    (case  ((string_drop s40550 s40560)) of
          s40570 =>
    (case  ((reg_name_matches_prefix s40570 :: (( 5 Word.word * ii)) option)) of
          Some ((rs2, s40580)) =>
    (let p00 = (string_drop s40570 s40580) in
    if (((p00 = ('''')))) then Some (s, rd, rs1, rs2) else None)
      | _ => None
    )
    )
      | _ => None
    )
    )
      | _ => None
    )
    )
      | _ => None
    )
    )
      | _ => None
    )
    )
      | _ => None
    )
    ) else None)
    | _ => None
  )
  )
   else None))\<close> 
  for  s40420  :: " string "


\<comment> \<open>\<open>val _s4022_ : string -> maybe ((bool * mword ty5 * mword ty5 * mword ty5))\<close>\<close>

definition s4022  :: \<open> string \<Rightarrow>(bool*(5)Word.word*(5)Word.word*(5)Word.word)option \<close>  where 
     \<open> s4022 s40230 = (
   (let s40240 = s40230 in
   if ((string_startswith s40240 (''div''))) then  
  (case  ((string_drop s40240 ((string_length (''div''))))) of
        s40250 =>
  (case  ((maybe_not_u_matches_prefix s40250)) of
        Some ((s, s40260)) =>
  (let s40270 = (string_drop s40250 s40260) in
  if ((string_startswith s40270 (''w''))) then
    (case  ((string_drop s40270 ((string_length (''w''))))) of
          s40280 =>
    (case  ((spc_matches_prefix0 s40280)) of
          Some ((_, s40290)) =>
    (case  ((string_drop s40280 s40290)) of
          s40300 =>
    (case  ((reg_name_matches_prefix s40300 :: (( 5 Word.word * ii)) option)) of
          Some ((rd, s40310)) =>
    (case  ((string_drop s40300 s40310)) of
          s40320 =>
    (case  ((sep_matches_prefix s40320)) of
          Some ((_, s40330)) =>
    (case  ((string_drop s40320 s40330)) of
          s40340 =>
    (case  ((reg_name_matches_prefix s40340 :: (( 5 Word.word * ii)) option)) of
          Some ((rs1, s40350)) =>
    (case  ((string_drop s40340 s40350)) of
          s40360 =>
    (case  ((sep_matches_prefix s40360)) of
          Some ((_, s40370)) =>
    (case  ((string_drop s40360 s40370)) of
          s40380 =>
    (case  ((reg_name_matches_prefix s40380 :: (( 5 Word.word * ii)) option)) of
          Some ((rs2, s40390)) =>
    (let p00 = (string_drop s40380 s40390) in
    if (((p00 = ('''')))) then Some (s, rd, rs1, rs2) else None)
      | _ => None
    )
    )
      | _ => None
    )
    )
      | _ => None
    )
    )
      | _ => None
    )
    )
      | _ => None
    )
    )
      | _ => None
    )
    ) else None)
    | _ => None
  )
  )
   else None))\<close> 
  for  s40230  :: " string "


\<comment> \<open>\<open>val _s4006_ : string -> maybe ((mword ty5 * mword ty5 * mword ty5))\<close>\<close>

definition s4006  :: \<open> string \<Rightarrow>((5)Word.word*(5)Word.word*(5)Word.word)option \<close>  where 
     \<open> s4006 s40070 = (
   (let s40080 = s40070 in
   if ((string_startswith s40080 (''mulw''))) then  
  (case  ((string_drop s40080 ((string_length (''mulw''))))) of
        s40090 =>
  (case  ((spc_matches_prefix0 s40090)) of
        Some ((_, s40100)) =>
  (case  ((string_drop s40090 s40100)) of
        s40110 =>
  (case  ((reg_name_matches_prefix s40110 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s40120)) =>
  (case  ((string_drop s40110 s40120)) of
        s40130 =>
  (case  ((sep_matches_prefix s40130)) of
        Some ((_, s40140)) =>
  (case  ((string_drop s40130 s40140)) of
        s40150 =>
  (case  ((reg_name_matches_prefix s40150 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s40160)) =>
  (case  ((string_drop s40150 s40160)) of
        s40170 =>
  (case  ((sep_matches_prefix s40170)) of
        Some ((_, s40180)) =>
  (case  ((string_drop s40170 s40180)) of
        s40190 =>
  (case  ((reg_name_matches_prefix s40190 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s40200)) =>
  (let p00 = (string_drop s40190 s40200) in
  if (((p00 = ('''')))) then Some (rd, rs1, rs2) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s40070  :: " string "


\<comment> \<open>\<open>val _s3988_ : string -> maybe ((bool * mword ty5 * mword ty5 * mword ty5))\<close>\<close>

definition s3988  :: \<open> string \<Rightarrow>(bool*(5)Word.word*(5)Word.word*(5)Word.word)option \<close>  where 
     \<open> s3988 s39890 = (
   (let s39900 = s39890 in
   if ((string_startswith s39900 (''rem''))) then  
  (case  ((string_drop s39900 ((string_length (''rem''))))) of
        s39910 =>
  (case  ((maybe_not_u_matches_prefix s39910)) of
        Some ((s, s39920)) =>
  (case  ((string_drop s39910 s39920)) of
        s39930 =>
  (case  ((spc_matches_prefix0 s39930)) of
        Some ((_, s39940)) =>
  (case  ((string_drop s39930 s39940)) of
        s39950 =>
  (case  ((reg_name_matches_prefix s39950 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s39960)) =>
  (case  ((string_drop s39950 s39960)) of
        s39970 =>
  (case  ((sep_matches_prefix s39970)) of
        Some ((_, s39980)) =>
  (case  ((string_drop s39970 s39980)) of
        s39990 =>
  (case  ((reg_name_matches_prefix s39990 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s40000)) =>
  (case  ((string_drop s39990 s40000)) of
        s40010 =>
  (case  ((sep_matches_prefix s40010)) of
        Some ((_, s40020)) =>
  (case  ((string_drop s40010 s40020)) of
        s40030 =>
  (case  ((reg_name_matches_prefix s40030 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s40040)) =>
  (let p00 = (string_drop s40030 s40040) in
  if (((p00 = ('''')))) then Some (s, rd, rs1, rs2) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s39890  :: " string "


\<comment> \<open>\<open>val _s3970_ : string -> maybe ((bool * mword ty5 * mword ty5 * mword ty5))\<close>\<close>

definition s3970  :: \<open> string \<Rightarrow>(bool*(5)Word.word*(5)Word.word*(5)Word.word)option \<close>  where 
     \<open> s3970 s39710 = (
   (let s39720 = s39710 in
   if ((string_startswith s39720 (''div''))) then  
  (case  ((string_drop s39720 ((string_length (''div''))))) of
        s39730 =>
  (case  ((maybe_not_u_matches_prefix s39730)) of
        Some ((s, s39740)) =>
  (case  ((string_drop s39730 s39740)) of
        s39750 =>
  (case  ((spc_matches_prefix0 s39750)) of
        Some ((_, s39760)) =>
  (case  ((string_drop s39750 s39760)) of
        s39770 =>
  (case  ((reg_name_matches_prefix s39770 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s39780)) =>
  (case  ((string_drop s39770 s39780)) of
        s39790 =>
  (case  ((sep_matches_prefix s39790)) of
        Some ((_, s39800)) =>
  (case  ((string_drop s39790 s39800)) of
        s39810 =>
  (case  ((reg_name_matches_prefix s39810 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s39820)) =>
  (case  ((string_drop s39810 s39820)) of
        s39830 =>
  (case  ((sep_matches_prefix s39830)) of
        Some ((_, s39840)) =>
  (case  ((string_drop s39830 s39840)) of
        s39850 =>
  (case  ((reg_name_matches_prefix s39850 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s39860)) =>
  (let p00 = (string_drop s39850 s39860) in
  if (((p00 = ('''')))) then Some (s, rd, rs1, rs2) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s39710  :: " string "


\<comment> \<open>\<open>val _s3953_ : string -> maybe ((bool * bool * bool * mword ty5 * mword ty5 * mword ty5))\<close>\<close>

definition s3953  :: \<open> string \<Rightarrow>(bool*bool*bool*(5)Word.word*(5)Word.word*(5)Word.word)option \<close>  where 
     \<open> s3953 s39550 = (
      (case  ((mul_mnemonic_matches_prefix s39550)) of
        Some (((high, signed1, signed2), s39560)) => 
  (case  ((string_drop s39550 s39560)) of
        s39570 =>
  (case  ((spc_matches_prefix0 s39570)) of
        Some ((_, s39580)) =>
  (case  ((string_drop s39570 s39580)) of
        s39590 =>
  (case  ((reg_name_matches_prefix s39590 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s39600)) =>
  (case  ((string_drop s39590 s39600)) of
        s39610 =>
  (case  ((sep_matches_prefix s39610)) of
        Some ((_, s39620)) =>
  (case  ((string_drop s39610 s39620)) of
        s39630 =>
  (case  ((reg_name_matches_prefix s39630 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s39640)) =>
  (case  ((string_drop s39630 s39640)) of
        s39650 =>
  (case  ((sep_matches_prefix s39650)) of
        Some ((_, s39660)) =>
  (case  ((string_drop s39650 s39660)) of
        s39670 =>
  (case  ((reg_name_matches_prefix s39670 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s39680)) =>
  (let p00 = (string_drop s39670 s39680) in
  if (((p00 = ('''')))) then Some (high, signed1, signed2, rd, rs1, rs2) else
    None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s39550  :: " string "


\<comment> \<open>\<open>val _s3941_ : string -> maybe ((mword ty5 * mword ty5))\<close>\<close>

definition s3941  :: \<open> string \<Rightarrow>((5)Word.word*(5)Word.word)option \<close>  where 
     \<open> s3941 s39420 = (
   (let s39430 = s39420 in
   if ((string_startswith s39430 (''c.add''))) then  
  (case  ((string_drop s39430 ((string_length (''c.add''))))) of
        s39440 =>
  (case  ((spc_matches_prefix0 s39440)) of
        Some ((_, s39450)) =>
  (case  ((string_drop s39440 s39450)) of
        s39460 =>
  (case  ((reg_name_matches_prefix s39460 :: (( 5 Word.word * ii)) option)) of
        Some ((rsd, s39470)) =>
  (case  ((string_drop s39460 s39470)) of
        s39480 =>
  (case  ((sep_matches_prefix s39480)) of
        Some ((_, s39490)) =>
  (case  ((string_drop s39480 s39490)) of
        s39500 =>
  (case  ((reg_name_matches_prefix s39500 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s39510)) =>
  (let p00 = (string_drop s39500 s39510) in
  if (((p00 = ('''')))) then Some (rsd, rs2) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s39420  :: " string "


\<comment> \<open>\<open>val _s3929_ : string -> maybe ((mword ty5 * mword ty5))\<close>\<close>

definition s3929  :: \<open> string \<Rightarrow>((5)Word.word*(5)Word.word)option \<close>  where 
     \<open> s3929 s39300 = (
   (let s39310 = s39300 in
   if ((string_startswith s39310 (''c.mv''))) then  
  (case  ((string_drop s39310 ((string_length (''c.mv''))))) of
        s39320 =>
  (case  ((spc_matches_prefix0 s39320)) of
        Some ((_, s39330)) =>
  (case  ((string_drop s39320 s39330)) of
        s39340 =>
  (case  ((reg_name_matches_prefix s39340 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s39350)) =>
  (case  ((string_drop s39340 s39350)) of
        s39360 =>
  (case  ((sep_matches_prefix s39360)) of
        Some ((_, s39370)) =>
  (case  ((string_drop s39360 s39370)) of
        s39380 =>
  (case  ((reg_name_matches_prefix s39380 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s39390)) =>
  (let p00 = (string_drop s39380 s39390) in
  if (((p00 = ('''')))) then Some (rd, rs2) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s39300  :: " string "


\<comment> \<open>\<open>val _s3921_ : string -> maybe (mword ty5)\<close>\<close>

definition s3921  :: \<open> string \<Rightarrow>((5)Word.word)option \<close>  where 
     \<open> s3921 s39220 = (
   (let s39230 = s39220 in
   if ((string_startswith s39230 (''c.jalr''))) then  
  (case  ((string_drop s39230 ((string_length (''c.jalr''))))) of
        s39240 =>
  (case  ((spc_matches_prefix0 s39240)) of
        Some ((_, s39250)) =>
  (case  ((string_drop s39240 s39250)) of
        s39260 =>
  (case  ((reg_name_matches_prefix s39260 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s39270)) =>
  (let p00 = (string_drop s39260 s39270) in
  if (((p00 = ('''')))) then Some rs1 else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s39220  :: " string "


\<comment> \<open>\<open>val _s3913_ : string -> maybe (mword ty5)\<close>\<close>

definition s3913  :: \<open> string \<Rightarrow>((5)Word.word)option \<close>  where 
     \<open> s3913 s39140 = (
   (let s39150 = s39140 in
   if ((string_startswith s39150 (''c.jr''))) then  
  (case  ((string_drop s39150 ((string_length (''c.jr''))))) of
        s39160 =>
  (case  ((spc_matches_prefix0 s39160)) of
        Some ((_, s39170)) =>
  (case  ((string_drop s39160 s39170)) of
        s39180 =>
  (case  ((reg_name_matches_prefix s39180 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s39190)) =>
  (let p00 = (string_drop s39180 s39190) in
  if (((p00 = ('''')))) then Some rs1 else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s39140  :: " string "


\<comment> \<open>\<open>val _s3901_ : string -> maybe ((mword ty5 * mword ty6))\<close>\<close>

definition s3901  :: \<open> string \<Rightarrow>((5)Word.word*(6)Word.word)option \<close>  where 
     \<open> s3901 s39020 = (
   (let s39030 = s39020 in
   if ((string_startswith s39030 (''c.sdsp''))) then  
  (case  ((string_drop s39030 ((string_length (''c.sdsp''))))) of
        s39040 =>
  (case  ((spc_matches_prefix0 s39040)) of
        Some ((_, s39050)) =>
  (case  ((string_drop s39040 s39050)) of
        s39060 =>
  (case  ((reg_name_matches_prefix s39060 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s39070)) =>
  (case  ((string_drop s39060 s39070)) of
        s39080 =>
  (case  ((sep_matches_prefix s39080)) of
        Some ((_, s39090)) =>
  (case  ((string_drop s39080 s39090)) of
        s39100 =>
  (case  ((hex_bits_6_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s39100 :: (( 6 Word.word * ii)) option)) of
        Some ((uimm, s39110)) =>
  (let p00 = (string_drop s39100 s39110) in
  if (((p00 = ('''')))) then Some (rs2, uimm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s39020  :: " string "


\<comment> \<open>\<open>val _s3889_ : string -> maybe ((mword ty5 * mword ty6))\<close>\<close>

definition s3889  :: \<open> string \<Rightarrow>((5)Word.word*(6)Word.word)option \<close>  where 
     \<open> s3889 s38900 = (
   (let s38910 = s38900 in
   if ((string_startswith s38910 (''c.swsp''))) then  
  (case  ((string_drop s38910 ((string_length (''c.swsp''))))) of
        s38920 =>
  (case  ((spc_matches_prefix0 s38920)) of
        Some ((_, s38930)) =>
  (case  ((string_drop s38920 s38930)) of
        s38940 =>
  (case  ((reg_name_matches_prefix s38940 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s38950)) =>
  (case  ((string_drop s38940 s38950)) of
        s38960 =>
  (case  ((sep_matches_prefix s38960)) of
        Some ((_, s38970)) =>
  (case  ((string_drop s38960 s38970)) of
        s38980 =>
  (case  ((hex_bits_6_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s38980 :: (( 6 Word.word * ii)) option)) of
        Some ((uimm, s38990)) =>
  (let p00 = (string_drop s38980 s38990) in
  if (((p00 = ('''')))) then Some (rd, uimm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s38900  :: " string "


\<comment> \<open>\<open>val _s3877_ : string -> maybe ((mword ty5 * mword ty6))\<close>\<close>

definition s3877  :: \<open> string \<Rightarrow>((5)Word.word*(6)Word.word)option \<close>  where 
     \<open> s3877 s38780 = (
   (let s38790 = s38780 in
   if ((string_startswith s38790 (''c.ldsp''))) then  
  (case  ((string_drop s38790 ((string_length (''c.ldsp''))))) of
        s38800 =>
  (case  ((spc_matches_prefix0 s38800)) of
        Some ((_, s38810)) =>
  (case  ((string_drop s38800 s38810)) of
        s38820 =>
  (case  ((reg_name_matches_prefix s38820 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s38830)) =>
  (case  ((string_drop s38820 s38830)) of
        s38840 =>
  (case  ((sep_matches_prefix s38840)) of
        Some ((_, s38850)) =>
  (case  ((string_drop s38840 s38850)) of
        s38860 =>
  (case  ((hex_bits_6_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s38860 :: (( 6 Word.word * ii)) option)) of
        Some ((uimm, s38870)) =>
  (let p00 = (string_drop s38860 s38870) in
  if (((p00 = ('''')))) then Some (rd, uimm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s38780  :: " string "


\<comment> \<open>\<open>val _s3865_ : string -> maybe ((mword ty5 * mword ty6))\<close>\<close>

definition s3865  :: \<open> string \<Rightarrow>((5)Word.word*(6)Word.word)option \<close>  where 
     \<open> s3865 s38660 = (
   (let s38670 = s38660 in
   if ((string_startswith s38670 (''c.lwsp''))) then  
  (case  ((string_drop s38670 ((string_length (''c.lwsp''))))) of
        s38680 =>
  (case  ((spc_matches_prefix0 s38680)) of
        Some ((_, s38690)) =>
  (case  ((string_drop s38680 s38690)) of
        s38700 =>
  (case  ((reg_name_matches_prefix s38700 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s38710)) =>
  (case  ((string_drop s38700 s38710)) of
        s38720 =>
  (case  ((sep_matches_prefix s38720)) of
        Some ((_, s38730)) =>
  (case  ((string_drop s38720 s38730)) of
        s38740 =>
  (case  ((hex_bits_6_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s38740 :: (( 6 Word.word * ii)) option)) of
        Some ((uimm, s38750)) =>
  (let p00 = (string_drop s38740 s38750) in
  if (((p00 = ('''')))) then Some (rd, uimm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s38660  :: " string "


\<comment> \<open>\<open>val _s3853_ : string -> maybe ((mword ty5 * mword ty6))\<close>\<close>

definition s3853  :: \<open> string \<Rightarrow>((5)Word.word*(6)Word.word)option \<close>  where 
     \<open> s3853 s38540 = (
   (let s38550 = s38540 in
   if ((string_startswith s38550 (''c.slli''))) then  
  (case  ((string_drop s38550 ((string_length (''c.slli''))))) of
        s38560 =>
  (case  ((spc_matches_prefix0 s38560)) of
        Some ((_, s38570)) =>
  (case  ((string_drop s38560 s38570)) of
        s38580 =>
  (case  ((reg_name_matches_prefix s38580 :: (( 5 Word.word * ii)) option)) of
        Some ((rsd, s38590)) =>
  (case  ((string_drop s38580 s38590)) of
        s38600 =>
  (case  ((sep_matches_prefix s38600)) of
        Some ((_, s38610)) =>
  (case  ((string_drop s38600 s38610)) of
        s38620 =>
  (case  ((hex_bits_6_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s38620 :: (( 6 Word.word * ii)) option)) of
        Some ((shamt, s38630)) =>
  (let p00 = (string_drop s38620 s38630) in
  if (((p00 = ('''')))) then Some (rsd, shamt) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s38540  :: " string "


\<comment> \<open>\<open>val _s3841_ : string -> maybe ((mword ty3 * mword ty8))\<close>\<close>

definition s3841  :: \<open> string \<Rightarrow>((3)Word.word*(8)Word.word)option \<close>  where 
     \<open> s3841 s38420 = (
   (let s38430 = s38420 in
   if ((string_startswith s38430 (''c.bnez''))) then  
  (case  ((string_drop s38430 ((string_length (''c.bnez''))))) of
        s38440 =>
  (case  ((spc_matches_prefix0 s38440)) of
        Some ((_, s38450)) =>
  (case  ((string_drop s38440 s38450)) of
        s38460 =>
  (case  ((creg_name_matches_prefix s38460 :: (( 3 Word.word * ii)) option)) of
        Some ((rs, s38470)) =>
  (case  ((string_drop s38460 s38470)) of
        s38480 =>
  (case  ((sep_matches_prefix s38480)) of
        Some ((_, s38490)) =>
  (case  ((string_drop s38480 s38490)) of
        s38500 =>
  (case  ((hex_bits_8_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s38500 :: (( 8 Word.word * ii)) option)) of
        Some ((imm, s38510)) =>
  (let p00 = (string_drop s38500 s38510) in
  if (((p00 = ('''')))) then Some (rs, imm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s38420  :: " string "


\<comment> \<open>\<open>val _s3829_ : string -> maybe ((mword ty3 * mword ty8))\<close>\<close>

definition s3829  :: \<open> string \<Rightarrow>((3)Word.word*(8)Word.word)option \<close>  where 
     \<open> s3829 s38300 = (
   (let s38310 = s38300 in
   if ((string_startswith s38310 (''c.beqz''))) then  
  (case  ((string_drop s38310 ((string_length (''c.beqz''))))) of
        s38320 =>
  (case  ((spc_matches_prefix0 s38320)) of
        Some ((_, s38330)) =>
  (case  ((string_drop s38320 s38330)) of
        s38340 =>
  (case  ((creg_name_matches_prefix s38340 :: (( 3 Word.word * ii)) option)) of
        Some ((rs, s38350)) =>
  (case  ((string_drop s38340 s38350)) of
        s38360 =>
  (case  ((sep_matches_prefix s38360)) of
        Some ((_, s38370)) =>
  (case  ((string_drop s38360 s38370)) of
        s38380 =>
  (case  ((hex_bits_8_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s38380 :: (( 8 Word.word * ii)) option)) of
        Some ((imm, s38390)) =>
  (let p00 = (string_drop s38380 s38390) in
  if (((p00 = ('''')))) then Some (rs, imm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s38300  :: " string "


\<comment> \<open>\<open>val _s3821_ : string -> maybe (mword ty11)\<close>\<close>

definition s3821  :: \<open> string \<Rightarrow>((11)Word.word)option \<close>  where 
     \<open> s3821 s38220 = (
   (let s38230 = s38220 in
   if ((string_startswith s38230 (''c.j''))) then  
  (case  ((string_drop s38230 ((string_length (''c.j''))))) of
        s38240 =>
  (case  ((spc_matches_prefix0 s38240)) of
        Some ((_, s38250)) =>
  (case  ((string_drop s38240 s38250)) of
        s38260 =>
  (case  ((hex_bits_11_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s38260 :: (( 11 Word.word * ii)) option)) of
        Some ((imm, s38270)) =>
  (let p00 = (string_drop s38260 s38270) in
  if (((p00 = ('''')))) then Some imm else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s38220  :: " string "


\<comment> \<open>\<open>val _s3809_ : string -> maybe ((mword ty3 * mword ty3))\<close>\<close>

definition s3809  :: \<open> string \<Rightarrow>((3)Word.word*(3)Word.word)option \<close>  where 
     \<open> s3809 s38100 = (
   (let s38110 = s38100 in
   if ((string_startswith s38110 (''c.addw''))) then  
  (case  ((string_drop s38110 ((string_length (''c.addw''))))) of
        s38120 =>
  (case  ((spc_matches_prefix0 s38120)) of
        Some ((_, s38130)) =>
  (case  ((string_drop s38120 s38130)) of
        s38140 =>
  (case  ((creg_name_matches_prefix s38140 :: (( 3 Word.word * ii)) option)) of
        Some ((rsd, s38150)) =>
  (case  ((string_drop s38140 s38150)) of
        s38160 =>
  (case  ((sep_matches_prefix s38160)) of
        Some ((_, s38170)) =>
  (case  ((string_drop s38160 s38170)) of
        s38180 =>
  (case  ((creg_name_matches_prefix s38180 :: (( 3 Word.word * ii)) option)) of
        Some ((rs2, s38190)) =>
  (let p00 = (string_drop s38180 s38190) in
  if (((p00 = ('''')))) then Some (rsd, rs2) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s38100  :: " string "


\<comment> \<open>\<open>val _s3797_ : string -> maybe ((mword ty3 * mword ty3))\<close>\<close>

definition s3797  :: \<open> string \<Rightarrow>((3)Word.word*(3)Word.word)option \<close>  where 
     \<open> s3797 s37980 = (
   (let s37990 = s37980 in
   if ((string_startswith s37990 (''c.subw''))) then  
  (case  ((string_drop s37990 ((string_length (''c.subw''))))) of
        s38000 =>
  (case  ((spc_matches_prefix0 s38000)) of
        Some ((_, s38010)) =>
  (case  ((string_drop s38000 s38010)) of
        s38020 =>
  (case  ((creg_name_matches_prefix s38020 :: (( 3 Word.word * ii)) option)) of
        Some ((rsd, s38030)) =>
  (case  ((string_drop s38020 s38030)) of
        s38040 =>
  (case  ((sep_matches_prefix s38040)) of
        Some ((_, s38050)) =>
  (case  ((string_drop s38040 s38050)) of
        s38060 =>
  (case  ((creg_name_matches_prefix s38060 :: (( 3 Word.word * ii)) option)) of
        Some ((rs2, s38070)) =>
  (let p00 = (string_drop s38060 s38070) in
  if (((p00 = ('''')))) then Some (rsd, rs2) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s37980  :: " string "


\<comment> \<open>\<open>val _s3785_ : string -> maybe ((mword ty3 * mword ty3))\<close>\<close>

definition s3785  :: \<open> string \<Rightarrow>((3)Word.word*(3)Word.word)option \<close>  where 
     \<open> s3785 s37860 = (
   (let s37870 = s37860 in
   if ((string_startswith s37870 (''c.and''))) then  
  (case  ((string_drop s37870 ((string_length (''c.and''))))) of
        s37880 =>
  (case  ((spc_matches_prefix0 s37880)) of
        Some ((_, s37890)) =>
  (case  ((string_drop s37880 s37890)) of
        s37900 =>
  (case  ((creg_name_matches_prefix s37900 :: (( 3 Word.word * ii)) option)) of
        Some ((rsd, s37910)) =>
  (case  ((string_drop s37900 s37910)) of
        s37920 =>
  (case  ((sep_matches_prefix s37920)) of
        Some ((_, s37930)) =>
  (case  ((string_drop s37920 s37930)) of
        s37940 =>
  (case  ((creg_name_matches_prefix s37940 :: (( 3 Word.word * ii)) option)) of
        Some ((rs2, s37950)) =>
  (let p00 = (string_drop s37940 s37950) in
  if (((p00 = ('''')))) then Some (rsd, rs2) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s37860  :: " string "


\<comment> \<open>\<open>val _s3773_ : string -> maybe ((mword ty3 * mword ty3))\<close>\<close>

definition s3773  :: \<open> string \<Rightarrow>((3)Word.word*(3)Word.word)option \<close>  where 
     \<open> s3773 s37740 = (
   (let s37750 = s37740 in
   if ((string_startswith s37750 (''c.or''))) then  
  (case  ((string_drop s37750 ((string_length (''c.or''))))) of
        s37760 =>
  (case  ((spc_matches_prefix0 s37760)) of
        Some ((_, s37770)) =>
  (case  ((string_drop s37760 s37770)) of
        s37780 =>
  (case  ((creg_name_matches_prefix s37780 :: (( 3 Word.word * ii)) option)) of
        Some ((rsd, s37790)) =>
  (case  ((string_drop s37780 s37790)) of
        s37800 =>
  (case  ((sep_matches_prefix s37800)) of
        Some ((_, s37810)) =>
  (case  ((string_drop s37800 s37810)) of
        s37820 =>
  (case  ((creg_name_matches_prefix s37820 :: (( 3 Word.word * ii)) option)) of
        Some ((rs2, s37830)) =>
  (let p00 = (string_drop s37820 s37830) in
  if (((p00 = ('''')))) then Some (rsd, rs2) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s37740  :: " string "


\<comment> \<open>\<open>val _s3761_ : string -> maybe ((mword ty3 * mword ty3))\<close>\<close>

definition s3761  :: \<open> string \<Rightarrow>((3)Word.word*(3)Word.word)option \<close>  where 
     \<open> s3761 s37620 = (
   (let s37630 = s37620 in
   if ((string_startswith s37630 (''c.xor''))) then  
  (case  ((string_drop s37630 ((string_length (''c.xor''))))) of
        s37640 =>
  (case  ((spc_matches_prefix0 s37640)) of
        Some ((_, s37650)) =>
  (case  ((string_drop s37640 s37650)) of
        s37660 =>
  (case  ((creg_name_matches_prefix s37660 :: (( 3 Word.word * ii)) option)) of
        Some ((rsd, s37670)) =>
  (case  ((string_drop s37660 s37670)) of
        s37680 =>
  (case  ((sep_matches_prefix s37680)) of
        Some ((_, s37690)) =>
  (case  ((string_drop s37680 s37690)) of
        s37700 =>
  (case  ((creg_name_matches_prefix s37700 :: (( 3 Word.word * ii)) option)) of
        Some ((rs2, s37710)) =>
  (let p00 = (string_drop s37700 s37710) in
  if (((p00 = ('''')))) then Some (rsd, rs2) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s37620  :: " string "


\<comment> \<open>\<open>val _s3749_ : string -> maybe ((mword ty3 * mword ty3))\<close>\<close>

definition s3749  :: \<open> string \<Rightarrow>((3)Word.word*(3)Word.word)option \<close>  where 
     \<open> s3749 s37500 = (
   (let s37510 = s37500 in
   if ((string_startswith s37510 (''c.sub''))) then  
  (case  ((string_drop s37510 ((string_length (''c.sub''))))) of
        s37520 =>
  (case  ((spc_matches_prefix0 s37520)) of
        Some ((_, s37530)) =>
  (case  ((string_drop s37520 s37530)) of
        s37540 =>
  (case  ((creg_name_matches_prefix s37540 :: (( 3 Word.word * ii)) option)) of
        Some ((rsd, s37550)) =>
  (case  ((string_drop s37540 s37550)) of
        s37560 =>
  (case  ((sep_matches_prefix s37560)) of
        Some ((_, s37570)) =>
  (case  ((string_drop s37560 s37570)) of
        s37580 =>
  (case  ((creg_name_matches_prefix s37580 :: (( 3 Word.word * ii)) option)) of
        Some ((rs2, s37590)) =>
  (let p00 = (string_drop s37580 s37590) in
  if (((p00 = ('''')))) then Some (rsd, rs2) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s37500  :: " string "


\<comment> \<open>\<open>val _s3737_ : string -> maybe ((mword ty3 * mword ty6))\<close>\<close>

definition s3737  :: \<open> string \<Rightarrow>((3)Word.word*(6)Word.word)option \<close>  where 
     \<open> s3737 s37380 = (
   (let s37390 = s37380 in
   if ((string_startswith s37390 (''c.andi''))) then  
  (case  ((string_drop s37390 ((string_length (''c.andi''))))) of
        s37400 =>
  (case  ((spc_matches_prefix0 s37400)) of
        Some ((_, s37410)) =>
  (case  ((string_drop s37400 s37410)) of
        s37420 =>
  (case  ((creg_name_matches_prefix s37420 :: (( 3 Word.word * ii)) option)) of
        Some ((rsd, s37430)) =>
  (case  ((string_drop s37420 s37430)) of
        s37440 =>
  (case  ((sep_matches_prefix s37440)) of
        Some ((_, s37450)) =>
  (case  ((string_drop s37440 s37450)) of
        s37460 =>
  (case  ((hex_bits_6_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s37460 :: (( 6 Word.word * ii)) option)) of
        Some ((imm, s37470)) =>
  (let p00 = (string_drop s37460 s37470) in
  if (((p00 = ('''')))) then Some (rsd, imm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s37380  :: " string "


\<comment> \<open>\<open>val _s3725_ : string -> maybe ((mword ty3 * mword ty6))\<close>\<close>

definition s3725  :: \<open> string \<Rightarrow>((3)Word.word*(6)Word.word)option \<close>  where 
     \<open> s3725 s37260 = (
   (let s37270 = s37260 in
   if ((string_startswith s37270 (''c.srai''))) then  
  (case  ((string_drop s37270 ((string_length (''c.srai''))))) of
        s37280 =>
  (case  ((spc_matches_prefix0 s37280)) of
        Some ((_, s37290)) =>
  (case  ((string_drop s37280 s37290)) of
        s37300 =>
  (case  ((creg_name_matches_prefix s37300 :: (( 3 Word.word * ii)) option)) of
        Some ((rsd, s37310)) =>
  (case  ((string_drop s37300 s37310)) of
        s37320 =>
  (case  ((sep_matches_prefix s37320)) of
        Some ((_, s37330)) =>
  (case  ((string_drop s37320 s37330)) of
        s37340 =>
  (case  ((hex_bits_6_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s37340 :: (( 6 Word.word * ii)) option)) of
        Some ((shamt, s37350)) =>
  (let p00 = (string_drop s37340 s37350) in
  if (((p00 = ('''')))) then Some (rsd, shamt) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s37260  :: " string "


\<comment> \<open>\<open>val _s3713_ : string -> maybe ((mword ty3 * mword ty6))\<close>\<close>

definition s3713  :: \<open> string \<Rightarrow>((3)Word.word*(6)Word.word)option \<close>  where 
     \<open> s3713 s37140 = (
   (let s37150 = s37140 in
   if ((string_startswith s37150 (''c.srli''))) then  
  (case  ((string_drop s37150 ((string_length (''c.srli''))))) of
        s37160 =>
  (case  ((spc_matches_prefix0 s37160)) of
        Some ((_, s37170)) =>
  (case  ((string_drop s37160 s37170)) of
        s37180 =>
  (case  ((creg_name_matches_prefix s37180 :: (( 3 Word.word * ii)) option)) of
        Some ((rsd, s37190)) =>
  (case  ((string_drop s37180 s37190)) of
        s37200 =>
  (case  ((sep_matches_prefix s37200)) of
        Some ((_, s37210)) =>
  (case  ((string_drop s37200 s37210)) of
        s37220 =>
  (case  ((hex_bits_6_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s37220 :: (( 6 Word.word * ii)) option)) of
        Some ((shamt, s37230)) =>
  (let p00 = (string_drop s37220 s37230) in
  if (((p00 = ('''')))) then Some (rsd, shamt) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s37140  :: " string "


\<comment> \<open>\<open>val _s3701_ : string -> maybe ((mword ty5 * mword ty6))\<close>\<close>

definition s3701  :: \<open> string \<Rightarrow>((5)Word.word*(6)Word.word)option \<close>  where 
     \<open> s3701 s37020 = (
   (let s37030 = s37020 in
   if ((string_startswith s37030 (''c.lui''))) then  
  (case  ((string_drop s37030 ((string_length (''c.lui''))))) of
        s37040 =>
  (case  ((spc_matches_prefix0 s37040)) of
        Some ((_, s37050)) =>
  (case  ((string_drop s37040 s37050)) of
        s37060 =>
  (case  ((reg_name_matches_prefix s37060 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s37070)) =>
  (case  ((string_drop s37060 s37070)) of
        s37080 =>
  (case  ((sep_matches_prefix s37080)) of
        Some ((_, s37090)) =>
  (case  ((string_drop s37080 s37090)) of
        s37100 =>
  (case  ((hex_bits_6_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s37100 :: (( 6 Word.word * ii)) option)) of
        Some ((imm, s37110)) =>
  (let p00 = (string_drop s37100 s37110) in
  if (((p00 = ('''')))) then Some (rd, imm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s37020  :: " string "


\<comment> \<open>\<open>val _s3693_ : string -> maybe (mword ty6)\<close>\<close>

definition s3693  :: \<open> string \<Rightarrow>((6)Word.word)option \<close>  where 
     \<open> s3693 s36940 = (
   (let s36950 = s36940 in
   if ((string_startswith s36950 (''c.addi16sp''))) then  
  (case  ((string_drop s36950 ((string_length (''c.addi16sp''))))) of
        s36960 =>
  (case  ((spc_matches_prefix0 s36960)) of
        Some ((_, s36970)) =>
  (case  ((string_drop s36960 s36970)) of
        s36980 =>
  (case  ((hex_bits_6_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s36980 :: (( 6 Word.word * ii)) option)) of
        Some ((imm, s36990)) =>
  (let p00 = (string_drop s36980 s36990) in
  if (((p00 = ('''')))) then Some imm else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s36940  :: " string "


\<comment> \<open>\<open>val _s3681_ : string -> maybe ((mword ty5 * mword ty6))\<close>\<close>

definition s3681  :: \<open> string \<Rightarrow>((5)Word.word*(6)Word.word)option \<close>  where 
     \<open> s3681 s36820 = (
   (let s36830 = s36820 in
   if ((string_startswith s36830 (''c.li''))) then  
  (case  ((string_drop s36830 ((string_length (''c.li''))))) of
        s36840 =>
  (case  ((spc_matches_prefix0 s36840)) of
        Some ((_, s36850)) =>
  (case  ((string_drop s36840 s36850)) of
        s36860 =>
  (case  ((reg_name_matches_prefix s36860 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s36870)) =>
  (case  ((string_drop s36860 s36870)) of
        s36880 =>
  (case  ((sep_matches_prefix s36880)) of
        Some ((_, s36890)) =>
  (case  ((string_drop s36880 s36890)) of
        s36900 =>
  (case  ((hex_bits_6_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s36900 :: (( 6 Word.word * ii)) option)) of
        Some ((imm, s36910)) =>
  (let p00 = (string_drop s36900 s36910) in
  if (((p00 = ('''')))) then Some (rd, imm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s36820  :: " string "


\<comment> \<open>\<open>val _s3669_ : string -> maybe ((mword ty5 * mword ty6))\<close>\<close>

definition s3669  :: \<open> string \<Rightarrow>((5)Word.word*(6)Word.word)option \<close>  where 
     \<open> s3669 s36700 = (
   (let s36710 = s36700 in
   if ((string_startswith s36710 (''c.addiw''))) then  
  (case  ((string_drop s36710 ((string_length (''c.addiw''))))) of
        s36720 =>
  (case  ((spc_matches_prefix0 s36720)) of
        Some ((_, s36730)) =>
  (case  ((string_drop s36720 s36730)) of
        s36740 =>
  (case  ((reg_name_matches_prefix s36740 :: (( 5 Word.word * ii)) option)) of
        Some ((rsd, s36750)) =>
  (case  ((string_drop s36740 s36750)) of
        s36760 =>
  (case  ((sep_matches_prefix s36760)) of
        Some ((_, s36770)) =>
  (case  ((string_drop s36760 s36770)) of
        s36780 =>
  (case  ((hex_bits_6_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s36780 :: (( 6 Word.word * ii)) option)) of
        Some ((imm, s36790)) =>
  (let p00 = (string_drop s36780 s36790) in
  if (((p00 = ('''')))) then Some (rsd, imm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s36700  :: " string "


\<comment> \<open>\<open>val _s3661_ : string -> maybe (mword ty11)\<close>\<close>

definition s3661  :: \<open> string \<Rightarrow>((11)Word.word)option \<close>  where 
     \<open> s3661 s36620 = (
   (let s36630 = s36620 in
   if ((string_startswith s36630 (''c.jal''))) then  
  (case  ((string_drop s36630 ((string_length (''c.jal''))))) of
        s36640 =>
  (case  ((spc_matches_prefix0 s36640)) of
        Some ((_, s36650)) =>
  (case  ((string_drop s36640 s36650)) of
        s36660 =>
  (case  ((hex_bits_12_matches_prefix0 s36660 :: (( 12 Word.word * ii)) option)) of
        Some ((v__1470, s36670)) =>
  if (((((subrange_vec_dec v__1470 (( 0 :: int):: ii) (( 0 :: int):: ii) :: 1 Word.word))
          = ( 0b0 :: 1 Word.word)))) then
    (let (imm :: 11 Word.word) = ((subrange_vec_dec v__1470
                                     (( 11 :: int):: ii) (( 1 :: int):: ii) :: 11 Word.word)) in
    (let (imm :: 11 Word.word) = ((subrange_vec_dec v__1470
                                     (( 11 :: int):: ii) (( 1 :: int):: ii) :: 11 Word.word)) in
    (let p00 = (string_drop s36660 s36670) in
    if (((p00 = ('''')))) then Some imm else None))) else None
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s36620  :: " string "


\<comment> \<open>\<open>val _s3649_ : string -> maybe ((mword ty5 * mword ty6))\<close>\<close>

definition s3649  :: \<open> string \<Rightarrow>((5)Word.word*(6)Word.word)option \<close>  where 
     \<open> s3649 s36500 = (
   (let s36510 = s36500 in
   if ((string_startswith s36510 (''c.addi''))) then  
  (case  ((string_drop s36510 ((string_length (''c.addi''))))) of
        s36520 =>
  (case  ((spc_matches_prefix0 s36520)) of
        Some ((_, s36530)) =>
  (case  ((string_drop s36520 s36530)) of
        s36540 =>
  (case  ((reg_name_matches_prefix s36540 :: (( 5 Word.word * ii)) option)) of
        Some ((rsd, s36550)) =>
  (case  ((string_drop s36540 s36550)) of
        s36560 =>
  (case  ((sep_matches_prefix s36560)) of
        Some ((_, s36570)) =>
  (case  ((string_drop s36560 s36570)) of
        s36580 =>
  (case  ((hex_bits_6_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s36580 :: (( 6 Word.word * ii)) option)) of
        Some ((nzi, s36590)) =>
  (let p00 = (string_drop s36580 s36590) in
  if (((p00 = ('''')))) then Some (rsd, nzi) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s36500  :: " string "


\<comment> \<open>\<open>val _s3633_ : string -> maybe ((mword ty3 * mword ty3 * mword ty5))\<close>\<close>

definition s3633  :: \<open> string \<Rightarrow>((3)Word.word*(3)Word.word*(5)Word.word)option \<close>  where 
     \<open> s3633 s36340 = (
   (let s36350 = s36340 in
   if ((string_startswith s36350 (''c.sd''))) then  
  (case  ((string_drop s36350 ((string_length (''c.sd''))))) of
        s36360 =>
  (case  ((spc_matches_prefix0 s36360)) of
        Some ((_, s36370)) =>
  (case  ((string_drop s36360 s36370)) of
        s36380 =>
  (case  ((creg_name_matches_prefix s36380 :: (( 3 Word.word * ii)) option)) of
        Some ((rsc1, s36390)) =>
  (case  ((string_drop s36380 s36390)) of
        s36400 =>
  (case  ((sep_matches_prefix s36400)) of
        Some ((_, s36410)) =>
  (case  ((string_drop s36400 s36410)) of
        s36420 =>
  (case  ((creg_name_matches_prefix s36420 :: (( 3 Word.word * ii)) option)) of
        Some ((rsc2, s36430)) =>
  (case  ((string_drop s36420 s36430)) of
        s36440 =>
  (case  ((sep_matches_prefix s36440)) of
        Some ((_, s36450)) =>
  (case  ((string_drop s36440 s36450)) of
        s36460 =>
  (case  ((hex_bits_8_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s36460 :: (( 8 Word.word * ii)) option)) of
        Some ((v__1472, s36470)) =>
  if (((((subrange_vec_dec v__1472 (( 2 :: int):: ii) (( 0 :: int):: ii)
         :: 3 Word.word)) = ( 0b000 :: 3 Word.word)))) then
    (let (uimm :: 5 Word.word) =
         ((subrange_vec_dec v__1472 (( 7 :: int):: ii) (( 3 :: int):: ii) :: 5 Word.word)) in
    (let (uimm :: 5 Word.word) =
         ((subrange_vec_dec v__1472 (( 7 :: int):: ii) (( 3 :: int):: ii) :: 5 Word.word)) in
    (let p00 = (string_drop s36460 s36470) in
    if (((p00 = ('''')))) then Some (rsc1, rsc2, uimm) else None))) else 
  None
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s36340  :: " string "


\<comment> \<open>\<open>val _s3617_ : string -> maybe ((mword ty3 * mword ty3 * mword ty5))\<close>\<close>

definition s3617  :: \<open> string \<Rightarrow>((3)Word.word*(3)Word.word*(5)Word.word)option \<close>  where 
     \<open> s3617 s36180 = (
   (let s36190 = s36180 in
   if ((string_startswith s36190 (''c.sw''))) then  
  (case  ((string_drop s36190 ((string_length (''c.sw''))))) of
        s36200 =>
  (case  ((spc_matches_prefix0 s36200)) of
        Some ((_, s36210)) =>
  (case  ((string_drop s36200 s36210)) of
        s36220 =>
  (case  ((creg_name_matches_prefix s36220 :: (( 3 Word.word * ii)) option)) of
        Some ((rsc1, s36230)) =>
  (case  ((string_drop s36220 s36230)) of
        s36240 =>
  (case  ((sep_matches_prefix s36240)) of
        Some ((_, s36250)) =>
  (case  ((string_drop s36240 s36250)) of
        s36260 =>
  (case  ((creg_name_matches_prefix s36260 :: (( 3 Word.word * ii)) option)) of
        Some ((rsc2, s36270)) =>
  (case  ((string_drop s36260 s36270)) of
        s36280 =>
  (case  ((sep_matches_prefix s36280)) of
        Some ((_, s36290)) =>
  (case  ((string_drop s36280 s36290)) of
        s36300 =>
  (case  ((hex_bits_7_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s36300 :: (( 7 Word.word * ii)) option)) of
        Some ((v__1474, s36310)) =>
  if (((((subrange_vec_dec v__1474 (( 1 :: int):: ii) (( 0 :: int):: ii)
         :: 2 Word.word)) = ( 0b00 :: 2 Word.word)))) then
    (let (uimm :: 5 Word.word) =
         ((subrange_vec_dec v__1474 (( 6 :: int):: ii) (( 2 :: int):: ii) :: 5 Word.word)) in
    (let (uimm :: 5 Word.word) =
         ((subrange_vec_dec v__1474 (( 6 :: int):: ii) (( 2 :: int):: ii) :: 5 Word.word)) in
    (let p00 = (string_drop s36300 s36310) in
    if (((p00 = ('''')))) then Some (rsc1, rsc2, uimm) else None))) else 
  None
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s36180  :: " string "


\<comment> \<open>\<open>val _s3601_ : string -> maybe ((mword ty3 * mword ty3 * mword ty5))\<close>\<close>

definition s3601  :: \<open> string \<Rightarrow>((3)Word.word*(3)Word.word*(5)Word.word)option \<close>  where 
     \<open> s3601 s36020 = (
   (let s36030 = s36020 in
   if ((string_startswith s36030 (''c.ld''))) then  
  (case  ((string_drop s36030 ((string_length (''c.ld''))))) of
        s36040 =>
  (case  ((spc_matches_prefix0 s36040)) of
        Some ((_, s36050)) =>
  (case  ((string_drop s36040 s36050)) of
        s36060 =>
  (case  ((creg_name_matches_prefix s36060 :: (( 3 Word.word * ii)) option)) of
        Some ((rdc, s36070)) =>
  (case  ((string_drop s36060 s36070)) of
        s36080 =>
  (case  ((sep_matches_prefix s36080)) of
        Some ((_, s36090)) =>
  (case  ((string_drop s36080 s36090)) of
        s36100 =>
  (case  ((creg_name_matches_prefix s36100 :: (( 3 Word.word * ii)) option)) of
        Some ((rsc, s36110)) =>
  (case  ((string_drop s36100 s36110)) of
        s36120 =>
  (case  ((sep_matches_prefix s36120)) of
        Some ((_, s36130)) =>
  (case  ((string_drop s36120 s36130)) of
        s36140 =>
  (case  ((hex_bits_8_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s36140 :: (( 8 Word.word * ii)) option)) of
        Some ((v__1476, s36150)) =>
  if (((((subrange_vec_dec v__1476 (( 2 :: int):: ii) (( 0 :: int):: ii)
         :: 3 Word.word)) = ( 0b000 :: 3 Word.word)))) then
    (let (uimm :: 5 Word.word) =
         ((subrange_vec_dec v__1476 (( 7 :: int):: ii) (( 3 :: int):: ii) :: 5 Word.word)) in
    (let (uimm :: 5 Word.word) =
         ((subrange_vec_dec v__1476 (( 7 :: int):: ii) (( 3 :: int):: ii) :: 5 Word.word)) in
    (let p00 = (string_drop s36140 s36150) in
    if (((p00 = ('''')))) then Some (rdc, rsc, uimm) else None))) else 
  None
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s36020  :: " string "


\<comment> \<open>\<open>val _s3585_ : string -> maybe ((mword ty3 * mword ty3 * mword ty5))\<close>\<close>

definition s3585  :: \<open> string \<Rightarrow>((3)Word.word*(3)Word.word*(5)Word.word)option \<close>  where 
     \<open> s3585 s35860 = (
   (let s35870 = s35860 in
   if ((string_startswith s35870 (''c.lw''))) then  
  (case  ((string_drop s35870 ((string_length (''c.lw''))))) of
        s35880 =>
  (case  ((spc_matches_prefix0 s35880)) of
        Some ((_, s35890)) =>
  (case  ((string_drop s35880 s35890)) of
        s35900 =>
  (case  ((creg_name_matches_prefix s35900 :: (( 3 Word.word * ii)) option)) of
        Some ((rdc, s35910)) =>
  (case  ((string_drop s35900 s35910)) of
        s35920 =>
  (case  ((sep_matches_prefix s35920)) of
        Some ((_, s35930)) =>
  (case  ((string_drop s35920 s35930)) of
        s35940 =>
  (case  ((creg_name_matches_prefix s35940 :: (( 3 Word.word * ii)) option)) of
        Some ((rsc, s35950)) =>
  (case  ((string_drop s35940 s35950)) of
        s35960 =>
  (case  ((sep_matches_prefix s35960)) of
        Some ((_, s35970)) =>
  (case  ((string_drop s35960 s35970)) of
        s35980 =>
  (case  ((hex_bits_7_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s35980 :: (( 7 Word.word * ii)) option)) of
        Some ((v__1478, s35990)) =>
  if (((((subrange_vec_dec v__1478 (( 1 :: int):: ii) (( 0 :: int):: ii)
         :: 2 Word.word)) = ( 0b00 :: 2 Word.word)))) then
    (let (uimm :: 5 Word.word) =
         ((subrange_vec_dec v__1478 (( 6 :: int):: ii) (( 2 :: int):: ii) :: 5 Word.word)) in
    (let (uimm :: 5 Word.word) =
         ((subrange_vec_dec v__1478 (( 6 :: int):: ii) (( 2 :: int):: ii) :: 5 Word.word)) in
    (let p00 = (string_drop s35980 s35990) in
    if (((p00 = ('''')))) then Some (rdc, rsc, uimm) else None))) else 
  None
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s35860  :: " string "


\<comment> \<open>\<open>val _s3573_ : string -> maybe ((mword ty3 * mword ty8))\<close>\<close>

definition s3573  :: \<open> string \<Rightarrow>((3)Word.word*(8)Word.word)option \<close>  where 
     \<open> s3573 s35740 = (
   (let s35750 = s35740 in
   if ((string_startswith s35750 (''c.addi4spn''))) then  
  (case  ((string_drop s35750 ((string_length (''c.addi4spn''))))) of
        s35760 =>
  (case  ((spc_matches_prefix0 s35760)) of
        Some ((_, s35770)) =>
  (case  ((string_drop s35760 s35770)) of
        s35780 =>
  (case  ((creg_name_matches_prefix s35780 :: (( 3 Word.word * ii)) option)) of
        Some ((rdc, s35790)) =>
  (case  ((string_drop s35780 s35790)) of
        s35800 =>
  (case  ((sep_matches_prefix s35800)) of
        Some ((_, s35810)) =>
  (case  ((string_drop s35800 s35810)) of
        s35820 =>
  (case  ((hex_bits_10_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s35820 :: (( 10 Word.word * ii)) option)) of
        Some ((v__1480, s35830)) =>
  if (((((subrange_vec_dec v__1480 (( 1 :: int):: ii) (( 0 :: int):: ii) :: 2 Word.word))
          = ( 0b00 :: 2 Word.word)))) then
    (let (nzimm :: 8 Word.word) =
         ((subrange_vec_dec v__1480 (( 9 :: int):: ii) (( 2 :: int):: ii) :: 8 Word.word)) in
    (let (nzimm :: 8 Word.word) =
         ((subrange_vec_dec v__1480 (( 9 :: int):: ii) (( 2 :: int):: ii) :: 8 Word.word)) in
    (let p00 = (string_drop s35820 s35830) in
    if (((p00 = ('''')))) then Some (rdc, nzimm) else None))) else None
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s35740  :: " string "


\<comment> \<open>\<open>val _s3547_ : string -> maybe ((amoop * word_width * bool * bool * mword ty5 * mword ty5 * mword ty5))\<close>\<close>

definition s3547  :: \<open> string \<Rightarrow>(amoop*word_width*bool*bool*(5)Word.word*(5)Word.word*(5)Word.word)option \<close>  where 
     \<open> s3547 s35490 = (
      (case  ((amo_mnemonic_matches_prefix s35490)) of
        Some ((op1, s35500)) =>
         (let s35510 = (string_drop s35490 s35500) in
         if ((string_startswith s35510 (''.''))) then  
  (case  ((string_drop s35510 ((string_length (''.''))))) of
        s35520 =>
  (case  ((size_mnemonic_matches_prefix s35520)) of
        Some ((width, s35530)) =>
  (case  ((string_drop s35520 s35530)) of
        s35540 =>
  (case  ((maybe_aq_matches_prefix s35540)) of
        Some ((aq, s35550)) =>
  (case  ((string_drop s35540 s35550)) of
        s35560 =>
  (case  ((maybe_rl_matches_prefix s35560)) of
        Some ((rl, s35570)) =>
  (case  ((string_drop s35560 s35570)) of
        s35580 =>
  (case  ((spc_matches_prefix0 s35580)) of
        Some ((_, s35590)) =>
  (case  ((string_drop s35580 s35590)) of
        s35600 =>
  (case  ((reg_name_matches_prefix s35600 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s35610)) =>
  (case  ((string_drop s35600 s35610)) of
        s35620 =>
  (case  ((sep_matches_prefix s35620)) of
        Some ((_, s35630)) =>
  (case  ((string_drop s35620 s35630)) of
        s35640 =>
  (case  ((reg_name_matches_prefix s35640 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s35650)) =>
  (case  ((string_drop s35640 s35650)) of
        s35660 =>
  (case  ((sep_matches_prefix s35660)) of
        Some ((_, s35670)) =>
  (let s35680 = (string_drop s35660 s35670) in
  if ((string_startswith s35680 (''(''))) then
    (case  ((string_drop s35680 ((string_length (''(''))))) of
          s35690 =>
    (case  ((reg_name_matches_prefix s35690 :: (( 5 Word.word * ii)) option)) of
          Some ((rs1, s35700)) =>
    (let s35710 = (string_drop s35690 s35700) in
    if ((string_startswith s35710 ('')''))) then
      (let p00 = (string_drop s35710 ((string_length ('')'')))) in
      if (((p00 = ('''')))) then Some (op1, width, aq, rl, rd, rs2, rs1) else
        None) else None)
      | _ => None
    )
    ) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
         else None)
      | _ => None
      ))\<close> 
  for  s35490  :: " string "


\<comment> \<open>\<open>val _s3525_ : string -> maybe ((word_width * bool * bool * mword ty5 * mword ty5 * mword ty5))\<close>\<close>

definition s3525  :: \<open> string \<Rightarrow>(word_width*bool*bool*(5)Word.word*(5)Word.word*(5)Word.word)option \<close>  where 
     \<open> s3525 s35260 = (
   (let s35270 = s35260 in
   if ((string_startswith s35270 (''sc.''))) then  
  (case  ((string_drop s35270 ((string_length (''sc.''))))) of
        s35280 =>
  (case  ((size_mnemonic_matches_prefix s35280)) of
        Some ((size1, s35290)) =>
  (case  ((string_drop s35280 s35290)) of
        s35300 =>
  (case  ((maybe_aq_matches_prefix s35300)) of
        Some ((aq, s35310)) =>
  (case  ((string_drop s35300 s35310)) of
        s35320 =>
  (case  ((maybe_rl_matches_prefix s35320)) of
        Some ((rl, s35330)) =>
  (case  ((string_drop s35320 s35330)) of
        s35340 =>
  (case  ((spc_matches_prefix0 s35340)) of
        Some ((_, s35350)) =>
  (case  ((string_drop s35340 s35350)) of
        s35360 =>
  (case  ((reg_name_matches_prefix s35360 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s35370)) =>
  (case  ((string_drop s35360 s35370)) of
        s35380 =>
  (case  ((sep_matches_prefix s35380)) of
        Some ((_, s35390)) =>
  (case  ((string_drop s35380 s35390)) of
        s35400 =>
  (case  ((reg_name_matches_prefix s35400 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s35410)) =>
  (case  ((string_drop s35400 s35410)) of
        s35420 =>
  (case  ((sep_matches_prefix s35420)) of
        Some ((_, s35430)) =>
  (case  ((string_drop s35420 s35430)) of
        s35440 =>
  (case  ((reg_name_matches_prefix s35440 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s35450)) =>
  (let p00 = (string_drop s35440 s35450) in
  if (((p00 = ('''')))) then Some (size1, aq, rl, rd, rs1, rs2) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s35260  :: " string "


\<comment> \<open>\<open>val _s3507_ : string -> maybe ((word_width * bool * bool * mword ty5 * mword ty5))\<close>\<close>

definition s3507  :: \<open> string \<Rightarrow>(word_width*bool*bool*(5)Word.word*(5)Word.word)option \<close>  where 
     \<open> s3507 s35080 = (
   (let s35090 = s35080 in
   if ((string_startswith s35090 (''lr.''))) then  
  (case  ((string_drop s35090 ((string_length (''lr.''))))) of
        s35100 =>
  (case  ((size_mnemonic_matches_prefix s35100)) of
        Some ((size1, s35110)) =>
  (case  ((string_drop s35100 s35110)) of
        s35120 =>
  (case  ((maybe_aq_matches_prefix s35120)) of
        Some ((aq, s35130)) =>
  (case  ((string_drop s35120 s35130)) of
        s35140 =>
  (case  ((maybe_rl_matches_prefix s35140)) of
        Some ((rl, s35150)) =>
  (case  ((string_drop s35140 s35150)) of
        s35160 =>
  (case  ((spc_matches_prefix0 s35160)) of
        Some ((_, s35170)) =>
  (case  ((string_drop s35160 s35170)) of
        s35180 =>
  (case  ((reg_name_matches_prefix s35180 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s35190)) =>
  (case  ((string_drop s35180 s35190)) of
        s35200 =>
  (case  ((sep_matches_prefix s35200)) of
        Some ((_, s35210)) =>
  (case  ((string_drop s35200 s35210)) of
        s35220 =>
  (case  ((reg_name_matches_prefix s35220 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s35230)) =>
  (let p00 = (string_drop s35220 s35230) in
  if (((p00 = ('''')))) then Some (size1, aq, rl, rd, rs1) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s35080  :: " string "


\<comment> \<open>\<open>val _s3495_ : string -> maybe ((mword ty5 * mword ty5))\<close>\<close>

definition s3495  :: \<open> string \<Rightarrow>((5)Word.word*(5)Word.word)option \<close>  where 
     \<open> s3495 s34960 = (
   (let s34970 = s34960 in
   if ((string_startswith s34970 (''sfence.vma''))) then  
  (case  ((string_drop s34970 ((string_length (''sfence.vma''))))) of
        s34980 =>
  (case  ((spc_matches_prefix0 s34980)) of
        Some ((_, s34990)) =>
  (case  ((string_drop s34980 s34990)) of
        s35000 =>
  (case  ((reg_name_matches_prefix s35000 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s35010)) =>
  (case  ((string_drop s35000 s35010)) of
        s35020 =>
  (case  ((sep_matches_prefix s35020)) of
        Some ((_, s35030)) =>
  (case  ((string_drop s35020 s35030)) of
        s35040 =>
  (case  ((reg_name_matches_prefix s35040 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s35050)) =>
  (let p00 = (string_drop s35040 s35050) in
  if (((p00 = ('''')))) then Some (rs1, rs2) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s34960  :: " string "


\<comment> \<open>\<open>val _s3483_ : string -> maybe ((mword ty4 * mword ty4))\<close>\<close>

definition s3483  :: \<open> string \<Rightarrow>((4)Word.word*(4)Word.word)option \<close>  where 
     \<open> s3483 s34840 = (
   (let s34850 = s34840 in
   if ((string_startswith s34850 (''fence.tso''))) then  
  (case  ((string_drop s34850 ((string_length (''fence.tso''))))) of
        s34860 =>
  (case  ((spc_matches_prefix0 s34860)) of
        Some ((_, s34870)) =>
  (case  ((string_drop s34860 s34870)) of
        s34880 =>
  (case  ((fence_bits_matches_prefix s34880 :: (( 4 Word.word * ii)) option)) of
        Some ((pred, s34890)) =>
  (case  ((string_drop s34880 s34890)) of
        s34900 =>
  (case  ((sep_matches_prefix s34900)) of
        Some ((_, s34910)) =>
  (case  ((string_drop s34900 s34910)) of
        s34920 =>
  (case  ((fence_bits_matches_prefix s34920 :: (( 4 Word.word * ii)) option)) of
        Some ((succ, s34930)) =>
  (let p00 = (string_drop s34920 s34930) in
  if (((p00 = ('''')))) then Some (pred, succ) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s34840  :: " string "


\<comment> \<open>\<open>val _s3471_ : string -> maybe ((mword ty4 * mword ty4))\<close>\<close>

definition s3471  :: \<open> string \<Rightarrow>((4)Word.word*(4)Word.word)option \<close>  where 
     \<open> s3471 s34720 = (
   (let s34730 = s34720 in
   if ((string_startswith s34730 (''fence''))) then  
  (case  ((string_drop s34730 ((string_length (''fence''))))) of
        s34740 =>
  (case  ((spc_matches_prefix0 s34740)) of
        Some ((_, s34750)) =>
  (case  ((string_drop s34740 s34750)) of
        s34760 =>
  (case  ((fence_bits_matches_prefix s34760 :: (( 4 Word.word * ii)) option)) of
        Some ((pred, s34770)) =>
  (case  ((string_drop s34760 s34770)) of
        s34780 =>
  (case  ((sep_matches_prefix s34780)) of
        Some ((_, s34790)) =>
  (case  ((string_drop s34780 s34790)) of
        s34800 =>
  (case  ((fence_bits_matches_prefix s34800 :: (( 4 Word.word * ii)) option)) of
        Some ((succ, s34810)) =>
  (let p00 = (string_drop s34800 s34810) in
  if (((p00 = ('''')))) then Some (pred, succ) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s34720  :: " string "


\<comment> \<open>\<open>val _s3454_ : string -> maybe ((sopw * mword ty5 * mword ty5 * mword ty5))\<close>\<close>

definition s3454  :: \<open> string \<Rightarrow>(sopw*(5)Word.word*(5)Word.word*(5)Word.word)option \<close>  where 
     \<open> s3454 s34560 = (
      (case  ((shiftiwop_mnemonic_matches_prefix s34560)) of
        Some ((op1, s34570)) => 
  (case  ((string_drop s34560 s34570)) of
        s34580 =>
  (case  ((spc_matches_prefix0 s34580)) of
        Some ((_, s34590)) =>
  (case  ((string_drop s34580 s34590)) of
        s34600 =>
  (case  ((reg_name_matches_prefix s34600 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s34610)) =>
  (case  ((string_drop s34600 s34610)) of
        s34620 =>
  (case  ((sep_matches_prefix s34620)) of
        Some ((_, s34630)) =>
  (case  ((string_drop s34620 s34630)) of
        s34640 =>
  (case  ((reg_name_matches_prefix s34640 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s34650)) =>
  (case  ((string_drop s34640 s34650)) of
        s34660 =>
  (case  ((sep_matches_prefix s34660)) of
        Some ((_, s34670)) =>
  (case  ((string_drop s34660 s34670)) of
        s34680 =>
  (case  ((hex_bits_5_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s34680 :: (( 5 Word.word * ii)) option)) of
        Some ((shamt, s34690)) =>
  (let p00 = (string_drop s34680 s34690) in
  if (((p00 = ('''')))) then Some (op1, rd, rs1, shamt) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s34560  :: " string "


\<comment> \<open>\<open>val _s3437_ : string -> maybe ((ropw * mword ty5 * mword ty5 * mword ty5))\<close>\<close>

definition s3437  :: \<open> string \<Rightarrow>(ropw*(5)Word.word*(5)Word.word*(5)Word.word)option \<close>  where 
     \<open> s3437 s34390 = (
      (case  ((rtypew_mnemonic_matches_prefix s34390)) of
        Some ((op1, s34400)) => 
  (case  ((string_drop s34390 s34400)) of
        s34410 =>
  (case  ((spc_matches_prefix0 s34410)) of
        Some ((_, s34420)) =>
  (case  ((string_drop s34410 s34420)) of
        s34430 =>
  (case  ((reg_name_matches_prefix s34430 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s34440)) =>
  (case  ((string_drop s34430 s34440)) of
        s34450 =>
  (case  ((sep_matches_prefix s34450)) of
        Some ((_, s34460)) =>
  (case  ((string_drop s34450 s34460)) of
        s34470 =>
  (case  ((reg_name_matches_prefix s34470 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s34480)) =>
  (case  ((string_drop s34470 s34480)) of
        s34490 =>
  (case  ((sep_matches_prefix s34490)) of
        Some ((_, s34500)) =>
  (case  ((string_drop s34490 s34500)) of
        s34510 =>
  (case  ((reg_name_matches_prefix s34510 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s34520)) =>
  (let p00 = (string_drop s34510 s34520) in
  if (((p00 = ('''')))) then Some (op1, rd, rs1, rs2) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s34390  :: " string "


\<comment> \<open>\<open>val _s3420_ : string -> maybe ((sop * mword ty5 * mword ty5 * mword ty5))\<close>\<close>

definition s3420  :: \<open> string \<Rightarrow>(sop*(5)Word.word*(5)Word.word*(5)Word.word)option \<close>  where 
     \<open> s3420 s34220 = (
      (case  ((shiftw_mnemonic_matches_prefix s34220)) of
        Some ((op1, s34230)) => 
  (case  ((string_drop s34220 s34230)) of
        s34240 =>
  (case  ((spc_matches_prefix0 s34240)) of
        Some ((_, s34250)) =>
  (case  ((string_drop s34240 s34250)) of
        s34260 =>
  (case  ((reg_name_matches_prefix s34260 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s34270)) =>
  (case  ((string_drop s34260 s34270)) of
        s34280 =>
  (case  ((sep_matches_prefix s34280)) of
        Some ((_, s34290)) =>
  (case  ((string_drop s34280 s34290)) of
        s34300 =>
  (case  ((reg_name_matches_prefix s34300 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s34310)) =>
  (case  ((string_drop s34300 s34310)) of
        s34320 =>
  (case  ((sep_matches_prefix s34320)) of
        Some ((_, s34330)) =>
  (case  ((string_drop s34320 s34330)) of
        s34340 =>
  (case  ((hex_bits_5_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s34340 :: (( 5 Word.word * ii)) option)) of
        Some ((shamt, s34350)) =>
  (let p00 = (string_drop s34340 s34350) in
  if (((p00 = ('''')))) then Some (op1, rd, rs1, shamt) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s34220  :: " string "


\<comment> \<open>\<open>val _s3404_ : string -> maybe ((mword ty5 * mword ty5 * mword ty12))\<close>\<close>

definition s3404  :: \<open> string \<Rightarrow>((5)Word.word*(5)Word.word*(12)Word.word)option \<close>  where 
     \<open> s3404 s34050 = (
   (let s34060 = s34050 in
   if ((string_startswith s34060 (''addiw''))) then  
  (case  ((string_drop s34060 ((string_length (''addiw''))))) of
        s34070 =>
  (case  ((spc_matches_prefix0 s34070)) of
        Some ((_, s34080)) =>
  (case  ((string_drop s34070 s34080)) of
        s34090 =>
  (case  ((reg_name_matches_prefix s34090 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s34100)) =>
  (case  ((string_drop s34090 s34100)) of
        s34110 =>
  (case  ((sep_matches_prefix s34110)) of
        Some ((_, s34120)) =>
  (case  ((string_drop s34110 s34120)) of
        s34130 =>
  (case  ((reg_name_matches_prefix s34130 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s34140)) =>
  (case  ((string_drop s34130 s34140)) of
        s34150 =>
  (case  ((sep_matches_prefix s34150)) of
        Some ((_, s34160)) =>
  (case  ((string_drop s34150 s34160)) of
        s34170 =>
  (case  ((hex_bits_12_matches_prefix0 s34170
          :: (( 12 Word.word * ii)) option)) of
        Some ((imm, s34180)) =>
  (let p00 = (string_drop s34170 s34180) in
  if (((p00 = ('''')))) then Some (rd, rs1, imm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s34050  :: " string "


\<comment> \<open>\<open>val _s3376_ : string -> maybe ((word_width * bool * bool * mword ty5 * mword ty12 * mword ty5))\<close>\<close>

definition s3376  :: \<open> string \<Rightarrow>(word_width*bool*bool*(5)Word.word*(12)Word.word*(5)Word.word)option \<close>  where 
     \<open> s3376 s33770 = (
   (let s33780 = s33770 in
   if ((string_startswith s33780 (''s''))) then  
  (case  ((string_drop s33780 ((string_length (''s''))))) of
        s33790 =>
  (case  ((size_mnemonic_matches_prefix s33790)) of
        Some ((size1, s33800)) =>
  (case  ((string_drop s33790 s33800)) of
        s33810 =>
  (case  ((maybe_aq_matches_prefix s33810)) of
        Some ((aq, s33820)) =>
  (case  ((string_drop s33810 s33820)) of
        s33830 =>
  (case  ((maybe_rl_matches_prefix s33830)) of
        Some ((rl, s33840)) =>
  (case  ((string_drop s33830 s33840)) of
        s33850 =>
  (case  ((spc_matches_prefix0 s33850)) of
        Some ((_, s33860)) =>
  (case  ((string_drop s33850 s33860)) of
        s33870 =>
  (case  ((reg_name_matches_prefix s33870 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s33880)) =>
  (case  ((string_drop s33870 s33880)) of
        s33890 =>
  (case  ((sep_matches_prefix s33890)) of
        Some ((_, s33900)) =>
  (case  ((string_drop s33890 s33900)) of
        s33910 =>
  (case  ((hex_bits_12_matches_prefix0 s33910
          :: (( 12 Word.word * ii)) option)) of
        Some ((imm, s33920)) =>
  (case  ((string_drop s33910 s33920)) of
        s33930 =>
  (case  ((opt_spc_matches_prefix0 s33930)) of
        Some ((_, s33940)) =>
  (let s33950 = (string_drop s33930 s33940) in
  if ((string_startswith s33950 (''(''))) then
    (case  ((string_drop s33950 ((string_length (''(''))))) of
          s33960 =>
    (case  ((opt_spc_matches_prefix0 s33960)) of
          Some ((_, s33970)) =>
    (case  ((string_drop s33960 s33970)) of
          s33980 =>
    (case  ((reg_name_matches_prefix s33980 :: (( 5 Word.word * ii)) option)) of
          Some ((rs1, s33990)) =>
    (case  ((string_drop s33980 s33990)) of
          s34000 =>
    (case  ((opt_spc_matches_prefix0 s34000)) of
          Some ((_, s34010)) =>
    (let s34020 = (string_drop s34000 s34010) in
    if ((string_startswith s34020 ('')''))) then
      (let p00 = (string_drop s34020 ((string_length ('')'')))) in
      if (((p00 = ('''')))) then Some (size1, aq, rl, rs2, imm, rs1) else
        None) else None)
      | _ => None
    )
    )
      | _ => None
    )
    )
      | _ => None
    )
    ) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s33770  :: " string "


\<comment> \<open>\<open>val _s3346_ : string -> maybe ((word_width * bool * bool * bool * mword ty5 * mword ty12 * mword ty5))\<close>\<close>

definition s3346  :: \<open> string \<Rightarrow>(word_width*bool*bool*bool*(5)Word.word*(12)Word.word*(5)Word.word)option \<close>  where 
     \<open> s3346 s33470 = (
   (let s33480 = s33470 in
   if ((string_startswith s33480 (''l''))) then  
  (case  ((string_drop s33480 ((string_length (''l''))))) of
        s33490 =>
  (case  ((size_mnemonic_matches_prefix s33490)) of
        Some ((size1, s33500)) =>
  (case  ((string_drop s33490 s33500)) of
        s33510 =>
  (case  ((maybe_u_matches_prefix s33510)) of
        Some ((is_unsigned, s33520)) =>
  (case  ((string_drop s33510 s33520)) of
        s33530 =>
  (case  ((maybe_aq_matches_prefix s33530)) of
        Some ((aq, s33540)) =>
  (case  ((string_drop s33530 s33540)) of
        s33550 =>
  (case  ((maybe_rl_matches_prefix s33550)) of
        Some ((rl, s33560)) =>
  (case  ((string_drop s33550 s33560)) of
        s33570 =>
  (case  ((spc_matches_prefix0 s33570)) of
        Some ((_, s33580)) =>
  (case  ((string_drop s33570 s33580)) of
        s33590 =>
  (case  ((reg_name_matches_prefix s33590 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s33600)) =>
  (case  ((string_drop s33590 s33600)) of
        s33610 =>
  (case  ((sep_matches_prefix s33610)) of
        Some ((_, s33620)) =>
  (case  ((string_drop s33610 s33620)) of
        s33630 =>
  (case  ((hex_bits_12_matches_prefix0 s33630
          :: (( 12 Word.word * ii)) option)) of
        Some ((imm, s33640)) =>
  (case  ((string_drop s33630 s33640)) of
        s33650 =>
  (case  ((opt_spc_matches_prefix0 s33650)) of
        Some ((_, s33660)) =>
  (let s33670 = (string_drop s33650 s33660) in
  if ((string_startswith s33670 (''(''))) then
    (case  ((string_drop s33670 ((string_length (''(''))))) of
          s33680 =>
    (case  ((opt_spc_matches_prefix0 s33680)) of
          Some ((_, s33690)) =>
    (case  ((string_drop s33680 s33690)) of
          s33700 =>
    (case  ((reg_name_matches_prefix s33700 :: (( 5 Word.word * ii)) option)) of
          Some ((rs1, s33710)) =>
    (case  ((string_drop s33700 s33710)) of
          s33720 =>
    (case  ((opt_spc_matches_prefix0 s33720)) of
          Some ((_, s33730)) =>
    (let s33740 = (string_drop s33720 s33730) in
    if ((string_startswith s33740 ('')''))) then
      (let p00 = (string_drop s33740 ((string_length ('')'')))) in
      if (((p00 = ('''')))) then
        Some (size1, is_unsigned, aq, rl, rd, imm, rs1) else None) else 
    None)
      | _ => None
    )
    )
      | _ => None
    )
    )
      | _ => None
    )
    ) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s33470  :: " string "


\<comment> \<open>\<open>val _s3329_ : string -> maybe ((rop * mword ty5 * mword ty5 * mword ty5))\<close>\<close>

definition s3329  :: \<open> string \<Rightarrow>(rop*(5)Word.word*(5)Word.word*(5)Word.word)option \<close>  where 
     \<open> s3329 s33310 = (
      (case  ((rtype_mnemonic_matches_prefix s33310)) of
        Some ((op1, s33320)) => 
  (case  ((string_drop s33310 s33320)) of
        s33330 =>
  (case  ((spc_matches_prefix0 s33330)) of
        Some ((_, s33340)) =>
  (case  ((string_drop s33330 s33340)) of
        s33350 =>
  (case  ((reg_name_matches_prefix s33350 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s33360)) =>
  (case  ((string_drop s33350 s33360)) of
        s33370 =>
  (case  ((sep_matches_prefix s33370)) of
        Some ((_, s33380)) =>
  (case  ((string_drop s33370 s33380)) of
        s33390 =>
  (case  ((reg_name_matches_prefix s33390 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s33400)) =>
  (case  ((string_drop s33390 s33400)) of
        s33410 =>
  (case  ((sep_matches_prefix s33410)) of
        Some ((_, s33420)) =>
  (case  ((string_drop s33410 s33420)) of
        s33430 =>
  (case  ((reg_name_matches_prefix s33430 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s33440)) =>
  (let p00 = (string_drop s33430 s33440) in
  if (((p00 = ('''')))) then Some (op1, rd, rs1, rs2) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s33310  :: " string "


\<comment> \<open>\<open>val _s3312_ : string -> maybe ((sop * mword ty5 * mword ty5 * mword ty6))\<close>\<close>

definition s3312  :: \<open> string \<Rightarrow>(sop*(5)Word.word*(5)Word.word*(6)Word.word)option \<close>  where 
     \<open> s3312 s33140 = (
      (case  ((shiftiop_mnemonic_matches_prefix s33140)) of
        Some ((op1, s33150)) => 
  (case  ((string_drop s33140 s33150)) of
        s33160 =>
  (case  ((spc_matches_prefix0 s33160)) of
        Some ((_, s33170)) =>
  (case  ((string_drop s33160 s33170)) of
        s33180 =>
  (case  ((reg_name_matches_prefix s33180 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s33190)) =>
  (case  ((string_drop s33180 s33190)) of
        s33200 =>
  (case  ((sep_matches_prefix s33200)) of
        Some ((_, s33210)) =>
  (case  ((string_drop s33200 s33210)) of
        s33220 =>
  (case  ((reg_name_matches_prefix s33220 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s33230)) =>
  (case  ((string_drop s33220 s33230)) of
        s33240 =>
  (case  ((sep_matches_prefix s33240)) of
        Some ((_, s33250)) =>
  (case  ((string_drop s33240 s33250)) of
        s33260 =>
  (case  ((hex_bits_6_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s33260 :: (( 6 Word.word * ii)) option)) of
        Some ((shamt, s33270)) =>
  (let p00 = (string_drop s33260 s33270) in
  if (((p00 = ('''')))) then Some (op1, rd, rs1, shamt) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s33140  :: " string "


\<comment> \<open>\<open>val _s3295_ : string -> maybe ((iop * mword ty5 * mword ty5 * mword ty12))\<close>\<close>

definition s3295  :: \<open> string \<Rightarrow>(iop*(5)Word.word*(5)Word.word*(12)Word.word)option \<close>  where 
     \<open> s3295 s32970 = (
      (case  ((itype_mnemonic_matches_prefix s32970)) of
        Some ((op1, s32980)) => 
  (case  ((string_drop s32970 s32980)) of
        s32990 =>
  (case  ((spc_matches_prefix0 s32990)) of
        Some ((_, s33000)) =>
  (case  ((string_drop s32990 s33000)) of
        s33010 =>
  (case  ((reg_name_matches_prefix s33010 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s33020)) =>
  (case  ((string_drop s33010 s33020)) of
        s33030 =>
  (case  ((sep_matches_prefix s33030)) of
        Some ((_, s33040)) =>
  (case  ((string_drop s33030 s33040)) of
        s33050 =>
  (case  ((reg_name_matches_prefix s33050 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s33060)) =>
  (case  ((string_drop s33050 s33060)) of
        s33070 =>
  (case  ((sep_matches_prefix s33070)) of
        Some ((_, s33080)) =>
  (case  ((string_drop s33070 s33080)) of
        s33090 =>
  (case  ((hex_bits_12_matches_prefix0 s33090
          :: (( 12 Word.word * ii)) option)) of
        Some ((imm, s33100)) =>
  (let p00 = (string_drop s33090 s33100) in
  if (((p00 = ('''')))) then Some (op1, rd, rs1, imm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s32970  :: " string "


\<comment> \<open>\<open>val _s3278_ : string -> maybe ((bop * mword ty5 * mword ty5 * mword ty13))\<close>\<close>

definition s3278  :: \<open> string \<Rightarrow>(bop*(5)Word.word*(5)Word.word*(13)Word.word)option \<close>  where 
     \<open> s3278 s32800 = (
      (case  ((btype_mnemonic_matches_prefix s32800)) of
        Some ((op1, s32810)) => 
  (case  ((string_drop s32800 s32810)) of
        s32820 =>
  (case  ((spc_matches_prefix0 s32820)) of
        Some ((_, s32830)) =>
  (case  ((string_drop s32820 s32830)) of
        s32840 =>
  (case  ((reg_name_matches_prefix s32840 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s32850)) =>
  (case  ((string_drop s32840 s32850)) of
        s32860 =>
  (case  ((sep_matches_prefix s32860)) of
        Some ((_, s32870)) =>
  (case  ((string_drop s32860 s32870)) of
        s32880 =>
  (case  ((reg_name_matches_prefix s32880 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s32890)) =>
  (case  ((string_drop s32880 s32890)) of
        s32900 =>
  (case  ((sep_matches_prefix s32900)) of
        Some ((_, s32910)) =>
  (case  ((string_drop s32900 s32910)) of
        s32920 =>
  (case  ((hex_bits_13_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s32920 :: (( 13 Word.word * ii)) option)) of
        Some ((imm, s32930)) =>
  (let p00 = (string_drop s32920 s32930) in
  if (((p00 = ('''')))) then Some (op1, rs1, rs2, imm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s32800  :: " string "


\<comment> \<open>\<open>val _s3262_ : string -> maybe ((mword ty5 * mword ty5 * mword ty12))\<close>\<close>

definition s3262  :: \<open> string \<Rightarrow>((5)Word.word*(5)Word.word*(12)Word.word)option \<close>  where 
     \<open> s3262 s32630 = (
   (let s32640 = s32630 in
   if ((string_startswith s32640 (''jalr''))) then  
  (case  ((string_drop s32640 ((string_length (''jalr''))))) of
        s32650 =>
  (case  ((spc_matches_prefix0 s32650)) of
        Some ((_, s32660)) =>
  (case  ((string_drop s32650 s32660)) of
        s32670 =>
  (case  ((reg_name_matches_prefix s32670 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s32680)) =>
  (case  ((string_drop s32670 s32680)) of
        s32690 =>
  (case  ((sep_matches_prefix s32690)) of
        Some ((_, s32700)) =>
  (case  ((string_drop s32690 s32700)) of
        s32710 =>
  (case  ((reg_name_matches_prefix s32710 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s32720)) =>
  (case  ((string_drop s32710 s32720)) of
        s32730 =>
  (case  ((sep_matches_prefix s32730)) of
        Some ((_, s32740)) =>
  (case  ((string_drop s32730 s32740)) of
        s32750 =>
  (case  ((hex_bits_12_matches_prefix0 s32750
          :: (( 12 Word.word * ii)) option)) of
        Some ((imm, s32760)) =>
  (let p00 = (string_drop s32750 s32760) in
  if (((p00 = ('''')))) then Some (rd, rs1, imm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s32630  :: " string "


\<comment> \<open>\<open>val _s3250_ : string -> maybe ((mword ty5 * mword ty21))\<close>\<close>

definition s3250  :: \<open> string \<Rightarrow>((5)Word.word*(21)Word.word)option \<close>  where 
     \<open> s3250 s32510 = (
   (let s32520 = s32510 in
   if ((string_startswith s32520 (''jal''))) then  
  (case  ((string_drop s32520 ((string_length (''jal''))))) of
        s32530 =>
  (case  ((spc_matches_prefix0 s32530)) of
        Some ((_, s32540)) =>
  (case  ((string_drop s32530 s32540)) of
        s32550 =>
  (case  ((reg_name_matches_prefix s32550 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s32560)) =>
  (case  ((string_drop s32550 s32560)) of
        s32570 =>
  (case  ((sep_matches_prefix s32570)) of
        Some ((_, s32580)) =>
  (case  ((string_drop s32570 s32580)) of
        s32590 =>
  (case  ((hex_bits_21_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s32590 :: (( 21 Word.word * ii)) option)) of
        Some ((imm, s32600)) =>
  (let p00 = (string_drop s32590 s32600) in
  if (((p00 = ('''')))) then Some (rd, imm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s32510  :: " string "


\<comment> \<open>\<open>val _s3237_ : string -> maybe ((uop * mword ty5 * mword ty20))\<close>\<close>

definition s3237  :: \<open> string \<Rightarrow>(uop*(5)Word.word*(20)Word.word)option \<close>  where 
     \<open> s3237 s32390 = (
      (case  ((utype_mnemonic_matches_prefix s32390)) of
        Some ((op1, s32400)) => 
  (case  ((string_drop s32390 s32400)) of
        s32410 =>
  (case  ((spc_matches_prefix0 s32410)) of
        Some ((_, s32420)) =>
  (case  ((string_drop s32410 s32420)) of
        s32430 =>
  (case  ((reg_name_matches_prefix s32430 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s32440)) =>
  (case  ((string_drop s32430 s32440)) of
        s32450 =>
  (case  ((sep_matches_prefix s32450)) of
        Some ((_, s32460)) =>
  (case  ((string_drop s32450 s32460)) of
        s32470 =>
  (case  ((hex_bits_20_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s32470 :: (( 20 Word.word * ii)) option)) of
        Some ((imm, s32480)) =>
  (let p00 = (string_drop s32470 s32480) in
  if (((p00 = ('''')))) then Some (op1, rd, imm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s32390  :: " string "


definition assembly_backwards_matches  :: \<open> string \<Rightarrow> bool \<close>  where 
     \<open> assembly_backwards_matches arg1 = (
   (let s32490 = arg1 in
   if ((case  ((s3237 s32490  ::  ((uop *  5 Word.word *  20 Word.word))option)) of
       Some ((op1, rd, imm)) => True
     | _ => False
     )) then  (case  (s3237 s32490 :: (( uop * 5 Word.word * 20 Word.word)) option) of
     (Some ((op1, rd, imm))) =>
 True
 )
   else if ((case  ((s3250 s32490  ::  (( 5 Word.word *  21 Word.word))option)) of
       Some ((rd, imm)) => True
     | _ => False
     )) then  (case  (s3250 s32490 :: (( 5 Word.word * 21 Word.word)) option) of
     (Some ((rd, imm))) =>
 True
 )
   else if ((case  ((s3262 s32490  ::  (( 5 Word.word *  5 Word.word *  12 Word.word))option)) of
       Some ((rd, rs1, imm)) => True
     | _ => False
     )) then  (case  (s3262 s32490 :: (( 5 Word.word * 5 Word.word * 12 Word.word)) option) of
     (Some ((rd, rs1, imm))) =>
 True
 )
   else if ((case  ((s3278 s32490  ::  ((bop *  5 Word.word *  5 Word.word *  13 Word.word))option)) of
       Some ((op1, rs1, rs2, imm)) => True
     | _ => False
     )) then  (case 
 (s3278 s32490 :: (( bop * 5 Word.word * 5 Word.word * 13 Word.word)) option) of
     (Some ((op1, rs1, rs2, imm))) =>
 True
 )
   else if ((case  ((s3295 s32490  ::  ((iop *  5 Word.word *  5 Word.word *  12 Word.word))option)) of
       Some ((op1, rd, rs1, imm)) => True
     | _ => False
     )) then  (case 
 (s3295 s32490 :: (( iop * 5 Word.word * 5 Word.word * 12 Word.word)) option) of
     (Some ((op1, rd, rs1, imm))) =>
 True
 )
   else if ((case  ((s3312 s32490  ::  ((sop *  5 Word.word *  5 Word.word *  6 Word.word))option)) of
       Some ((op1, rd, rs1, shamt)) => True
     | _ => False
     )) then  (case 
 (s3312 s32490 :: (( sop * 5 Word.word * 5 Word.word * 6 Word.word)) option) of
     (Some ((op1, rd, rs1, shamt))) =>
 True
 )
   else if ((case  ((s3329 s32490  ::  ((rop *  5 Word.word *  5 Word.word *  5 Word.word))option)) of
       Some ((op1, rd, rs1, rs2)) => True
     | _ => False
     )) then  (case 
 (s3329 s32490 :: (( rop * 5 Word.word * 5 Word.word * 5 Word.word)) option) of
     (Some ((op1, rd, rs1, rs2))) =>
 True
 )
   else if ((case  ((s3346 s32490
                     ::  ((word_width * bool * bool * bool *  5 Word.word *  12 Word.word *  5 Word.word))option)) of
       Some ((size1, is_unsigned, aq, rl, rd, imm, rs1)) => True
     | _ => False
     )) then  (case 
 (s3346 s32490
 :: (( word_width * bool * bool * bool * 5 Word.word * 12 Word.word * 5 Word.word)) option) of
     (Some ((size1, is_unsigned, aq, rl, rd, imm, rs1))) =>
 True
 )
   else if ((case  ((s3376 s32490
                     ::  ((word_width * bool * bool *  5 Word.word *  12 Word.word *  5 Word.word))option)) of
       Some ((size1, aq, rl, rs2, imm, rs1)) => True
     | _ => False
     )) then  (case 
 (s3376 s32490 :: (( word_width * bool * bool * 5 Word.word * 12 Word.word * 5 Word.word)) option) of
     (Some ((size1, aq, rl, rs2, imm, rs1))) =>
 True
 )
   else if ((case  ((s3404 s32490  ::  (( 5 Word.word *  5 Word.word *  12 Word.word))option)) of
       Some ((rd, rs1, imm)) => ((( 64 :: int)::ii) = (( 64 :: int)::ii))
     | _ => False
     )) then  (case  (s3404 s32490 :: (( 5 Word.word * 5 Word.word * 12 Word.word)) option) of
     (Some ((rd, rs1, imm))) =>
 True
 )
   else if ((case  ((s3420 s32490  ::  ((sop *  5 Word.word *  5 Word.word *  5 Word.word))option)) of
       Some ((op1, rd, rs1, shamt)) => ((( 64 :: int)::ii) = (( 64 :: int)::ii))
     | _ => False
     )) then  (case 
 (s3420 s32490 :: (( sop * 5 Word.word * 5 Word.word * 5 Word.word)) option) of
     (Some ((op1, rd, rs1, shamt))) =>
 True
 )
   else if ((case  ((s3437 s32490  ::  ((ropw *  5 Word.word *  5 Word.word *  5 Word.word))option)) of
       Some ((op1, rd, rs1, rs2)) => ((( 64 :: int)::ii) = (( 64 :: int)::ii))
     | _ => False
     )) then  (case 
 (s3437 s32490 :: (( ropw * 5 Word.word * 5 Word.word * 5 Word.word)) option) of
     (Some ((op1, rd, rs1, rs2))) =>
 True
 )
   else if ((case  ((s3454 s32490  ::  ((sopw *  5 Word.word *  5 Word.word *  5 Word.word))option)) of
       Some ((op1, rd, rs1, shamt)) => ((( 64 :: int)::ii) = (( 64 :: int)::ii))
     | _ => False
     )) then  (case 
 (s3454 s32490 :: (( sopw * 5 Word.word * 5 Word.word * 5 Word.word)) option) of
     (Some ((op1, rd, rs1, shamt))) =>
 True
 )
   else if ((case  ((s3471 s32490  ::  (( 4 Word.word *  4 Word.word))option)) of
       Some ((pred, succ)) => True
     | _ => False
     )) then  (case  (s3471 s32490 :: (( 4 Word.word * 4 Word.word)) option) of
     (Some ((pred, succ))) =>
 True
 )
   else if ((case  ((s3483 s32490  ::  (( 4 Word.word *  4 Word.word))option)) of
       Some ((pred, succ)) => True
     | _ => False
     )) then  (case  (s3483 s32490 :: (( 4 Word.word * 4 Word.word)) option) of
     (Some ((pred, succ))) =>
 True
 )
   else if (((s32490 = (''fence.i'')))) then True
   else if (((s32490 = (''ecall'')))) then True
   else if (((s32490 = (''mret'')))) then True
   else if (((s32490 = (''sret'')))) then True
   else if (((s32490 = (''ebreak'')))) then True
   else if (((s32490 = (''wfi'')))) then True
   else if ((case  ((s3495 s32490  ::  (( 5 Word.word *  5 Word.word))option)) of
       Some ((rs1, rs2)) => True
     | _ => False
     )) then  (case  (s3495 s32490 :: (( 5 Word.word * 5 Word.word)) option) of
     (Some ((rs1, rs2))) =>
 True
 )
   else if ((case  ((s3507 s32490  ::  ((word_width * bool * bool *  5 Word.word *  5 Word.word))option)) of
       Some ((size1, aq, rl, rd, rs1)) => True
     | _ => False
     )) then  (case 
 (s3507 s32490 :: (( word_width * bool * bool * 5 Word.word * 5 Word.word)) option) of
     (Some ((size1, aq, rl, rd, rs1))) =>
 True
 )
   else if ((case  ((s3525 s32490
                     ::  ((word_width * bool * bool *  5 Word.word *  5 Word.word *  5 Word.word))option)) of
       Some ((size1, aq, rl, rd, rs1, rs2)) => True
     | _ => False
     )) then  (case 
 (s3525 s32490 :: (( word_width * bool * bool * 5 Word.word * 5 Word.word * 5 Word.word)) option) of
     (Some ((size1, aq, rl, rd, rs1, rs2))) =>
 True
 )
   else if ((case  ((s3547 s32490
                     ::  ((amoop * word_width * bool * bool *  5 Word.word *  5 Word.word *  5 Word.word))option)) of
       Some ((op1, width, aq, rl, rd, rs2, rs1)) => True
     | _ => False
     )) then  (case 
 (s3547 s32490
 :: (( amoop * word_width * bool * bool * 5 Word.word * 5 Word.word * 5 Word.word)) option) of
     (Some ((op1, width, aq, rl, rd, rs2, rs1))) =>
 True
 )
   else if (((s32490 = (''c.nop'')))) then True
   else if ((case  ((s3573 s32490  ::  (( 3 Word.word *  8 Word.word))option)) of
       Some ((rdc, nzimm)) => (nzimm \<noteq> ( 0x00 ::  8 Word.word))
     | _ => False
     )) then  (case  (s3573 s32490 :: (( 3 Word.word * 8 Word.word)) option) of
     (Some ((rdc, nzimm))) =>
 True
 )
   else if ((case  ((s3585 s32490  ::  (( 3 Word.word *  3 Word.word *  5 Word.word))option)) of
       Some ((rdc, rsc, uimm)) => True
     | _ => False
     )) then  (case 
 (s3585 s32490 :: (( 3 Word.word * 3 Word.word * 5 Word.word)) option) of
     (Some ((rdc, rsc, uimm))) =>
 True
 )
   else if ((case  ((s3601 s32490  ::  (( 3 Word.word *  3 Word.word *  5 Word.word))option)) of
       Some ((rdc, rsc, uimm)) => ((( 64 :: int)::ii) = (( 64 :: int)::ii))
     | _ => False
     )) then  (case 
 (s3601 s32490 :: (( 3 Word.word * 3 Word.word * 5 Word.word)) option) of
     (Some ((rdc, rsc, uimm))) =>
 True
 )
   else if ((case  ((s3617 s32490  ::  (( 3 Word.word *  3 Word.word *  5 Word.word))option)) of
       Some ((rsc1, rsc2, uimm)) => True
     | _ => False
     )) then  (case 
 (s3617 s32490 :: (( 3 Word.word * 3 Word.word * 5 Word.word)) option) of
     (Some ((rsc1, rsc2, uimm))) =>
 True
 )
   else if ((case  ((s3633 s32490  ::  (( 3 Word.word *  3 Word.word *  5 Word.word))option)) of
       Some ((rsc1, rsc2, uimm)) => ((( 64 :: int)::ii) = (( 64 :: int)::ii))
     | _ => False
     )) then  (case 
 (s3633 s32490 :: (( 3 Word.word * 3 Word.word * 5 Word.word)) option) of
     (Some ((rsc1, rsc2, uimm))) =>
 True
 )
   else if ((case  ((s3649 s32490  ::  (( 5 Word.word *  6 Word.word))option)) of
       Some ((rsd, nzi)) => ((((nzi \<noteq> ( 0b000000 ::  6 Word.word)))) \<and> (((rsd \<noteq> zreg))))
     | _ => False
     )) then  (case  (s3649 s32490 :: (( 5 Word.word * 6 Word.word)) option) of
     (Some ((rsd, nzi))) =>
 True
 )
   else if ((case  ((s3661 s32490  ::  ( 11 Word.word)option)) of
       Some (imm) => ((( 64 :: int)::ii) = (( 32 :: int)::ii))
     | _ => False
     )) then  (case  (s3661 s32490 :: ( 11 Word.word) option) of (Some (imm)) => True )
   else if ((case  ((s3669 s32490  ::  (( 5 Word.word *  6 Word.word))option)) of
       Some ((rsd, imm)) => ((( 64 :: int)::ii) = (( 64 :: int)::ii))
     | _ => False
     )) then  (case  (s3669 s32490 :: (( 5 Word.word * 6 Word.word)) option) of
     (Some ((rsd, imm))) =>
 True
 )
   else if ((case  ((s3681 s32490  ::  (( 5 Word.word *  6 Word.word))option)) of
       Some ((rd, imm)) => (rd \<noteq> zreg)
     | _ => False
     )) then  (case  (s3681 s32490 :: (( 5 Word.word * 6 Word.word)) option) of
     (Some ((rd, imm))) =>
 True
 )
   else if ((case  ((s3693 s32490  ::  ( 6 Word.word)option)) of
       Some (imm) => (imm \<noteq> ( 0b000000 ::  6 Word.word))
     | _ => False
     )) then  (case  (s3693 s32490 :: ( 6 Word.word) option) of (Some (imm)) => True )
   else if ((case  ((s3701 s32490  ::  (( 5 Word.word *  6 Word.word))option)) of
       Some ((rd, imm)) =>
        ((((rd \<noteq> zreg))) \<and> ((((((rd \<noteq> sp))) \<and> (((imm \<noteq> ( 0b000000 ::  6 Word.word))))))))
     | _ => False
     )) then  (case  (s3701 s32490 :: (( 5 Word.word * 6 Word.word)) option) of
     (Some ((rd, imm))) =>
 True
 )
   else if ((case  ((s3713 s32490  ::  (( 3 Word.word *  6 Word.word))option)) of
       Some ((rsd, shamt)) => (shamt \<noteq> ( 0b000000 ::  6 Word.word))
     | _ => False
     )) then  (case  (s3713 s32490 :: (( 3 Word.word * 6 Word.word)) option) of
     (Some ((rsd, shamt))) =>
 True
 )
   else if ((case  ((s3725 s32490  ::  (( 3 Word.word *  6 Word.word))option)) of
       Some ((rsd, shamt)) => (shamt \<noteq> ( 0b000000 ::  6 Word.word))
     | _ => False
     )) then  (case  (s3725 s32490 :: (( 3 Word.word * 6 Word.word)) option) of
     (Some ((rsd, shamt))) =>
 True
 )
   else if ((case  ((s3737 s32490  ::  (( 3 Word.word *  6 Word.word))option)) of
       Some ((rsd, imm)) => True
     | _ => False
     )) then  (case  (s3737 s32490 :: (( 3 Word.word * 6 Word.word)) option) of
     (Some ((rsd, imm))) =>
 True
 )
   else if ((case  ((s3749 s32490  ::  (( 3 Word.word *  3 Word.word))option)) of
       Some ((rsd, rs2)) => True
     | _ => False
     )) then  (case  (s3749 s32490 :: (( 3 Word.word * 3 Word.word)) option) of
     (Some ((rsd, rs2))) =>
 True
 )
   else if ((case  ((s3761 s32490  ::  (( 3 Word.word *  3 Word.word))option)) of
       Some ((rsd, rs2)) => True
     | _ => False
     )) then  (case  (s3761 s32490 :: (( 3 Word.word * 3 Word.word)) option) of
     (Some ((rsd, rs2))) =>
 True
 )
   else if ((case  ((s3773 s32490  ::  (( 3 Word.word *  3 Word.word))option)) of
       Some ((rsd, rs2)) => True
     | _ => False
     )) then  (case  (s3773 s32490 :: (( 3 Word.word * 3 Word.word)) option) of
     (Some ((rsd, rs2))) =>
 True
 )
   else if ((case  ((s3785 s32490  ::  (( 3 Word.word *  3 Word.word))option)) of
       Some ((rsd, rs2)) => True
     | _ => False
     )) then  (case  (s3785 s32490 :: (( 3 Word.word * 3 Word.word)) option) of
     (Some ((rsd, rs2))) =>
 True
 )
   else if ((case  ((s3797 s32490  ::  (( 3 Word.word *  3 Word.word))option)) of
       Some ((rsd, rs2)) => ((( 64 :: int)::ii) = (( 64 :: int)::ii))
     | _ => False
     )) then  (case  (s3797 s32490 :: (( 3 Word.word * 3 Word.word)) option) of
     (Some ((rsd, rs2))) =>
 True
 )
   else if ((case  ((s3809 s32490  ::  (( 3 Word.word *  3 Word.word))option)) of
       Some ((rsd, rs2)) => ((( 64 :: int)::ii) = (( 64 :: int)::ii))
     | _ => False
     )) then  (case  (s3809 s32490 :: (( 3 Word.word * 3 Word.word)) option) of
     (Some ((rsd, rs2))) =>
 True
 )
   else if ((case  ((s3821 s32490  ::  ( 11 Word.word)option)) of
       Some (imm) => True
     | _ => False
     )) then  (case  (s3821 s32490 :: ( 11 Word.word) option) of (Some (imm)) => True )
   else if ((case  ((s3829 s32490  ::  (( 3 Word.word *  8 Word.word))option)) of
       Some ((rs, imm)) => True
     | _ => False
     )) then  (case  (s3829 s32490 :: (( 3 Word.word * 8 Word.word)) option) of
     (Some ((rs, imm))) =>
 True
 )
   else if ((case  ((s3841 s32490  ::  (( 3 Word.word *  8 Word.word))option)) of
       Some ((rs, imm)) => True
     | _ => False
     )) then  (case  (s3841 s32490 :: (( 3 Word.word * 8 Word.word)) option) of
     (Some ((rs, imm))) =>
 True
 )
   else if ((case  ((s3853 s32490  ::  (( 5 Word.word *  6 Word.word))option)) of
       Some ((rsd, shamt)) => ((((shamt \<noteq> ( 0b000000 ::  6 Word.word)))) \<and> (((rsd \<noteq> zreg))))
     | _ => False
     )) then  (case  (s3853 s32490 :: (( 5 Word.word * 6 Word.word)) option) of
     (Some ((rsd, shamt))) =>
 True
 )
   else if ((case  ((s3865 s32490  ::  (( 5 Word.word *  6 Word.word))option)) of
       Some ((rd, uimm)) => (rd \<noteq> zreg)
     | _ => False
     )) then  (case  (s3865 s32490 :: (( 5 Word.word * 6 Word.word)) option) of
     (Some ((rd, uimm))) =>
 True
 )
   else if ((case  ((s3877 s32490  ::  (( 5 Word.word *  6 Word.word))option)) of
       Some ((rd, uimm)) => ((((rd \<noteq> zreg))) \<and> ((((( 64 :: int)::ii) = (( 64 :: int)::ii)))))
     | _ => False
     )) then  (case  (s3877 s32490 :: (( 5 Word.word * 6 Word.word)) option) of
     (Some ((rd, uimm))) =>
 True
 )
   else if ((case  ((s3889 s32490  ::  (( 5 Word.word *  6 Word.word))option)) of
       Some ((rd, uimm)) => True
     | _ => False
     )) then  (case  (s3889 s32490 :: (( 5 Word.word * 6 Word.word)) option) of
     (Some ((rd, uimm))) =>
 True
 )
   else if ((case  ((s3901 s32490  ::  (( 5 Word.word *  6 Word.word))option)) of
       Some ((rs2, uimm)) => ((( 64 :: int)::ii) = (( 64 :: int)::ii))
     | _ => False
     )) then  (case  (s3901 s32490 :: (( 5 Word.word * 6 Word.word)) option) of
     (Some ((rs2, uimm))) =>
 True
 )
   else if ((case  ((s3913 s32490  ::  ( 5 Word.word)option)) of
       Some (rs1) => (rs1 \<noteq> zreg)
     | _ => False
     )) then  (case  (s3913 s32490 :: ( 5 Word.word) option) of (Some (rs1)) => True )
   else if ((case  ((s3921 s32490  ::  ( 5 Word.word)option)) of
       Some (rs1) => (rs1 \<noteq> zreg)
     | _ => False
     )) then  (case  (s3921 s32490 :: ( 5 Word.word) option) of (Some (rs1)) => True )
   else if ((case  ((s3929 s32490  ::  (( 5 Word.word *  5 Word.word))option)) of
       Some ((rd, rs2)) => ((((rd \<noteq> zreg))) \<and> (((rs2 \<noteq> zreg))))
     | _ => False
     )) then  (case  (s3929 s32490 :: (( 5 Word.word * 5 Word.word)) option) of
     (Some ((rd, rs2))) =>
 True
 )
   else if (((s32490 = (''c.ebreak'')))) then True
   else if ((case  ((s3941 s32490  ::  (( 5 Word.word *  5 Word.word))option)) of
       Some ((rsd, rs2)) => ((((rsd \<noteq> zreg))) \<and> (((rs2 \<noteq> zreg))))
     | _ => False
     )) then  (case  (s3941 s32490 :: (( 5 Word.word * 5 Word.word)) option) of
     (Some ((rsd, rs2))) =>
 True
 )
   else if ((case  ((s3953 s32490
                     ::  ((bool * bool * bool *  5 Word.word *  5 Word.word *  5 Word.word))option)) of
       Some ((high, signed1, signed2, rd, rs1, rs2)) => True
     | _ => False
     )) then  (case 
 (s3953 s32490 :: (( bool * bool * bool * 5 Word.word * 5 Word.word * 5 Word.word)) option) of
     (Some ((high, signed1, signed2, rd, rs1, rs2))) =>
 True
 )
   else if ((case  ((s3970 s32490  ::  ((bool *  5 Word.word *  5 Word.word *  5 Word.word))option)) of
       Some ((s, rd, rs1, rs2)) => True
     | _ => False
     )) then  (case 
 (s3970 s32490 :: (( bool * 5 Word.word * 5 Word.word * 5 Word.word)) option) of
     (Some ((s, rd, rs1, rs2))) =>
 True
 )
   else if ((case  ((s3988 s32490  ::  ((bool *  5 Word.word *  5 Word.word *  5 Word.word))option)) of
       Some ((s, rd, rs1, rs2)) => True
     | _ => False
     )) then  (case 
 (s3988 s32490 :: (( bool * 5 Word.word * 5 Word.word * 5 Word.word)) option) of
     (Some ((s, rd, rs1, rs2))) =>
 True
 )
   else if ((case  ((s4006 s32490  ::  (( 5 Word.word *  5 Word.word *  5 Word.word))option)) of
       Some ((rd, rs1, rs2)) => ((( 64 :: int)::ii) = (( 64 :: int)::ii))
     | _ => False
     )) then  (case  (s4006 s32490 :: (( 5 Word.word * 5 Word.word * 5 Word.word)) option) of
     (Some ((rd, rs1, rs2))) =>
 True
 )
   else if ((case  ((s4022 s32490  ::  ((bool *  5 Word.word *  5 Word.word *  5 Word.word))option)) of
       Some ((s, rd, rs1, rs2)) => ((( 64 :: int)::ii) = (( 64 :: int)::ii))
     | _ => False
     )) then  (case 
 (s4022 s32490 :: (( bool * 5 Word.word * 5 Word.word * 5 Word.word)) option) of
     (Some ((s, rd, rs1, rs2))) =>
 True
 )
   else if ((case  ((s4041 s32490  ::  ((bool *  5 Word.word *  5 Word.word *  5 Word.word))option)) of
       Some ((s, rd, rs1, rs2)) => ((( 64 :: int)::ii) = (( 64 :: int)::ii))
     | _ => False
     )) then  (case 
 (s4041 s32490 :: (( bool * 5 Word.word * 5 Word.word * 5 Word.word)) option) of
     (Some ((s, rd, rs1, rs2))) =>
 True
 )
   else if ((case  ((s4060 s32490  ::  ((csrop *  5 Word.word *  12 Word.word *  5 Word.word))option)) of
       Some ((op1, rd, csr, rs1)) => True
     | _ => False
     )) then  (case 
 (s4060 s32490 :: (( csrop * 5 Word.word * 12 Word.word * 5 Word.word)) option) of
     (Some ((op1, rd, csr, rs1))) =>
 True
 )
   else if ((case  ((s4078 s32490  ::  ((csrop *  5 Word.word *  12 Word.word *  5 Word.word))option)) of
       Some ((op1, rd, csr, rs1)) => True
     | _ => False
     )) then  (case 
 (s4078 s32490 :: (( csrop * 5 Word.word * 12 Word.word * 5 Word.word)) option) of
     (Some ((op1, rd, csr, rs1))) =>
 True
 )
   else if (((s32490 = (''uret'')))) then True
   else if ((case  ((s4095 s32490  ::  ( 6 Word.word)option)) of
       Some (imm) => True
     | _ => False
     )) then  (case  (s4095 s32490 :: ( 6 Word.word) option) of (Some (imm)) => True )
   else if ((case  ((s4101 s32490  ::  ( 5 Word.word)option)) of
       Some (rsd) => (rsd \<noteq> zreg)
     | _ => False
     )) then  (case  (s4101 s32490 :: ( 5 Word.word) option) of (Some (rsd)) => True )
   else if ((case  ((s4107 s32490  ::  ( 6 Word.word)option)) of
       Some (imm) => True
     | _ => False
     )) then  (case  (s4107 s32490 :: ( 6 Word.word) option) of (Some (imm)) => True )
   else if ((case  ((s4113 s32490  ::  ( 6 Word.word)option)) of
       Some (imm) => (imm \<noteq> ( 0b000000 ::  6 Word.word))
     | _ => False
     )) then  (case  (s4113 s32490 :: ( 6 Word.word) option) of (Some (imm)) => True )
   else if ((case  ((s4119 s32490  ::  ( 5 Word.word)option)) of
       Some (rs2) => (rs2 \<noteq> zreg)
     | _ => False
     )) then  (case  (s4119 s32490 :: ( 5 Word.word) option) of (Some (rs2)) => True )
   else if ((case  ((s4125 s32490  ::  ( 5 Word.word)option)) of
       Some (rs2) => (rs2 \<noteq> zreg)
     | _ => False
     )) then  (case  (s4125 s32490 :: ( 5 Word.word) option) of (Some (rs2)) => True )
   else if ((case  ((s4131 s32490  ::  (( 5 Word.word *  6 Word.word))option)) of
       Some ((rsd, shamt)) => ((((shamt = ( 0b000000 ::  6 Word.word)))) \<or> (((rsd = zreg))))
     | _ => False
     )) then  (case  (s4131 s32490 :: (( 5 Word.word * 6 Word.word)) option) of
     (Some ((rsd, shamt))) =>
 True
 )
   else if ((case  ((s4140 s32490  ::  ( 3 Word.word)option)) of
       Some (rsd) => True
     | _ => False
     )) then  (case  (s4140 s32490 :: ( 3 Word.word) option) of (Some (rsd)) => True )
   else if ((case  ((s4146 s32490  ::  ( 3 Word.word)option)) of
       Some (rsd) => True
     | _ => False
     )) then  (case  (s4146 s32490 :: ( 3 Word.word) option) of (Some (rsd)) => True )
   else if ((case  ((s4152 s32490
                     ::  (( 4 Word.word *  4 Word.word *  5 Word.word *  5 Word.word *  4 Word.word))option)) of
       Some ((pred, succ, rs, rd, fm)) =>
        (((((((fm \<noteq> ( 0x0 ::  4 Word.word)))) \<and> (((fm \<noteq> ( 0x8 ::  4 Word.word))))))) \<or> ((((((rs \<noteq> ( 0b00000 ::  5 Word.word)))) \<or> (((rd \<noteq> ( 0b00000 ::  5 Word.word))))))))
     | _ => False
     )) then  (case 
 (s4152 s32490 :: (( 4 Word.word * 4 Word.word * 5 Word.word * 5 Word.word * 4 Word.word)) option) of
     (Some ((pred, succ, rs, rd, fm))) =>
 True
 )
   else if ((case  ((s4170 s32490  ::  (( 5 Word.word *  5 Word.word *  12 Word.word))option)) of
       Some ((rd, rs, imm)) =>
        ((((imm \<noteq> ( 0x000 ::  12 Word.word)))) \<or> ((((((rs \<noteq> zreg))) \<or> (((rd \<noteq> zreg)))))))
     | _ => False
     )) then  (case  (s4170 s32490 :: (( 5 Word.word * 5 Word.word * 12 Word.word)) option) of
     (Some ((rd, rs, imm))) =>
 True
 )
   else if ((case  ((s4182 s32490  ::  ((word_width *  5 Word.word *  12 Word.word *  5 Word.word))option)) of
       Some ((width, rd, imm, rs1)) => True
     | _ => False
     )) then  (case 
 (s4182 s32490 :: (( word_width * 5 Word.word * 12 Word.word * 5 Word.word)) option) of
     (Some ((width, rd, imm, rs1))) =>
 True
 )
   else if ((case  ((s4206 s32490  ::  ((word_width *  5 Word.word *  12 Word.word *  5 Word.word))option)) of
       Some ((width, rs2, imm, rs1)) => True
     | _ => False
     )) then  (case 
 (s4206 s32490 :: (( word_width * 5 Word.word * 12 Word.word * 5 Word.word)) option) of
     (Some ((width, rs2, imm, rs1))) =>
 True
 )
   else if ((case  ((s4230 s32490
                     ::  ((f_madd_op_S *  5 Word.word *  5 Word.word *  5 Word.word *  5 Word.word * rounding_mode))option)) of
       Some ((op1, rd, rs1, rs2, rs3, rm)) => True
     | _ => False
     )) then  (case 
 (s4230 s32490
 :: (( f_madd_op_S * 5 Word.word * 5 Word.word * 5 Word.word * 5 Word.word * rounding_mode)) option) of
     (Some ((op1, rd, rs1, rs2, rs3, rm))) =>
 True
 )
   else if ((case  ((s4255 s32490
                     ::  ((f_bin_rm_op_S *  5 Word.word *  5 Word.word *  5 Word.word * rounding_mode))option)) of
       Some ((op1, rd, rs1, rs2, rm)) => True
     | _ => False
     )) then  (case 
 (s4255 s32490
 :: (( f_bin_rm_op_S * 5 Word.word * 5 Word.word * 5 Word.word * rounding_mode)) option) of
     (Some ((op1, rd, rs1, rs2, rm))) =>
 True
 )
   else if ((case  ((s4276 s32490
                     ::  ((f_un_rm_op_S *  5 Word.word *  5 Word.word * rounding_mode))option)) of
       Some ((FSQRT_S, rd, rs1, rm)) => True
     | _ => False
     )) then  (case 
 (s4276 s32490 :: (( f_un_rm_op_S * 5 Word.word * 5 Word.word * rounding_mode)) option) of
     (Some ((FSQRT_S, rd, rs1, rm))) =>
 True
 )
   else if ((case  ((s4293 s32490
                     ::  ((f_un_rm_op_S *  5 Word.word *  5 Word.word * rounding_mode))option)) of
       Some ((FCVT_W_S, rd, rs1, rm)) => True
     | _ => False
     )) then  (case 
 (s4293 s32490 :: (( f_un_rm_op_S * 5 Word.word * 5 Word.word * rounding_mode)) option) of
     (Some ((FCVT_W_S, rd, rs1, rm))) =>
 True
 )
   else if ((case  ((s4310 s32490
                     ::  ((f_un_rm_op_S *  5 Word.word *  5 Word.word * rounding_mode))option)) of
       Some ((FCVT_WU_S, rd, rs1, rm)) => True
     | _ => False
     )) then  (case 
 (s4310 s32490 :: (( f_un_rm_op_S * 5 Word.word * 5 Word.word * rounding_mode)) option) of
     (Some ((FCVT_WU_S, rd, rs1, rm))) =>
 True
 )
   else if ((case  ((s4327 s32490
                     ::  ((f_un_rm_op_S *  5 Word.word *  5 Word.word * rounding_mode))option)) of
       Some ((FCVT_S_W, rd, rs1, rm)) => True
     | _ => False
     )) then  (case 
 (s4327 s32490 :: (( f_un_rm_op_S * 5 Word.word * 5 Word.word * rounding_mode)) option) of
     (Some ((FCVT_S_W, rd, rs1, rm))) =>
 True
 )
   else if ((case  ((s4344 s32490
                     ::  ((f_un_rm_op_S *  5 Word.word *  5 Word.word * rounding_mode))option)) of
       Some ((FCVT_S_WU, rd, rs1, rm)) => True
     | _ => False
     )) then  (case 
 (s4344 s32490 :: (( f_un_rm_op_S * 5 Word.word * 5 Word.word * rounding_mode)) option) of
     (Some ((FCVT_S_WU, rd, rs1, rm))) =>
 True
 )
   else if ((case  ((s4361 s32490
                     ::  ((f_un_rm_op_S *  5 Word.word *  5 Word.word * rounding_mode))option)) of
       Some ((FCVT_L_S, rd, rs1, rm)) => True
     | _ => False
     )) then  (case 
 (s4361 s32490 :: (( f_un_rm_op_S * 5 Word.word * 5 Word.word * rounding_mode)) option) of
     (Some ((FCVT_L_S, rd, rs1, rm))) =>
 True
 )
   else if ((case  ((s4378 s32490
                     ::  ((f_un_rm_op_S *  5 Word.word *  5 Word.word * rounding_mode))option)) of
       Some ((FCVT_LU_S, rd, rs1, rm)) => True
     | _ => False
     )) then  (case 
 (s4378 s32490 :: (( f_un_rm_op_S * 5 Word.word * 5 Word.word * rounding_mode)) option) of
     (Some ((FCVT_LU_S, rd, rs1, rm))) =>
 True
 )
   else if ((case  ((s4395 s32490
                     ::  ((f_un_rm_op_S *  5 Word.word *  5 Word.word * rounding_mode))option)) of
       Some ((FCVT_S_L, rd, rs1, rm)) => True
     | _ => False
     )) then  (case 
 (s4395 s32490 :: (( f_un_rm_op_S * 5 Word.word * 5 Word.word * rounding_mode)) option) of
     (Some ((FCVT_S_L, rd, rs1, rm))) =>
 True
 )
   else if ((case  ((s4412 s32490
                     ::  ((f_un_rm_op_S *  5 Word.word *  5 Word.word * rounding_mode))option)) of
       Some ((FCVT_S_LU, rd, rs1, rm)) => True
     | _ => False
     )) then  (case 
 (s4412 s32490 :: (( f_un_rm_op_S * 5 Word.word * 5 Word.word * rounding_mode)) option) of
     (Some ((FCVT_S_LU, rd, rs1, rm))) =>
 True
 )
   else if ((case  ((s4429 s32490  ::  ((f_bin_op_S *  5 Word.word *  5 Word.word *  5 Word.word))option)) of
       Some ((FSGNJ_S, rd, rs1, rs2)) => True
     | _ => False
     )) then  (case 
 (s4429 s32490 :: (( f_bin_op_S * 5 Word.word * 5 Word.word * 5 Word.word)) option) of
     (Some ((FSGNJ_S, rd, rs1, rs2))) =>
 True
 )
   else if ((case  ((s4446 s32490  ::  ((f_bin_op_S *  5 Word.word *  5 Word.word *  5 Word.word))option)) of
       Some ((FSGNJN_S, rd, rs1, rs2)) => True
     | _ => False
     )) then  (case 
 (s4446 s32490 :: (( f_bin_op_S * 5 Word.word * 5 Word.word * 5 Word.word)) option) of
     (Some ((FSGNJN_S, rd, rs1, rs2))) =>
 True
 )
   else if ((case  ((s4463 s32490  ::  ((f_bin_op_S *  5 Word.word *  5 Word.word *  5 Word.word))option)) of
       Some ((FSGNJX_S, rd, rs1, rs2)) => True
     | _ => False
     )) then  (case 
 (s4463 s32490 :: (( f_bin_op_S * 5 Word.word * 5 Word.word * 5 Word.word)) option) of
     (Some ((FSGNJX_S, rd, rs1, rs2))) =>
 True
 )
   else if ((case  ((s4480 s32490  ::  ((f_bin_op_S *  5 Word.word *  5 Word.word *  5 Word.word))option)) of
       Some ((FMIN_S, rd, rs1, rs2)) => True
     | _ => False
     )) then  (case 
 (s4480 s32490 :: (( f_bin_op_S * 5 Word.word * 5 Word.word * 5 Word.word)) option) of
     (Some ((FMIN_S, rd, rs1, rs2))) =>
 True
 )
   else if ((case  ((s4497 s32490  ::  ((f_bin_op_S *  5 Word.word *  5 Word.word *  5 Word.word))option)) of
       Some ((FMAX_S, rd, rs1, rs2)) => True
     | _ => False
     )) then  (case 
 (s4497 s32490 :: (( f_bin_op_S * 5 Word.word * 5 Word.word * 5 Word.word)) option) of
     (Some ((FMAX_S, rd, rs1, rs2))) =>
 True
 )
   else if ((case  ((s4514 s32490  ::  ((f_bin_op_S *  5 Word.word *  5 Word.word *  5 Word.word))option)) of
       Some ((FEQ_S, rd, rs1, rs2)) => True
     | _ => False
     )) then  (case 
 (s4514 s32490 :: (( f_bin_op_S * 5 Word.word * 5 Word.word * 5 Word.word)) option) of
     (Some ((FEQ_S, rd, rs1, rs2))) =>
 True
 )
   else if ((case  ((s4531 s32490  ::  ((f_bin_op_S *  5 Word.word *  5 Word.word *  5 Word.word))option)) of
       Some ((FLT_S, rd, rs1, rs2)) => True
     | _ => False
     )) then  (case 
 (s4531 s32490 :: (( f_bin_op_S * 5 Word.word * 5 Word.word * 5 Word.word)) option) of
     (Some ((FLT_S, rd, rs1, rs2))) =>
 True
 )
   else if ((case  ((s4548 s32490  ::  ((f_bin_op_S *  5 Word.word *  5 Word.word *  5 Word.word))option)) of
       Some ((FLE_S, rd, rs1, rs2)) => True
     | _ => False
     )) then  (case 
 (s4548 s32490 :: (( f_bin_op_S * 5 Word.word * 5 Word.word * 5 Word.word)) option) of
     (Some ((FLE_S, rd, rs1, rs2))) =>
 True
 )
   else if ((case  ((s4565 s32490  ::  ((f_un_op_S *  5 Word.word *  5 Word.word))option)) of
       Some ((FMV_X_W, rd, rs1)) => True
     | _ => False
     )) then  (case 
 (s4565 s32490 :: (( f_un_op_S * 5 Word.word * 5 Word.word)) option) of
     (Some ((FMV_X_W, rd, rs1))) =>
 True
 )
   else if ((case  ((s4578 s32490  ::  ((f_un_op_S *  5 Word.word *  5 Word.word))option)) of
       Some ((FMV_W_X, rd, rs1)) => True
     | _ => False
     )) then  (case 
 (s4578 s32490 :: (( f_un_op_S * 5 Word.word * 5 Word.word)) option) of
     (Some ((FMV_W_X, rd, rs1))) =>
 True
 )
   else if ((case  ((s4591 s32490  ::  ((f_un_op_S *  5 Word.word *  5 Word.word))option)) of
       Some ((FCLASS_S, rd, rs1)) => True
     | _ => False
     )) then  (case 
 (s4591 s32490 :: (( f_un_op_S * 5 Word.word * 5 Word.word)) option) of
     (Some ((FCLASS_S, rd, rs1))) =>
 True
 )
   else if ((case  ((s4604 s32490  ::  (( 5 Word.word *  6 Word.word))option)) of
       Some ((rd, imm)) => ((( 64 :: int)::ii) = (( 32 :: int)::ii))
     | _ => False
     )) then  (case  (s4604 s32490 :: (( 5 Word.word * 6 Word.word)) option) of
     (Some ((rd, imm))) =>
 True
 )
   else if ((case  ((s4616 s32490  ::  (( 5 Word.word *  6 Word.word))option)) of
       Some ((rd, uimm)) => ((( 64 :: int)::ii) = (( 32 :: int)::ii))
     | _ => False
     )) then  (case  (s4616 s32490 :: (( 5 Word.word * 6 Word.word)) option) of
     (Some ((rd, uimm))) =>
 True
 )
   else if ((case  ((s4628 s32490  ::  (( 3 Word.word *  3 Word.word *  5 Word.word))option)) of
       Some ((rdc, rsc, uimm)) => ((( 64 :: int)::ii) = (( 32 :: int)::ii))
     | _ => False
     )) then  (case 
 (s4628 s32490 :: (( 3 Word.word * 3 Word.word * 5 Word.word)) option) of
     (Some ((rdc, rsc, uimm))) =>
 True
 )
   else if ((case  ((s4644 s32490  ::  (( 3 Word.word *  3 Word.word *  5 Word.word))option)) of
       Some ((rsc1, rsc2, uimm)) => ((( 64 :: int)::ii) = (( 32 :: int)::ii))
     | _ => False
     )) then  (case 
 (s4644 s32490 :: (( 3 Word.word * 3 Word.word * 5 Word.word)) option) of
     (Some ((rsc1, rsc2, uimm))) =>
 True
 )
   else if ((case  ((s4660 s32490
                     ::  ((f_madd_op_D *  5 Word.word *  5 Word.word *  5 Word.word *  5 Word.word * rounding_mode))option)) of
       Some ((op1, rd, rs1, rs2, rs3, rm)) => True
     | _ => False
     )) then  (case 
 (s4660 s32490
 :: (( f_madd_op_D * 5 Word.word * 5 Word.word * 5 Word.word * 5 Word.word * rounding_mode)) option) of
     (Some ((op1, rd, rs1, rs2, rs3, rm))) =>
 True
 )
   else if ((case  ((s4685 s32490
                     ::  ((f_bin_rm_op_D *  5 Word.word *  5 Word.word *  5 Word.word * rounding_mode))option)) of
       Some ((op1, rd, rs1, rs2, rm)) => True
     | _ => False
     )) then  (case 
 (s4685 s32490
 :: (( f_bin_rm_op_D * 5 Word.word * 5 Word.word * 5 Word.word * rounding_mode)) option) of
     (Some ((op1, rd, rs1, rs2, rm))) =>
 True
 )
   else if ((case  ((s4706 s32490
                     ::  ((f_un_rm_op_D *  5 Word.word *  5 Word.word * rounding_mode))option)) of
       Some ((FSQRT_D, rd, rs1, rm)) => True
     | _ => False
     )) then  (case 
 (s4706 s32490 :: (( f_un_rm_op_D * 5 Word.word * 5 Word.word * rounding_mode)) option) of
     (Some ((FSQRT_D, rd, rs1, rm))) =>
 True
 )
   else if ((case  ((s4723 s32490
                     ::  ((f_un_rm_op_D *  5 Word.word *  5 Word.word * rounding_mode))option)) of
       Some ((FCVT_W_D, rd, rs1, rm)) => True
     | _ => False
     )) then  (case 
 (s4723 s32490 :: (( f_un_rm_op_D * 5 Word.word * 5 Word.word * rounding_mode)) option) of
     (Some ((FCVT_W_D, rd, rs1, rm))) =>
 True
 )
   else if ((case  ((s4740 s32490
                     ::  ((f_un_rm_op_D *  5 Word.word *  5 Word.word * rounding_mode))option)) of
       Some ((FCVT_WU_D, rd, rs1, rm)) => True
     | _ => False
     )) then  (case 
 (s4740 s32490 :: (( f_un_rm_op_D * 5 Word.word * 5 Word.word * rounding_mode)) option) of
     (Some ((FCVT_WU_D, rd, rs1, rm))) =>
 True
 )
   else if ((case  ((s4757 s32490
                     ::  ((f_un_rm_op_D *  5 Word.word *  5 Word.word * rounding_mode))option)) of
       Some ((FCVT_D_W, rd, rs1, rm)) => True
     | _ => False
     )) then  (case 
 (s4757 s32490 :: (( f_un_rm_op_D * 5 Word.word * 5 Word.word * rounding_mode)) option) of
     (Some ((FCVT_D_W, rd, rs1, rm))) =>
 True
 )
   else if ((case  ((s4774 s32490
                     ::  ((f_un_rm_op_D *  5 Word.word *  5 Word.word * rounding_mode))option)) of
       Some ((FCVT_D_WU, rd, rs1, rm)) => True
     | _ => False
     )) then  (case 
 (s4774 s32490 :: (( f_un_rm_op_D * 5 Word.word * 5 Word.word * rounding_mode)) option) of
     (Some ((FCVT_D_WU, rd, rs1, rm))) =>
 True
 )
   else if ((case  ((s4791 s32490
                     ::  ((f_un_rm_op_D *  5 Word.word *  5 Word.word * rounding_mode))option)) of
       Some ((FCVT_L_D, rd, rs1, rm)) => True
     | _ => False
     )) then  (case 
 (s4791 s32490 :: (( f_un_rm_op_D * 5 Word.word * 5 Word.word * rounding_mode)) option) of
     (Some ((FCVT_L_D, rd, rs1, rm))) =>
 True
 )
   else if ((case  ((s4808 s32490
                     ::  ((f_un_rm_op_D *  5 Word.word *  5 Word.word * rounding_mode))option)) of
       Some ((FCVT_LU_D, rd, rs1, rm)) => True
     | _ => False
     )) then  (case 
 (s4808 s32490 :: (( f_un_rm_op_D * 5 Word.word * 5 Word.word * rounding_mode)) option) of
     (Some ((FCVT_LU_D, rd, rs1, rm))) =>
 True
 )
   else if ((case  ((s4825 s32490
                     ::  ((f_un_rm_op_D *  5 Word.word *  5 Word.word * rounding_mode))option)) of
       Some ((FCVT_D_L, rd, rs1, rm)) => True
     | _ => False
     )) then  (case 
 (s4825 s32490 :: (( f_un_rm_op_D * 5 Word.word * 5 Word.word * rounding_mode)) option) of
     (Some ((FCVT_D_L, rd, rs1, rm))) =>
 True
 )
   else if ((case  ((s4842 s32490
                     ::  ((f_un_rm_op_D *  5 Word.word *  5 Word.word * rounding_mode))option)) of
       Some ((FCVT_D_LU, rd, rs1, rm)) => True
     | _ => False
     )) then  (case 
 (s4842 s32490 :: (( f_un_rm_op_D * 5 Word.word * 5 Word.word * rounding_mode)) option) of
     (Some ((FCVT_D_LU, rd, rs1, rm))) =>
 True
 )
   else if ((case  ((s4859 s32490
                     ::  ((f_un_rm_op_D *  5 Word.word *  5 Word.word * rounding_mode))option)) of
       Some ((FCVT_S_D, rd, rs1, rm)) => True
     | _ => False
     )) then  (case 
 (s4859 s32490 :: (( f_un_rm_op_D * 5 Word.word * 5 Word.word * rounding_mode)) option) of
     (Some ((FCVT_S_D, rd, rs1, rm))) =>
 True
 )
   else if ((case  ((s4876 s32490
                     ::  ((f_un_rm_op_D *  5 Word.word *  5 Word.word * rounding_mode))option)) of
       Some ((FCVT_D_S, rd, rs1, rm)) => True
     | _ => False
     )) then  (case 
 (s4876 s32490 :: (( f_un_rm_op_D * 5 Word.word * 5 Word.word * rounding_mode)) option) of
     (Some ((FCVT_D_S, rd, rs1, rm))) =>
 True
 )
   else if ((case  ((s4893 s32490  ::  ((f_bin_op_D *  5 Word.word *  5 Word.word *  5 Word.word))option)) of
       Some ((FSGNJ_D, rd, rs1, rs2)) => True
     | _ => False
     )) then  (case 
 (s4893 s32490 :: (( f_bin_op_D * 5 Word.word * 5 Word.word * 5 Word.word)) option) of
     (Some ((FSGNJ_D, rd, rs1, rs2))) =>
 True
 )
   else if ((case  ((s4910 s32490  ::  ((f_bin_op_D *  5 Word.word *  5 Word.word *  5 Word.word))option)) of
       Some ((FSGNJN_D, rd, rs1, rs2)) => True
     | _ => False
     )) then  (case 
 (s4910 s32490 :: (( f_bin_op_D * 5 Word.word * 5 Word.word * 5 Word.word)) option) of
     (Some ((FSGNJN_D, rd, rs1, rs2))) =>
 True
 )
   else if ((case  ((s4927 s32490  ::  ((f_bin_op_D *  5 Word.word *  5 Word.word *  5 Word.word))option)) of
       Some ((FSGNJX_D, rd, rs1, rs2)) => True
     | _ => False
     )) then  (case 
 (s4927 s32490 :: (( f_bin_op_D * 5 Word.word * 5 Word.word * 5 Word.word)) option) of
     (Some ((FSGNJX_D, rd, rs1, rs2))) =>
 True
 )
   else if ((case  ((s4944 s32490  ::  ((f_bin_op_D *  5 Word.word *  5 Word.word *  5 Word.word))option)) of
       Some ((FMIN_D, rd, rs1, rs2)) => True
     | _ => False
     )) then  (case 
 (s4944 s32490 :: (( f_bin_op_D * 5 Word.word * 5 Word.word * 5 Word.word)) option) of
     (Some ((FMIN_D, rd, rs1, rs2))) =>
 True
 )
   else if ((case  ((s4961 s32490  ::  ((f_bin_op_D *  5 Word.word *  5 Word.word *  5 Word.word))option)) of
       Some ((FMAX_D, rd, rs1, rs2)) => True
     | _ => False
     )) then  (case 
 (s4961 s32490 :: (( f_bin_op_D * 5 Word.word * 5 Word.word * 5 Word.word)) option) of
     (Some ((FMAX_D, rd, rs1, rs2))) =>
 True
 )
   else if ((case  ((s4978 s32490  ::  ((f_bin_op_D *  5 Word.word *  5 Word.word *  5 Word.word))option)) of
       Some ((FEQ_D, rd, rs1, rs2)) => True
     | _ => False
     )) then  (case 
 (s4978 s32490 :: (( f_bin_op_D * 5 Word.word * 5 Word.word * 5 Word.word)) option) of
     (Some ((FEQ_D, rd, rs1, rs2))) =>
 True
 )
   else if ((case  ((s4995 s32490  ::  ((f_bin_op_D *  5 Word.word *  5 Word.word *  5 Word.word))option)) of
       Some ((FLT_D, rd, rs1, rs2)) => True
     | _ => False
     )) then  (case 
 (s4995 s32490 :: (( f_bin_op_D * 5 Word.word * 5 Word.word * 5 Word.word)) option) of
     (Some ((FLT_D, rd, rs1, rs2))) =>
 True
 )
   else if ((case  ((s5012 s32490  ::  ((f_bin_op_D *  5 Word.word *  5 Word.word *  5 Word.word))option)) of
       Some ((FLE_D, rd, rs1, rs2)) => True
     | _ => False
     )) then  (case 
 (s5012 s32490 :: (( f_bin_op_D * 5 Word.word * 5 Word.word * 5 Word.word)) option) of
     (Some ((FLE_D, rd, rs1, rs2))) =>
 True
 )
   else if ((case  ((s5029 s32490  ::  ((f_un_op_D *  5 Word.word *  5 Word.word))option)) of
       Some ((FMV_X_D, rd, rs1)) => True
     | _ => False
     )) then  (case 
 (s5029 s32490 :: (( f_un_op_D * 5 Word.word * 5 Word.word)) option) of
     (Some ((FMV_X_D, rd, rs1))) =>
 True
 )
   else if ((case  ((s5042 s32490  ::  ((f_un_op_D *  5 Word.word *  5 Word.word))option)) of
       Some ((FMV_D_X, rd, rs1)) => True
     | _ => False
     )) then  (case 
 (s5042 s32490 :: (( f_un_op_D * 5 Word.word * 5 Word.word)) option) of
     (Some ((FMV_D_X, rd, rs1))) =>
 True
 )
   else if ((case  ((s5055 s32490  ::  ((f_un_op_D *  5 Word.word *  5 Word.word))option)) of
       Some ((FCLASS_D, rd, rs1)) => True
     | _ => False
     )) then  (case 
 (s5055 s32490 :: (( f_un_op_D * 5 Word.word * 5 Word.word)) option) of
     (Some ((FCLASS_D, rd, rs1))) =>
 True
 )
   else if ((case  ((s5068 s32490  ::  (( 5 Word.word *  6 Word.word))option)) of
       Some ((rd, uimm)) => (((((( 64 :: int)::ii) = (( 32 :: int)::ii)))) \<or> ((((( 64 :: int)::ii) = (( 64 :: int)::ii)))))
     | _ => False
     )) then  (case  (s5068 s32490 :: (( 5 Word.word * 6 Word.word)) option) of
     (Some ((rd, uimm))) =>
 True
 )
   else if ((case  ((s5080 s32490  ::  (( 5 Word.word *  6 Word.word))option)) of
       Some ((rs2, uimm)) => (((((( 64 :: int)::ii) = (( 32 :: int)::ii)))) \<or> ((((( 64 :: int)::ii) = (( 64 :: int)::ii)))))
     | _ => False
     )) then  (case  (s5080 s32490 :: (( 5 Word.word * 6 Word.word)) option) of
     (Some ((rs2, uimm))) =>
 True
 )
   else if ((case  ((s5092 s32490  ::  (( 3 Word.word *  3 Word.word *  5 Word.word))option)) of
       Some ((rdc, rsc, uimm)) => (((((( 64 :: int)::ii) = (( 32 :: int)::ii)))) \<or> ((((( 64 :: int)::ii) = (( 64 :: int)::ii)))))
     | _ => False
     )) then  (case 
 (s5092 s32490 :: (( 3 Word.word * 3 Word.word * 5 Word.word)) option) of
     (Some ((rdc, rsc, uimm))) =>
 True
 )
   else if ((case  ((s5108 s32490  ::  (( 3 Word.word *  3 Word.word *  5 Word.word))option)) of
       Some ((rsc1, rsc2, uimm)) => (((((( 64 :: int)::ii) = (( 32 :: int)::ii)))) \<or> ((((( 64 :: int)::ii) = (( 64 :: int)::ii)))))
     | _ => False
     )) then  (case 
 (s5108 s32490 :: (( 3 Word.word * 3 Word.word * 5 Word.word)) option) of
     (Some ((rsc1, rsc2, uimm))) =>
 True
 )
   else if ((case  ((s5124 s32490  ::  ( 32 Word.word)option)) of   Some (s) => True | _ => False ))
   then  (case  (s5124 s32490 :: ( 32 Word.word) option) of (Some (s)) => True )
   else if ((case  ((s5132 s32490  ::  ( 16 Word.word)option)) of   Some (s) => True | _ => False ))
   then  (case  (s5132 s32490 :: ( 16 Word.word) option) of (Some (s)) => True )
   else False))\<close> 
  for  arg1  :: " string "


\<comment> \<open>\<open>val _s7071_ : string -> maybe ((mword ty16 * string))\<close>\<close>

definition s7071  :: \<open> string \<Rightarrow>((16)Word.word*string)option \<close>  where 
     \<open> s7071 s70720 = (
   (let s70730 = s70720 in
   if ((string_startswith s70730 (''c.illegal''))) then  
  (case  ((string_drop s70730 ((string_length (''c.illegal''))))) of
        s70740 =>
  (case  ((spc_matches_prefix0 s70740)) of
        Some ((_, s70750)) =>
  (case  ((string_drop s70740 s70750)) of
        s70760 =>
  (case  ((hex_bits_16_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s70760 :: (( 16 Word.word * ii)) option)) of
        Some ((s, s70770)) =>
  (case  ((string_drop s70760 s70770)) of   s2 => Some (s, s2) )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s70720  :: " string "


\<comment> \<open>\<open>val _s7063_ : string -> maybe ((mword ty32 * string))\<close>\<close>

definition s7063  :: \<open> string \<Rightarrow>((32)Word.word*string)option \<close>  where 
     \<open> s7063 s70640 = (
   (let s70650 = s70640 in
   if ((string_startswith s70650 (''illegal''))) then  
  (case  ((string_drop s70650 ((string_length (''illegal''))))) of
        s70660 =>
  (case  ((spc_matches_prefix0 s70660)) of
        Some ((_, s70670)) =>
  (case  ((string_drop s70660 s70670)) of
        s70680 =>
  (case  ((hex_bits_32_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s70680 :: (( 32 Word.word * ii)) option)) of
        Some ((s, s70690)) =>
  (case  ((string_drop s70680 s70690)) of   s2 => Some (s, s2) )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s70640  :: " string "


\<comment> \<open>\<open>val _s7047_ : string -> maybe ((mword ty3 * mword ty3 * mword ty5 * string))\<close>\<close>

definition s7047  :: \<open> string \<Rightarrow>((3)Word.word*(3)Word.word*(5)Word.word*string)option \<close>  where 
     \<open> s7047 s70480 = (
   (let s70490 = s70480 in
   if ((string_startswith s70490 (''c.fsd''))) then  
  (case  ((string_drop s70490 ((string_length (''c.fsd''))))) of
        s70500 =>
  (case  ((spc_matches_prefix0 s70500)) of
        Some ((_, s70510)) =>
  (case  ((string_drop s70500 s70510)) of
        s70520 =>
  (case  ((creg_name_matches_prefix s70520 :: (( 3 Word.word * ii)) option)) of
        Some ((rsc1, s70530)) =>
  (case  ((string_drop s70520 s70530)) of
        s70540 =>
  (case  ((sep_matches_prefix s70540)) of
        Some ((_, s70550)) =>
  (case  ((string_drop s70540 s70550)) of
        s70560 =>
  (case  ((creg_name_matches_prefix s70560 :: (( 3 Word.word * ii)) option)) of
        Some ((rsc2, s70570)) =>
  (case  ((string_drop s70560 s70570)) of
        s70580 =>
  (case  ((sep_matches_prefix s70580)) of
        Some ((_, s70590)) =>
  (case  ((string_drop s70580 s70590)) of
        s70600 =>
  (case  ((hex_bits_8_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s70600 :: (( 8 Word.word * ii)) option)) of
        Some ((v__1482, s70610)) =>
  if (((((subrange_vec_dec v__1482 (( 2 :: int):: ii) (( 0 :: int):: ii)
         :: 3 Word.word)) = ( 0b000 :: 3 Word.word)))) then
    (let (uimm :: 5 Word.word) =
         ((subrange_vec_dec v__1482 (( 7 :: int):: ii) (( 3 :: int):: ii) :: 5 Word.word)) in
    (let (uimm :: 5 Word.word) =
         ((subrange_vec_dec v__1482 (( 7 :: int):: ii) (( 3 :: int):: ii) :: 5 Word.word)) in
    (case  ((string_drop s70600 s70610)) of
          s1 => Some (rsc1, rsc2, uimm, s1)
    ))) else None
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s70480  :: " string "


\<comment> \<open>\<open>val _s7031_ : string -> maybe ((mword ty3 * mword ty3 * mword ty5 * string))\<close>\<close>

definition s7031  :: \<open> string \<Rightarrow>((3)Word.word*(3)Word.word*(5)Word.word*string)option \<close>  where 
     \<open> s7031 s70320 = (
   (let s70330 = s70320 in
   if ((string_startswith s70330 (''c.fld''))) then  
  (case  ((string_drop s70330 ((string_length (''c.fld''))))) of
        s70340 =>
  (case  ((spc_matches_prefix0 s70340)) of
        Some ((_, s70350)) =>
  (case  ((string_drop s70340 s70350)) of
        s70360 =>
  (case  ((creg_name_matches_prefix s70360 :: (( 3 Word.word * ii)) option)) of
        Some ((rdc, s70370)) =>
  (case  ((string_drop s70360 s70370)) of
        s70380 =>
  (case  ((sep_matches_prefix s70380)) of
        Some ((_, s70390)) =>
  (case  ((string_drop s70380 s70390)) of
        s70400 =>
  (case  ((creg_name_matches_prefix s70400 :: (( 3 Word.word * ii)) option)) of
        Some ((rsc, s70410)) =>
  (case  ((string_drop s70400 s70410)) of
        s70420 =>
  (case  ((sep_matches_prefix s70420)) of
        Some ((_, s70430)) =>
  (case  ((string_drop s70420 s70430)) of
        s70440 =>
  (case  ((hex_bits_8_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s70440 :: (( 8 Word.word * ii)) option)) of
        Some ((v__1484, s70450)) =>
  if (((((subrange_vec_dec v__1484 (( 2 :: int):: ii) (( 0 :: int):: ii)
         :: 3 Word.word)) = ( 0b000 :: 3 Word.word)))) then
    (let (uimm :: 5 Word.word) =
         ((subrange_vec_dec v__1484 (( 7 :: int):: ii) (( 3 :: int):: ii) :: 5 Word.word)) in
    (let (uimm :: 5 Word.word) =
         ((subrange_vec_dec v__1484 (( 7 :: int):: ii) (( 3 :: int):: ii) :: 5 Word.word)) in
    (case  ((string_drop s70440 s70450)) of
          s1 => Some (rdc, rsc, uimm, s1)
    ))) else None
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s70320  :: " string "


\<comment> \<open>\<open>val _s7019_ : string -> maybe ((mword ty5 * mword ty6 * string))\<close>\<close>

definition s7019  :: \<open> string \<Rightarrow>((5)Word.word*(6)Word.word*string)option \<close>  where 
     \<open> s7019 s70200 = (
   (let s70210 = s70200 in
   if ((string_startswith s70210 (''c.fsdsp''))) then  
  (case  ((string_drop s70210 ((string_length (''c.fsdsp''))))) of
        s70220 =>
  (case  ((spc_matches_prefix0 s70220)) of
        Some ((_, s70230)) =>
  (case  ((string_drop s70220 s70230)) of
        s70240 =>
  (case  ((reg_name_matches_prefix s70240 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s70250)) =>
  (case  ((string_drop s70240 s70250)) of
        s70260 =>
  (case  ((sep_matches_prefix s70260)) of
        Some ((_, s70270)) =>
  (case  ((string_drop s70260 s70270)) of
        s70280 =>
  (case  ((hex_bits_6_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s70280 :: (( 6 Word.word * ii)) option)) of
        Some ((uimm, s70290)) =>
  (case  ((string_drop s70280 s70290)) of   s1 => Some (rs2, uimm, s1) )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s70200  :: " string "


\<comment> \<open>\<open>val _s7007_ : string -> maybe ((mword ty5 * mword ty6 * string))\<close>\<close>

definition s7007  :: \<open> string \<Rightarrow>((5)Word.word*(6)Word.word*string)option \<close>  where 
     \<open> s7007 s70080 = (
   (let s70090 = s70080 in
   if ((string_startswith s70090 (''c.fldsp''))) then  
  (case  ((string_drop s70090 ((string_length (''c.fldsp''))))) of
        s70100 =>
  (case  ((spc_matches_prefix0 s70100)) of
        Some ((_, s70110)) =>
  (case  ((string_drop s70100 s70110)) of
        s70120 =>
  (case  ((reg_name_matches_prefix s70120 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s70130)) =>
  (case  ((string_drop s70120 s70130)) of
        s70140 =>
  (case  ((sep_matches_prefix s70140)) of
        Some ((_, s70150)) =>
  (case  ((string_drop s70140 s70150)) of
        s70160 =>
  (case  ((hex_bits_6_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s70160 :: (( 6 Word.word * ii)) option)) of
        Some ((uimm, s70170)) =>
  (case  ((string_drop s70160 s70170)) of   s1 => Some (rd, uimm, s1) )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s70080  :: " string "


\<comment> \<open>\<open>val _s6994_ : string -> maybe ((f_un_op_D * mword ty5 * mword ty5 * string))\<close>\<close>

definition s6994  :: \<open> string \<Rightarrow>(f_un_op_D*(5)Word.word*(5)Word.word*string)option \<close>  where 
     \<open> s6994 s69960 = (
      (case  ((f_un_type_mnemonic_D_matches_prefix s69960)) of
        Some ((FCLASS_D, s69970)) => 
  (case  ((string_drop s69960 s69970)) of
        s69980 =>
  (case  ((spc_matches_prefix0 s69980)) of
        Some ((_, s69990)) =>
  (case  ((string_drop s69980 s69990)) of
        s70000 =>
  (case  ((reg_name_matches_prefix s70000 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s70010)) =>
  (case  ((string_drop s70000 s70010)) of
        s70020 =>
  (case  ((sep_matches_prefix s70020)) of
        Some ((_, s70030)) =>
  (case  ((string_drop s70020 s70030)) of
        s70040 =>
  (case  ((freg_name_matches_prefix s70040 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s70050)) =>
  (case  ((string_drop s70040 s70050)) of
        s1 => Some (FCLASS_D, rd, rs1, s1)
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s69960  :: " string "


\<comment> \<open>\<open>val _s6981_ : string -> maybe ((f_un_op_D * mword ty5 * mword ty5 * string))\<close>\<close>

definition s6981  :: \<open> string \<Rightarrow>(f_un_op_D*(5)Word.word*(5)Word.word*string)option \<close>  where 
     \<open> s6981 s69830 = (
      (case  ((f_un_type_mnemonic_D_matches_prefix s69830)) of
        Some ((FMV_D_X, s69840)) => 
  (case  ((string_drop s69830 s69840)) of
        s69850 =>
  (case  ((spc_matches_prefix0 s69850)) of
        Some ((_, s69860)) =>
  (case  ((string_drop s69850 s69860)) of
        s69870 =>
  (case  ((freg_name_matches_prefix s69870 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s69880)) =>
  (case  ((string_drop s69870 s69880)) of
        s69890 =>
  (case  ((sep_matches_prefix s69890)) of
        Some ((_, s69900)) =>
  (case  ((string_drop s69890 s69900)) of
        s69910 =>
  (case  ((reg_name_matches_prefix s69910 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s69920)) =>
  (case  ((string_drop s69910 s69920)) of
        s1 => Some (FMV_D_X, rd, rs1, s1)
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s69830  :: " string "


\<comment> \<open>\<open>val _s6968_ : string -> maybe ((f_un_op_D * mword ty5 * mword ty5 * string))\<close>\<close>

definition s6968  :: \<open> string \<Rightarrow>(f_un_op_D*(5)Word.word*(5)Word.word*string)option \<close>  where 
     \<open> s6968 s69700 = (
      (case  ((f_un_type_mnemonic_D_matches_prefix s69700)) of
        Some ((FMV_X_D, s69710)) => 
  (case  ((string_drop s69700 s69710)) of
        s69720 =>
  (case  ((spc_matches_prefix0 s69720)) of
        Some ((_, s69730)) =>
  (case  ((string_drop s69720 s69730)) of
        s69740 =>
  (case  ((reg_name_matches_prefix s69740 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s69750)) =>
  (case  ((string_drop s69740 s69750)) of
        s69760 =>
  (case  ((sep_matches_prefix s69760)) of
        Some ((_, s69770)) =>
  (case  ((string_drop s69760 s69770)) of
        s69780 =>
  (case  ((freg_name_matches_prefix s69780 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s69790)) =>
  (case  ((string_drop s69780 s69790)) of
        s1 => Some (FMV_X_D, rd, rs1, s1)
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s69700  :: " string "


\<comment> \<open>\<open>val _s6951_ : string -> maybe ((f_bin_op_D * mword ty5 * mword ty5 * mword ty5 * string))\<close>\<close>

definition s6951  :: \<open> string \<Rightarrow>(f_bin_op_D*(5)Word.word*(5)Word.word*(5)Word.word*string)option \<close>  where 
     \<open> s6951 s69530 = (
      (case  ((f_bin_type_mnemonic_D_matches_prefix s69530)) of
        Some ((FLE_D, s69540)) => 
  (case  ((string_drop s69530 s69540)) of
        s69550 =>
  (case  ((spc_matches_prefix0 s69550)) of
        Some ((_, s69560)) =>
  (case  ((string_drop s69550 s69560)) of
        s69570 =>
  (case  ((reg_name_matches_prefix s69570 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s69580)) =>
  (case  ((string_drop s69570 s69580)) of
        s69590 =>
  (case  ((sep_matches_prefix s69590)) of
        Some ((_, s69600)) =>
  (case  ((string_drop s69590 s69600)) of
        s69610 =>
  (case  ((freg_name_matches_prefix s69610 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s69620)) =>
  (case  ((string_drop s69610 s69620)) of
        s69630 =>
  (case  ((sep_matches_prefix s69630)) of
        Some ((_, s69640)) =>
  (case  ((string_drop s69630 s69640)) of
        s69650 =>
  (case  ((freg_name_matches_prefix s69650 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s69660)) =>
  (case  ((string_drop s69650 s69660)) of
        s1 => Some (FLE_D, rd, rs1, rs2, s1)
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s69530  :: " string "


\<comment> \<open>\<open>val _s6934_ : string -> maybe ((f_bin_op_D * mword ty5 * mword ty5 * mword ty5 * string))\<close>\<close>

definition s6934  :: \<open> string \<Rightarrow>(f_bin_op_D*(5)Word.word*(5)Word.word*(5)Word.word*string)option \<close>  where 
     \<open> s6934 s69360 = (
      (case  ((f_bin_type_mnemonic_D_matches_prefix s69360)) of
        Some ((FLT_D, s69370)) => 
  (case  ((string_drop s69360 s69370)) of
        s69380 =>
  (case  ((spc_matches_prefix0 s69380)) of
        Some ((_, s69390)) =>
  (case  ((string_drop s69380 s69390)) of
        s69400 =>
  (case  ((reg_name_matches_prefix s69400 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s69410)) =>
  (case  ((string_drop s69400 s69410)) of
        s69420 =>
  (case  ((sep_matches_prefix s69420)) of
        Some ((_, s69430)) =>
  (case  ((string_drop s69420 s69430)) of
        s69440 =>
  (case  ((freg_name_matches_prefix s69440 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s69450)) =>
  (case  ((string_drop s69440 s69450)) of
        s69460 =>
  (case  ((sep_matches_prefix s69460)) of
        Some ((_, s69470)) =>
  (case  ((string_drop s69460 s69470)) of
        s69480 =>
  (case  ((freg_name_matches_prefix s69480 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s69490)) =>
  (case  ((string_drop s69480 s69490)) of
        s1 => Some (FLT_D, rd, rs1, rs2, s1)
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s69360  :: " string "


\<comment> \<open>\<open>val _s6917_ : string -> maybe ((f_bin_op_D * mword ty5 * mword ty5 * mword ty5 * string))\<close>\<close>

definition s6917  :: \<open> string \<Rightarrow>(f_bin_op_D*(5)Word.word*(5)Word.word*(5)Word.word*string)option \<close>  where 
     \<open> s6917 s69190 = (
      (case  ((f_bin_type_mnemonic_D_matches_prefix s69190)) of
        Some ((FEQ_D, s69200)) => 
  (case  ((string_drop s69190 s69200)) of
        s69210 =>
  (case  ((spc_matches_prefix0 s69210)) of
        Some ((_, s69220)) =>
  (case  ((string_drop s69210 s69220)) of
        s69230 =>
  (case  ((reg_name_matches_prefix s69230 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s69240)) =>
  (case  ((string_drop s69230 s69240)) of
        s69250 =>
  (case  ((sep_matches_prefix s69250)) of
        Some ((_, s69260)) =>
  (case  ((string_drop s69250 s69260)) of
        s69270 =>
  (case  ((freg_name_matches_prefix s69270 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s69280)) =>
  (case  ((string_drop s69270 s69280)) of
        s69290 =>
  (case  ((sep_matches_prefix s69290)) of
        Some ((_, s69300)) =>
  (case  ((string_drop s69290 s69300)) of
        s69310 =>
  (case  ((freg_name_matches_prefix s69310 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s69320)) =>
  (case  ((string_drop s69310 s69320)) of
        s1 => Some (FEQ_D, rd, rs1, rs2, s1)
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s69190  :: " string "


\<comment> \<open>\<open>val _s6900_ : string -> maybe ((f_bin_op_D * mword ty5 * mword ty5 * mword ty5 * string))\<close>\<close>

definition s6900  :: \<open> string \<Rightarrow>(f_bin_op_D*(5)Word.word*(5)Word.word*(5)Word.word*string)option \<close>  where 
     \<open> s6900 s69020 = (
      (case  ((f_bin_type_mnemonic_D_matches_prefix s69020)) of
        Some ((FMAX_D, s69030)) => 
  (case  ((string_drop s69020 s69030)) of
        s69040 =>
  (case  ((spc_matches_prefix0 s69040)) of
        Some ((_, s69050)) =>
  (case  ((string_drop s69040 s69050)) of
        s69060 =>
  (case  ((freg_name_matches_prefix s69060 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s69070)) =>
  (case  ((string_drop s69060 s69070)) of
        s69080 =>
  (case  ((sep_matches_prefix s69080)) of
        Some ((_, s69090)) =>
  (case  ((string_drop s69080 s69090)) of
        s69100 =>
  (case  ((freg_name_matches_prefix s69100 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s69110)) =>
  (case  ((string_drop s69100 s69110)) of
        s69120 =>
  (case  ((sep_matches_prefix s69120)) of
        Some ((_, s69130)) =>
  (case  ((string_drop s69120 s69130)) of
        s69140 =>
  (case  ((freg_name_matches_prefix s69140 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s69150)) =>
  (case  ((string_drop s69140 s69150)) of
        s1 => Some (FMAX_D, rd, rs1, rs2, s1)
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s69020  :: " string "


\<comment> \<open>\<open>val _s6883_ : string -> maybe ((f_bin_op_D * mword ty5 * mword ty5 * mword ty5 * string))\<close>\<close>

definition s6883  :: \<open> string \<Rightarrow>(f_bin_op_D*(5)Word.word*(5)Word.word*(5)Word.word*string)option \<close>  where 
     \<open> s6883 s68850 = (
      (case  ((f_bin_type_mnemonic_D_matches_prefix s68850)) of
        Some ((FMIN_D, s68860)) => 
  (case  ((string_drop s68850 s68860)) of
        s68870 =>
  (case  ((spc_matches_prefix0 s68870)) of
        Some ((_, s68880)) =>
  (case  ((string_drop s68870 s68880)) of
        s68890 =>
  (case  ((freg_name_matches_prefix s68890 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s68900)) =>
  (case  ((string_drop s68890 s68900)) of
        s68910 =>
  (case  ((sep_matches_prefix s68910)) of
        Some ((_, s68920)) =>
  (case  ((string_drop s68910 s68920)) of
        s68930 =>
  (case  ((freg_name_matches_prefix s68930 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s68940)) =>
  (case  ((string_drop s68930 s68940)) of
        s68950 =>
  (case  ((sep_matches_prefix s68950)) of
        Some ((_, s68960)) =>
  (case  ((string_drop s68950 s68960)) of
        s68970 =>
  (case  ((freg_name_matches_prefix s68970 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s68980)) =>
  (case  ((string_drop s68970 s68980)) of
        s1 => Some (FMIN_D, rd, rs1, rs2, s1)
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s68850  :: " string "


\<comment> \<open>\<open>val _s6866_ : string -> maybe ((f_bin_op_D * mword ty5 * mword ty5 * mword ty5 * string))\<close>\<close>

definition s6866  :: \<open> string \<Rightarrow>(f_bin_op_D*(5)Word.word*(5)Word.word*(5)Word.word*string)option \<close>  where 
     \<open> s6866 s68680 = (
      (case  ((f_bin_type_mnemonic_D_matches_prefix s68680)) of
        Some ((FSGNJX_D, s68690)) => 
  (case  ((string_drop s68680 s68690)) of
        s68700 =>
  (case  ((spc_matches_prefix0 s68700)) of
        Some ((_, s68710)) =>
  (case  ((string_drop s68700 s68710)) of
        s68720 =>
  (case  ((freg_name_matches_prefix s68720 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s68730)) =>
  (case  ((string_drop s68720 s68730)) of
        s68740 =>
  (case  ((sep_matches_prefix s68740)) of
        Some ((_, s68750)) =>
  (case  ((string_drop s68740 s68750)) of
        s68760 =>
  (case  ((freg_name_matches_prefix s68760 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s68770)) =>
  (case  ((string_drop s68760 s68770)) of
        s68780 =>
  (case  ((sep_matches_prefix s68780)) of
        Some ((_, s68790)) =>
  (case  ((string_drop s68780 s68790)) of
        s68800 =>
  (case  ((freg_name_matches_prefix s68800 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s68810)) =>
  (case  ((string_drop s68800 s68810)) of
        s1 => Some (FSGNJX_D, rd, rs1, rs2, s1)
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s68680  :: " string "


\<comment> \<open>\<open>val _s6849_ : string -> maybe ((f_bin_op_D * mword ty5 * mword ty5 * mword ty5 * string))\<close>\<close>

definition s6849  :: \<open> string \<Rightarrow>(f_bin_op_D*(5)Word.word*(5)Word.word*(5)Word.word*string)option \<close>  where 
     \<open> s6849 s68510 = (
      (case  ((f_bin_type_mnemonic_D_matches_prefix s68510)) of
        Some ((FSGNJN_D, s68520)) => 
  (case  ((string_drop s68510 s68520)) of
        s68530 =>
  (case  ((spc_matches_prefix0 s68530)) of
        Some ((_, s68540)) =>
  (case  ((string_drop s68530 s68540)) of
        s68550 =>
  (case  ((freg_name_matches_prefix s68550 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s68560)) =>
  (case  ((string_drop s68550 s68560)) of
        s68570 =>
  (case  ((sep_matches_prefix s68570)) of
        Some ((_, s68580)) =>
  (case  ((string_drop s68570 s68580)) of
        s68590 =>
  (case  ((freg_name_matches_prefix s68590 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s68600)) =>
  (case  ((string_drop s68590 s68600)) of
        s68610 =>
  (case  ((sep_matches_prefix s68610)) of
        Some ((_, s68620)) =>
  (case  ((string_drop s68610 s68620)) of
        s68630 =>
  (case  ((freg_name_matches_prefix s68630 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s68640)) =>
  (case  ((string_drop s68630 s68640)) of
        s1 => Some (FSGNJN_D, rd, rs1, rs2, s1)
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s68510  :: " string "


\<comment> \<open>\<open>val _s6832_ : string -> maybe ((f_bin_op_D * mword ty5 * mword ty5 * mword ty5 * string))\<close>\<close>

definition s6832  :: \<open> string \<Rightarrow>(f_bin_op_D*(5)Word.word*(5)Word.word*(5)Word.word*string)option \<close>  where 
     \<open> s6832 s68340 = (
      (case  ((f_bin_type_mnemonic_D_matches_prefix s68340)) of
        Some ((FSGNJ_D, s68350)) => 
  (case  ((string_drop s68340 s68350)) of
        s68360 =>
  (case  ((spc_matches_prefix0 s68360)) of
        Some ((_, s68370)) =>
  (case  ((string_drop s68360 s68370)) of
        s68380 =>
  (case  ((freg_name_matches_prefix s68380 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s68390)) =>
  (case  ((string_drop s68380 s68390)) of
        s68400 =>
  (case  ((sep_matches_prefix s68400)) of
        Some ((_, s68410)) =>
  (case  ((string_drop s68400 s68410)) of
        s68420 =>
  (case  ((freg_name_matches_prefix s68420 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s68430)) =>
  (case  ((string_drop s68420 s68430)) of
        s68440 =>
  (case  ((sep_matches_prefix s68440)) of
        Some ((_, s68450)) =>
  (case  ((string_drop s68440 s68450)) of
        s68460 =>
  (case  ((freg_name_matches_prefix s68460 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s68470)) =>
  (case  ((string_drop s68460 s68470)) of
        s1 => Some (FSGNJ_D, rd, rs1, rs2, s1)
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s68340  :: " string "


\<comment> \<open>\<open>val _s6815_ : string -> maybe ((f_un_rm_op_D * mword ty5 * mword ty5 * rounding_mode * string))\<close>\<close>

definition s6815  :: \<open> string \<Rightarrow>(f_un_rm_op_D*(5)Word.word*(5)Word.word*rounding_mode*string)option \<close>  where 
     \<open> s6815 s68170 = (
      (case  ((f_un_rm_type_mnemonic_D_matches_prefix s68170)) of
        Some ((FCVT_D_S, s68180)) => 
  (case  ((string_drop s68170 s68180)) of
        s68190 =>
  (case  ((spc_matches_prefix0 s68190)) of
        Some ((_, s68200)) =>
  (case  ((string_drop s68190 s68200)) of
        s68210 =>
  (case  ((freg_name_matches_prefix s68210 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s68220)) =>
  (case  ((string_drop s68210 s68220)) of
        s68230 =>
  (case  ((sep_matches_prefix s68230)) of
        Some ((_, s68240)) =>
  (case  ((string_drop s68230 s68240)) of
        s68250 =>
  (case  ((freg_name_matches_prefix s68250 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s68260)) =>
  (case  ((string_drop s68250 s68260)) of
        s68270 =>
  (case  ((sep_matches_prefix s68270)) of
        Some ((_, s68280)) =>
  (case  ((string_drop s68270 s68280)) of
        s68290 =>
  (case  ((frm_mnemonic_matches_prefix s68290)) of
        Some ((rm, s68300)) =>
  (case  ((string_drop s68290 s68300)) of
        s1 => Some (FCVT_D_S, rd, rs1, rm, s1)
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s68170  :: " string "


\<comment> \<open>\<open>val _s6798_ : string -> maybe ((f_un_rm_op_D * mword ty5 * mword ty5 * rounding_mode * string))\<close>\<close>

definition s6798  :: \<open> string \<Rightarrow>(f_un_rm_op_D*(5)Word.word*(5)Word.word*rounding_mode*string)option \<close>  where 
     \<open> s6798 s68000 = (
      (case  ((f_un_rm_type_mnemonic_D_matches_prefix s68000)) of
        Some ((FCVT_S_D, s68010)) => 
  (case  ((string_drop s68000 s68010)) of
        s68020 =>
  (case  ((spc_matches_prefix0 s68020)) of
        Some ((_, s68030)) =>
  (case  ((string_drop s68020 s68030)) of
        s68040 =>
  (case  ((freg_name_matches_prefix s68040 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s68050)) =>
  (case  ((string_drop s68040 s68050)) of
        s68060 =>
  (case  ((sep_matches_prefix s68060)) of
        Some ((_, s68070)) =>
  (case  ((string_drop s68060 s68070)) of
        s68080 =>
  (case  ((freg_name_matches_prefix s68080 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s68090)) =>
  (case  ((string_drop s68080 s68090)) of
        s68100 =>
  (case  ((sep_matches_prefix s68100)) of
        Some ((_, s68110)) =>
  (case  ((string_drop s68100 s68110)) of
        s68120 =>
  (case  ((frm_mnemonic_matches_prefix s68120)) of
        Some ((rm, s68130)) =>
  (case  ((string_drop s68120 s68130)) of
        s1 => Some (FCVT_S_D, rd, rs1, rm, s1)
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s68000  :: " string "


\<comment> \<open>\<open>val _s6781_ : string -> maybe ((f_un_rm_op_D * mword ty5 * mword ty5 * rounding_mode * string))\<close>\<close>

definition s6781  :: \<open> string \<Rightarrow>(f_un_rm_op_D*(5)Word.word*(5)Word.word*rounding_mode*string)option \<close>  where 
     \<open> s6781 s67830 = (
      (case  ((f_un_rm_type_mnemonic_D_matches_prefix s67830)) of
        Some ((FCVT_D_LU, s67840)) => 
  (case  ((string_drop s67830 s67840)) of
        s67850 =>
  (case  ((spc_matches_prefix0 s67850)) of
        Some ((_, s67860)) =>
  (case  ((string_drop s67850 s67860)) of
        s67870 =>
  (case  ((freg_name_matches_prefix s67870 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s67880)) =>
  (case  ((string_drop s67870 s67880)) of
        s67890 =>
  (case  ((sep_matches_prefix s67890)) of
        Some ((_, s67900)) =>
  (case  ((string_drop s67890 s67900)) of
        s67910 =>
  (case  ((reg_name_matches_prefix s67910 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s67920)) =>
  (case  ((string_drop s67910 s67920)) of
        s67930 =>
  (case  ((sep_matches_prefix s67930)) of
        Some ((_, s67940)) =>
  (case  ((string_drop s67930 s67940)) of
        s67950 =>
  (case  ((frm_mnemonic_matches_prefix s67950)) of
        Some ((rm, s67960)) =>
  (case  ((string_drop s67950 s67960)) of
        s1 => Some (FCVT_D_LU, rd, rs1, rm, s1)
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s67830  :: " string "


\<comment> \<open>\<open>val _s6764_ : string -> maybe ((f_un_rm_op_D * mword ty5 * mword ty5 * rounding_mode * string))\<close>\<close>

definition s6764  :: \<open> string \<Rightarrow>(f_un_rm_op_D*(5)Word.word*(5)Word.word*rounding_mode*string)option \<close>  where 
     \<open> s6764 s67660 = (
      (case  ((f_un_rm_type_mnemonic_D_matches_prefix s67660)) of
        Some ((FCVT_D_L, s67670)) => 
  (case  ((string_drop s67660 s67670)) of
        s67680 =>
  (case  ((spc_matches_prefix0 s67680)) of
        Some ((_, s67690)) =>
  (case  ((string_drop s67680 s67690)) of
        s67700 =>
  (case  ((freg_name_matches_prefix s67700 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s67710)) =>
  (case  ((string_drop s67700 s67710)) of
        s67720 =>
  (case  ((sep_matches_prefix s67720)) of
        Some ((_, s67730)) =>
  (case  ((string_drop s67720 s67730)) of
        s67740 =>
  (case  ((reg_name_matches_prefix s67740 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s67750)) =>
  (case  ((string_drop s67740 s67750)) of
        s67760 =>
  (case  ((sep_matches_prefix s67760)) of
        Some ((_, s67770)) =>
  (case  ((string_drop s67760 s67770)) of
        s67780 =>
  (case  ((frm_mnemonic_matches_prefix s67780)) of
        Some ((rm, s67790)) =>
  (case  ((string_drop s67780 s67790)) of
        s1 => Some (FCVT_D_L, rd, rs1, rm, s1)
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s67660  :: " string "


\<comment> \<open>\<open>val _s6747_ : string -> maybe ((f_un_rm_op_D * mword ty5 * mword ty5 * rounding_mode * string))\<close>\<close>

definition s6747  :: \<open> string \<Rightarrow>(f_un_rm_op_D*(5)Word.word*(5)Word.word*rounding_mode*string)option \<close>  where 
     \<open> s6747 s67490 = (
      (case  ((f_un_rm_type_mnemonic_D_matches_prefix s67490)) of
        Some ((FCVT_LU_D, s67500)) => 
  (case  ((string_drop s67490 s67500)) of
        s67510 =>
  (case  ((spc_matches_prefix0 s67510)) of
        Some ((_, s67520)) =>
  (case  ((string_drop s67510 s67520)) of
        s67530 =>
  (case  ((reg_name_matches_prefix s67530 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s67540)) =>
  (case  ((string_drop s67530 s67540)) of
        s67550 =>
  (case  ((sep_matches_prefix s67550)) of
        Some ((_, s67560)) =>
  (case  ((string_drop s67550 s67560)) of
        s67570 =>
  (case  ((freg_name_matches_prefix s67570 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s67580)) =>
  (case  ((string_drop s67570 s67580)) of
        s67590 =>
  (case  ((sep_matches_prefix s67590)) of
        Some ((_, s67600)) =>
  (case  ((string_drop s67590 s67600)) of
        s67610 =>
  (case  ((frm_mnemonic_matches_prefix s67610)) of
        Some ((rm, s67620)) =>
  (case  ((string_drop s67610 s67620)) of
        s1 => Some (FCVT_LU_D, rd, rs1, rm, s1)
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s67490  :: " string "


\<comment> \<open>\<open>val _s6730_ : string -> maybe ((f_un_rm_op_D * mword ty5 * mword ty5 * rounding_mode * string))\<close>\<close>

definition s6730  :: \<open> string \<Rightarrow>(f_un_rm_op_D*(5)Word.word*(5)Word.word*rounding_mode*string)option \<close>  where 
     \<open> s6730 s67320 = (
      (case  ((f_un_rm_type_mnemonic_D_matches_prefix s67320)) of
        Some ((FCVT_L_D, s67330)) => 
  (case  ((string_drop s67320 s67330)) of
        s67340 =>
  (case  ((spc_matches_prefix0 s67340)) of
        Some ((_, s67350)) =>
  (case  ((string_drop s67340 s67350)) of
        s67360 =>
  (case  ((reg_name_matches_prefix s67360 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s67370)) =>
  (case  ((string_drop s67360 s67370)) of
        s67380 =>
  (case  ((sep_matches_prefix s67380)) of
        Some ((_, s67390)) =>
  (case  ((string_drop s67380 s67390)) of
        s67400 =>
  (case  ((freg_name_matches_prefix s67400 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s67410)) =>
  (case  ((string_drop s67400 s67410)) of
        s67420 =>
  (case  ((sep_matches_prefix s67420)) of
        Some ((_, s67430)) =>
  (case  ((string_drop s67420 s67430)) of
        s67440 =>
  (case  ((frm_mnemonic_matches_prefix s67440)) of
        Some ((rm, s67450)) =>
  (case  ((string_drop s67440 s67450)) of
        s1 => Some (FCVT_L_D, rd, rs1, rm, s1)
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s67320  :: " string "


\<comment> \<open>\<open>val _s6713_ : string -> maybe ((f_un_rm_op_D * mword ty5 * mword ty5 * rounding_mode * string))\<close>\<close>

definition s6713  :: \<open> string \<Rightarrow>(f_un_rm_op_D*(5)Word.word*(5)Word.word*rounding_mode*string)option \<close>  where 
     \<open> s6713 s67150 = (
      (case  ((f_un_rm_type_mnemonic_D_matches_prefix s67150)) of
        Some ((FCVT_D_WU, s67160)) => 
  (case  ((string_drop s67150 s67160)) of
        s67170 =>
  (case  ((spc_matches_prefix0 s67170)) of
        Some ((_, s67180)) =>
  (case  ((string_drop s67170 s67180)) of
        s67190 =>
  (case  ((freg_name_matches_prefix s67190 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s67200)) =>
  (case  ((string_drop s67190 s67200)) of
        s67210 =>
  (case  ((sep_matches_prefix s67210)) of
        Some ((_, s67220)) =>
  (case  ((string_drop s67210 s67220)) of
        s67230 =>
  (case  ((reg_name_matches_prefix s67230 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s67240)) =>
  (case  ((string_drop s67230 s67240)) of
        s67250 =>
  (case  ((sep_matches_prefix s67250)) of
        Some ((_, s67260)) =>
  (case  ((string_drop s67250 s67260)) of
        s67270 =>
  (case  ((frm_mnemonic_matches_prefix s67270)) of
        Some ((rm, s67280)) =>
  (case  ((string_drop s67270 s67280)) of
        s1 => Some (FCVT_D_WU, rd, rs1, rm, s1)
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s67150  :: " string "


\<comment> \<open>\<open>val _s6696_ : string -> maybe ((f_un_rm_op_D * mword ty5 * mword ty5 * rounding_mode * string))\<close>\<close>

definition s6696  :: \<open> string \<Rightarrow>(f_un_rm_op_D*(5)Word.word*(5)Word.word*rounding_mode*string)option \<close>  where 
     \<open> s6696 s66980 = (
      (case  ((f_un_rm_type_mnemonic_D_matches_prefix s66980)) of
        Some ((FCVT_D_W, s66990)) => 
  (case  ((string_drop s66980 s66990)) of
        s67000 =>
  (case  ((spc_matches_prefix0 s67000)) of
        Some ((_, s67010)) =>
  (case  ((string_drop s67000 s67010)) of
        s67020 =>
  (case  ((freg_name_matches_prefix s67020 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s67030)) =>
  (case  ((string_drop s67020 s67030)) of
        s67040 =>
  (case  ((sep_matches_prefix s67040)) of
        Some ((_, s67050)) =>
  (case  ((string_drop s67040 s67050)) of
        s67060 =>
  (case  ((reg_name_matches_prefix s67060 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s67070)) =>
  (case  ((string_drop s67060 s67070)) of
        s67080 =>
  (case  ((sep_matches_prefix s67080)) of
        Some ((_, s67090)) =>
  (case  ((string_drop s67080 s67090)) of
        s67100 =>
  (case  ((frm_mnemonic_matches_prefix s67100)) of
        Some ((rm, s67110)) =>
  (case  ((string_drop s67100 s67110)) of
        s1 => Some (FCVT_D_W, rd, rs1, rm, s1)
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s66980  :: " string "


\<comment> \<open>\<open>val _s6679_ : string -> maybe ((f_un_rm_op_D * mword ty5 * mword ty5 * rounding_mode * string))\<close>\<close>

definition s6679  :: \<open> string \<Rightarrow>(f_un_rm_op_D*(5)Word.word*(5)Word.word*rounding_mode*string)option \<close>  where 
     \<open> s6679 s66810 = (
      (case  ((f_un_rm_type_mnemonic_D_matches_prefix s66810)) of
        Some ((FCVT_WU_D, s66820)) => 
  (case  ((string_drop s66810 s66820)) of
        s66830 =>
  (case  ((spc_matches_prefix0 s66830)) of
        Some ((_, s66840)) =>
  (case  ((string_drop s66830 s66840)) of
        s66850 =>
  (case  ((reg_name_matches_prefix s66850 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s66860)) =>
  (case  ((string_drop s66850 s66860)) of
        s66870 =>
  (case  ((sep_matches_prefix s66870)) of
        Some ((_, s66880)) =>
  (case  ((string_drop s66870 s66880)) of
        s66890 =>
  (case  ((freg_name_matches_prefix s66890 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s66900)) =>
  (case  ((string_drop s66890 s66900)) of
        s66910 =>
  (case  ((sep_matches_prefix s66910)) of
        Some ((_, s66920)) =>
  (case  ((string_drop s66910 s66920)) of
        s66930 =>
  (case  ((frm_mnemonic_matches_prefix s66930)) of
        Some ((rm, s66940)) =>
  (case  ((string_drop s66930 s66940)) of
        s1 => Some (FCVT_WU_D, rd, rs1, rm, s1)
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s66810  :: " string "


\<comment> \<open>\<open>val _s6662_ : string -> maybe ((f_un_rm_op_D * mword ty5 * mword ty5 * rounding_mode * string))\<close>\<close>

definition s6662  :: \<open> string \<Rightarrow>(f_un_rm_op_D*(5)Word.word*(5)Word.word*rounding_mode*string)option \<close>  where 
     \<open> s6662 s66640 = (
      (case  ((f_un_rm_type_mnemonic_D_matches_prefix s66640)) of
        Some ((FCVT_W_D, s66650)) => 
  (case  ((string_drop s66640 s66650)) of
        s66660 =>
  (case  ((spc_matches_prefix0 s66660)) of
        Some ((_, s66670)) =>
  (case  ((string_drop s66660 s66670)) of
        s66680 =>
  (case  ((reg_name_matches_prefix s66680 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s66690)) =>
  (case  ((string_drop s66680 s66690)) of
        s66700 =>
  (case  ((sep_matches_prefix s66700)) of
        Some ((_, s66710)) =>
  (case  ((string_drop s66700 s66710)) of
        s66720 =>
  (case  ((freg_name_matches_prefix s66720 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s66730)) =>
  (case  ((string_drop s66720 s66730)) of
        s66740 =>
  (case  ((sep_matches_prefix s66740)) of
        Some ((_, s66750)) =>
  (case  ((string_drop s66740 s66750)) of
        s66760 =>
  (case  ((frm_mnemonic_matches_prefix s66760)) of
        Some ((rm, s66770)) =>
  (case  ((string_drop s66760 s66770)) of
        s1 => Some (FCVT_W_D, rd, rs1, rm, s1)
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s66640  :: " string "


\<comment> \<open>\<open>val _s6645_ : string -> maybe ((f_un_rm_op_D * mword ty5 * mword ty5 * rounding_mode * string))\<close>\<close>

definition s6645  :: \<open> string \<Rightarrow>(f_un_rm_op_D*(5)Word.word*(5)Word.word*rounding_mode*string)option \<close>  where 
     \<open> s6645 s66470 = (
      (case  ((f_un_rm_type_mnemonic_D_matches_prefix s66470)) of
        Some ((FSQRT_D, s66480)) => 
  (case  ((string_drop s66470 s66480)) of
        s66490 =>
  (case  ((spc_matches_prefix0 s66490)) of
        Some ((_, s66500)) =>
  (case  ((string_drop s66490 s66500)) of
        s66510 =>
  (case  ((freg_name_matches_prefix s66510 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s66520)) =>
  (case  ((string_drop s66510 s66520)) of
        s66530 =>
  (case  ((sep_matches_prefix s66530)) of
        Some ((_, s66540)) =>
  (case  ((string_drop s66530 s66540)) of
        s66550 =>
  (case  ((freg_name_matches_prefix s66550 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s66560)) =>
  (case  ((string_drop s66550 s66560)) of
        s66570 =>
  (case  ((sep_matches_prefix s66570)) of
        Some ((_, s66580)) =>
  (case  ((string_drop s66570 s66580)) of
        s66590 =>
  (case  ((frm_mnemonic_matches_prefix s66590)) of
        Some ((rm, s66600)) =>
  (case  ((string_drop s66590 s66600)) of
        s1 => Some (FSQRT_D, rd, rs1, rm, s1)
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s66470  :: " string "


\<comment> \<open>\<open>val _s6624_ : string -> maybe ((f_bin_rm_op_D * mword ty5 * mword ty5 * mword ty5 * rounding_mode * string))\<close>\<close>

definition s6624  :: \<open> string \<Rightarrow>(f_bin_rm_op_D*(5)Word.word*(5)Word.word*(5)Word.word*rounding_mode*string)option \<close>  where 
     \<open> s6624 s66260 = (
      (case  ((f_bin_rm_type_mnemonic_D_matches_prefix s66260)) of
        Some ((op1, s66270)) => 
  (case  ((string_drop s66260 s66270)) of
        s66280 =>
  (case  ((spc_matches_prefix0 s66280)) of
        Some ((_, s66290)) =>
  (case  ((string_drop s66280 s66290)) of
        s66300 =>
  (case  ((freg_name_matches_prefix s66300 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s66310)) =>
  (case  ((string_drop s66300 s66310)) of
        s66320 =>
  (case  ((sep_matches_prefix s66320)) of
        Some ((_, s66330)) =>
  (case  ((string_drop s66320 s66330)) of
        s66340 =>
  (case  ((freg_name_matches_prefix s66340 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s66350)) =>
  (case  ((string_drop s66340 s66350)) of
        s66360 =>
  (case  ((sep_matches_prefix s66360)) of
        Some ((_, s66370)) =>
  (case  ((string_drop s66360 s66370)) of
        s66380 =>
  (case  ((freg_name_matches_prefix s66380 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s66390)) =>
  (case  ((string_drop s66380 s66390)) of
        s66400 =>
  (case  ((sep_matches_prefix s66400)) of
        Some ((_, s66410)) =>
  (case  ((string_drop s66400 s66410)) of
        s66420 =>
  (case  ((frm_mnemonic_matches_prefix s66420)) of
        Some ((rm, s66430)) =>
  (case  ((string_drop s66420 s66430)) of
        s1 => Some (op1, rd, rs1, rs2, rm, s1)
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s66260  :: " string "


\<comment> \<open>\<open>val _s6599_ : string -> maybe ((f_madd_op_D * mword ty5 * mword ty5 * mword ty5 * mword ty5 * rounding_mode * string))\<close>\<close>

definition s6599  :: \<open> string \<Rightarrow>(f_madd_op_D*(5)Word.word*(5)Word.word*(5)Word.word*(5)Word.word*rounding_mode*string)option \<close>  where 
     \<open> s6599 s66010 = (
      (case  ((f_madd_type_mnemonic_D_matches_prefix s66010)) of
        Some ((op1, s66020)) => 
  (case  ((string_drop s66010 s66020)) of
        s66030 =>
  (case  ((spc_matches_prefix0 s66030)) of
        Some ((_, s66040)) =>
  (case  ((string_drop s66030 s66040)) of
        s66050 =>
  (case  ((freg_name_matches_prefix s66050 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s66060)) =>
  (case  ((string_drop s66050 s66060)) of
        s66070 =>
  (case  ((sep_matches_prefix s66070)) of
        Some ((_, s66080)) =>
  (case  ((string_drop s66070 s66080)) of
        s66090 =>
  (case  ((freg_name_matches_prefix s66090 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s66100)) =>
  (case  ((string_drop s66090 s66100)) of
        s66110 =>
  (case  ((sep_matches_prefix s66110)) of
        Some ((_, s66120)) =>
  (case  ((string_drop s66110 s66120)) of
        s66130 =>
  (case  ((freg_name_matches_prefix s66130 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s66140)) =>
  (case  ((string_drop s66130 s66140)) of
        s66150 =>
  (case  ((sep_matches_prefix s66150)) of
        Some ((_, s66160)) =>
  (case  ((string_drop s66150 s66160)) of
        s66170 =>
  (case  ((freg_name_matches_prefix s66170 :: (( 5 Word.word * ii)) option)) of
        Some ((rs3, s66180)) =>
  (case  ((string_drop s66170 s66180)) of
        s66190 =>
  (case  ((sep_matches_prefix s66190)) of
        Some ((_, s66200)) =>
  (case  ((string_drop s66190 s66200)) of
        s66210 =>
  (case  ((frm_mnemonic_matches_prefix s66210)) of
        Some ((rm, s66220)) =>
  (case  ((string_drop s66210 s66220)) of
        s1 =>
  Some (op1, rd, rs1, rs2, rs3, rm, s1)
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s66010  :: " string "


\<comment> \<open>\<open>val _s6583_ : string -> maybe ((mword ty3 * mword ty3 * mword ty5 * string))\<close>\<close>

definition s6583  :: \<open> string \<Rightarrow>((3)Word.word*(3)Word.word*(5)Word.word*string)option \<close>  where 
     \<open> s6583 s65840 = (
   (let s65850 = s65840 in
   if ((string_startswith s65850 (''c.fsw''))) then  
  (case  ((string_drop s65850 ((string_length (''c.fsw''))))) of
        s65860 =>
  (case  ((spc_matches_prefix0 s65860)) of
        Some ((_, s65870)) =>
  (case  ((string_drop s65860 s65870)) of
        s65880 =>
  (case  ((creg_name_matches_prefix s65880 :: (( 3 Word.word * ii)) option)) of
        Some ((rsc1, s65890)) =>
  (case  ((string_drop s65880 s65890)) of
        s65900 =>
  (case  ((sep_matches_prefix s65900)) of
        Some ((_, s65910)) =>
  (case  ((string_drop s65900 s65910)) of
        s65920 =>
  (case  ((creg_name_matches_prefix s65920 :: (( 3 Word.word * ii)) option)) of
        Some ((rsc2, s65930)) =>
  (case  ((string_drop s65920 s65930)) of
        s65940 =>
  (case  ((sep_matches_prefix s65940)) of
        Some ((_, s65950)) =>
  (case  ((string_drop s65940 s65950)) of
        s65960 =>
  (case  ((hex_bits_7_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s65960 :: (( 7 Word.word * ii)) option)) of
        Some ((v__1486, s65970)) =>
  if (((((subrange_vec_dec v__1486 (( 1 :: int):: ii) (( 0 :: int):: ii)
         :: 2 Word.word)) = ( 0b00 :: 2 Word.word)))) then
    (let (uimm :: 5 Word.word) =
         ((subrange_vec_dec v__1486 (( 6 :: int):: ii) (( 2 :: int):: ii) :: 5 Word.word)) in
    (let (uimm :: 5 Word.word) =
         ((subrange_vec_dec v__1486 (( 6 :: int):: ii) (( 2 :: int):: ii) :: 5 Word.word)) in
    (case  ((string_drop s65960 s65970)) of
          s1 => Some (rsc1, rsc2, uimm, s1)
    ))) else None
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s65840  :: " string "


\<comment> \<open>\<open>val _s6567_ : string -> maybe ((mword ty3 * mword ty3 * mword ty5 * string))\<close>\<close>

definition s6567  :: \<open> string \<Rightarrow>((3)Word.word*(3)Word.word*(5)Word.word*string)option \<close>  where 
     \<open> s6567 s65680 = (
   (let s65690 = s65680 in
   if ((string_startswith s65690 (''c.flw''))) then  
  (case  ((string_drop s65690 ((string_length (''c.flw''))))) of
        s65700 =>
  (case  ((spc_matches_prefix0 s65700)) of
        Some ((_, s65710)) =>
  (case  ((string_drop s65700 s65710)) of
        s65720 =>
  (case  ((creg_name_matches_prefix s65720 :: (( 3 Word.word * ii)) option)) of
        Some ((rdc, s65730)) =>
  (case  ((string_drop s65720 s65730)) of
        s65740 =>
  (case  ((sep_matches_prefix s65740)) of
        Some ((_, s65750)) =>
  (case  ((string_drop s65740 s65750)) of
        s65760 =>
  (case  ((creg_name_matches_prefix s65760 :: (( 3 Word.word * ii)) option)) of
        Some ((rsc, s65770)) =>
  (case  ((string_drop s65760 s65770)) of
        s65780 =>
  (case  ((sep_matches_prefix s65780)) of
        Some ((_, s65790)) =>
  (case  ((string_drop s65780 s65790)) of
        s65800 =>
  (case  ((hex_bits_7_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s65800 :: (( 7 Word.word * ii)) option)) of
        Some ((v__1488, s65810)) =>
  if (((((subrange_vec_dec v__1488 (( 1 :: int):: ii) (( 0 :: int):: ii)
         :: 2 Word.word)) = ( 0b00 :: 2 Word.word)))) then
    (let (uimm :: 5 Word.word) =
         ((subrange_vec_dec v__1488 (( 6 :: int):: ii) (( 2 :: int):: ii) :: 5 Word.word)) in
    (let (uimm :: 5 Word.word) =
         ((subrange_vec_dec v__1488 (( 6 :: int):: ii) (( 2 :: int):: ii) :: 5 Word.word)) in
    (case  ((string_drop s65800 s65810)) of
          s1 => Some (rdc, rsc, uimm, s1)
    ))) else None
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s65680  :: " string "


\<comment> \<open>\<open>val _s6555_ : string -> maybe ((mword ty5 * mword ty6 * string))\<close>\<close>

definition s6555  :: \<open> string \<Rightarrow>((5)Word.word*(6)Word.word*string)option \<close>  where 
     \<open> s6555 s65560 = (
   (let s65570 = s65560 in
   if ((string_startswith s65570 (''c.fswsp''))) then  
  (case  ((string_drop s65570 ((string_length (''c.fswsp''))))) of
        s65580 =>
  (case  ((spc_matches_prefix0 s65580)) of
        Some ((_, s65590)) =>
  (case  ((string_drop s65580 s65590)) of
        s65600 =>
  (case  ((reg_name_matches_prefix s65600 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s65610)) =>
  (case  ((string_drop s65600 s65610)) of
        s65620 =>
  (case  ((sep_matches_prefix s65620)) of
        Some ((_, s65630)) =>
  (case  ((string_drop s65620 s65630)) of
        s65640 =>
  (case  ((hex_bits_6_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s65640 :: (( 6 Word.word * ii)) option)) of
        Some ((uimm, s65650)) =>
  (case  ((string_drop s65640 s65650)) of   s1 => Some (rd, uimm, s1) )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s65560  :: " string "


\<comment> \<open>\<open>val _s6543_ : string -> maybe ((mword ty5 * mword ty6 * string))\<close>\<close>

definition s6543  :: \<open> string \<Rightarrow>((5)Word.word*(6)Word.word*string)option \<close>  where 
     \<open> s6543 s65440 = (
   (let s65450 = s65440 in
   if ((string_startswith s65450 (''c.flwsp''))) then  
  (case  ((string_drop s65450 ((string_length (''c.flwsp''))))) of
        s65460 =>
  (case  ((spc_matches_prefix0 s65460)) of
        Some ((_, s65470)) =>
  (case  ((string_drop s65460 s65470)) of
        s65480 =>
  (case  ((reg_name_matches_prefix s65480 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s65490)) =>
  (case  ((string_drop s65480 s65490)) of
        s65500 =>
  (case  ((sep_matches_prefix s65500)) of
        Some ((_, s65510)) =>
  (case  ((string_drop s65500 s65510)) of
        s65520 =>
  (case  ((hex_bits_6_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s65520 :: (( 6 Word.word * ii)) option)) of
        Some ((imm, s65530)) =>
  (case  ((string_drop s65520 s65530)) of   s1 => Some (rd, imm, s1) )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s65440  :: " string "


\<comment> \<open>\<open>val _s6530_ : string -> maybe ((f_un_op_S * mword ty5 * mword ty5 * string))\<close>\<close>

definition s6530  :: \<open> string \<Rightarrow>(f_un_op_S*(5)Word.word*(5)Word.word*string)option \<close>  where 
     \<open> s6530 s65320 = (
      (case  ((f_un_type_mnemonic_S_matches_prefix s65320)) of
        Some ((FCLASS_S, s65330)) => 
  (case  ((string_drop s65320 s65330)) of
        s65340 =>
  (case  ((spc_matches_prefix0 s65340)) of
        Some ((_, s65350)) =>
  (case  ((string_drop s65340 s65350)) of
        s65360 =>
  (case  ((reg_name_matches_prefix s65360 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s65370)) =>
  (case  ((string_drop s65360 s65370)) of
        s65380 =>
  (case  ((sep_matches_prefix s65380)) of
        Some ((_, s65390)) =>
  (case  ((string_drop s65380 s65390)) of
        s65400 =>
  (case  ((freg_name_matches_prefix s65400 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s65410)) =>
  (case  ((string_drop s65400 s65410)) of
        s1 => Some (FCLASS_S, rd, rs1, s1)
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s65320  :: " string "


\<comment> \<open>\<open>val _s6517_ : string -> maybe ((f_un_op_S * mword ty5 * mword ty5 * string))\<close>\<close>

definition s6517  :: \<open> string \<Rightarrow>(f_un_op_S*(5)Word.word*(5)Word.word*string)option \<close>  where 
     \<open> s6517 s65190 = (
      (case  ((f_un_type_mnemonic_S_matches_prefix s65190)) of
        Some ((FMV_W_X, s65200)) => 
  (case  ((string_drop s65190 s65200)) of
        s65210 =>
  (case  ((spc_matches_prefix0 s65210)) of
        Some ((_, s65220)) =>
  (case  ((string_drop s65210 s65220)) of
        s65230 =>
  (case  ((freg_name_matches_prefix s65230 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s65240)) =>
  (case  ((string_drop s65230 s65240)) of
        s65250 =>
  (case  ((sep_matches_prefix s65250)) of
        Some ((_, s65260)) =>
  (case  ((string_drop s65250 s65260)) of
        s65270 =>
  (case  ((reg_name_matches_prefix s65270 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s65280)) =>
  (case  ((string_drop s65270 s65280)) of
        s1 => Some (FMV_W_X, rd, rs1, s1)
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s65190  :: " string "


\<comment> \<open>\<open>val _s6504_ : string -> maybe ((f_un_op_S * mword ty5 * mword ty5 * string))\<close>\<close>

definition s6504  :: \<open> string \<Rightarrow>(f_un_op_S*(5)Word.word*(5)Word.word*string)option \<close>  where 
     \<open> s6504 s65060 = (
      (case  ((f_un_type_mnemonic_S_matches_prefix s65060)) of
        Some ((FMV_X_W, s65070)) => 
  (case  ((string_drop s65060 s65070)) of
        s65080 =>
  (case  ((spc_matches_prefix0 s65080)) of
        Some ((_, s65090)) =>
  (case  ((string_drop s65080 s65090)) of
        s65100 =>
  (case  ((reg_name_matches_prefix s65100 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s65110)) =>
  (case  ((string_drop s65100 s65110)) of
        s65120 =>
  (case  ((sep_matches_prefix s65120)) of
        Some ((_, s65130)) =>
  (case  ((string_drop s65120 s65130)) of
        s65140 =>
  (case  ((freg_name_matches_prefix s65140 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s65150)) =>
  (case  ((string_drop s65140 s65150)) of
        s1 => Some (FMV_X_W, rd, rs1, s1)
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s65060  :: " string "


\<comment> \<open>\<open>val _s6487_ : string -> maybe ((f_bin_op_S * mword ty5 * mword ty5 * mword ty5 * string))\<close>\<close>

definition s6487  :: \<open> string \<Rightarrow>(f_bin_op_S*(5)Word.word*(5)Word.word*(5)Word.word*string)option \<close>  where 
     \<open> s6487 s64890 = (
      (case  ((f_bin_type_mnemonic_S_matches_prefix s64890)) of
        Some ((FLE_S, s64900)) => 
  (case  ((string_drop s64890 s64900)) of
        s64910 =>
  (case  ((spc_matches_prefix0 s64910)) of
        Some ((_, s64920)) =>
  (case  ((string_drop s64910 s64920)) of
        s64930 =>
  (case  ((reg_name_matches_prefix s64930 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s64940)) =>
  (case  ((string_drop s64930 s64940)) of
        s64950 =>
  (case  ((sep_matches_prefix s64950)) of
        Some ((_, s64960)) =>
  (case  ((string_drop s64950 s64960)) of
        s64970 =>
  (case  ((freg_name_matches_prefix s64970 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s64980)) =>
  (case  ((string_drop s64970 s64980)) of
        s64990 =>
  (case  ((sep_matches_prefix s64990)) of
        Some ((_, s65000)) =>
  (case  ((string_drop s64990 s65000)) of
        s65010 =>
  (case  ((freg_name_matches_prefix s65010 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s65020)) =>
  (case  ((string_drop s65010 s65020)) of
        s1 => Some (FLE_S, rd, rs1, rs2, s1)
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s64890  :: " string "


\<comment> \<open>\<open>val _s6470_ : string -> maybe ((f_bin_op_S * mword ty5 * mword ty5 * mword ty5 * string))\<close>\<close>

definition s6470  :: \<open> string \<Rightarrow>(f_bin_op_S*(5)Word.word*(5)Word.word*(5)Word.word*string)option \<close>  where 
     \<open> s6470 s64720 = (
      (case  ((f_bin_type_mnemonic_S_matches_prefix s64720)) of
        Some ((FLT_S, s64730)) => 
  (case  ((string_drop s64720 s64730)) of
        s64740 =>
  (case  ((spc_matches_prefix0 s64740)) of
        Some ((_, s64750)) =>
  (case  ((string_drop s64740 s64750)) of
        s64760 =>
  (case  ((reg_name_matches_prefix s64760 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s64770)) =>
  (case  ((string_drop s64760 s64770)) of
        s64780 =>
  (case  ((sep_matches_prefix s64780)) of
        Some ((_, s64790)) =>
  (case  ((string_drop s64780 s64790)) of
        s64800 =>
  (case  ((freg_name_matches_prefix s64800 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s64810)) =>
  (case  ((string_drop s64800 s64810)) of
        s64820 =>
  (case  ((sep_matches_prefix s64820)) of
        Some ((_, s64830)) =>
  (case  ((string_drop s64820 s64830)) of
        s64840 =>
  (case  ((freg_name_matches_prefix s64840 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s64850)) =>
  (case  ((string_drop s64840 s64850)) of
        s1 => Some (FLT_S, rd, rs1, rs2, s1)
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s64720  :: " string "


\<comment> \<open>\<open>val _s6453_ : string -> maybe ((f_bin_op_S * mword ty5 * mword ty5 * mword ty5 * string))\<close>\<close>

definition s6453  :: \<open> string \<Rightarrow>(f_bin_op_S*(5)Word.word*(5)Word.word*(5)Word.word*string)option \<close>  where 
     \<open> s6453 s64550 = (
      (case  ((f_bin_type_mnemonic_S_matches_prefix s64550)) of
        Some ((FEQ_S, s64560)) => 
  (case  ((string_drop s64550 s64560)) of
        s64570 =>
  (case  ((spc_matches_prefix0 s64570)) of
        Some ((_, s64580)) =>
  (case  ((string_drop s64570 s64580)) of
        s64590 =>
  (case  ((reg_name_matches_prefix s64590 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s64600)) =>
  (case  ((string_drop s64590 s64600)) of
        s64610 =>
  (case  ((sep_matches_prefix s64610)) of
        Some ((_, s64620)) =>
  (case  ((string_drop s64610 s64620)) of
        s64630 =>
  (case  ((freg_name_matches_prefix s64630 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s64640)) =>
  (case  ((string_drop s64630 s64640)) of
        s64650 =>
  (case  ((sep_matches_prefix s64650)) of
        Some ((_, s64660)) =>
  (case  ((string_drop s64650 s64660)) of
        s64670 =>
  (case  ((freg_name_matches_prefix s64670 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s64680)) =>
  (case  ((string_drop s64670 s64680)) of
        s1 => Some (FEQ_S, rd, rs1, rs2, s1)
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s64550  :: " string "


\<comment> \<open>\<open>val _s6436_ : string -> maybe ((f_bin_op_S * mword ty5 * mword ty5 * mword ty5 * string))\<close>\<close>

definition s6436  :: \<open> string \<Rightarrow>(f_bin_op_S*(5)Word.word*(5)Word.word*(5)Word.word*string)option \<close>  where 
     \<open> s6436 s64380 = (
      (case  ((f_bin_type_mnemonic_S_matches_prefix s64380)) of
        Some ((FMAX_S, s64390)) => 
  (case  ((string_drop s64380 s64390)) of
        s64400 =>
  (case  ((spc_matches_prefix0 s64400)) of
        Some ((_, s64410)) =>
  (case  ((string_drop s64400 s64410)) of
        s64420 =>
  (case  ((freg_name_matches_prefix s64420 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s64430)) =>
  (case  ((string_drop s64420 s64430)) of
        s64440 =>
  (case  ((sep_matches_prefix s64440)) of
        Some ((_, s64450)) =>
  (case  ((string_drop s64440 s64450)) of
        s64460 =>
  (case  ((freg_name_matches_prefix s64460 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s64470)) =>
  (case  ((string_drop s64460 s64470)) of
        s64480 =>
  (case  ((sep_matches_prefix s64480)) of
        Some ((_, s64490)) =>
  (case  ((string_drop s64480 s64490)) of
        s64500 =>
  (case  ((freg_name_matches_prefix s64500 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s64510)) =>
  (case  ((string_drop s64500 s64510)) of
        s1 => Some (FMAX_S, rd, rs1, rs2, s1)
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s64380  :: " string "


\<comment> \<open>\<open>val _s6419_ : string -> maybe ((f_bin_op_S * mword ty5 * mword ty5 * mword ty5 * string))\<close>\<close>

definition s6419  :: \<open> string \<Rightarrow>(f_bin_op_S*(5)Word.word*(5)Word.word*(5)Word.word*string)option \<close>  where 
     \<open> s6419 s64210 = (
      (case  ((f_bin_type_mnemonic_S_matches_prefix s64210)) of
        Some ((FMIN_S, s64220)) => 
  (case  ((string_drop s64210 s64220)) of
        s64230 =>
  (case  ((spc_matches_prefix0 s64230)) of
        Some ((_, s64240)) =>
  (case  ((string_drop s64230 s64240)) of
        s64250 =>
  (case  ((freg_name_matches_prefix s64250 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s64260)) =>
  (case  ((string_drop s64250 s64260)) of
        s64270 =>
  (case  ((sep_matches_prefix s64270)) of
        Some ((_, s64280)) =>
  (case  ((string_drop s64270 s64280)) of
        s64290 =>
  (case  ((freg_name_matches_prefix s64290 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s64300)) =>
  (case  ((string_drop s64290 s64300)) of
        s64310 =>
  (case  ((sep_matches_prefix s64310)) of
        Some ((_, s64320)) =>
  (case  ((string_drop s64310 s64320)) of
        s64330 =>
  (case  ((freg_name_matches_prefix s64330 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s64340)) =>
  (case  ((string_drop s64330 s64340)) of
        s1 => Some (FMIN_S, rd, rs1, rs2, s1)
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s64210  :: " string "


\<comment> \<open>\<open>val _s6402_ : string -> maybe ((f_bin_op_S * mword ty5 * mword ty5 * mword ty5 * string))\<close>\<close>

definition s6402  :: \<open> string \<Rightarrow>(f_bin_op_S*(5)Word.word*(5)Word.word*(5)Word.word*string)option \<close>  where 
     \<open> s6402 s64040 = (
      (case  ((f_bin_type_mnemonic_S_matches_prefix s64040)) of
        Some ((FSGNJX_S, s64050)) => 
  (case  ((string_drop s64040 s64050)) of
        s64060 =>
  (case  ((spc_matches_prefix0 s64060)) of
        Some ((_, s64070)) =>
  (case  ((string_drop s64060 s64070)) of
        s64080 =>
  (case  ((freg_name_matches_prefix s64080 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s64090)) =>
  (case  ((string_drop s64080 s64090)) of
        s64100 =>
  (case  ((sep_matches_prefix s64100)) of
        Some ((_, s64110)) =>
  (case  ((string_drop s64100 s64110)) of
        s64120 =>
  (case  ((freg_name_matches_prefix s64120 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s64130)) =>
  (case  ((string_drop s64120 s64130)) of
        s64140 =>
  (case  ((sep_matches_prefix s64140)) of
        Some ((_, s64150)) =>
  (case  ((string_drop s64140 s64150)) of
        s64160 =>
  (case  ((freg_name_matches_prefix s64160 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s64170)) =>
  (case  ((string_drop s64160 s64170)) of
        s1 => Some (FSGNJX_S, rd, rs1, rs2, s1)
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s64040  :: " string "


\<comment> \<open>\<open>val _s6385_ : string -> maybe ((f_bin_op_S * mword ty5 * mword ty5 * mword ty5 * string))\<close>\<close>

definition s6385  :: \<open> string \<Rightarrow>(f_bin_op_S*(5)Word.word*(5)Word.word*(5)Word.word*string)option \<close>  where 
     \<open> s6385 s63870 = (
      (case  ((f_bin_type_mnemonic_S_matches_prefix s63870)) of
        Some ((FSGNJN_S, s63880)) => 
  (case  ((string_drop s63870 s63880)) of
        s63890 =>
  (case  ((spc_matches_prefix0 s63890)) of
        Some ((_, s63900)) =>
  (case  ((string_drop s63890 s63900)) of
        s63910 =>
  (case  ((freg_name_matches_prefix s63910 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s63920)) =>
  (case  ((string_drop s63910 s63920)) of
        s63930 =>
  (case  ((sep_matches_prefix s63930)) of
        Some ((_, s63940)) =>
  (case  ((string_drop s63930 s63940)) of
        s63950 =>
  (case  ((freg_name_matches_prefix s63950 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s63960)) =>
  (case  ((string_drop s63950 s63960)) of
        s63970 =>
  (case  ((sep_matches_prefix s63970)) of
        Some ((_, s63980)) =>
  (case  ((string_drop s63970 s63980)) of
        s63990 =>
  (case  ((freg_name_matches_prefix s63990 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s64000)) =>
  (case  ((string_drop s63990 s64000)) of
        s1 => Some (FSGNJN_S, rd, rs1, rs2, s1)
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s63870  :: " string "


\<comment> \<open>\<open>val _s6368_ : string -> maybe ((f_bin_op_S * mword ty5 * mword ty5 * mword ty5 * string))\<close>\<close>

definition s6368  :: \<open> string \<Rightarrow>(f_bin_op_S*(5)Word.word*(5)Word.word*(5)Word.word*string)option \<close>  where 
     \<open> s6368 s63700 = (
      (case  ((f_bin_type_mnemonic_S_matches_prefix s63700)) of
        Some ((FSGNJ_S, s63710)) => 
  (case  ((string_drop s63700 s63710)) of
        s63720 =>
  (case  ((spc_matches_prefix0 s63720)) of
        Some ((_, s63730)) =>
  (case  ((string_drop s63720 s63730)) of
        s63740 =>
  (case  ((freg_name_matches_prefix s63740 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s63750)) =>
  (case  ((string_drop s63740 s63750)) of
        s63760 =>
  (case  ((sep_matches_prefix s63760)) of
        Some ((_, s63770)) =>
  (case  ((string_drop s63760 s63770)) of
        s63780 =>
  (case  ((freg_name_matches_prefix s63780 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s63790)) =>
  (case  ((string_drop s63780 s63790)) of
        s63800 =>
  (case  ((sep_matches_prefix s63800)) of
        Some ((_, s63810)) =>
  (case  ((string_drop s63800 s63810)) of
        s63820 =>
  (case  ((freg_name_matches_prefix s63820 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s63830)) =>
  (case  ((string_drop s63820 s63830)) of
        s1 => Some (FSGNJ_S, rd, rs1, rs2, s1)
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s63700  :: " string "


\<comment> \<open>\<open>val _s6351_ : string -> maybe ((f_un_rm_op_S * mword ty5 * mword ty5 * rounding_mode * string))\<close>\<close>

definition s6351  :: \<open> string \<Rightarrow>(f_un_rm_op_S*(5)Word.word*(5)Word.word*rounding_mode*string)option \<close>  where 
     \<open> s6351 s63530 = (
      (case  ((f_un_rm_type_mnemonic_S_matches_prefix s63530)) of
        Some ((FCVT_S_LU, s63540)) => 
  (case  ((string_drop s63530 s63540)) of
        s63550 =>
  (case  ((spc_matches_prefix0 s63550)) of
        Some ((_, s63560)) =>
  (case  ((string_drop s63550 s63560)) of
        s63570 =>
  (case  ((freg_name_matches_prefix s63570 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s63580)) =>
  (case  ((string_drop s63570 s63580)) of
        s63590 =>
  (case  ((sep_matches_prefix s63590)) of
        Some ((_, s63600)) =>
  (case  ((string_drop s63590 s63600)) of
        s63610 =>
  (case  ((reg_name_matches_prefix s63610 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s63620)) =>
  (case  ((string_drop s63610 s63620)) of
        s63630 =>
  (case  ((sep_matches_prefix s63630)) of
        Some ((_, s63640)) =>
  (case  ((string_drop s63630 s63640)) of
        s63650 =>
  (case  ((frm_mnemonic_matches_prefix s63650)) of
        Some ((rm, s63660)) =>
  (case  ((string_drop s63650 s63660)) of
        s1 => Some (FCVT_S_LU, rd, rs1, rm, s1)
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s63530  :: " string "


\<comment> \<open>\<open>val _s6334_ : string -> maybe ((f_un_rm_op_S * mword ty5 * mword ty5 * rounding_mode * string))\<close>\<close>

definition s6334  :: \<open> string \<Rightarrow>(f_un_rm_op_S*(5)Word.word*(5)Word.word*rounding_mode*string)option \<close>  where 
     \<open> s6334 s63360 = (
      (case  ((f_un_rm_type_mnemonic_S_matches_prefix s63360)) of
        Some ((FCVT_S_L, s63370)) => 
  (case  ((string_drop s63360 s63370)) of
        s63380 =>
  (case  ((spc_matches_prefix0 s63380)) of
        Some ((_, s63390)) =>
  (case  ((string_drop s63380 s63390)) of
        s63400 =>
  (case  ((freg_name_matches_prefix s63400 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s63410)) =>
  (case  ((string_drop s63400 s63410)) of
        s63420 =>
  (case  ((sep_matches_prefix s63420)) of
        Some ((_, s63430)) =>
  (case  ((string_drop s63420 s63430)) of
        s63440 =>
  (case  ((reg_name_matches_prefix s63440 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s63450)) =>
  (case  ((string_drop s63440 s63450)) of
        s63460 =>
  (case  ((sep_matches_prefix s63460)) of
        Some ((_, s63470)) =>
  (case  ((string_drop s63460 s63470)) of
        s63480 =>
  (case  ((frm_mnemonic_matches_prefix s63480)) of
        Some ((rm, s63490)) =>
  (case  ((string_drop s63480 s63490)) of
        s1 => Some (FCVT_S_L, rd, rs1, rm, s1)
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s63360  :: " string "


\<comment> \<open>\<open>val _s6317_ : string -> maybe ((f_un_rm_op_S * mword ty5 * mword ty5 * rounding_mode * string))\<close>\<close>

definition s6317  :: \<open> string \<Rightarrow>(f_un_rm_op_S*(5)Word.word*(5)Word.word*rounding_mode*string)option \<close>  where 
     \<open> s6317 s63190 = (
      (case  ((f_un_rm_type_mnemonic_S_matches_prefix s63190)) of
        Some ((FCVT_LU_S, s63200)) => 
  (case  ((string_drop s63190 s63200)) of
        s63210 =>
  (case  ((spc_matches_prefix0 s63210)) of
        Some ((_, s63220)) =>
  (case  ((string_drop s63210 s63220)) of
        s63230 =>
  (case  ((reg_name_matches_prefix s63230 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s63240)) =>
  (case  ((string_drop s63230 s63240)) of
        s63250 =>
  (case  ((sep_matches_prefix s63250)) of
        Some ((_, s63260)) =>
  (case  ((string_drop s63250 s63260)) of
        s63270 =>
  (case  ((freg_name_matches_prefix s63270 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s63280)) =>
  (case  ((string_drop s63270 s63280)) of
        s63290 =>
  (case  ((sep_matches_prefix s63290)) of
        Some ((_, s63300)) =>
  (case  ((string_drop s63290 s63300)) of
        s63310 =>
  (case  ((frm_mnemonic_matches_prefix s63310)) of
        Some ((rm, s63320)) =>
  (case  ((string_drop s63310 s63320)) of
        s1 => Some (FCVT_LU_S, rd, rs1, rm, s1)
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s63190  :: " string "


\<comment> \<open>\<open>val _s6300_ : string -> maybe ((f_un_rm_op_S * mword ty5 * mword ty5 * rounding_mode * string))\<close>\<close>

definition s6300  :: \<open> string \<Rightarrow>(f_un_rm_op_S*(5)Word.word*(5)Word.word*rounding_mode*string)option \<close>  where 
     \<open> s6300 s63020 = (
      (case  ((f_un_rm_type_mnemonic_S_matches_prefix s63020)) of
        Some ((FCVT_L_S, s63030)) => 
  (case  ((string_drop s63020 s63030)) of
        s63040 =>
  (case  ((spc_matches_prefix0 s63040)) of
        Some ((_, s63050)) =>
  (case  ((string_drop s63040 s63050)) of
        s63060 =>
  (case  ((reg_name_matches_prefix s63060 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s63070)) =>
  (case  ((string_drop s63060 s63070)) of
        s63080 =>
  (case  ((sep_matches_prefix s63080)) of
        Some ((_, s63090)) =>
  (case  ((string_drop s63080 s63090)) of
        s63100 =>
  (case  ((freg_name_matches_prefix s63100 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s63110)) =>
  (case  ((string_drop s63100 s63110)) of
        s63120 =>
  (case  ((sep_matches_prefix s63120)) of
        Some ((_, s63130)) =>
  (case  ((string_drop s63120 s63130)) of
        s63140 =>
  (case  ((frm_mnemonic_matches_prefix s63140)) of
        Some ((rm, s63150)) =>
  (case  ((string_drop s63140 s63150)) of
        s1 => Some (FCVT_L_S, rd, rs1, rm, s1)
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s63020  :: " string "


\<comment> \<open>\<open>val _s6283_ : string -> maybe ((f_un_rm_op_S * mword ty5 * mword ty5 * rounding_mode * string))\<close>\<close>

definition s6283  :: \<open> string \<Rightarrow>(f_un_rm_op_S*(5)Word.word*(5)Word.word*rounding_mode*string)option \<close>  where 
     \<open> s6283 s62850 = (
      (case  ((f_un_rm_type_mnemonic_S_matches_prefix s62850)) of
        Some ((FCVT_S_WU, s62860)) => 
  (case  ((string_drop s62850 s62860)) of
        s62870 =>
  (case  ((spc_matches_prefix0 s62870)) of
        Some ((_, s62880)) =>
  (case  ((string_drop s62870 s62880)) of
        s62890 =>
  (case  ((freg_name_matches_prefix s62890 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s62900)) =>
  (case  ((string_drop s62890 s62900)) of
        s62910 =>
  (case  ((sep_matches_prefix s62910)) of
        Some ((_, s62920)) =>
  (case  ((string_drop s62910 s62920)) of
        s62930 =>
  (case  ((reg_name_matches_prefix s62930 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s62940)) =>
  (case  ((string_drop s62930 s62940)) of
        s62950 =>
  (case  ((sep_matches_prefix s62950)) of
        Some ((_, s62960)) =>
  (case  ((string_drop s62950 s62960)) of
        s62970 =>
  (case  ((frm_mnemonic_matches_prefix s62970)) of
        Some ((rm, s62980)) =>
  (case  ((string_drop s62970 s62980)) of
        s1 => Some (FCVT_S_WU, rd, rs1, rm, s1)
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s62850  :: " string "


\<comment> \<open>\<open>val _s6266_ : string -> maybe ((f_un_rm_op_S * mword ty5 * mword ty5 * rounding_mode * string))\<close>\<close>

definition s6266  :: \<open> string \<Rightarrow>(f_un_rm_op_S*(5)Word.word*(5)Word.word*rounding_mode*string)option \<close>  where 
     \<open> s6266 s62680 = (
      (case  ((f_un_rm_type_mnemonic_S_matches_prefix s62680)) of
        Some ((FCVT_S_W, s62690)) => 
  (case  ((string_drop s62680 s62690)) of
        s62700 =>
  (case  ((spc_matches_prefix0 s62700)) of
        Some ((_, s62710)) =>
  (case  ((string_drop s62700 s62710)) of
        s62720 =>
  (case  ((freg_name_matches_prefix s62720 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s62730)) =>
  (case  ((string_drop s62720 s62730)) of
        s62740 =>
  (case  ((sep_matches_prefix s62740)) of
        Some ((_, s62750)) =>
  (case  ((string_drop s62740 s62750)) of
        s62760 =>
  (case  ((reg_name_matches_prefix s62760 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s62770)) =>
  (case  ((string_drop s62760 s62770)) of
        s62780 =>
  (case  ((sep_matches_prefix s62780)) of
        Some ((_, s62790)) =>
  (case  ((string_drop s62780 s62790)) of
        s62800 =>
  (case  ((frm_mnemonic_matches_prefix s62800)) of
        Some ((rm, s62810)) =>
  (case  ((string_drop s62800 s62810)) of
        s1 => Some (FCVT_S_W, rd, rs1, rm, s1)
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s62680  :: " string "


\<comment> \<open>\<open>val _s6249_ : string -> maybe ((f_un_rm_op_S * mword ty5 * mword ty5 * rounding_mode * string))\<close>\<close>

definition s6249  :: \<open> string \<Rightarrow>(f_un_rm_op_S*(5)Word.word*(5)Word.word*rounding_mode*string)option \<close>  where 
     \<open> s6249 s62510 = (
      (case  ((f_un_rm_type_mnemonic_S_matches_prefix s62510)) of
        Some ((FCVT_WU_S, s62520)) => 
  (case  ((string_drop s62510 s62520)) of
        s62530 =>
  (case  ((spc_matches_prefix0 s62530)) of
        Some ((_, s62540)) =>
  (case  ((string_drop s62530 s62540)) of
        s62550 =>
  (case  ((reg_name_matches_prefix s62550 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s62560)) =>
  (case  ((string_drop s62550 s62560)) of
        s62570 =>
  (case  ((sep_matches_prefix s62570)) of
        Some ((_, s62580)) =>
  (case  ((string_drop s62570 s62580)) of
        s62590 =>
  (case  ((freg_name_matches_prefix s62590 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s62600)) =>
  (case  ((string_drop s62590 s62600)) of
        s62610 =>
  (case  ((sep_matches_prefix s62610)) of
        Some ((_, s62620)) =>
  (case  ((string_drop s62610 s62620)) of
        s62630 =>
  (case  ((frm_mnemonic_matches_prefix s62630)) of
        Some ((rm, s62640)) =>
  (case  ((string_drop s62630 s62640)) of
        s1 => Some (FCVT_WU_S, rd, rs1, rm, s1)
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s62510  :: " string "


\<comment> \<open>\<open>val _s6232_ : string -> maybe ((f_un_rm_op_S * mword ty5 * mword ty5 * rounding_mode * string))\<close>\<close>

definition s6232  :: \<open> string \<Rightarrow>(f_un_rm_op_S*(5)Word.word*(5)Word.word*rounding_mode*string)option \<close>  where 
     \<open> s6232 s62340 = (
      (case  ((f_un_rm_type_mnemonic_S_matches_prefix s62340)) of
        Some ((FCVT_W_S, s62350)) => 
  (case  ((string_drop s62340 s62350)) of
        s62360 =>
  (case  ((spc_matches_prefix0 s62360)) of
        Some ((_, s62370)) =>
  (case  ((string_drop s62360 s62370)) of
        s62380 =>
  (case  ((reg_name_matches_prefix s62380 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s62390)) =>
  (case  ((string_drop s62380 s62390)) of
        s62400 =>
  (case  ((sep_matches_prefix s62400)) of
        Some ((_, s62410)) =>
  (case  ((string_drop s62400 s62410)) of
        s62420 =>
  (case  ((freg_name_matches_prefix s62420 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s62430)) =>
  (case  ((string_drop s62420 s62430)) of
        s62440 =>
  (case  ((sep_matches_prefix s62440)) of
        Some ((_, s62450)) =>
  (case  ((string_drop s62440 s62450)) of
        s62460 =>
  (case  ((frm_mnemonic_matches_prefix s62460)) of
        Some ((rm, s62470)) =>
  (case  ((string_drop s62460 s62470)) of
        s1 => Some (FCVT_W_S, rd, rs1, rm, s1)
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s62340  :: " string "


\<comment> \<open>\<open>val _s6215_ : string -> maybe ((f_un_rm_op_S * mword ty5 * mword ty5 * rounding_mode * string))\<close>\<close>

definition s6215  :: \<open> string \<Rightarrow>(f_un_rm_op_S*(5)Word.word*(5)Word.word*rounding_mode*string)option \<close>  where 
     \<open> s6215 s62170 = (
      (case  ((f_un_rm_type_mnemonic_S_matches_prefix s62170)) of
        Some ((FSQRT_S, s62180)) => 
  (case  ((string_drop s62170 s62180)) of
        s62190 =>
  (case  ((spc_matches_prefix0 s62190)) of
        Some ((_, s62200)) =>
  (case  ((string_drop s62190 s62200)) of
        s62210 =>
  (case  ((freg_name_matches_prefix s62210 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s62220)) =>
  (case  ((string_drop s62210 s62220)) of
        s62230 =>
  (case  ((sep_matches_prefix s62230)) of
        Some ((_, s62240)) =>
  (case  ((string_drop s62230 s62240)) of
        s62250 =>
  (case  ((freg_name_matches_prefix s62250 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s62260)) =>
  (case  ((string_drop s62250 s62260)) of
        s62270 =>
  (case  ((sep_matches_prefix s62270)) of
        Some ((_, s62280)) =>
  (case  ((string_drop s62270 s62280)) of
        s62290 =>
  (case  ((frm_mnemonic_matches_prefix s62290)) of
        Some ((rm, s62300)) =>
  (case  ((string_drop s62290 s62300)) of
        s1 => Some (FSQRT_S, rd, rs1, rm, s1)
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s62170  :: " string "


\<comment> \<open>\<open>val _s6194_ : string -> maybe ((f_bin_rm_op_S * mword ty5 * mword ty5 * mword ty5 * rounding_mode * string))\<close>\<close>

definition s6194  :: \<open> string \<Rightarrow>(f_bin_rm_op_S*(5)Word.word*(5)Word.word*(5)Word.word*rounding_mode*string)option \<close>  where 
     \<open> s6194 s61960 = (
      (case  ((f_bin_rm_type_mnemonic_S_matches_prefix s61960)) of
        Some ((op1, s61970)) => 
  (case  ((string_drop s61960 s61970)) of
        s61980 =>
  (case  ((spc_matches_prefix0 s61980)) of
        Some ((_, s61990)) =>
  (case  ((string_drop s61980 s61990)) of
        s62000 =>
  (case  ((freg_name_matches_prefix s62000 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s62010)) =>
  (case  ((string_drop s62000 s62010)) of
        s62020 =>
  (case  ((sep_matches_prefix s62020)) of
        Some ((_, s62030)) =>
  (case  ((string_drop s62020 s62030)) of
        s62040 =>
  (case  ((freg_name_matches_prefix s62040 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s62050)) =>
  (case  ((string_drop s62040 s62050)) of
        s62060 =>
  (case  ((sep_matches_prefix s62060)) of
        Some ((_, s62070)) =>
  (case  ((string_drop s62060 s62070)) of
        s62080 =>
  (case  ((freg_name_matches_prefix s62080 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s62090)) =>
  (case  ((string_drop s62080 s62090)) of
        s62100 =>
  (case  ((sep_matches_prefix s62100)) of
        Some ((_, s62110)) =>
  (case  ((string_drop s62100 s62110)) of
        s62120 =>
  (case  ((frm_mnemonic_matches_prefix s62120)) of
        Some ((rm, s62130)) =>
  (case  ((string_drop s62120 s62130)) of
        s1 => Some (op1, rd, rs1, rs2, rm, s1)
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s61960  :: " string "


\<comment> \<open>\<open>val _s6169_ : string -> maybe ((f_madd_op_S * mword ty5 * mword ty5 * mword ty5 * mword ty5 * rounding_mode * string))\<close>\<close>

definition s6169  :: \<open> string \<Rightarrow>(f_madd_op_S*(5)Word.word*(5)Word.word*(5)Word.word*(5)Word.word*rounding_mode*string)option \<close>  where 
     \<open> s6169 s61710 = (
      (case  ((f_madd_type_mnemonic_S_matches_prefix s61710)) of
        Some ((op1, s61720)) => 
  (case  ((string_drop s61710 s61720)) of
        s61730 =>
  (case  ((spc_matches_prefix0 s61730)) of
        Some ((_, s61740)) =>
  (case  ((string_drop s61730 s61740)) of
        s61750 =>
  (case  ((freg_name_matches_prefix s61750 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s61760)) =>
  (case  ((string_drop s61750 s61760)) of
        s61770 =>
  (case  ((sep_matches_prefix s61770)) of
        Some ((_, s61780)) =>
  (case  ((string_drop s61770 s61780)) of
        s61790 =>
  (case  ((freg_name_matches_prefix s61790 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s61800)) =>
  (case  ((string_drop s61790 s61800)) of
        s61810 =>
  (case  ((sep_matches_prefix s61810)) of
        Some ((_, s61820)) =>
  (case  ((string_drop s61810 s61820)) of
        s61830 =>
  (case  ((freg_name_matches_prefix s61830 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s61840)) =>
  (case  ((string_drop s61830 s61840)) of
        s61850 =>
  (case  ((sep_matches_prefix s61850)) of
        Some ((_, s61860)) =>
  (case  ((string_drop s61850 s61860)) of
        s61870 =>
  (case  ((freg_name_matches_prefix s61870 :: (( 5 Word.word * ii)) option)) of
        Some ((rs3, s61880)) =>
  (case  ((string_drop s61870 s61880)) of
        s61890 =>
  (case  ((sep_matches_prefix s61890)) of
        Some ((_, s61900)) =>
  (case  ((string_drop s61890 s61900)) of
        s61910 =>
  (case  ((frm_mnemonic_matches_prefix s61910)) of
        Some ((rm, s61920)) =>
  (case  ((string_drop s61910 s61920)) of
        s1 =>
  Some (op1, rd, rs1, rs2, rs3, rm, s1)
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s61710  :: " string "


\<comment> \<open>\<open>val _s6145_ : string -> maybe ((word_width * mword ty5 * mword ty12 * mword ty5 * string))\<close>\<close>

definition s6145  :: \<open> string \<Rightarrow>(word_width*(5)Word.word*(12)Word.word*(5)Word.word*string)option \<close>  where 
     \<open> s6145 s61460 = (
   (let s61470 = s61460 in
   if ((string_startswith s61470 (''fs''))) then  
  (case  ((string_drop s61470 ((string_length (''fs''))))) of
        s61480 =>
  (case  ((size_mnemonic_matches_prefix s61480)) of
        Some ((width, s61490)) =>
  (case  ((string_drop s61480 s61490)) of
        s61500 =>
  (case  ((spc_matches_prefix0 s61500)) of
        Some ((_, s61510)) =>
  (case  ((string_drop s61500 s61510)) of
        s61520 =>
  (case  ((freg_name_matches_prefix s61520 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s61530)) =>
  (case  ((string_drop s61520 s61530)) of
        s61540 =>
  (case  ((sep_matches_prefix s61540)) of
        Some ((_, s61550)) =>
  (case  ((string_drop s61540 s61550)) of
        s61560 =>
  (case  ((hex_bits_12_matches_prefix0 s61560
          :: (( 12 Word.word * ii)) option)) of
        Some ((imm, s61570)) =>
  (case  ((string_drop s61560 s61570)) of
        s61580 =>
  (case  ((opt_spc_matches_prefix0 s61580)) of
        Some ((_, s61590)) =>
  (let s61600 = (string_drop s61580 s61590) in
  if ((string_startswith s61600 (''(''))) then
    (case  ((string_drop s61600 ((string_length (''(''))))) of
          s61610 =>
    (case  ((opt_spc_matches_prefix0 s61610)) of
          Some ((_, s61620)) =>
    (case  ((string_drop s61610 s61620)) of
          s61630 =>
    (case  ((reg_name_matches_prefix s61630 :: (( 5 Word.word * ii)) option)) of
          Some ((rs1, s61640)) =>
    (case  ((string_drop s61630 s61640)) of
          s61650 =>
    (case  ((opt_spc_matches_prefix0 s61650)) of
          Some ((_, s61660)) =>
    (let s61670 = (string_drop s61650 s61660) in
    if ((string_startswith s61670 ('')''))) then
      (case  ((string_drop s61670 ((string_length ('')''))))) of
            s1 =>
      Some (width, rs2, imm, rs1, s1)
      ) else None)
      | _ => None
    )
    )
      | _ => None
    )
    )
      | _ => None
    )
    ) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s61460  :: " string "


\<comment> \<open>\<open>val _s6121_ : string -> maybe ((word_width * mword ty5 * mword ty12 * mword ty5 * string))\<close>\<close>

definition s6121  :: \<open> string \<Rightarrow>(word_width*(5)Word.word*(12)Word.word*(5)Word.word*string)option \<close>  where 
     \<open> s6121 s61220 = (
   (let s61230 = s61220 in
   if ((string_startswith s61230 (''fl''))) then  
  (case  ((string_drop s61230 ((string_length (''fl''))))) of
        s61240 =>
  (case  ((size_mnemonic_matches_prefix s61240)) of
        Some ((width, s61250)) =>
  (case  ((string_drop s61240 s61250)) of
        s61260 =>
  (case  ((spc_matches_prefix0 s61260)) of
        Some ((_, s61270)) =>
  (case  ((string_drop s61260 s61270)) of
        s61280 =>
  (case  ((freg_name_matches_prefix s61280 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s61290)) =>
  (case  ((string_drop s61280 s61290)) of
        s61300 =>
  (case  ((sep_matches_prefix s61300)) of
        Some ((_, s61310)) =>
  (case  ((string_drop s61300 s61310)) of
        s61320 =>
  (case  ((hex_bits_12_matches_prefix0 s61320
          :: (( 12 Word.word * ii)) option)) of
        Some ((imm, s61330)) =>
  (case  ((string_drop s61320 s61330)) of
        s61340 =>
  (case  ((opt_spc_matches_prefix0 s61340)) of
        Some ((_, s61350)) =>
  (let s61360 = (string_drop s61340 s61350) in
  if ((string_startswith s61360 (''(''))) then
    (case  ((string_drop s61360 ((string_length (''(''))))) of
          s61370 =>
    (case  ((opt_spc_matches_prefix0 s61370)) of
          Some ((_, s61380)) =>
    (case  ((string_drop s61370 s61380)) of
          s61390 =>
    (case  ((reg_name_matches_prefix s61390 :: (( 5 Word.word * ii)) option)) of
          Some ((rs1, s61400)) =>
    (case  ((string_drop s61390 s61400)) of
          s61410 =>
    (case  ((opt_spc_matches_prefix0 s61410)) of
          Some ((_, s61420)) =>
    (let s61430 = (string_drop s61410 s61420) in
    if ((string_startswith s61430 ('')''))) then
      (case  ((string_drop s61430 ((string_length ('')''))))) of
            s1 =>
      Some (width, rd, imm, rs1, s1)
      ) else None)
      | _ => None
    )
    )
      | _ => None
    )
    )
      | _ => None
    )
    ) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s61220  :: " string "


\<comment> \<open>\<open>val _s6109_ : string -> maybe ((mword ty5 * mword ty5 * mword ty12 * string))\<close>\<close>

definition s6109  :: \<open> string \<Rightarrow>((5)Word.word*(5)Word.word*(12)Word.word*string)option \<close>  where 
     \<open> s6109 s61100 = (
   (let s61110 = s61100 in
   if ((string_startswith s61110 (''fence.i.reserved.''))) then  
  (case  ((string_drop s61110 ((string_length (''fence.i.reserved.''))))) of
        s61120 =>
  (case  ((reg_name_matches_prefix s61120 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s61130)) =>
  (let s61140 = (string_drop s61120 s61130) in
  if ((string_startswith s61140 (''.''))) then
    (case  ((string_drop s61140 ((string_length (''.''))))) of
          s61150 =>
    (case  ((reg_name_matches_prefix s61150 :: (( 5 Word.word * ii)) option)) of
          Some ((rs, s61160)) =>
    (let s61170 = (string_drop s61150 s61160) in
    if ((string_startswith s61170 (''.''))) then
      (case  ((string_drop s61170 ((string_length (''.''))))) of
            s61180 =>
      (case  ((hex_bits_12_matches_prefix0 s61180 :: (( 12 Word.word * ii)) option)) of
            Some ((imm, s61190)) =>
      (case  ((string_drop s61180 s61190)) of
            s1 => Some (rd, rs, imm, s1)
      )
        | _ => None
      )
      ) else None)
      | _ => None
    )
    ) else None)
    | _ => None
  )
  )
   else None))\<close> 
  for  s61100  :: " string "


\<comment> \<open>\<open>val _s6091_ : string -> maybe ((mword ty4 * mword ty4 * mword ty5 * mword ty5 * mword ty4 * string))\<close>\<close>

definition s6091  :: \<open> string \<Rightarrow>((4)Word.word*(4)Word.word*(5)Word.word*(5)Word.word*(4)Word.word*string)option \<close>  where 
     \<open> s6091 s60920 = (
   (let s60930 = s60920 in
   if ((string_startswith s60930 (''fence.reserved.''))) then  
  (case  ((string_drop s60930 ((string_length (''fence.reserved.''))))) of
        s60940 =>
  (case  ((fence_bits_matches_prefix s60940 :: (( 4 Word.word * ii)) option)) of
        Some ((pred, s60950)) =>
  (let s60960 = (string_drop s60940 s60950) in
  if ((string_startswith s60960 (''.''))) then
    (case  ((string_drop s60960 ((string_length (''.''))))) of
          s60970 =>
    (case  ((fence_bits_matches_prefix s60970 :: (( 4 Word.word * ii)) option)) of
          Some ((succ, s60980)) =>
    (let s60990 = (string_drop s60970 s60980) in
    if ((string_startswith s60990 (''.''))) then
      (case  ((string_drop s60990 ((string_length (''.''))))) of
            s61000 =>
      (case  ((reg_name_matches_prefix s61000 :: (( 5 Word.word * ii)) option)) of
            Some ((rs, s61010)) =>
      (let s61020 = (string_drop s61000 s61010) in
      if ((string_startswith s61020 (''.''))) then
        (case  ((string_drop s61020 ((string_length (''.''))))) of
              s61030 =>
        (case  ((reg_name_matches_prefix s61030 :: (( 5 Word.word * ii)) option)) of
              Some ((rd, s61040)) =>
        (let s61050 = (string_drop s61030 s61040) in
        if ((string_startswith s61050 (''.''))) then
          (case  ((string_drop s61050 ((string_length (''.''))))) of
                s61060 =>
          (case  ((hex_bits_4_matches_prefix
                     instance_Sail2_values_Bitvector_Machine_word_mword_dict
                     s61060 :: (( 4 Word.word * ii)) option)) of
                Some ((fm, s61070)) =>
          (case  ((string_drop s61060 s61070)) of
                s1 => Some (pred, succ, rs, rd, fm, s1)
          )
            | _ => None
          )
          ) else None)
          | _ => None
        )
        ) else None)
        | _ => None
      )
      ) else None)
      | _ => None
    )
    ) else None)
    | _ => None
  )
  )
   else None))\<close> 
  for  s60920  :: " string "


\<comment> \<open>\<open>val _s6085_ : string -> maybe ((mword ty3 * string))\<close>\<close>

definition s6085  :: \<open> string \<Rightarrow>((3)Word.word*string)option \<close>  where 
     \<open> s6085 s60860 = (
   (let s60870 = s60860 in
   if ((string_startswith s60870 (''c.srai.hint.''))) then  
  (case  ((string_drop s60870 ((string_length (''c.srai.hint.''))))) of
        s60880 =>
  (case  ((creg_name_matches_prefix s60880 :: (( 3 Word.word * ii)) option)) of
        Some ((rsd, s60890)) =>
  (case  ((string_drop s60880 s60890)) of   s1 => Some (rsd, s1) )
    | _ => None
  )
  )
   else None))\<close> 
  for  s60860  :: " string "


\<comment> \<open>\<open>val _s6079_ : string -> maybe ((mword ty3 * string))\<close>\<close>

definition s6079  :: \<open> string \<Rightarrow>((3)Word.word*string)option \<close>  where 
     \<open> s6079 s60800 = (
   (let s60810 = s60800 in
   if ((string_startswith s60810 (''c.srli.hint.''))) then  
  (case  ((string_drop s60810 ((string_length (''c.srli.hint.''))))) of
        s60820 =>
  (case  ((creg_name_matches_prefix s60820 :: (( 3 Word.word * ii)) option)) of
        Some ((rsd, s60830)) =>
  (case  ((string_drop s60820 s60830)) of   s1 => Some (rsd, s1) )
    | _ => None
  )
  )
   else None))\<close> 
  for  s60800  :: " string "


\<comment> \<open>\<open>val _s6070_ : string -> maybe ((mword ty5 * mword ty6 * string))\<close>\<close>

definition s6070  :: \<open> string \<Rightarrow>((5)Word.word*(6)Word.word*string)option \<close>  where 
     \<open> s6070 s60710 = (
   (let s60720 = s60710 in
   if ((string_startswith s60720 (''c.slli.hint.''))) then  
  (case  ((string_drop s60720 ((string_length (''c.slli.hint.''))))) of
        s60730 =>
  (case  ((reg_name_matches_prefix s60730 :: (( 5 Word.word * ii)) option)) of
        Some ((rsd, s60740)) =>
  (let s60750 = (string_drop s60730 s60740) in
  if ((string_startswith s60750 (''.''))) then
    (case  ((string_drop s60750 ((string_length (''.''))))) of
          s60760 =>
    (case  ((hex_bits_6_matches_prefix
               instance_Sail2_values_Bitvector_Machine_word_mword_dict 
             s60760 :: (( 6 Word.word * ii)) option)) of
          Some ((shamt, s60770)) =>
    (case  ((string_drop s60760 s60770)) of   s1 => Some (rsd, shamt, s1) )
      | _ => None
    )
    ) else None)
    | _ => None
  )
  )
   else None))\<close> 
  for  s60710  :: " string "


\<comment> \<open>\<open>val _s6064_ : string -> maybe ((mword ty5 * string))\<close>\<close>

definition s6064  :: \<open> string \<Rightarrow>((5)Word.word*string)option \<close>  where 
     \<open> s6064 s60650 = (
   (let s60660 = s60650 in
   if ((string_startswith s60660 (''c.add.hint.''))) then  
  (case  ((string_drop s60660 ((string_length (''c.add.hint.''))))) of
        s60670 =>
  (case  ((reg_name_matches_prefix s60670 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s60680)) =>
  (case  ((string_drop s60670 s60680)) of   s1 => Some (rs2, s1) )
    | _ => None
  )
  )
   else None))\<close> 
  for  s60650  :: " string "


\<comment> \<open>\<open>val _s6058_ : string -> maybe ((mword ty5 * string))\<close>\<close>

definition s6058  :: \<open> string \<Rightarrow>((5)Word.word*string)option \<close>  where 
     \<open> s6058 s60590 = (
   (let s60600 = s60590 in
   if ((string_startswith s60600 (''c.mv.hint.''))) then  
  (case  ((string_drop s60600 ((string_length (''c.mv.hint.''))))) of
        s60610 =>
  (case  ((reg_name_matches_prefix s60610 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s60620)) =>
  (case  ((string_drop s60610 s60620)) of   s1 => Some (rs2, s1) )
    | _ => None
  )
  )
   else None))\<close> 
  for  s60590  :: " string "


\<comment> \<open>\<open>val _s6052_ : string -> maybe ((mword ty6 * string))\<close>\<close>

definition s6052  :: \<open> string \<Rightarrow>((6)Word.word*string)option \<close>  where 
     \<open> s6052 s60530 = (
   (let s60540 = s60530 in
   if ((string_startswith s60540 (''c.lui.hint.''))) then  
  (case  ((string_drop s60540 ((string_length (''c.lui.hint.''))))) of
        s60550 =>
  (case  ((hex_bits_6_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s60550 :: (( 6 Word.word * ii)) option)) of
        Some ((imm, s60560)) =>
  (case  ((string_drop s60550 s60560)) of   s1 => Some (imm, s1) )
    | _ => None
  )
  )
   else None))\<close> 
  for  s60530  :: " string "


\<comment> \<open>\<open>val _s6046_ : string -> maybe ((mword ty6 * string))\<close>\<close>

definition s6046  :: \<open> string \<Rightarrow>((6)Word.word*string)option \<close>  where 
     \<open> s6046 s60470 = (
   (let s60480 = s60470 in
   if ((string_startswith s60480 (''c.li.hint.''))) then  
  (case  ((string_drop s60480 ((string_length (''c.li.hint.''))))) of
        s60490 =>
  (case  ((hex_bits_6_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s60490 :: (( 6 Word.word * ii)) option)) of
        Some ((imm, s60500)) =>
  (case  ((string_drop s60490 s60500)) of   s1 => Some (imm, s1) )
    | _ => None
  )
  )
   else None))\<close> 
  for  s60470  :: " string "


\<comment> \<open>\<open>val _s6040_ : string -> maybe ((mword ty5 * string))\<close>\<close>

definition s6040  :: \<open> string \<Rightarrow>((5)Word.word*string)option \<close>  where 
     \<open> s6040 s60410 = (
   (let s60420 = s60410 in
   if ((string_startswith s60420 (''c.addi.hint.''))) then  
  (case  ((string_drop s60420 ((string_length (''c.addi.hint.''))))) of
        s60430 =>
  (case  ((reg_name_matches_prefix s60430 :: (( 5 Word.word * ii)) option)) of
        Some ((rsd, s60440)) =>
  (case  ((string_drop s60430 s60440)) of   s1 => Some (rsd, s1) )
    | _ => None
  )
  )
   else None))\<close> 
  for  s60410  :: " string "


\<comment> \<open>\<open>val _s6034_ : string -> maybe ((mword ty6 * string))\<close>\<close>

definition s6034  :: \<open> string \<Rightarrow>((6)Word.word*string)option \<close>  where 
     \<open> s6034 s60350 = (
   (let s60360 = s60350 in
   if ((string_startswith s60360 (''c.nop.hint.''))) then  
  (case  ((string_drop s60360 ((string_length (''c.nop.hint.''))))) of
        s60370 =>
  (case  ((hex_bits_6_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s60370 :: (( 6 Word.word * ii)) option)) of
        Some ((imm, s60380)) =>
  (case  ((string_drop s60370 s60380)) of   s1 => Some (imm, s1) )
    | _ => None
  )
  )
   else None))\<close> 
  for  s60350  :: " string "


\<comment> \<open>\<open>val _s6030_ : string -> maybe string\<close>\<close>

definition s6030  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s6030 s60310 = (
   (let s60320 = s60310 in
   if ((string_startswith s60320 (''uret''))) then  
  (case  ((string_drop s60320 ((string_length (''uret''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s60310  :: " string "


\<comment> \<open>\<open>val _s6013_ : string -> maybe ((csrop * mword ty5 * mword ty12 * mword ty5 * string))\<close>\<close>

definition s6013  :: \<open> string \<Rightarrow>(csrop*(5)Word.word*(12)Word.word*(5)Word.word*string)option \<close>  where 
     \<open> s6013 s60150 = (
      (case  ((csr_mnemonic_matches_prefix s60150)) of
        Some ((op1, s60160)) => 
  (case  ((string_drop s60150 s60160)) of
        s60170 =>
  (case  ((spc_matches_prefix0 s60170)) of
        Some ((_, s60180)) =>
  (case  ((string_drop s60170 s60180)) of
        s60190 =>
  (case  ((reg_name_matches_prefix s60190 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s60200)) =>
  (case  ((string_drop s60190 s60200)) of
        s60210 =>
  (case  ((sep_matches_prefix s60210)) of
        Some ((_, s60220)) =>
  (case  ((string_drop s60210 s60220)) of
        s60230 =>
  (case  ((csr_name_map_matches_prefix s60230
          :: (( 12 Word.word * ii)) option)) of
        Some ((csr, s60240)) =>
  (case  ((string_drop s60230 s60240)) of
        s60250 =>
  (case  ((sep_matches_prefix s60250)) of
        Some ((_, s60260)) =>
  (case  ((string_drop s60250 s60260)) of
        s60270 =>
  (case  ((reg_name_matches_prefix s60270 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s60280)) =>
  (case  ((string_drop s60270 s60280)) of
        s1 => Some (op1, rd, csr, rs1, s1)
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s60150  :: " string "


\<comment> \<open>\<open>val _s5995_ : string -> maybe ((csrop * mword ty5 * mword ty12 * mword ty5 * string))\<close>\<close>

definition s5995  :: \<open> string \<Rightarrow>(csrop*(5)Word.word*(12)Word.word*(5)Word.word*string)option \<close>  where 
     \<open> s5995 s59970 = (
      (case  ((csr_mnemonic_matches_prefix s59970)) of
        Some ((op1, s59980)) =>
         (let s59990 = (string_drop s59970 s59980) in
         if ((string_startswith s59990 (''i''))) then  
  (case  ((string_drop s59990 ((string_length (''i''))))) of
        s60000 =>
  (case  ((spc_matches_prefix0 s60000)) of
        Some ((_, s60010)) =>
  (case  ((string_drop s60000 s60010)) of
        s60020 =>
  (case  ((reg_name_matches_prefix s60020 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s60030)) =>
  (case  ((string_drop s60020 s60030)) of
        s60040 =>
  (case  ((sep_matches_prefix s60040)) of
        Some ((_, s60050)) =>
  (case  ((string_drop s60040 s60050)) of
        s60060 =>
  (case  ((csr_name_map_matches_prefix s60060
          :: (( 12 Word.word * ii)) option)) of
        Some ((csr, s60070)) =>
  (case  ((string_drop s60060 s60070)) of
        s60080 =>
  (case  ((sep_matches_prefix s60080)) of
        Some ((_, s60090)) =>
  (case  ((string_drop s60080 s60090)) of
        s60100 =>
  (case  ((hex_bits_5_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s60100 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s60110)) =>
  (case  ((string_drop s60100 s60110)) of
        s1 => Some (op1, rd, csr, rs1, s1)
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
         else None)
      | _ => None
      ))\<close> 
  for  s59970  :: " string "


\<comment> \<open>\<open>val _s5976_ : string -> maybe ((bool * mword ty5 * mword ty5 * mword ty5 * string))\<close>\<close>

definition s5976  :: \<open> string \<Rightarrow>(bool*(5)Word.word*(5)Word.word*(5)Word.word*string)option \<close>  where 
     \<open> s5976 s59770 = (
   (let s59780 = s59770 in
   if ((string_startswith s59780 (''rem''))) then  
  (case  ((string_drop s59780 ((string_length (''rem''))))) of
        s59790 =>
  (case  ((maybe_not_u_matches_prefix s59790)) of
        Some ((s, s59800)) =>
  (let s59810 = (string_drop s59790 s59800) in
  if ((string_startswith s59810 (''w''))) then
    (case  ((string_drop s59810 ((string_length (''w''))))) of
          s59820 =>
    (case  ((spc_matches_prefix0 s59820)) of
          Some ((_, s59830)) =>
    (case  ((string_drop s59820 s59830)) of
          s59840 =>
    (case  ((reg_name_matches_prefix s59840 :: (( 5 Word.word * ii)) option)) of
          Some ((rd, s59850)) =>
    (case  ((string_drop s59840 s59850)) of
          s59860 =>
    (case  ((sep_matches_prefix s59860)) of
          Some ((_, s59870)) =>
    (case  ((string_drop s59860 s59870)) of
          s59880 =>
    (case  ((reg_name_matches_prefix s59880 :: (( 5 Word.word * ii)) option)) of
          Some ((rs1, s59890)) =>
    (case  ((string_drop s59880 s59890)) of
          s59900 =>
    (case  ((sep_matches_prefix s59900)) of
          Some ((_, s59910)) =>
    (case  ((string_drop s59900 s59910)) of
          s59920 =>
    (case  ((reg_name_matches_prefix s59920 :: (( 5 Word.word * ii)) option)) of
          Some ((rs2, s59930)) =>
    (case  ((string_drop s59920 s59930)) of
          s2 => Some (s, rd, rs1, rs2, s2)
    )
      | _ => None
    )
    )
      | _ => None
    )
    )
      | _ => None
    )
    )
      | _ => None
    )
    )
      | _ => None
    )
    )
      | _ => None
    )
    ) else None)
    | _ => None
  )
  )
   else None))\<close> 
  for  s59770  :: " string "


\<comment> \<open>\<open>val _s5957_ : string -> maybe ((bool * mword ty5 * mword ty5 * mword ty5 * string))\<close>\<close>

definition s5957  :: \<open> string \<Rightarrow>(bool*(5)Word.word*(5)Word.word*(5)Word.word*string)option \<close>  where 
     \<open> s5957 s59580 = (
   (let s59590 = s59580 in
   if ((string_startswith s59590 (''div''))) then  
  (case  ((string_drop s59590 ((string_length (''div''))))) of
        s59600 =>
  (case  ((maybe_not_u_matches_prefix s59600)) of
        Some ((s, s59610)) =>
  (let s59620 = (string_drop s59600 s59610) in
  if ((string_startswith s59620 (''w''))) then
    (case  ((string_drop s59620 ((string_length (''w''))))) of
          s59630 =>
    (case  ((spc_matches_prefix0 s59630)) of
          Some ((_, s59640)) =>
    (case  ((string_drop s59630 s59640)) of
          s59650 =>
    (case  ((reg_name_matches_prefix s59650 :: (( 5 Word.word * ii)) option)) of
          Some ((rd, s59660)) =>
    (case  ((string_drop s59650 s59660)) of
          s59670 =>
    (case  ((sep_matches_prefix s59670)) of
          Some ((_, s59680)) =>
    (case  ((string_drop s59670 s59680)) of
          s59690 =>
    (case  ((reg_name_matches_prefix s59690 :: (( 5 Word.word * ii)) option)) of
          Some ((rs1, s59700)) =>
    (case  ((string_drop s59690 s59700)) of
          s59710 =>
    (case  ((sep_matches_prefix s59710)) of
          Some ((_, s59720)) =>
    (case  ((string_drop s59710 s59720)) of
          s59730 =>
    (case  ((reg_name_matches_prefix s59730 :: (( 5 Word.word * ii)) option)) of
          Some ((rs2, s59740)) =>
    (case  ((string_drop s59730 s59740)) of
          s2 => Some (s, rd, rs1, rs2, s2)
    )
      | _ => None
    )
    )
      | _ => None
    )
    )
      | _ => None
    )
    )
      | _ => None
    )
    )
      | _ => None
    )
    )
      | _ => None
    )
    ) else None)
    | _ => None
  )
  )
   else None))\<close> 
  for  s59580  :: " string "


\<comment> \<open>\<open>val _s5941_ : string -> maybe ((mword ty5 * mword ty5 * mword ty5 * string))\<close>\<close>

definition s5941  :: \<open> string \<Rightarrow>((5)Word.word*(5)Word.word*(5)Word.word*string)option \<close>  where 
     \<open> s5941 s59420 = (
   (let s59430 = s59420 in
   if ((string_startswith s59430 (''mulw''))) then  
  (case  ((string_drop s59430 ((string_length (''mulw''))))) of
        s59440 =>
  (case  ((spc_matches_prefix0 s59440)) of
        Some ((_, s59450)) =>
  (case  ((string_drop s59440 s59450)) of
        s59460 =>
  (case  ((reg_name_matches_prefix s59460 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s59470)) =>
  (case  ((string_drop s59460 s59470)) of
        s59480 =>
  (case  ((sep_matches_prefix s59480)) of
        Some ((_, s59490)) =>
  (case  ((string_drop s59480 s59490)) of
        s59500 =>
  (case  ((reg_name_matches_prefix s59500 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s59510)) =>
  (case  ((string_drop s59500 s59510)) of
        s59520 =>
  (case  ((sep_matches_prefix s59520)) of
        Some ((_, s59530)) =>
  (case  ((string_drop s59520 s59530)) of
        s59540 =>
  (case  ((reg_name_matches_prefix s59540 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s59550)) =>
  (case  ((string_drop s59540 s59550)) of   s1 => Some (rd, rs1, rs2, s1) )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s59420  :: " string "


\<comment> \<open>\<open>val _s5923_ : string -> maybe ((bool * mword ty5 * mword ty5 * mword ty5 * string))\<close>\<close>

definition s5923  :: \<open> string \<Rightarrow>(bool*(5)Word.word*(5)Word.word*(5)Word.word*string)option \<close>  where 
     \<open> s5923 s59240 = (
   (let s59250 = s59240 in
   if ((string_startswith s59250 (''rem''))) then  
  (case  ((string_drop s59250 ((string_length (''rem''))))) of
        s59260 =>
  (case  ((maybe_not_u_matches_prefix s59260)) of
        Some ((s, s59270)) =>
  (case  ((string_drop s59260 s59270)) of
        s59280 =>
  (case  ((spc_matches_prefix0 s59280)) of
        Some ((_, s59290)) =>
  (case  ((string_drop s59280 s59290)) of
        s59300 =>
  (case  ((reg_name_matches_prefix s59300 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s59310)) =>
  (case  ((string_drop s59300 s59310)) of
        s59320 =>
  (case  ((sep_matches_prefix s59320)) of
        Some ((_, s59330)) =>
  (case  ((string_drop s59320 s59330)) of
        s59340 =>
  (case  ((reg_name_matches_prefix s59340 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s59350)) =>
  (case  ((string_drop s59340 s59350)) of
        s59360 =>
  (case  ((sep_matches_prefix s59360)) of
        Some ((_, s59370)) =>
  (case  ((string_drop s59360 s59370)) of
        s59380 =>
  (case  ((reg_name_matches_prefix s59380 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s59390)) =>
  (case  ((string_drop s59380 s59390)) of
        s2 => Some (s, rd, rs1, rs2, s2)
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s59240  :: " string "


\<comment> \<open>\<open>val _s5905_ : string -> maybe ((bool * mword ty5 * mword ty5 * mword ty5 * string))\<close>\<close>

definition s5905  :: \<open> string \<Rightarrow>(bool*(5)Word.word*(5)Word.word*(5)Word.word*string)option \<close>  where 
     \<open> s5905 s59060 = (
   (let s59070 = s59060 in
   if ((string_startswith s59070 (''div''))) then  
  (case  ((string_drop s59070 ((string_length (''div''))))) of
        s59080 =>
  (case  ((maybe_not_u_matches_prefix s59080)) of
        Some ((s, s59090)) =>
  (case  ((string_drop s59080 s59090)) of
        s59100 =>
  (case  ((spc_matches_prefix0 s59100)) of
        Some ((_, s59110)) =>
  (case  ((string_drop s59100 s59110)) of
        s59120 =>
  (case  ((reg_name_matches_prefix s59120 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s59130)) =>
  (case  ((string_drop s59120 s59130)) of
        s59140 =>
  (case  ((sep_matches_prefix s59140)) of
        Some ((_, s59150)) =>
  (case  ((string_drop s59140 s59150)) of
        s59160 =>
  (case  ((reg_name_matches_prefix s59160 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s59170)) =>
  (case  ((string_drop s59160 s59170)) of
        s59180 =>
  (case  ((sep_matches_prefix s59180)) of
        Some ((_, s59190)) =>
  (case  ((string_drop s59180 s59190)) of
        s59200 =>
  (case  ((reg_name_matches_prefix s59200 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s59210)) =>
  (case  ((string_drop s59200 s59210)) of
        s2 => Some (s, rd, rs1, rs2, s2)
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s59060  :: " string "


\<comment> \<open>\<open>val _s5888_ : string -> maybe ((bool * bool * bool * mword ty5 * mword ty5 * mword ty5 * string))\<close>\<close>

definition s5888  :: \<open> string \<Rightarrow>(bool*bool*bool*(5)Word.word*(5)Word.word*(5)Word.word*string)option \<close>  where 
     \<open> s5888 s58900 = (
      (case  ((mul_mnemonic_matches_prefix s58900)) of
        Some (((high, signed1, signed2), s58910)) => 
  (case  ((string_drop s58900 s58910)) of
        s58920 =>
  (case  ((spc_matches_prefix0 s58920)) of
        Some ((_, s58930)) =>
  (case  ((string_drop s58920 s58930)) of
        s58940 =>
  (case  ((reg_name_matches_prefix s58940 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s58950)) =>
  (case  ((string_drop s58940 s58950)) of
        s58960 =>
  (case  ((sep_matches_prefix s58960)) of
        Some ((_, s58970)) =>
  (case  ((string_drop s58960 s58970)) of
        s58980 =>
  (case  ((reg_name_matches_prefix s58980 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s58990)) =>
  (case  ((string_drop s58980 s58990)) of
        s59000 =>
  (case  ((sep_matches_prefix s59000)) of
        Some ((_, s59010)) =>
  (case  ((string_drop s59000 s59010)) of
        s59020 =>
  (case  ((reg_name_matches_prefix s59020 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s59030)) =>
  (case  ((string_drop s59020 s59030)) of
        s1 => Some (high, signed1, signed2, rd, rs1, rs2, s1)
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s58900  :: " string "


\<comment> \<open>\<open>val _s5876_ : string -> maybe ((mword ty5 * mword ty5 * string))\<close>\<close>

definition s5876  :: \<open> string \<Rightarrow>((5)Word.word*(5)Word.word*string)option \<close>  where 
     \<open> s5876 s58770 = (
   (let s58780 = s58770 in
   if ((string_startswith s58780 (''c.add''))) then  
  (case  ((string_drop s58780 ((string_length (''c.add''))))) of
        s58790 =>
  (case  ((spc_matches_prefix0 s58790)) of
        Some ((_, s58800)) =>
  (case  ((string_drop s58790 s58800)) of
        s58810 =>
  (case  ((reg_name_matches_prefix s58810 :: (( 5 Word.word * ii)) option)) of
        Some ((rsd, s58820)) =>
  (case  ((string_drop s58810 s58820)) of
        s58830 =>
  (case  ((sep_matches_prefix s58830)) of
        Some ((_, s58840)) =>
  (case  ((string_drop s58830 s58840)) of
        s58850 =>
  (case  ((reg_name_matches_prefix s58850 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s58860)) =>
  (case  ((string_drop s58850 s58860)) of   s1 => Some (rsd, rs2, s1) )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s58770  :: " string "


\<comment> \<open>\<open>val _s5872_ : string -> maybe string\<close>\<close>

definition s5872  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s5872 s58730 = (
   (let s58740 = s58730 in
   if ((string_startswith s58740 (''c.ebreak''))) then  
  (case  ((string_drop s58740 ((string_length (''c.ebreak''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s58730  :: " string "


\<comment> \<open>\<open>val _s5860_ : string -> maybe ((mword ty5 * mword ty5 * string))\<close>\<close>

definition s5860  :: \<open> string \<Rightarrow>((5)Word.word*(5)Word.word*string)option \<close>  where 
     \<open> s5860 s58610 = (
   (let s58620 = s58610 in
   if ((string_startswith s58620 (''c.mv''))) then  
  (case  ((string_drop s58620 ((string_length (''c.mv''))))) of
        s58630 =>
  (case  ((spc_matches_prefix0 s58630)) of
        Some ((_, s58640)) =>
  (case  ((string_drop s58630 s58640)) of
        s58650 =>
  (case  ((reg_name_matches_prefix s58650 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s58660)) =>
  (case  ((string_drop s58650 s58660)) of
        s58670 =>
  (case  ((sep_matches_prefix s58670)) of
        Some ((_, s58680)) =>
  (case  ((string_drop s58670 s58680)) of
        s58690 =>
  (case  ((reg_name_matches_prefix s58690 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s58700)) =>
  (case  ((string_drop s58690 s58700)) of   s1 => Some (rd, rs2, s1) )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s58610  :: " string "


\<comment> \<open>\<open>val _s5852_ : string -> maybe ((mword ty5 * string))\<close>\<close>

definition s5852  :: \<open> string \<Rightarrow>((5)Word.word*string)option \<close>  where 
     \<open> s5852 s58530 = (
   (let s58540 = s58530 in
   if ((string_startswith s58540 (''c.jalr''))) then  
  (case  ((string_drop s58540 ((string_length (''c.jalr''))))) of
        s58550 =>
  (case  ((spc_matches_prefix0 s58550)) of
        Some ((_, s58560)) =>
  (case  ((string_drop s58550 s58560)) of
        s58570 =>
  (case  ((reg_name_matches_prefix s58570 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s58580)) =>
  (case  ((string_drop s58570 s58580)) of   s1 => Some (rs1, s1) )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s58530  :: " string "


\<comment> \<open>\<open>val _s5844_ : string -> maybe ((mword ty5 * string))\<close>\<close>

definition s5844  :: \<open> string \<Rightarrow>((5)Word.word*string)option \<close>  where 
     \<open> s5844 s58450 = (
   (let s58460 = s58450 in
   if ((string_startswith s58460 (''c.jr''))) then  
  (case  ((string_drop s58460 ((string_length (''c.jr''))))) of
        s58470 =>
  (case  ((spc_matches_prefix0 s58470)) of
        Some ((_, s58480)) =>
  (case  ((string_drop s58470 s58480)) of
        s58490 =>
  (case  ((reg_name_matches_prefix s58490 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s58500)) =>
  (case  ((string_drop s58490 s58500)) of   s1 => Some (rs1, s1) )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s58450  :: " string "


\<comment> \<open>\<open>val _s5832_ : string -> maybe ((mword ty5 * mword ty6 * string))\<close>\<close>

definition s5832  :: \<open> string \<Rightarrow>((5)Word.word*(6)Word.word*string)option \<close>  where 
     \<open> s5832 s58330 = (
   (let s58340 = s58330 in
   if ((string_startswith s58340 (''c.sdsp''))) then  
  (case  ((string_drop s58340 ((string_length (''c.sdsp''))))) of
        s58350 =>
  (case  ((spc_matches_prefix0 s58350)) of
        Some ((_, s58360)) =>
  (case  ((string_drop s58350 s58360)) of
        s58370 =>
  (case  ((reg_name_matches_prefix s58370 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s58380)) =>
  (case  ((string_drop s58370 s58380)) of
        s58390 =>
  (case  ((sep_matches_prefix s58390)) of
        Some ((_, s58400)) =>
  (case  ((string_drop s58390 s58400)) of
        s58410 =>
  (case  ((hex_bits_6_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s58410 :: (( 6 Word.word * ii)) option)) of
        Some ((uimm, s58420)) =>
  (case  ((string_drop s58410 s58420)) of   s1 => Some (rs2, uimm, s1) )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s58330  :: " string "


\<comment> \<open>\<open>val _s5820_ : string -> maybe ((mword ty5 * mword ty6 * string))\<close>\<close>

definition s5820  :: \<open> string \<Rightarrow>((5)Word.word*(6)Word.word*string)option \<close>  where 
     \<open> s5820 s58210 = (
   (let s58220 = s58210 in
   if ((string_startswith s58220 (''c.swsp''))) then  
  (case  ((string_drop s58220 ((string_length (''c.swsp''))))) of
        s58230 =>
  (case  ((spc_matches_prefix0 s58230)) of
        Some ((_, s58240)) =>
  (case  ((string_drop s58230 s58240)) of
        s58250 =>
  (case  ((reg_name_matches_prefix s58250 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s58260)) =>
  (case  ((string_drop s58250 s58260)) of
        s58270 =>
  (case  ((sep_matches_prefix s58270)) of
        Some ((_, s58280)) =>
  (case  ((string_drop s58270 s58280)) of
        s58290 =>
  (case  ((hex_bits_6_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s58290 :: (( 6 Word.word * ii)) option)) of
        Some ((uimm, s58300)) =>
  (case  ((string_drop s58290 s58300)) of   s1 => Some (rd, uimm, s1) )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s58210  :: " string "


\<comment> \<open>\<open>val _s5808_ : string -> maybe ((mword ty5 * mword ty6 * string))\<close>\<close>

definition s5808  :: \<open> string \<Rightarrow>((5)Word.word*(6)Word.word*string)option \<close>  where 
     \<open> s5808 s58090 = (
   (let s58100 = s58090 in
   if ((string_startswith s58100 (''c.ldsp''))) then  
  (case  ((string_drop s58100 ((string_length (''c.ldsp''))))) of
        s58110 =>
  (case  ((spc_matches_prefix0 s58110)) of
        Some ((_, s58120)) =>
  (case  ((string_drop s58110 s58120)) of
        s58130 =>
  (case  ((reg_name_matches_prefix s58130 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s58140)) =>
  (case  ((string_drop s58130 s58140)) of
        s58150 =>
  (case  ((sep_matches_prefix s58150)) of
        Some ((_, s58160)) =>
  (case  ((string_drop s58150 s58160)) of
        s58170 =>
  (case  ((hex_bits_6_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s58170 :: (( 6 Word.word * ii)) option)) of
        Some ((uimm, s58180)) =>
  (case  ((string_drop s58170 s58180)) of   s1 => Some (rd, uimm, s1) )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s58090  :: " string "


\<comment> \<open>\<open>val _s5796_ : string -> maybe ((mword ty5 * mword ty6 * string))\<close>\<close>

definition s5796  :: \<open> string \<Rightarrow>((5)Word.word*(6)Word.word*string)option \<close>  where 
     \<open> s5796 s57970 = (
   (let s57980 = s57970 in
   if ((string_startswith s57980 (''c.lwsp''))) then  
  (case  ((string_drop s57980 ((string_length (''c.lwsp''))))) of
        s57990 =>
  (case  ((spc_matches_prefix0 s57990)) of
        Some ((_, s58000)) =>
  (case  ((string_drop s57990 s58000)) of
        s58010 =>
  (case  ((reg_name_matches_prefix s58010 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s58020)) =>
  (case  ((string_drop s58010 s58020)) of
        s58030 =>
  (case  ((sep_matches_prefix s58030)) of
        Some ((_, s58040)) =>
  (case  ((string_drop s58030 s58040)) of
        s58050 =>
  (case  ((hex_bits_6_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s58050 :: (( 6 Word.word * ii)) option)) of
        Some ((uimm, s58060)) =>
  (case  ((string_drop s58050 s58060)) of   s1 => Some (rd, uimm, s1) )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s57970  :: " string "


\<comment> \<open>\<open>val _s5784_ : string -> maybe ((mword ty5 * mword ty6 * string))\<close>\<close>

definition s5784  :: \<open> string \<Rightarrow>((5)Word.word*(6)Word.word*string)option \<close>  where 
     \<open> s5784 s57850 = (
   (let s57860 = s57850 in
   if ((string_startswith s57860 (''c.slli''))) then  
  (case  ((string_drop s57860 ((string_length (''c.slli''))))) of
        s57870 =>
  (case  ((spc_matches_prefix0 s57870)) of
        Some ((_, s57880)) =>
  (case  ((string_drop s57870 s57880)) of
        s57890 =>
  (case  ((reg_name_matches_prefix s57890 :: (( 5 Word.word * ii)) option)) of
        Some ((rsd, s57900)) =>
  (case  ((string_drop s57890 s57900)) of
        s57910 =>
  (case  ((sep_matches_prefix s57910)) of
        Some ((_, s57920)) =>
  (case  ((string_drop s57910 s57920)) of
        s57930 =>
  (case  ((hex_bits_6_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s57930 :: (( 6 Word.word * ii)) option)) of
        Some ((shamt, s57940)) =>
  (case  ((string_drop s57930 s57940)) of   s1 => Some (rsd, shamt, s1) )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s57850  :: " string "


\<comment> \<open>\<open>val _s5772_ : string -> maybe ((mword ty3 * mword ty8 * string))\<close>\<close>

definition s5772  :: \<open> string \<Rightarrow>((3)Word.word*(8)Word.word*string)option \<close>  where 
     \<open> s5772 s57730 = (
   (let s57740 = s57730 in
   if ((string_startswith s57740 (''c.bnez''))) then  
  (case  ((string_drop s57740 ((string_length (''c.bnez''))))) of
        s57750 =>
  (case  ((spc_matches_prefix0 s57750)) of
        Some ((_, s57760)) =>
  (case  ((string_drop s57750 s57760)) of
        s57770 =>
  (case  ((creg_name_matches_prefix s57770 :: (( 3 Word.word * ii)) option)) of
        Some ((rs, s57780)) =>
  (case  ((string_drop s57770 s57780)) of
        s57790 =>
  (case  ((sep_matches_prefix s57790)) of
        Some ((_, s57800)) =>
  (case  ((string_drop s57790 s57800)) of
        s57810 =>
  (case  ((hex_bits_8_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s57810 :: (( 8 Word.word * ii)) option)) of
        Some ((imm, s57820)) =>
  (case  ((string_drop s57810 s57820)) of   s1 => Some (rs, imm, s1) )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s57730  :: " string "


\<comment> \<open>\<open>val _s5760_ : string -> maybe ((mword ty3 * mword ty8 * string))\<close>\<close>

definition s5760  :: \<open> string \<Rightarrow>((3)Word.word*(8)Word.word*string)option \<close>  where 
     \<open> s5760 s57610 = (
   (let s57620 = s57610 in
   if ((string_startswith s57620 (''c.beqz''))) then  
  (case  ((string_drop s57620 ((string_length (''c.beqz''))))) of
        s57630 =>
  (case  ((spc_matches_prefix0 s57630)) of
        Some ((_, s57640)) =>
  (case  ((string_drop s57630 s57640)) of
        s57650 =>
  (case  ((creg_name_matches_prefix s57650 :: (( 3 Word.word * ii)) option)) of
        Some ((rs, s57660)) =>
  (case  ((string_drop s57650 s57660)) of
        s57670 =>
  (case  ((sep_matches_prefix s57670)) of
        Some ((_, s57680)) =>
  (case  ((string_drop s57670 s57680)) of
        s57690 =>
  (case  ((hex_bits_8_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s57690 :: (( 8 Word.word * ii)) option)) of
        Some ((imm, s57700)) =>
  (case  ((string_drop s57690 s57700)) of   s1 => Some (rs, imm, s1) )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s57610  :: " string "


\<comment> \<open>\<open>val _s5752_ : string -> maybe ((mword ty11 * string))\<close>\<close>

definition s5752  :: \<open> string \<Rightarrow>((11)Word.word*string)option \<close>  where 
     \<open> s5752 s57530 = (
   (let s57540 = s57530 in
   if ((string_startswith s57540 (''c.j''))) then  
  (case  ((string_drop s57540 ((string_length (''c.j''))))) of
        s57550 =>
  (case  ((spc_matches_prefix0 s57550)) of
        Some ((_, s57560)) =>
  (case  ((string_drop s57550 s57560)) of
        s57570 =>
  (case  ((hex_bits_11_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s57570 :: (( 11 Word.word * ii)) option)) of
        Some ((imm, s57580)) =>
  (case  ((string_drop s57570 s57580)) of   s1 => Some (imm, s1) )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s57530  :: " string "


\<comment> \<open>\<open>val _s5740_ : string -> maybe ((mword ty3 * mword ty3 * string))\<close>\<close>

definition s5740  :: \<open> string \<Rightarrow>((3)Word.word*(3)Word.word*string)option \<close>  where 
     \<open> s5740 s57410 = (
   (let s57420 = s57410 in
   if ((string_startswith s57420 (''c.addw''))) then  
  (case  ((string_drop s57420 ((string_length (''c.addw''))))) of
        s57430 =>
  (case  ((spc_matches_prefix0 s57430)) of
        Some ((_, s57440)) =>
  (case  ((string_drop s57430 s57440)) of
        s57450 =>
  (case  ((creg_name_matches_prefix s57450 :: (( 3 Word.word * ii)) option)) of
        Some ((rsd, s57460)) =>
  (case  ((string_drop s57450 s57460)) of
        s57470 =>
  (case  ((sep_matches_prefix s57470)) of
        Some ((_, s57480)) =>
  (case  ((string_drop s57470 s57480)) of
        s57490 =>
  (case  ((creg_name_matches_prefix s57490 :: (( 3 Word.word * ii)) option)) of
        Some ((rs2, s57500)) =>
  (case  ((string_drop s57490 s57500)) of   s1 => Some (rsd, rs2, s1) )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s57410  :: " string "


\<comment> \<open>\<open>val _s5728_ : string -> maybe ((mword ty3 * mword ty3 * string))\<close>\<close>

definition s5728  :: \<open> string \<Rightarrow>((3)Word.word*(3)Word.word*string)option \<close>  where 
     \<open> s5728 s57290 = (
   (let s57300 = s57290 in
   if ((string_startswith s57300 (''c.subw''))) then  
  (case  ((string_drop s57300 ((string_length (''c.subw''))))) of
        s57310 =>
  (case  ((spc_matches_prefix0 s57310)) of
        Some ((_, s57320)) =>
  (case  ((string_drop s57310 s57320)) of
        s57330 =>
  (case  ((creg_name_matches_prefix s57330 :: (( 3 Word.word * ii)) option)) of
        Some ((rsd, s57340)) =>
  (case  ((string_drop s57330 s57340)) of
        s57350 =>
  (case  ((sep_matches_prefix s57350)) of
        Some ((_, s57360)) =>
  (case  ((string_drop s57350 s57360)) of
        s57370 =>
  (case  ((creg_name_matches_prefix s57370 :: (( 3 Word.word * ii)) option)) of
        Some ((rs2, s57380)) =>
  (case  ((string_drop s57370 s57380)) of   s1 => Some (rsd, rs2, s1) )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s57290  :: " string "


\<comment> \<open>\<open>val _s5716_ : string -> maybe ((mword ty3 * mword ty3 * string))\<close>\<close>

definition s5716  :: \<open> string \<Rightarrow>((3)Word.word*(3)Word.word*string)option \<close>  where 
     \<open> s5716 s57170 = (
   (let s57180 = s57170 in
   if ((string_startswith s57180 (''c.and''))) then  
  (case  ((string_drop s57180 ((string_length (''c.and''))))) of
        s57190 =>
  (case  ((spc_matches_prefix0 s57190)) of
        Some ((_, s57200)) =>
  (case  ((string_drop s57190 s57200)) of
        s57210 =>
  (case  ((creg_name_matches_prefix s57210 :: (( 3 Word.word * ii)) option)) of
        Some ((rsd, s57220)) =>
  (case  ((string_drop s57210 s57220)) of
        s57230 =>
  (case  ((sep_matches_prefix s57230)) of
        Some ((_, s57240)) =>
  (case  ((string_drop s57230 s57240)) of
        s57250 =>
  (case  ((creg_name_matches_prefix s57250 :: (( 3 Word.word * ii)) option)) of
        Some ((rs2, s57260)) =>
  (case  ((string_drop s57250 s57260)) of   s1 => Some (rsd, rs2, s1) )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s57170  :: " string "


\<comment> \<open>\<open>val _s5704_ : string -> maybe ((mword ty3 * mword ty3 * string))\<close>\<close>

definition s5704  :: \<open> string \<Rightarrow>((3)Word.word*(3)Word.word*string)option \<close>  where 
     \<open> s5704 s57050 = (
   (let s57060 = s57050 in
   if ((string_startswith s57060 (''c.or''))) then  
  (case  ((string_drop s57060 ((string_length (''c.or''))))) of
        s57070 =>
  (case  ((spc_matches_prefix0 s57070)) of
        Some ((_, s57080)) =>
  (case  ((string_drop s57070 s57080)) of
        s57090 =>
  (case  ((creg_name_matches_prefix s57090 :: (( 3 Word.word * ii)) option)) of
        Some ((rsd, s57100)) =>
  (case  ((string_drop s57090 s57100)) of
        s57110 =>
  (case  ((sep_matches_prefix s57110)) of
        Some ((_, s57120)) =>
  (case  ((string_drop s57110 s57120)) of
        s57130 =>
  (case  ((creg_name_matches_prefix s57130 :: (( 3 Word.word * ii)) option)) of
        Some ((rs2, s57140)) =>
  (case  ((string_drop s57130 s57140)) of   s1 => Some (rsd, rs2, s1) )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s57050  :: " string "


\<comment> \<open>\<open>val _s5692_ : string -> maybe ((mword ty3 * mword ty3 * string))\<close>\<close>

definition s5692  :: \<open> string \<Rightarrow>((3)Word.word*(3)Word.word*string)option \<close>  where 
     \<open> s5692 s56930 = (
   (let s56940 = s56930 in
   if ((string_startswith s56940 (''c.xor''))) then  
  (case  ((string_drop s56940 ((string_length (''c.xor''))))) of
        s56950 =>
  (case  ((spc_matches_prefix0 s56950)) of
        Some ((_, s56960)) =>
  (case  ((string_drop s56950 s56960)) of
        s56970 =>
  (case  ((creg_name_matches_prefix s56970 :: (( 3 Word.word * ii)) option)) of
        Some ((rsd, s56980)) =>
  (case  ((string_drop s56970 s56980)) of
        s56990 =>
  (case  ((sep_matches_prefix s56990)) of
        Some ((_, s57000)) =>
  (case  ((string_drop s56990 s57000)) of
        s57010 =>
  (case  ((creg_name_matches_prefix s57010 :: (( 3 Word.word * ii)) option)) of
        Some ((rs2, s57020)) =>
  (case  ((string_drop s57010 s57020)) of   s1 => Some (rsd, rs2, s1) )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s56930  :: " string "


\<comment> \<open>\<open>val _s5680_ : string -> maybe ((mword ty3 * mword ty3 * string))\<close>\<close>

definition s5680  :: \<open> string \<Rightarrow>((3)Word.word*(3)Word.word*string)option \<close>  where 
     \<open> s5680 s56810 = (
   (let s56820 = s56810 in
   if ((string_startswith s56820 (''c.sub''))) then  
  (case  ((string_drop s56820 ((string_length (''c.sub''))))) of
        s56830 =>
  (case  ((spc_matches_prefix0 s56830)) of
        Some ((_, s56840)) =>
  (case  ((string_drop s56830 s56840)) of
        s56850 =>
  (case  ((creg_name_matches_prefix s56850 :: (( 3 Word.word * ii)) option)) of
        Some ((rsd, s56860)) =>
  (case  ((string_drop s56850 s56860)) of
        s56870 =>
  (case  ((sep_matches_prefix s56870)) of
        Some ((_, s56880)) =>
  (case  ((string_drop s56870 s56880)) of
        s56890 =>
  (case  ((creg_name_matches_prefix s56890 :: (( 3 Word.word * ii)) option)) of
        Some ((rs2, s56900)) =>
  (case  ((string_drop s56890 s56900)) of   s1 => Some (rsd, rs2, s1) )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s56810  :: " string "


\<comment> \<open>\<open>val _s5668_ : string -> maybe ((mword ty3 * mword ty6 * string))\<close>\<close>

definition s5668  :: \<open> string \<Rightarrow>((3)Word.word*(6)Word.word*string)option \<close>  where 
     \<open> s5668 s56690 = (
   (let s56700 = s56690 in
   if ((string_startswith s56700 (''c.andi''))) then  
  (case  ((string_drop s56700 ((string_length (''c.andi''))))) of
        s56710 =>
  (case  ((spc_matches_prefix0 s56710)) of
        Some ((_, s56720)) =>
  (case  ((string_drop s56710 s56720)) of
        s56730 =>
  (case  ((creg_name_matches_prefix s56730 :: (( 3 Word.word * ii)) option)) of
        Some ((rsd, s56740)) =>
  (case  ((string_drop s56730 s56740)) of
        s56750 =>
  (case  ((sep_matches_prefix s56750)) of
        Some ((_, s56760)) =>
  (case  ((string_drop s56750 s56760)) of
        s56770 =>
  (case  ((hex_bits_6_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s56770 :: (( 6 Word.word * ii)) option)) of
        Some ((imm, s56780)) =>
  (case  ((string_drop s56770 s56780)) of   s1 => Some (rsd, imm, s1) )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s56690  :: " string "


\<comment> \<open>\<open>val _s5656_ : string -> maybe ((mword ty3 * mword ty6 * string))\<close>\<close>

definition s5656  :: \<open> string \<Rightarrow>((3)Word.word*(6)Word.word*string)option \<close>  where 
     \<open> s5656 s56570 = (
   (let s56580 = s56570 in
   if ((string_startswith s56580 (''c.srai''))) then  
  (case  ((string_drop s56580 ((string_length (''c.srai''))))) of
        s56590 =>
  (case  ((spc_matches_prefix0 s56590)) of
        Some ((_, s56600)) =>
  (case  ((string_drop s56590 s56600)) of
        s56610 =>
  (case  ((creg_name_matches_prefix s56610 :: (( 3 Word.word * ii)) option)) of
        Some ((rsd, s56620)) =>
  (case  ((string_drop s56610 s56620)) of
        s56630 =>
  (case  ((sep_matches_prefix s56630)) of
        Some ((_, s56640)) =>
  (case  ((string_drop s56630 s56640)) of
        s56650 =>
  (case  ((hex_bits_6_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s56650 :: (( 6 Word.word * ii)) option)) of
        Some ((shamt, s56660)) =>
  (case  ((string_drop s56650 s56660)) of   s1 => Some (rsd, shamt, s1) )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s56570  :: " string "


\<comment> \<open>\<open>val _s5644_ : string -> maybe ((mword ty3 * mword ty6 * string))\<close>\<close>

definition s5644  :: \<open> string \<Rightarrow>((3)Word.word*(6)Word.word*string)option \<close>  where 
     \<open> s5644 s56450 = (
   (let s56460 = s56450 in
   if ((string_startswith s56460 (''c.srli''))) then  
  (case  ((string_drop s56460 ((string_length (''c.srli''))))) of
        s56470 =>
  (case  ((spc_matches_prefix0 s56470)) of
        Some ((_, s56480)) =>
  (case  ((string_drop s56470 s56480)) of
        s56490 =>
  (case  ((creg_name_matches_prefix s56490 :: (( 3 Word.word * ii)) option)) of
        Some ((rsd, s56500)) =>
  (case  ((string_drop s56490 s56500)) of
        s56510 =>
  (case  ((sep_matches_prefix s56510)) of
        Some ((_, s56520)) =>
  (case  ((string_drop s56510 s56520)) of
        s56530 =>
  (case  ((hex_bits_6_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s56530 :: (( 6 Word.word * ii)) option)) of
        Some ((shamt, s56540)) =>
  (case  ((string_drop s56530 s56540)) of   s1 => Some (rsd, shamt, s1) )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s56450  :: " string "


\<comment> \<open>\<open>val _s5632_ : string -> maybe ((mword ty5 * mword ty6 * string))\<close>\<close>

definition s5632  :: \<open> string \<Rightarrow>((5)Word.word*(6)Word.word*string)option \<close>  where 
     \<open> s5632 s56330 = (
   (let s56340 = s56330 in
   if ((string_startswith s56340 (''c.lui''))) then  
  (case  ((string_drop s56340 ((string_length (''c.lui''))))) of
        s56350 =>
  (case  ((spc_matches_prefix0 s56350)) of
        Some ((_, s56360)) =>
  (case  ((string_drop s56350 s56360)) of
        s56370 =>
  (case  ((reg_name_matches_prefix s56370 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s56380)) =>
  (case  ((string_drop s56370 s56380)) of
        s56390 =>
  (case  ((sep_matches_prefix s56390)) of
        Some ((_, s56400)) =>
  (case  ((string_drop s56390 s56400)) of
        s56410 =>
  (case  ((hex_bits_6_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s56410 :: (( 6 Word.word * ii)) option)) of
        Some ((imm, s56420)) =>
  (case  ((string_drop s56410 s56420)) of   s1 => Some (rd, imm, s1) )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s56330  :: " string "


\<comment> \<open>\<open>val _s5624_ : string -> maybe ((mword ty6 * string))\<close>\<close>

definition s5624  :: \<open> string \<Rightarrow>((6)Word.word*string)option \<close>  where 
     \<open> s5624 s56250 = (
   (let s56260 = s56250 in
   if ((string_startswith s56260 (''c.addi16sp''))) then  
  (case  ((string_drop s56260 ((string_length (''c.addi16sp''))))) of
        s56270 =>
  (case  ((spc_matches_prefix0 s56270)) of
        Some ((_, s56280)) =>
  (case  ((string_drop s56270 s56280)) of
        s56290 =>
  (case  ((hex_bits_6_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s56290 :: (( 6 Word.word * ii)) option)) of
        Some ((imm, s56300)) =>
  (case  ((string_drop s56290 s56300)) of   s1 => Some (imm, s1) )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s56250  :: " string "


\<comment> \<open>\<open>val _s5612_ : string -> maybe ((mword ty5 * mword ty6 * string))\<close>\<close>

definition s5612  :: \<open> string \<Rightarrow>((5)Word.word*(6)Word.word*string)option \<close>  where 
     \<open> s5612 s56130 = (
   (let s56140 = s56130 in
   if ((string_startswith s56140 (''c.li''))) then  
  (case  ((string_drop s56140 ((string_length (''c.li''))))) of
        s56150 =>
  (case  ((spc_matches_prefix0 s56150)) of
        Some ((_, s56160)) =>
  (case  ((string_drop s56150 s56160)) of
        s56170 =>
  (case  ((reg_name_matches_prefix s56170 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s56180)) =>
  (case  ((string_drop s56170 s56180)) of
        s56190 =>
  (case  ((sep_matches_prefix s56190)) of
        Some ((_, s56200)) =>
  (case  ((string_drop s56190 s56200)) of
        s56210 =>
  (case  ((hex_bits_6_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s56210 :: (( 6 Word.word * ii)) option)) of
        Some ((imm, s56220)) =>
  (case  ((string_drop s56210 s56220)) of   s1 => Some (rd, imm, s1) )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s56130  :: " string "


\<comment> \<open>\<open>val _s5600_ : string -> maybe ((mword ty5 * mword ty6 * string))\<close>\<close>

definition s5600  :: \<open> string \<Rightarrow>((5)Word.word*(6)Word.word*string)option \<close>  where 
     \<open> s5600 s56010 = (
   (let s56020 = s56010 in
   if ((string_startswith s56020 (''c.addiw''))) then  
  (case  ((string_drop s56020 ((string_length (''c.addiw''))))) of
        s56030 =>
  (case  ((spc_matches_prefix0 s56030)) of
        Some ((_, s56040)) =>
  (case  ((string_drop s56030 s56040)) of
        s56050 =>
  (case  ((reg_name_matches_prefix s56050 :: (( 5 Word.word * ii)) option)) of
        Some ((rsd, s56060)) =>
  (case  ((string_drop s56050 s56060)) of
        s56070 =>
  (case  ((sep_matches_prefix s56070)) of
        Some ((_, s56080)) =>
  (case  ((string_drop s56070 s56080)) of
        s56090 =>
  (case  ((hex_bits_6_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s56090 :: (( 6 Word.word * ii)) option)) of
        Some ((imm, s56100)) =>
  (case  ((string_drop s56090 s56100)) of   s1 => Some (rsd, imm, s1) )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s56010  :: " string "


\<comment> \<open>\<open>val _s5592_ : string -> maybe ((mword ty11 * string))\<close>\<close>

definition s5592  :: \<open> string \<Rightarrow>((11)Word.word*string)option \<close>  where 
     \<open> s5592 s55930 = (
   (let s55940 = s55930 in
   if ((string_startswith s55940 (''c.jal''))) then  
  (case  ((string_drop s55940 ((string_length (''c.jal''))))) of
        s55950 =>
  (case  ((spc_matches_prefix0 s55950)) of
        Some ((_, s55960)) =>
  (case  ((string_drop s55950 s55960)) of
        s55970 =>
  (case  ((hex_bits_12_matches_prefix0 s55970 :: (( 12 Word.word * ii)) option)) of
        Some ((v__1490, s55980)) =>
  if (((((subrange_vec_dec v__1490 (( 0 :: int):: ii) (( 0 :: int):: ii) :: 1 Word.word))
          = ( 0b0 :: 1 Word.word)))) then
    (let (imm :: 11 Word.word) = ((subrange_vec_dec v__1490
                                     (( 11 :: int):: ii) (( 1 :: int):: ii) :: 11 Word.word)) in
    (let (imm :: 11 Word.word) = ((subrange_vec_dec v__1490
                                     (( 11 :: int):: ii) (( 1 :: int):: ii) :: 11 Word.word)) in
    (case  ((string_drop s55970 s55980)) of   s1 => Some (imm, s1) ))) else
    None
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s55930  :: " string "


\<comment> \<open>\<open>val _s5580_ : string -> maybe ((mword ty5 * mword ty6 * string))\<close>\<close>

definition s5580  :: \<open> string \<Rightarrow>((5)Word.word*(6)Word.word*string)option \<close>  where 
     \<open> s5580 s55810 = (
   (let s55820 = s55810 in
   if ((string_startswith s55820 (''c.addi''))) then  
  (case  ((string_drop s55820 ((string_length (''c.addi''))))) of
        s55830 =>
  (case  ((spc_matches_prefix0 s55830)) of
        Some ((_, s55840)) =>
  (case  ((string_drop s55830 s55840)) of
        s55850 =>
  (case  ((reg_name_matches_prefix s55850 :: (( 5 Word.word * ii)) option)) of
        Some ((rsd, s55860)) =>
  (case  ((string_drop s55850 s55860)) of
        s55870 =>
  (case  ((sep_matches_prefix s55870)) of
        Some ((_, s55880)) =>
  (case  ((string_drop s55870 s55880)) of
        s55890 =>
  (case  ((hex_bits_6_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s55890 :: (( 6 Word.word * ii)) option)) of
        Some ((nzi, s55900)) =>
  (case  ((string_drop s55890 s55900)) of   s1 => Some (rsd, nzi, s1) )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s55810  :: " string "


\<comment> \<open>\<open>val _s5564_ : string -> maybe ((mword ty3 * mword ty3 * mword ty5 * string))\<close>\<close>

definition s5564  :: \<open> string \<Rightarrow>((3)Word.word*(3)Word.word*(5)Word.word*string)option \<close>  where 
     \<open> s5564 s55650 = (
   (let s55660 = s55650 in
   if ((string_startswith s55660 (''c.sd''))) then  
  (case  ((string_drop s55660 ((string_length (''c.sd''))))) of
        s55670 =>
  (case  ((spc_matches_prefix0 s55670)) of
        Some ((_, s55680)) =>
  (case  ((string_drop s55670 s55680)) of
        s55690 =>
  (case  ((creg_name_matches_prefix s55690 :: (( 3 Word.word * ii)) option)) of
        Some ((rsc1, s55700)) =>
  (case  ((string_drop s55690 s55700)) of
        s55710 =>
  (case  ((sep_matches_prefix s55710)) of
        Some ((_, s55720)) =>
  (case  ((string_drop s55710 s55720)) of
        s55730 =>
  (case  ((creg_name_matches_prefix s55730 :: (( 3 Word.word * ii)) option)) of
        Some ((rsc2, s55740)) =>
  (case  ((string_drop s55730 s55740)) of
        s55750 =>
  (case  ((sep_matches_prefix s55750)) of
        Some ((_, s55760)) =>
  (case  ((string_drop s55750 s55760)) of
        s55770 =>
  (case  ((hex_bits_8_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s55770 :: (( 8 Word.word * ii)) option)) of
        Some ((v__1492, s55780)) =>
  if (((((subrange_vec_dec v__1492 (( 2 :: int):: ii) (( 0 :: int):: ii)
         :: 3 Word.word)) = ( 0b000 :: 3 Word.word)))) then
    (let (uimm :: 5 Word.word) =
         ((subrange_vec_dec v__1492 (( 7 :: int):: ii) (( 3 :: int):: ii) :: 5 Word.word)) in
    (let (uimm :: 5 Word.word) =
         ((subrange_vec_dec v__1492 (( 7 :: int):: ii) (( 3 :: int):: ii) :: 5 Word.word)) in
    (case  ((string_drop s55770 s55780)) of
          s1 => Some (rsc1, rsc2, uimm, s1)
    ))) else None
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s55650  :: " string "


\<comment> \<open>\<open>val _s5548_ : string -> maybe ((mword ty3 * mword ty3 * mword ty5 * string))\<close>\<close>

definition s5548  :: \<open> string \<Rightarrow>((3)Word.word*(3)Word.word*(5)Word.word*string)option \<close>  where 
     \<open> s5548 s55490 = (
   (let s55500 = s55490 in
   if ((string_startswith s55500 (''c.sw''))) then  
  (case  ((string_drop s55500 ((string_length (''c.sw''))))) of
        s55510 =>
  (case  ((spc_matches_prefix0 s55510)) of
        Some ((_, s55520)) =>
  (case  ((string_drop s55510 s55520)) of
        s55530 =>
  (case  ((creg_name_matches_prefix s55530 :: (( 3 Word.word * ii)) option)) of
        Some ((rsc1, s55540)) =>
  (case  ((string_drop s55530 s55540)) of
        s55550 =>
  (case  ((sep_matches_prefix s55550)) of
        Some ((_, s55560)) =>
  (case  ((string_drop s55550 s55560)) of
        s55570 =>
  (case  ((creg_name_matches_prefix s55570 :: (( 3 Word.word * ii)) option)) of
        Some ((rsc2, s55580)) =>
  (case  ((string_drop s55570 s55580)) of
        s55590 =>
  (case  ((sep_matches_prefix s55590)) of
        Some ((_, s55600)) =>
  (case  ((string_drop s55590 s55600)) of
        s55610 =>
  (case  ((hex_bits_7_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s55610 :: (( 7 Word.word * ii)) option)) of
        Some ((v__1494, s55620)) =>
  if (((((subrange_vec_dec v__1494 (( 1 :: int):: ii) (( 0 :: int):: ii)
         :: 2 Word.word)) = ( 0b00 :: 2 Word.word)))) then
    (let (uimm :: 5 Word.word) =
         ((subrange_vec_dec v__1494 (( 6 :: int):: ii) (( 2 :: int):: ii) :: 5 Word.word)) in
    (let (uimm :: 5 Word.word) =
         ((subrange_vec_dec v__1494 (( 6 :: int):: ii) (( 2 :: int):: ii) :: 5 Word.word)) in
    (case  ((string_drop s55610 s55620)) of
          s1 => Some (rsc1, rsc2, uimm, s1)
    ))) else None
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s55490  :: " string "


\<comment> \<open>\<open>val _s5532_ : string -> maybe ((mword ty3 * mword ty3 * mword ty5 * string))\<close>\<close>

definition s5532  :: \<open> string \<Rightarrow>((3)Word.word*(3)Word.word*(5)Word.word*string)option \<close>  where 
     \<open> s5532 s55330 = (
   (let s55340 = s55330 in
   if ((string_startswith s55340 (''c.ld''))) then  
  (case  ((string_drop s55340 ((string_length (''c.ld''))))) of
        s55350 =>
  (case  ((spc_matches_prefix0 s55350)) of
        Some ((_, s55360)) =>
  (case  ((string_drop s55350 s55360)) of
        s55370 =>
  (case  ((creg_name_matches_prefix s55370 :: (( 3 Word.word * ii)) option)) of
        Some ((rdc, s55380)) =>
  (case  ((string_drop s55370 s55380)) of
        s55390 =>
  (case  ((sep_matches_prefix s55390)) of
        Some ((_, s55400)) =>
  (case  ((string_drop s55390 s55400)) of
        s55410 =>
  (case  ((creg_name_matches_prefix s55410 :: (( 3 Word.word * ii)) option)) of
        Some ((rsc, s55420)) =>
  (case  ((string_drop s55410 s55420)) of
        s55430 =>
  (case  ((sep_matches_prefix s55430)) of
        Some ((_, s55440)) =>
  (case  ((string_drop s55430 s55440)) of
        s55450 =>
  (case  ((hex_bits_8_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s55450 :: (( 8 Word.word * ii)) option)) of
        Some ((v__1496, s55460)) =>
  if (((((subrange_vec_dec v__1496 (( 2 :: int):: ii) (( 0 :: int):: ii)
         :: 3 Word.word)) = ( 0b000 :: 3 Word.word)))) then
    (let (uimm :: 5 Word.word) =
         ((subrange_vec_dec v__1496 (( 7 :: int):: ii) (( 3 :: int):: ii) :: 5 Word.word)) in
    (let (uimm :: 5 Word.word) =
         ((subrange_vec_dec v__1496 (( 7 :: int):: ii) (( 3 :: int):: ii) :: 5 Word.word)) in
    (case  ((string_drop s55450 s55460)) of
          s1 => Some (rdc, rsc, uimm, s1)
    ))) else None
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s55330  :: " string "


\<comment> \<open>\<open>val _s5516_ : string -> maybe ((mword ty3 * mword ty3 * mword ty5 * string))\<close>\<close>

definition s5516  :: \<open> string \<Rightarrow>((3)Word.word*(3)Word.word*(5)Word.word*string)option \<close>  where 
     \<open> s5516 s55170 = (
   (let s55180 = s55170 in
   if ((string_startswith s55180 (''c.lw''))) then  
  (case  ((string_drop s55180 ((string_length (''c.lw''))))) of
        s55190 =>
  (case  ((spc_matches_prefix0 s55190)) of
        Some ((_, s55200)) =>
  (case  ((string_drop s55190 s55200)) of
        s55210 =>
  (case  ((creg_name_matches_prefix s55210 :: (( 3 Word.word * ii)) option)) of
        Some ((rdc, s55220)) =>
  (case  ((string_drop s55210 s55220)) of
        s55230 =>
  (case  ((sep_matches_prefix s55230)) of
        Some ((_, s55240)) =>
  (case  ((string_drop s55230 s55240)) of
        s55250 =>
  (case  ((creg_name_matches_prefix s55250 :: (( 3 Word.word * ii)) option)) of
        Some ((rsc, s55260)) =>
  (case  ((string_drop s55250 s55260)) of
        s55270 =>
  (case  ((sep_matches_prefix s55270)) of
        Some ((_, s55280)) =>
  (case  ((string_drop s55270 s55280)) of
        s55290 =>
  (case  ((hex_bits_7_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s55290 :: (( 7 Word.word * ii)) option)) of
        Some ((v__1498, s55300)) =>
  if (((((subrange_vec_dec v__1498 (( 1 :: int):: ii) (( 0 :: int):: ii)
         :: 2 Word.word)) = ( 0b00 :: 2 Word.word)))) then
    (let (uimm :: 5 Word.word) =
         ((subrange_vec_dec v__1498 (( 6 :: int):: ii) (( 2 :: int):: ii) :: 5 Word.word)) in
    (let (uimm :: 5 Word.word) =
         ((subrange_vec_dec v__1498 (( 6 :: int):: ii) (( 2 :: int):: ii) :: 5 Word.word)) in
    (case  ((string_drop s55290 s55300)) of
          s1 => Some (rdc, rsc, uimm, s1)
    ))) else None
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s55170  :: " string "


\<comment> \<open>\<open>val _s5504_ : string -> maybe ((mword ty3 * mword ty8 * string))\<close>\<close>

definition s5504  :: \<open> string \<Rightarrow>((3)Word.word*(8)Word.word*string)option \<close>  where 
     \<open> s5504 s55050 = (
   (let s55060 = s55050 in
   if ((string_startswith s55060 (''c.addi4spn''))) then  
  (case  ((string_drop s55060 ((string_length (''c.addi4spn''))))) of
        s55070 =>
  (case  ((spc_matches_prefix0 s55070)) of
        Some ((_, s55080)) =>
  (case  ((string_drop s55070 s55080)) of
        s55090 =>
  (case  ((creg_name_matches_prefix s55090 :: (( 3 Word.word * ii)) option)) of
        Some ((rdc, s55100)) =>
  (case  ((string_drop s55090 s55100)) of
        s55110 =>
  (case  ((sep_matches_prefix s55110)) of
        Some ((_, s55120)) =>
  (case  ((string_drop s55110 s55120)) of
        s55130 =>
  (case  ((hex_bits_10_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s55130 :: (( 10 Word.word * ii)) option)) of
        Some ((v__1500, s55140)) =>
  if (((((subrange_vec_dec v__1500 (( 1 :: int):: ii) (( 0 :: int):: ii) :: 2 Word.word))
          = ( 0b00 :: 2 Word.word)))) then
    (let (nzimm :: 8 Word.word) =
         ((subrange_vec_dec v__1500 (( 9 :: int):: ii) (( 2 :: int):: ii) :: 8 Word.word)) in
    (let (nzimm :: 8 Word.word) =
         ((subrange_vec_dec v__1500 (( 9 :: int):: ii) (( 2 :: int):: ii) :: 8 Word.word)) in
    (case  ((string_drop s55130 s55140)) of   s1 => Some (rdc, nzimm, s1) )))
  else None
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s55050  :: " string "


\<comment> \<open>\<open>val _s5500_ : string -> maybe string\<close>\<close>

definition s5500  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s5500 s55010 = (
   (let s55020 = s55010 in
   if ((string_startswith s55020 (''c.nop''))) then  
  (case  ((string_drop s55020 ((string_length (''c.nop''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s55010  :: " string "


\<comment> \<open>\<open>val _s5474_ : string -> maybe ((amoop * word_width * bool * bool * mword ty5 * mword ty5 * mword ty5 * string))\<close>\<close>

definition s5474  :: \<open> string \<Rightarrow>(amoop*word_width*bool*bool*(5)Word.word*(5)Word.word*(5)Word.word*string)option \<close>  where 
     \<open> s5474 s54760 = (
      (case  ((amo_mnemonic_matches_prefix s54760)) of
        Some ((op1, s54770)) =>
         (let s54780 = (string_drop s54760 s54770) in
         if ((string_startswith s54780 (''.''))) then  
  (case  ((string_drop s54780 ((string_length (''.''))))) of
        s54790 =>
  (case  ((size_mnemonic_matches_prefix s54790)) of
        Some ((width, s54800)) =>
  (case  ((string_drop s54790 s54800)) of
        s54810 =>
  (case  ((maybe_aq_matches_prefix s54810)) of
        Some ((aq, s54820)) =>
  (case  ((string_drop s54810 s54820)) of
        s54830 =>
  (case  ((maybe_rl_matches_prefix s54830)) of
        Some ((rl, s54840)) =>
  (case  ((string_drop s54830 s54840)) of
        s54850 =>
  (case  ((spc_matches_prefix0 s54850)) of
        Some ((_, s54860)) =>
  (case  ((string_drop s54850 s54860)) of
        s54870 =>
  (case  ((reg_name_matches_prefix s54870 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s54880)) =>
  (case  ((string_drop s54870 s54880)) of
        s54890 =>
  (case  ((sep_matches_prefix s54890)) of
        Some ((_, s54900)) =>
  (case  ((string_drop s54890 s54900)) of
        s54910 =>
  (case  ((reg_name_matches_prefix s54910 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s54920)) =>
  (case  ((string_drop s54910 s54920)) of
        s54930 =>
  (case  ((sep_matches_prefix s54930)) of
        Some ((_, s54940)) =>
  (let s54950 = (string_drop s54930 s54940) in
  if ((string_startswith s54950 (''(''))) then
    (case  ((string_drop s54950 ((string_length (''(''))))) of
          s54960 =>
    (case  ((reg_name_matches_prefix s54960 :: (( 5 Word.word * ii)) option)) of
          Some ((rs1, s54970)) =>
    (let s54980 = (string_drop s54960 s54970) in
    if ((string_startswith s54980 ('')''))) then
      (case  ((string_drop s54980 ((string_length ('')''))))) of
            s1 =>
      Some (op1, width, aq, rl, rd, rs2, rs1, s1)
      ) else None)
      | _ => None
    )
    ) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
         else None)
      | _ => None
      ))\<close> 
  for  s54760  :: " string "


\<comment> \<open>\<open>val _s5452_ : string -> maybe ((word_width * bool * bool * mword ty5 * mword ty5 * mword ty5 * string))\<close>\<close>

definition s5452  :: \<open> string \<Rightarrow>(word_width*bool*bool*(5)Word.word*(5)Word.word*(5)Word.word*string)option \<close>  where 
     \<open> s5452 s54530 = (
   (let s54540 = s54530 in
   if ((string_startswith s54540 (''sc.''))) then  
  (case  ((string_drop s54540 ((string_length (''sc.''))))) of
        s54550 =>
  (case  ((size_mnemonic_matches_prefix s54550)) of
        Some ((size1, s54560)) =>
  (case  ((string_drop s54550 s54560)) of
        s54570 =>
  (case  ((maybe_aq_matches_prefix s54570)) of
        Some ((aq, s54580)) =>
  (case  ((string_drop s54570 s54580)) of
        s54590 =>
  (case  ((maybe_rl_matches_prefix s54590)) of
        Some ((rl, s54600)) =>
  (case  ((string_drop s54590 s54600)) of
        s54610 =>
  (case  ((spc_matches_prefix0 s54610)) of
        Some ((_, s54620)) =>
  (case  ((string_drop s54610 s54620)) of
        s54630 =>
  (case  ((reg_name_matches_prefix s54630 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s54640)) =>
  (case  ((string_drop s54630 s54640)) of
        s54650 =>
  (case  ((sep_matches_prefix s54650)) of
        Some ((_, s54660)) =>
  (case  ((string_drop s54650 s54660)) of
        s54670 =>
  (case  ((reg_name_matches_prefix s54670 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s54680)) =>
  (case  ((string_drop s54670 s54680)) of
        s54690 =>
  (case  ((sep_matches_prefix s54690)) of
        Some ((_, s54700)) =>
  (case  ((string_drop s54690 s54700)) of
        s54710 =>
  (case  ((reg_name_matches_prefix s54710 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s54720)) =>
  (case  ((string_drop s54710 s54720)) of
        s1 =>
  Some (size1, aq, rl, rd, rs1, rs2, s1)
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s54530  :: " string "


\<comment> \<open>\<open>val _s5434_ : string -> maybe ((word_width * bool * bool * mword ty5 * mword ty5 * string))\<close>\<close>

definition s5434  :: \<open> string \<Rightarrow>(word_width*bool*bool*(5)Word.word*(5)Word.word*string)option \<close>  where 
     \<open> s5434 s54350 = (
   (let s54360 = s54350 in
   if ((string_startswith s54360 (''lr.''))) then  
  (case  ((string_drop s54360 ((string_length (''lr.''))))) of
        s54370 =>
  (case  ((size_mnemonic_matches_prefix s54370)) of
        Some ((size1, s54380)) =>
  (case  ((string_drop s54370 s54380)) of
        s54390 =>
  (case  ((maybe_aq_matches_prefix s54390)) of
        Some ((aq, s54400)) =>
  (case  ((string_drop s54390 s54400)) of
        s54410 =>
  (case  ((maybe_rl_matches_prefix s54410)) of
        Some ((rl, s54420)) =>
  (case  ((string_drop s54410 s54420)) of
        s54430 =>
  (case  ((spc_matches_prefix0 s54430)) of
        Some ((_, s54440)) =>
  (case  ((string_drop s54430 s54440)) of
        s54450 =>
  (case  ((reg_name_matches_prefix s54450 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s54460)) =>
  (case  ((string_drop s54450 s54460)) of
        s54470 =>
  (case  ((sep_matches_prefix s54470)) of
        Some ((_, s54480)) =>
  (case  ((string_drop s54470 s54480)) of
        s54490 =>
  (case  ((reg_name_matches_prefix s54490 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s54500)) =>
  (case  ((string_drop s54490 s54500)) of
        s1 => Some (size1, aq, rl, rd, rs1, s1)
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s54350  :: " string "


\<comment> \<open>\<open>val _s5422_ : string -> maybe ((mword ty5 * mword ty5 * string))\<close>\<close>

definition s5422  :: \<open> string \<Rightarrow>((5)Word.word*(5)Word.word*string)option \<close>  where 
     \<open> s5422 s54230 = (
   (let s54240 = s54230 in
   if ((string_startswith s54240 (''sfence.vma''))) then  
  (case  ((string_drop s54240 ((string_length (''sfence.vma''))))) of
        s54250 =>
  (case  ((spc_matches_prefix0 s54250)) of
        Some ((_, s54260)) =>
  (case  ((string_drop s54250 s54260)) of
        s54270 =>
  (case  ((reg_name_matches_prefix s54270 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s54280)) =>
  (case  ((string_drop s54270 s54280)) of
        s54290 =>
  (case  ((sep_matches_prefix s54290)) of
        Some ((_, s54300)) =>
  (case  ((string_drop s54290 s54300)) of
        s54310 =>
  (case  ((reg_name_matches_prefix s54310 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s54320)) =>
  (case  ((string_drop s54310 s54320)) of   s1 => Some (rs1, rs2, s1) )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s54230  :: " string "


\<comment> \<open>\<open>val _s5418_ : string -> maybe string\<close>\<close>

definition s5418  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s5418 s54190 = (
   (let s54200 = s54190 in
   if ((string_startswith s54200 (''wfi''))) then  
  (case  ((string_drop s54200 ((string_length (''wfi''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s54190  :: " string "


\<comment> \<open>\<open>val _s5414_ : string -> maybe string\<close>\<close>

definition s5414  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s5414 s54150 = (
   (let s54160 = s54150 in
   if ((string_startswith s54160 (''ebreak''))) then  
  (case  ((string_drop s54160 ((string_length (''ebreak''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s54150  :: " string "


\<comment> \<open>\<open>val _s5410_ : string -> maybe string\<close>\<close>

definition s5410  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s5410 s54110 = (
   (let s54120 = s54110 in
   if ((string_startswith s54120 (''sret''))) then  
  (case  ((string_drop s54120 ((string_length (''sret''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s54110  :: " string "


\<comment> \<open>\<open>val _s5406_ : string -> maybe string\<close>\<close>

definition s5406  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s5406 s54070 = (
   (let s54080 = s54070 in
   if ((string_startswith s54080 (''mret''))) then  
  (case  ((string_drop s54080 ((string_length (''mret''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s54070  :: " string "


\<comment> \<open>\<open>val _s5402_ : string -> maybe string\<close>\<close>

definition s5402  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s5402 s54030 = (
   (let s54040 = s54030 in
   if ((string_startswith s54040 (''ecall''))) then  
  (case  ((string_drop s54040 ((string_length (''ecall''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s54030  :: " string "


\<comment> \<open>\<open>val _s5398_ : string -> maybe string\<close>\<close>

definition s5398  :: \<open> string \<Rightarrow>(string)option \<close>  where 
     \<open> s5398 s53990 = (
   (let s54000 = s53990 in
   if ((string_startswith s54000 (''fence.i''))) then  
  (case  ((string_drop s54000 ((string_length (''fence.i''))))) of
        s1 => Some s1
  )
   else None))\<close> 
  for  s53990  :: " string "


\<comment> \<open>\<open>val _s5386_ : string -> maybe ((mword ty4 * mword ty4 * string))\<close>\<close>

definition s5386  :: \<open> string \<Rightarrow>((4)Word.word*(4)Word.word*string)option \<close>  where 
     \<open> s5386 s53870 = (
   (let s53880 = s53870 in
   if ((string_startswith s53880 (''fence.tso''))) then  
  (case  ((string_drop s53880 ((string_length (''fence.tso''))))) of
        s53890 =>
  (case  ((spc_matches_prefix0 s53890)) of
        Some ((_, s53900)) =>
  (case  ((string_drop s53890 s53900)) of
        s53910 =>
  (case  ((fence_bits_matches_prefix s53910 :: (( 4 Word.word * ii)) option)) of
        Some ((pred, s53920)) =>
  (case  ((string_drop s53910 s53920)) of
        s53930 =>
  (case  ((sep_matches_prefix s53930)) of
        Some ((_, s53940)) =>
  (case  ((string_drop s53930 s53940)) of
        s53950 =>
  (case  ((fence_bits_matches_prefix s53950 :: (( 4 Word.word * ii)) option)) of
        Some ((succ, s53960)) =>
  (case  ((string_drop s53950 s53960)) of   s1 => Some (pred, succ, s1) )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s53870  :: " string "


\<comment> \<open>\<open>val _s5374_ : string -> maybe ((mword ty4 * mword ty4 * string))\<close>\<close>

definition s5374  :: \<open> string \<Rightarrow>((4)Word.word*(4)Word.word*string)option \<close>  where 
     \<open> s5374 s53750 = (
   (let s53760 = s53750 in
   if ((string_startswith s53760 (''fence''))) then  
  (case  ((string_drop s53760 ((string_length (''fence''))))) of
        s53770 =>
  (case  ((spc_matches_prefix0 s53770)) of
        Some ((_, s53780)) =>
  (case  ((string_drop s53770 s53780)) of
        s53790 =>
  (case  ((fence_bits_matches_prefix s53790 :: (( 4 Word.word * ii)) option)) of
        Some ((pred, s53800)) =>
  (case  ((string_drop s53790 s53800)) of
        s53810 =>
  (case  ((sep_matches_prefix s53810)) of
        Some ((_, s53820)) =>
  (case  ((string_drop s53810 s53820)) of
        s53830 =>
  (case  ((fence_bits_matches_prefix s53830 :: (( 4 Word.word * ii)) option)) of
        Some ((succ, s53840)) =>
  (case  ((string_drop s53830 s53840)) of   s1 => Some (pred, succ, s1) )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s53750  :: " string "


\<comment> \<open>\<open>val _s5357_ : string -> maybe ((sopw * mword ty5 * mword ty5 * mword ty5 * string))\<close>\<close>

definition s5357  :: \<open> string \<Rightarrow>(sopw*(5)Word.word*(5)Word.word*(5)Word.word*string)option \<close>  where 
     \<open> s5357 s53590 = (
      (case  ((shiftiwop_mnemonic_matches_prefix s53590)) of
        Some ((op1, s53600)) => 
  (case  ((string_drop s53590 s53600)) of
        s53610 =>
  (case  ((spc_matches_prefix0 s53610)) of
        Some ((_, s53620)) =>
  (case  ((string_drop s53610 s53620)) of
        s53630 =>
  (case  ((reg_name_matches_prefix s53630 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s53640)) =>
  (case  ((string_drop s53630 s53640)) of
        s53650 =>
  (case  ((sep_matches_prefix s53650)) of
        Some ((_, s53660)) =>
  (case  ((string_drop s53650 s53660)) of
        s53670 =>
  (case  ((reg_name_matches_prefix s53670 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s53680)) =>
  (case  ((string_drop s53670 s53680)) of
        s53690 =>
  (case  ((sep_matches_prefix s53690)) of
        Some ((_, s53700)) =>
  (case  ((string_drop s53690 s53700)) of
        s53710 =>
  (case  ((hex_bits_5_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s53710 :: (( 5 Word.word * ii)) option)) of
        Some ((shamt, s53720)) =>
  (case  ((string_drop s53710 s53720)) of
        s1 => Some (op1, rd, rs1, shamt, s1)
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s53590  :: " string "


\<comment> \<open>\<open>val _s5340_ : string -> maybe ((ropw * mword ty5 * mword ty5 * mword ty5 * string))\<close>\<close>

definition s5340  :: \<open> string \<Rightarrow>(ropw*(5)Word.word*(5)Word.word*(5)Word.word*string)option \<close>  where 
     \<open> s5340 s53420 = (
      (case  ((rtypew_mnemonic_matches_prefix s53420)) of
        Some ((op1, s53430)) => 
  (case  ((string_drop s53420 s53430)) of
        s53440 =>
  (case  ((spc_matches_prefix0 s53440)) of
        Some ((_, s53450)) =>
  (case  ((string_drop s53440 s53450)) of
        s53460 =>
  (case  ((reg_name_matches_prefix s53460 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s53470)) =>
  (case  ((string_drop s53460 s53470)) of
        s53480 =>
  (case  ((sep_matches_prefix s53480)) of
        Some ((_, s53490)) =>
  (case  ((string_drop s53480 s53490)) of
        s53500 =>
  (case  ((reg_name_matches_prefix s53500 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s53510)) =>
  (case  ((string_drop s53500 s53510)) of
        s53520 =>
  (case  ((sep_matches_prefix s53520)) of
        Some ((_, s53530)) =>
  (case  ((string_drop s53520 s53530)) of
        s53540 =>
  (case  ((reg_name_matches_prefix s53540 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s53550)) =>
  (case  ((string_drop s53540 s53550)) of
        s1 => Some (op1, rd, rs1, rs2, s1)
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s53420  :: " string "


\<comment> \<open>\<open>val _s5323_ : string -> maybe ((sop * mword ty5 * mword ty5 * mword ty5 * string))\<close>\<close>

definition s5323  :: \<open> string \<Rightarrow>(sop*(5)Word.word*(5)Word.word*(5)Word.word*string)option \<close>  where 
     \<open> s5323 s53250 = (
      (case  ((shiftw_mnemonic_matches_prefix s53250)) of
        Some ((op1, s53260)) => 
  (case  ((string_drop s53250 s53260)) of
        s53270 =>
  (case  ((spc_matches_prefix0 s53270)) of
        Some ((_, s53280)) =>
  (case  ((string_drop s53270 s53280)) of
        s53290 =>
  (case  ((reg_name_matches_prefix s53290 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s53300)) =>
  (case  ((string_drop s53290 s53300)) of
        s53310 =>
  (case  ((sep_matches_prefix s53310)) of
        Some ((_, s53320)) =>
  (case  ((string_drop s53310 s53320)) of
        s53330 =>
  (case  ((reg_name_matches_prefix s53330 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s53340)) =>
  (case  ((string_drop s53330 s53340)) of
        s53350 =>
  (case  ((sep_matches_prefix s53350)) of
        Some ((_, s53360)) =>
  (case  ((string_drop s53350 s53360)) of
        s53370 =>
  (case  ((hex_bits_5_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s53370 :: (( 5 Word.word * ii)) option)) of
        Some ((shamt, s53380)) =>
  (case  ((string_drop s53370 s53380)) of
        s1 => Some (op1, rd, rs1, shamt, s1)
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s53250  :: " string "


\<comment> \<open>\<open>val _s5307_ : string -> maybe ((mword ty5 * mword ty5 * mword ty12 * string))\<close>\<close>

definition s5307  :: \<open> string \<Rightarrow>((5)Word.word*(5)Word.word*(12)Word.word*string)option \<close>  where 
     \<open> s5307 s53080 = (
   (let s53090 = s53080 in
   if ((string_startswith s53090 (''addiw''))) then  
  (case  ((string_drop s53090 ((string_length (''addiw''))))) of
        s53100 =>
  (case  ((spc_matches_prefix0 s53100)) of
        Some ((_, s53110)) =>
  (case  ((string_drop s53100 s53110)) of
        s53120 =>
  (case  ((reg_name_matches_prefix s53120 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s53130)) =>
  (case  ((string_drop s53120 s53130)) of
        s53140 =>
  (case  ((sep_matches_prefix s53140)) of
        Some ((_, s53150)) =>
  (case  ((string_drop s53140 s53150)) of
        s53160 =>
  (case  ((reg_name_matches_prefix s53160 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s53170)) =>
  (case  ((string_drop s53160 s53170)) of
        s53180 =>
  (case  ((sep_matches_prefix s53180)) of
        Some ((_, s53190)) =>
  (case  ((string_drop s53180 s53190)) of
        s53200 =>
  (case  ((hex_bits_12_matches_prefix0 s53200
          :: (( 12 Word.word * ii)) option)) of
        Some ((imm, s53210)) =>
  (case  ((string_drop s53200 s53210)) of   s1 => Some (rd, rs1, imm, s1) )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s53080  :: " string "


\<comment> \<open>\<open>val _s5279_ : string -> maybe ((word_width * bool * bool * mword ty5 * mword ty12 * mword ty5 * string))\<close>\<close>

definition s5279  :: \<open> string \<Rightarrow>(word_width*bool*bool*(5)Word.word*(12)Word.word*(5)Word.word*string)option \<close>  where 
     \<open> s5279 s52800 = (
   (let s52810 = s52800 in
   if ((string_startswith s52810 (''s''))) then  
  (case  ((string_drop s52810 ((string_length (''s''))))) of
        s52820 =>
  (case  ((size_mnemonic_matches_prefix s52820)) of
        Some ((size1, s52830)) =>
  (case  ((string_drop s52820 s52830)) of
        s52840 =>
  (case  ((maybe_aq_matches_prefix s52840)) of
        Some ((aq, s52850)) =>
  (case  ((string_drop s52840 s52850)) of
        s52860 =>
  (case  ((maybe_rl_matches_prefix s52860)) of
        Some ((rl, s52870)) =>
  (case  ((string_drop s52860 s52870)) of
        s52880 =>
  (case  ((spc_matches_prefix0 s52880)) of
        Some ((_, s52890)) =>
  (case  ((string_drop s52880 s52890)) of
        s52900 =>
  (case  ((reg_name_matches_prefix s52900 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s52910)) =>
  (case  ((string_drop s52900 s52910)) of
        s52920 =>
  (case  ((sep_matches_prefix s52920)) of
        Some ((_, s52930)) =>
  (case  ((string_drop s52920 s52930)) of
        s52940 =>
  (case  ((hex_bits_12_matches_prefix0 s52940
          :: (( 12 Word.word * ii)) option)) of
        Some ((imm, s52950)) =>
  (case  ((string_drop s52940 s52950)) of
        s52960 =>
  (case  ((opt_spc_matches_prefix0 s52960)) of
        Some ((_, s52970)) =>
  (let s52980 = (string_drop s52960 s52970) in
  if ((string_startswith s52980 (''(''))) then
    (case  ((string_drop s52980 ((string_length (''(''))))) of
          s52990 =>
    (case  ((opt_spc_matches_prefix0 s52990)) of
          Some ((_, s53000)) =>
    (case  ((string_drop s52990 s53000)) of
          s53010 =>
    (case  ((reg_name_matches_prefix s53010 :: (( 5 Word.word * ii)) option)) of
          Some ((rs1, s53020)) =>
    (case  ((string_drop s53010 s53020)) of
          s53030 =>
    (case  ((opt_spc_matches_prefix0 s53030)) of
          Some ((_, s53040)) =>
    (let s53050 = (string_drop s53030 s53040) in
    if ((string_startswith s53050 ('')''))) then
      (case  ((string_drop s53050 ((string_length ('')''))))) of
            s1 =>
      Some (size1, aq, rl, rs2, imm, rs1, s1)
      ) else None)
      | _ => None
    )
    )
      | _ => None
    )
    )
      | _ => None
    )
    ) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s52800  :: " string "


\<comment> \<open>\<open>val _s5249_ : string -> maybe ((word_width * bool * bool * bool * mword ty5 * mword ty12 * mword ty5 * string))\<close>\<close>

definition s5249  :: \<open> string \<Rightarrow>(word_width*bool*bool*bool*(5)Word.word*(12)Word.word*(5)Word.word*string)option \<close>  where 
     \<open> s5249 s52500 = (
   (let s52510 = s52500 in
   if ((string_startswith s52510 (''l''))) then  
  (case  ((string_drop s52510 ((string_length (''l''))))) of
        s52520 =>
  (case  ((size_mnemonic_matches_prefix s52520)) of
        Some ((size1, s52530)) =>
  (case  ((string_drop s52520 s52530)) of
        s52540 =>
  (case  ((maybe_u_matches_prefix s52540)) of
        Some ((is_unsigned, s52550)) =>
  (case  ((string_drop s52540 s52550)) of
        s52560 =>
  (case  ((maybe_aq_matches_prefix s52560)) of
        Some ((aq, s52570)) =>
  (case  ((string_drop s52560 s52570)) of
        s52580 =>
  (case  ((maybe_rl_matches_prefix s52580)) of
        Some ((rl, s52590)) =>
  (case  ((string_drop s52580 s52590)) of
        s52600 =>
  (case  ((spc_matches_prefix0 s52600)) of
        Some ((_, s52610)) =>
  (case  ((string_drop s52600 s52610)) of
        s52620 =>
  (case  ((reg_name_matches_prefix s52620 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s52630)) =>
  (case  ((string_drop s52620 s52630)) of
        s52640 =>
  (case  ((sep_matches_prefix s52640)) of
        Some ((_, s52650)) =>
  (case  ((string_drop s52640 s52650)) of
        s52660 =>
  (case  ((hex_bits_12_matches_prefix0 s52660
          :: (( 12 Word.word * ii)) option)) of
        Some ((imm, s52670)) =>
  (case  ((string_drop s52660 s52670)) of
        s52680 =>
  (case  ((opt_spc_matches_prefix0 s52680)) of
        Some ((_, s52690)) =>
  (let s52700 = (string_drop s52680 s52690) in
  if ((string_startswith s52700 (''(''))) then
    (case  ((string_drop s52700 ((string_length (''(''))))) of
          s52710 =>
    (case  ((opt_spc_matches_prefix0 s52710)) of
          Some ((_, s52720)) =>
    (case  ((string_drop s52710 s52720)) of
          s52730 =>
    (case  ((reg_name_matches_prefix s52730 :: (( 5 Word.word * ii)) option)) of
          Some ((rs1, s52740)) =>
    (case  ((string_drop s52730 s52740)) of
          s52750 =>
    (case  ((opt_spc_matches_prefix0 s52750)) of
          Some ((_, s52760)) =>
    (let s52770 = (string_drop s52750 s52760) in
    if ((string_startswith s52770 ('')''))) then
      (case  ((string_drop s52770 ((string_length ('')''))))) of
            s1 =>
      Some (size1, is_unsigned, aq, rl, rd, imm, rs1, s1)
      ) else None)
      | _ => None
    )
    )
      | _ => None
    )
    )
      | _ => None
    )
    ) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s52500  :: " string "


\<comment> \<open>\<open>val _s5232_ : string -> maybe ((rop * mword ty5 * mword ty5 * mword ty5 * string))\<close>\<close>

definition s5232  :: \<open> string \<Rightarrow>(rop*(5)Word.word*(5)Word.word*(5)Word.word*string)option \<close>  where 
     \<open> s5232 s52340 = (
      (case  ((rtype_mnemonic_matches_prefix s52340)) of
        Some ((op1, s52350)) => 
  (case  ((string_drop s52340 s52350)) of
        s52360 =>
  (case  ((spc_matches_prefix0 s52360)) of
        Some ((_, s52370)) =>
  (case  ((string_drop s52360 s52370)) of
        s52380 =>
  (case  ((reg_name_matches_prefix s52380 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s52390)) =>
  (case  ((string_drop s52380 s52390)) of
        s52400 =>
  (case  ((sep_matches_prefix s52400)) of
        Some ((_, s52410)) =>
  (case  ((string_drop s52400 s52410)) of
        s52420 =>
  (case  ((reg_name_matches_prefix s52420 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s52430)) =>
  (case  ((string_drop s52420 s52430)) of
        s52440 =>
  (case  ((sep_matches_prefix s52440)) of
        Some ((_, s52450)) =>
  (case  ((string_drop s52440 s52450)) of
        s52460 =>
  (case  ((reg_name_matches_prefix s52460 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s52470)) =>
  (case  ((string_drop s52460 s52470)) of
        s1 => Some (op1, rd, rs1, rs2, s1)
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s52340  :: " string "


\<comment> \<open>\<open>val _s5215_ : string -> maybe ((sop * mword ty5 * mword ty5 * mword ty6 * string))\<close>\<close>

definition s5215  :: \<open> string \<Rightarrow>(sop*(5)Word.word*(5)Word.word*(6)Word.word*string)option \<close>  where 
     \<open> s5215 s52170 = (
      (case  ((shiftiop_mnemonic_matches_prefix s52170)) of
        Some ((op1, s52180)) => 
  (case  ((string_drop s52170 s52180)) of
        s52190 =>
  (case  ((spc_matches_prefix0 s52190)) of
        Some ((_, s52200)) =>
  (case  ((string_drop s52190 s52200)) of
        s52210 =>
  (case  ((reg_name_matches_prefix s52210 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s52220)) =>
  (case  ((string_drop s52210 s52220)) of
        s52230 =>
  (case  ((sep_matches_prefix s52230)) of
        Some ((_, s52240)) =>
  (case  ((string_drop s52230 s52240)) of
        s52250 =>
  (case  ((reg_name_matches_prefix s52250 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s52260)) =>
  (case  ((string_drop s52250 s52260)) of
        s52270 =>
  (case  ((sep_matches_prefix s52270)) of
        Some ((_, s52280)) =>
  (case  ((string_drop s52270 s52280)) of
        s52290 =>
  (case  ((hex_bits_6_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s52290 :: (( 6 Word.word * ii)) option)) of
        Some ((shamt, s52300)) =>
  (case  ((string_drop s52290 s52300)) of
        s1 => Some (op1, rd, rs1, shamt, s1)
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s52170  :: " string "


\<comment> \<open>\<open>val _s5198_ : string -> maybe ((iop * mword ty5 * mword ty5 * mword ty12 * string))\<close>\<close>

definition s5198  :: \<open> string \<Rightarrow>(iop*(5)Word.word*(5)Word.word*(12)Word.word*string)option \<close>  where 
     \<open> s5198 s52000 = (
      (case  ((itype_mnemonic_matches_prefix s52000)) of
        Some ((op1, s52010)) => 
  (case  ((string_drop s52000 s52010)) of
        s52020 =>
  (case  ((spc_matches_prefix0 s52020)) of
        Some ((_, s52030)) =>
  (case  ((string_drop s52020 s52030)) of
        s52040 =>
  (case  ((reg_name_matches_prefix s52040 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s52050)) =>
  (case  ((string_drop s52040 s52050)) of
        s52060 =>
  (case  ((sep_matches_prefix s52060)) of
        Some ((_, s52070)) =>
  (case  ((string_drop s52060 s52070)) of
        s52080 =>
  (case  ((reg_name_matches_prefix s52080 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s52090)) =>
  (case  ((string_drop s52080 s52090)) of
        s52100 =>
  (case  ((sep_matches_prefix s52100)) of
        Some ((_, s52110)) =>
  (case  ((string_drop s52100 s52110)) of
        s52120 =>
  (case  ((hex_bits_12_matches_prefix0 s52120
          :: (( 12 Word.word * ii)) option)) of
        Some ((imm, s52130)) =>
  (case  ((string_drop s52120 s52130)) of
        s1 => Some (op1, rd, rs1, imm, s1)
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s52000  :: " string "


\<comment> \<open>\<open>val _s5181_ : string -> maybe ((bop * mword ty5 * mword ty5 * mword ty13 * string))\<close>\<close>

definition s5181  :: \<open> string \<Rightarrow>(bop*(5)Word.word*(5)Word.word*(13)Word.word*string)option \<close>  where 
     \<open> s5181 s51830 = (
      (case  ((btype_mnemonic_matches_prefix s51830)) of
        Some ((op1, s51840)) => 
  (case  ((string_drop s51830 s51840)) of
        s51850 =>
  (case  ((spc_matches_prefix0 s51850)) of
        Some ((_, s51860)) =>
  (case  ((string_drop s51850 s51860)) of
        s51870 =>
  (case  ((reg_name_matches_prefix s51870 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s51880)) =>
  (case  ((string_drop s51870 s51880)) of
        s51890 =>
  (case  ((sep_matches_prefix s51890)) of
        Some ((_, s51900)) =>
  (case  ((string_drop s51890 s51900)) of
        s51910 =>
  (case  ((reg_name_matches_prefix s51910 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s51920)) =>
  (case  ((string_drop s51910 s51920)) of
        s51930 =>
  (case  ((sep_matches_prefix s51930)) of
        Some ((_, s51940)) =>
  (case  ((string_drop s51930 s51940)) of
        s51950 =>
  (case  ((hex_bits_13_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s51950 :: (( 13 Word.word * ii)) option)) of
        Some ((imm, s51960)) =>
  (case  ((string_drop s51950 s51960)) of
        s1 => Some (op1, rs1, rs2, imm, s1)
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s51830  :: " string "


\<comment> \<open>\<open>val _s5165_ : string -> maybe ((mword ty5 * mword ty5 * mword ty12 * string))\<close>\<close>

definition s5165  :: \<open> string \<Rightarrow>((5)Word.word*(5)Word.word*(12)Word.word*string)option \<close>  where 
     \<open> s5165 s51660 = (
   (let s51670 = s51660 in
   if ((string_startswith s51670 (''jalr''))) then  
  (case  ((string_drop s51670 ((string_length (''jalr''))))) of
        s51680 =>
  (case  ((spc_matches_prefix0 s51680)) of
        Some ((_, s51690)) =>
  (case  ((string_drop s51680 s51690)) of
        s51700 =>
  (case  ((reg_name_matches_prefix s51700 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s51710)) =>
  (case  ((string_drop s51700 s51710)) of
        s51720 =>
  (case  ((sep_matches_prefix s51720)) of
        Some ((_, s51730)) =>
  (case  ((string_drop s51720 s51730)) of
        s51740 =>
  (case  ((reg_name_matches_prefix s51740 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s51750)) =>
  (case  ((string_drop s51740 s51750)) of
        s51760 =>
  (case  ((sep_matches_prefix s51760)) of
        Some ((_, s51770)) =>
  (case  ((string_drop s51760 s51770)) of
        s51780 =>
  (case  ((hex_bits_12_matches_prefix0 s51780
          :: (( 12 Word.word * ii)) option)) of
        Some ((imm, s51790)) =>
  (case  ((string_drop s51780 s51790)) of   s1 => Some (rd, rs1, imm, s1) )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s51660  :: " string "


\<comment> \<open>\<open>val _s5153_ : string -> maybe ((mword ty5 * mword ty21 * string))\<close>\<close>

definition s5153  :: \<open> string \<Rightarrow>((5)Word.word*(21)Word.word*string)option \<close>  where 
     \<open> s5153 s51540 = (
   (let s51550 = s51540 in
   if ((string_startswith s51550 (''jal''))) then  
  (case  ((string_drop s51550 ((string_length (''jal''))))) of
        s51560 =>
  (case  ((spc_matches_prefix0 s51560)) of
        Some ((_, s51570)) =>
  (case  ((string_drop s51560 s51570)) of
        s51580 =>
  (case  ((reg_name_matches_prefix s51580 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s51590)) =>
  (case  ((string_drop s51580 s51590)) of
        s51600 =>
  (case  ((sep_matches_prefix s51600)) of
        Some ((_, s51610)) =>
  (case  ((string_drop s51600 s51610)) of
        s51620 =>
  (case  ((hex_bits_21_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s51620 :: (( 21 Word.word * ii)) option)) of
        Some ((imm, s51630)) =>
  (case  ((string_drop s51620 s51630)) of   s1 => Some (rd, imm, s1) )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))\<close> 
  for  s51540  :: " string "


\<comment> \<open>\<open>val _s5140_ : string -> maybe ((uop * mword ty5 * mword ty20 * string))\<close>\<close>

definition s5140  :: \<open> string \<Rightarrow>(uop*(5)Word.word*(20)Word.word*string)option \<close>  where 
     \<open> s5140 s51420 = (
      (case  ((utype_mnemonic_matches_prefix s51420)) of
        Some ((op1, s51430)) => 
  (case  ((string_drop s51420 s51430)) of
        s51440 =>
  (case  ((spc_matches_prefix0 s51440)) of
        Some ((_, s51450)) =>
  (case  ((string_drop s51440 s51450)) of
        s51460 =>
  (case  ((reg_name_matches_prefix s51460 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s51470)) =>
  (case  ((string_drop s51460 s51470)) of
        s51480 =>
  (case  ((sep_matches_prefix s51480)) of
        Some ((_, s51490)) =>
  (case  ((string_drop s51480 s51490)) of
        s51500 =>
  (case  ((hex_bits_20_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s51500 :: (( 20 Word.word * ii)) option)) of
        Some ((imm, s51510)) =>
  (case  ((string_drop s51500 s51510)) of   s1 => Some (op1, rd, imm, s1) )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))\<close> 
  for  s51420  :: " string "


definition assembly_matches_prefix  :: \<open> string \<Rightarrow>(ast*int)option \<close>  where 
     \<open> assembly_matches_prefix arg1 = (
   (let s51520 = arg1 in
   if ((case  ((s5140 s51520  ::  ((uop *  5 Word.word *  20 Word.word * string))option)) of
       Some ((op1, rd, imm, s1)) => True
     | _ => False
     )) then  (case 
 (s5140 s51520 :: (( uop * 5 Word.word * 20 Word.word * string)) option) of
     (Some ((op1, rd, imm, s1))) =>
 Some (UTYPE (imm, rd, op1), ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s5153 s51520  ::  (( 5 Word.word *  21 Word.word * string))option)) of
       Some ((rd, imm, s1)) => True
     | _ => False
     )) then  (case  (s5153 s51520 :: (( 5 Word.word * 21 Word.word * string)) option) of
     (Some ((rd, imm, s1))) =>
 Some (RISCV_JAL (imm, rd), ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s5165 s51520  ::  (( 5 Word.word *  5 Word.word *  12 Word.word * string))option)) of
       Some ((rd, rs1, imm, s1)) => True
     | _ => False
     )) then  (case 
 (s5165 s51520 :: (( 5 Word.word * 5 Word.word * 12 Word.word * string)) option) of
     (Some ((rd, rs1, imm, s1))) =>
 Some
   (RISCV_JALR (imm, rs1, rd), ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s5181 s51520  ::  ((bop *  5 Word.word *  5 Word.word *  13 Word.word * string))option)) of
       Some ((op1, rs1, rs2, imm, s1)) => True
     | _ => False
     )) then  (case 
 (s5181 s51520 :: (( bop * 5 Word.word * 5 Word.word * 13 Word.word * string)) option) of
     (Some ((op1, rs1, rs2, imm, s1))) =>
 Some
   (BTYPE (imm, rs2, rs1, op1), ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s5198 s51520  ::  ((iop *  5 Word.word *  5 Word.word *  12 Word.word * string))option)) of
       Some ((op1, rd, rs1, imm, s1)) => True
     | _ => False
     )) then  (case 
 (s5198 s51520 :: (( iop * 5 Word.word * 5 Word.word * 12 Word.word * string)) option) of
     (Some ((op1, rd, rs1, imm, s1))) =>
 Some
   (ITYPE (imm, rs1, rd, op1), ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s5215 s51520  ::  ((sop *  5 Word.word *  5 Word.word *  6 Word.word * string))option)) of
       Some ((op1, rd, rs1, shamt, s1)) => True
     | _ => False
     )) then  (case 
 (s5215 s51520 :: (( sop * 5 Word.word * 5 Word.word * 6 Word.word * string)) option) of
     (Some ((op1, rd, rs1, shamt, s1))) =>
 Some
   (SHIFTIOP (shamt, rs1, rd, op1), ((string_length arg1)) -
                                      ((string_length s1)))
 )
   else if ((case  ((s5232 s51520  ::  ((rop *  5 Word.word *  5 Word.word *  5 Word.word * string))option)) of
       Some ((op1, rd, rs1, rs2, s1)) => True
     | _ => False
     )) then  (case 
 (s5232 s51520 :: (( rop * 5 Word.word * 5 Word.word * 5 Word.word * string)) option) of
     (Some ((op1, rd, rs1, rs2, s1))) =>
 Some
   (RTYPE (rs2, rs1, rd, op1), ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s5249 s51520
                     ::  ((word_width * bool * bool * bool *  5 Word.word *  12 Word.word *  5 Word.word * string))option)) of
       Some ((size1, is_unsigned, aq, rl, rd, imm, rs1, s1)) => True
     | _ => False
     )) then  (case 
 (s5249 s51520
 :: (( word_width * bool * bool * bool * 5 Word.word * 12 Word.word * 5 Word.word * string)) option) of
     (Some ((size1, is_unsigned, aq, rl, rd, imm, rs1, s1))) =>
 Some
   (LOAD (imm, rs1, rd, is_unsigned, size1, aq, rl),
   ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s5279 s51520
                     ::  ((word_width * bool * bool *  5 Word.word *  12 Word.word *  5 Word.word * string))option)) of
       Some ((size1, aq, rl, rs2, imm, rs1, s1)) => True
     | _ => False
     )) then  (case 
 (s5279 s51520
 :: (( word_width * bool * bool * 5 Word.word * 12 Word.word * 5 Word.word * string)) option) of
     (Some ((size1, aq, rl, rs2, imm, rs1, s1))) =>
 Some
   (STORE (imm, rs2, rs1, size1, aq, rl),
   ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s5307 s51520  ::  (( 5 Word.word *  5 Word.word *  12 Word.word * string))option)) of
       Some ((rd, rs1, imm, s1)) => ((( 64 :: int)::ii) = (( 64 :: int)::ii))
     | _ => False
     )) then  (case 
 (s5307 s51520 :: (( 5 Word.word * 5 Word.word * 12 Word.word * string)) option) of
     (Some ((rd, rs1, imm, s1))) =>
 Some (ADDIW (imm, rs1, rd), ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s5323 s51520  ::  ((sop *  5 Word.word *  5 Word.word *  5 Word.word * string))option)) of
       Some ((op1, rd, rs1, shamt, s1)) => ((( 64 :: int)::ii) = (( 64 :: int)::ii))
     | _ => False
     )) then  (case 
 (s5323 s51520 :: (( sop * 5 Word.word * 5 Word.word * 5 Word.word * string)) option) of
     (Some ((op1, rd, rs1, shamt, s1))) =>
 Some
   (SHIFTW (shamt, rs1, rd, op1), ((string_length arg1)) -
                                    ((string_length s1)))
 )
   else if ((case  ((s5340 s51520  ::  ((ropw *  5 Word.word *  5 Word.word *  5 Word.word * string))option)) of
       Some ((op1, rd, rs1, rs2, s1)) => ((( 64 :: int)::ii) = (( 64 :: int)::ii))
     | _ => False
     )) then  (case 
 (s5340 s51520 :: (( ropw * 5 Word.word * 5 Word.word * 5 Word.word * string)) option) of
     (Some ((op1, rd, rs1, rs2, s1))) =>
 Some
   (RTYPEW (rs2, rs1, rd, op1), ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s5357 s51520  ::  ((sopw *  5 Word.word *  5 Word.word *  5 Word.word * string))option)) of
       Some ((op1, rd, rs1, shamt, s1)) => ((( 64 :: int)::ii) = (( 64 :: int)::ii))
     | _ => False
     )) then  (case 
 (s5357 s51520 :: (( sopw * 5 Word.word * 5 Word.word * 5 Word.word * string)) option) of
     (Some ((op1, rd, rs1, shamt, s1))) =>
 Some
   (SHIFTIWOP (shamt, rs1, rd, op1), ((string_length arg1)) -
                                       ((string_length s1)))
 )
   else if ((case  ((s5374 s51520  ::  (( 4 Word.word *  4 Word.word * string))option)) of
       Some ((pred, succ, s1)) => True
     | _ => False
     )) then  (case  (s5374 s51520 :: (( 4 Word.word * 4 Word.word * string)) option) of
     (Some ((pred, succ, s1))) =>
 Some (FENCE (pred, succ), ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s5386 s51520  ::  (( 4 Word.word *  4 Word.word * string))option)) of
       Some ((pred, succ, s1)) => True
     | _ => False
     )) then  (case  (s5386 s51520 :: (( 4 Word.word * 4 Word.word * string)) option) of
     (Some ((pred, succ, s1))) =>
 Some (FENCE_TSO (pred, succ), ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s5398 s51520)) of   Some (s1) => True | _ => False )) then  
  (case  s5398 s51520 of
      (Some (s1)) =>
  Some (FENCEI () , ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s5402 s51520)) of   Some (s1) => True | _ => False )) then  
  (case  s5402 s51520 of
      (Some (s1)) =>
  Some (ECALL () , ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s5406 s51520)) of   Some (s1) => True | _ => False )) then  
  (case  s5406 s51520 of
      (Some (s1)) =>
  Some (MRET () , ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s5410 s51520)) of   Some (s1) => True | _ => False )) then  
  (case  s5410 s51520 of
      (Some (s1)) =>
  Some (SRET () , ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s5414 s51520)) of   Some (s1) => True | _ => False )) then  
  (case  s5414 s51520 of
      (Some (s1)) =>
  Some (EBREAK () , ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s5418 s51520)) of   Some (s1) => True | _ => False )) then  
  (case  s5418 s51520 of
      (Some (s1)) =>
  Some (WFI () , ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s5422 s51520  ::  (( 5 Word.word *  5 Word.word * string))option)) of
       Some ((rs1, rs2, s1)) => True
     | _ => False
     )) then  (case  (s5422 s51520 :: (( 5 Word.word * 5 Word.word * string)) option) of
     (Some ((rs1, rs2, s1))) =>
 Some (SFENCE_VMA (rs1, rs2), ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s5434 s51520
                     ::  ((word_width * bool * bool *  5 Word.word *  5 Word.word * string))option)) of
       Some ((size1, aq, rl, rd, rs1, s1)) => True
     | _ => False
     )) then  (case 
 (s5434 s51520 :: (( word_width * bool * bool * 5 Word.word * 5 Word.word * string)) option) of
     (Some ((size1, aq, rl, rd, rs1, s1))) =>
 Some
   (LOADRES (aq, rl, rs1, size1, rd), ((string_length arg1)) -
                                        ((string_length s1)))
 )
   else if ((case  ((s5452 s51520
                     ::  ((word_width * bool * bool *  5 Word.word *  5 Word.word *  5 Word.word * string))option)) of
       Some ((size1, aq, rl, rd, rs1, rs2, s1)) => True
     | _ => False
     )) then  (case 
 (s5452 s51520
 :: (( word_width * bool * bool * 5 Word.word * 5 Word.word * 5 Word.word * string)) option) of
     (Some ((size1, aq, rl, rd, rs1, rs2, s1))) =>
 Some
   (STORECON (aq, rl, rs2, rs1, size1, rd),
   ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s5474 s51520
                     ::  ((amoop * word_width * bool * bool *  5 Word.word *  5 Word.word *  5 Word.word * string))option)) of
       Some ((op1, width, aq, rl, rd, rs2, rs1, s1)) => True
     | _ => False
     )) then  (case 
 (s5474 s51520
 :: (( amoop * word_width * bool * bool * 5 Word.word * 5 Word.word * 5 Word.word * string)) option) of
     (Some ((op1, width, aq, rl, rd, rs2, rs1, s1))) =>
 Some
   (AMO (op1, aq, rl, rs2, rs1, width, rd),
   ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s5500 s51520)) of   Some (s1) => True | _ => False )) then  
  (case  s5500 s51520 of
      (Some (s1)) =>
  Some (C_NOP () , ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s5504 s51520  ::  (( 3 Word.word *  8 Word.word * string))option)) of
       Some ((rdc, nzimm, s1)) => (nzimm \<noteq> ( 0x00 ::  8 Word.word))
     | _ => False
     )) then  (case  (s5504 s51520 :: (( 3 Word.word * 8 Word.word * string)) option) of
     (Some ((rdc, nzimm, s1))) =>
 Some
   (C_ADDI4SPN (rdc, nzimm), ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s5516 s51520  ::  (( 3 Word.word *  3 Word.word *  5 Word.word * string))option)) of
       Some ((rdc, rsc, uimm, s1)) => True
     | _ => False
     )) then  (case 
 (s5516 s51520 :: (( 3 Word.word * 3 Word.word * 5 Word.word * string)) option) of
     (Some ((rdc, rsc, uimm, s1))) =>
 Some (C_LW (uimm, rsc, rdc), ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s5532 s51520  ::  (( 3 Word.word *  3 Word.word *  5 Word.word * string))option)) of
       Some ((rdc, rsc, uimm, s1)) => ((( 64 :: int)::ii) = (( 64 :: int)::ii))
     | _ => False
     )) then  (case 
 (s5532 s51520 :: (( 3 Word.word * 3 Word.word * 5 Word.word * string)) option) of
     (Some ((rdc, rsc, uimm, s1))) =>
 Some (C_LD (uimm, rsc, rdc), ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s5548 s51520  ::  (( 3 Word.word *  3 Word.word *  5 Word.word * string))option)) of
       Some ((rsc1, rsc2, uimm, s1)) => True
     | _ => False
     )) then  (case 
 (s5548 s51520 :: (( 3 Word.word * 3 Word.word * 5 Word.word * string)) option) of
     (Some ((rsc1, rsc2, uimm, s1))) =>
 Some
   (C_SW (uimm, rsc1, rsc2), ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s5564 s51520  ::  (( 3 Word.word *  3 Word.word *  5 Word.word * string))option)) of
       Some ((rsc1, rsc2, uimm, s1)) => ((( 64 :: int)::ii) = (( 64 :: int)::ii))
     | _ => False
     )) then  (case 
 (s5564 s51520 :: (( 3 Word.word * 3 Word.word * 5 Word.word * string)) option) of
     (Some ((rsc1, rsc2, uimm, s1))) =>
 Some
   (C_SD (uimm, rsc1, rsc2), ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s5580 s51520  ::  (( 5 Word.word *  6 Word.word * string))option)) of
       Some ((rsd, nzi, s1)) => ((((nzi \<noteq> ( 0b000000 ::  6 Word.word)))) \<and> (((rsd \<noteq> zreg))))
     | _ => False
     )) then  (case  (s5580 s51520 :: (( 5 Word.word * 6 Word.word * string)) option) of
     (Some ((rsd, nzi, s1))) =>
 Some (C_ADDI (nzi, rsd), ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s5592 s51520  ::  (( 11 Word.word * string))option)) of
       Some ((imm, s1)) => ((( 64 :: int)::ii) = (( 32 :: int)::ii))
     | _ => False
     )) then  (case  (s5592 s51520 :: (( 11 Word.word * string)) option) of
     (Some ((imm, s1))) =>
 Some (C_JAL imm, ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s5600 s51520  ::  (( 5 Word.word *  6 Word.word * string))option)) of
       Some ((rsd, imm, s1)) => ((( 64 :: int)::ii) = (( 64 :: int)::ii))
     | _ => False
     )) then  (case  (s5600 s51520 :: (( 5 Word.word * 6 Word.word * string)) option) of
     (Some ((rsd, imm, s1))) =>
 Some (C_ADDIW (imm, rsd), ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s5612 s51520  ::  (( 5 Word.word *  6 Word.word * string))option)) of
       Some ((rd, imm, s1)) => (rd \<noteq> zreg)
     | _ => False
     )) then  (case  (s5612 s51520 :: (( 5 Word.word * 6 Word.word * string)) option) of
     (Some ((rd, imm, s1))) =>
 Some (C_LI (imm, rd), ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s5624 s51520  ::  (( 6 Word.word * string))option)) of
       Some ((imm, s1)) => (imm \<noteq> ( 0b000000 ::  6 Word.word))
     | _ => False
     )) then  (case  (s5624 s51520 :: (( 6 Word.word * string)) option) of
     (Some ((imm, s1))) =>
 Some (C_ADDI16SP imm, ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s5632 s51520  ::  (( 5 Word.word *  6 Word.word * string))option)) of
       Some ((rd, imm, s1)) =>
        ((((rd \<noteq> zreg))) \<and> ((((((rd \<noteq> sp))) \<and> (((imm \<noteq> ( 0b000000 ::  6 Word.word))))))))
     | _ => False
     )) then  (case  (s5632 s51520 :: (( 5 Word.word * 6 Word.word * string)) option) of
     (Some ((rd, imm, s1))) =>
 Some (C_LUI (imm, rd), ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s5644 s51520  ::  (( 3 Word.word *  6 Word.word * string))option)) of
       Some ((rsd, shamt, s1)) => (shamt \<noteq> ( 0b000000 ::  6 Word.word))
     | _ => False
     )) then  (case  (s5644 s51520 :: (( 3 Word.word * 6 Word.word * string)) option) of
     (Some ((rsd, shamt, s1))) =>
 Some (C_SRLI (shamt, rsd), ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s5656 s51520  ::  (( 3 Word.word *  6 Word.word * string))option)) of
       Some ((rsd, shamt, s1)) => (shamt \<noteq> ( 0b000000 ::  6 Word.word))
     | _ => False
     )) then  (case  (s5656 s51520 :: (( 3 Word.word * 6 Word.word * string)) option) of
     (Some ((rsd, shamt, s1))) =>
 Some (C_SRAI (shamt, rsd), ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s5668 s51520  ::  (( 3 Word.word *  6 Word.word * string))option)) of
       Some ((rsd, imm, s1)) => True
     | _ => False
     )) then  (case  (s5668 s51520 :: (( 3 Word.word * 6 Word.word * string)) option) of
     (Some ((rsd, imm, s1))) =>
 Some (C_ANDI (imm, rsd), ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s5680 s51520  ::  (( 3 Word.word *  3 Word.word * string))option)) of
       Some ((rsd, rs2, s1)) => True
     | _ => False
     )) then  (case  (s5680 s51520 :: (( 3 Word.word * 3 Word.word * string)) option) of
     (Some ((rsd, rs2, s1))) =>
 Some (C_SUB (rsd, rs2), ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s5692 s51520  ::  (( 3 Word.word *  3 Word.word * string))option)) of
       Some ((rsd, rs2, s1)) => True
     | _ => False
     )) then  (case  (s5692 s51520 :: (( 3 Word.word * 3 Word.word * string)) option) of
     (Some ((rsd, rs2, s1))) =>
 Some (C_XOR (rsd, rs2), ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s5704 s51520  ::  (( 3 Word.word *  3 Word.word * string))option)) of
       Some ((rsd, rs2, s1)) => True
     | _ => False
     )) then  (case  (s5704 s51520 :: (( 3 Word.word * 3 Word.word * string)) option) of
     (Some ((rsd, rs2, s1))) =>
 Some (C_OR (rsd, rs2), ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s5716 s51520  ::  (( 3 Word.word *  3 Word.word * string))option)) of
       Some ((rsd, rs2, s1)) => True
     | _ => False
     )) then  (case  (s5716 s51520 :: (( 3 Word.word * 3 Word.word * string)) option) of
     (Some ((rsd, rs2, s1))) =>
 Some (C_AND (rsd, rs2), ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s5728 s51520  ::  (( 3 Word.word *  3 Word.word * string))option)) of
       Some ((rsd, rs2, s1)) => ((( 64 :: int)::ii) = (( 64 :: int)::ii))
     | _ => False
     )) then  (case  (s5728 s51520 :: (( 3 Word.word * 3 Word.word * string)) option) of
     (Some ((rsd, rs2, s1))) =>
 Some (C_SUBW (rsd, rs2), ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s5740 s51520  ::  (( 3 Word.word *  3 Word.word * string))option)) of
       Some ((rsd, rs2, s1)) => ((( 64 :: int)::ii) = (( 64 :: int)::ii))
     | _ => False
     )) then  (case  (s5740 s51520 :: (( 3 Word.word * 3 Word.word * string)) option) of
     (Some ((rsd, rs2, s1))) =>
 Some (C_ADDW (rsd, rs2), ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s5752 s51520  ::  (( 11 Word.word * string))option)) of
       Some ((imm, s1)) => True
     | _ => False
     )) then  (case  (s5752 s51520 :: (( 11 Word.word * string)) option) of
     (Some ((imm, s1))) =>
 Some (C_J imm, ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s5760 s51520  ::  (( 3 Word.word *  8 Word.word * string))option)) of
       Some ((rs, imm, s1)) => True
     | _ => False
     )) then  (case  (s5760 s51520 :: (( 3 Word.word * 8 Word.word * string)) option) of
     (Some ((rs, imm, s1))) =>
 Some (C_BEQZ (imm, rs), ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s5772 s51520  ::  (( 3 Word.word *  8 Word.word * string))option)) of
       Some ((rs, imm, s1)) => True
     | _ => False
     )) then  (case  (s5772 s51520 :: (( 3 Word.word * 8 Word.word * string)) option) of
     (Some ((rs, imm, s1))) =>
 Some (C_BNEZ (imm, rs), ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s5784 s51520  ::  (( 5 Word.word *  6 Word.word * string))option)) of
       Some ((rsd, shamt, s1)) =>
        ((((shamt \<noteq> ( 0b000000 ::  6 Word.word)))) \<and> (((rsd \<noteq> zreg))))
     | _ => False
     )) then  (case  (s5784 s51520 :: (( 5 Word.word * 6 Word.word * string)) option) of
     (Some ((rsd, shamt, s1))) =>
 Some (C_SLLI (shamt, rsd), ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s5796 s51520  ::  (( 5 Word.word *  6 Word.word * string))option)) of
       Some ((rd, uimm, s1)) => (rd \<noteq> zreg)
     | _ => False
     )) then  (case  (s5796 s51520 :: (( 5 Word.word * 6 Word.word * string)) option) of
     (Some ((rd, uimm, s1))) =>
 Some (C_LWSP (uimm, rd), ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s5808 s51520  ::  (( 5 Word.word *  6 Word.word * string))option)) of
       Some ((rd, uimm, s1)) => ((((rd \<noteq> zreg))) \<and> ((((( 64 :: int)::ii) = (( 64 :: int)::ii)))))
     | _ => False
     )) then  (case  (s5808 s51520 :: (( 5 Word.word * 6 Word.word * string)) option) of
     (Some ((rd, uimm, s1))) =>
 Some (C_LDSP (uimm, rd), ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s5820 s51520  ::  (( 5 Word.word *  6 Word.word * string))option)) of
       Some ((rd, uimm, s1)) => True
     | _ => False
     )) then  (case  (s5820 s51520 :: (( 5 Word.word * 6 Word.word * string)) option) of
     (Some ((rd, uimm, s1))) =>
 Some (C_SWSP (uimm, rd), ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s5832 s51520  ::  (( 5 Word.word *  6 Word.word * string))option)) of
       Some ((rs2, uimm, s1)) => ((( 64 :: int)::ii) = (( 64 :: int)::ii))
     | _ => False
     )) then  (case  (s5832 s51520 :: (( 5 Word.word * 6 Word.word * string)) option) of
     (Some ((rs2, uimm, s1))) =>
 Some (C_SDSP (uimm, rs2), ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s5844 s51520  ::  (( 5 Word.word * string))option)) of
       Some ((rs1, s1)) => (rs1 \<noteq> zreg)
     | _ => False
     )) then  (case  (s5844 s51520 :: (( 5 Word.word * string)) option) of
     (Some ((rs1, s1))) =>
 Some (C_JR rs1, ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s5852 s51520  ::  (( 5 Word.word * string))option)) of
       Some ((rs1, s1)) => (rs1 \<noteq> zreg)
     | _ => False
     )) then  (case  (s5852 s51520 :: (( 5 Word.word * string)) option) of
     (Some ((rs1, s1))) =>
 Some (C_JALR rs1, ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s5860 s51520  ::  (( 5 Word.word *  5 Word.word * string))option)) of
       Some ((rd, rs2, s1)) => ((((rd \<noteq> zreg))) \<and> (((rs2 \<noteq> zreg))))
     | _ => False
     )) then  (case  (s5860 s51520 :: (( 5 Word.word * 5 Word.word * string)) option) of
     (Some ((rd, rs2, s1))) =>
 Some (C_MV (rd, rs2), ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s5872 s51520)) of   Some (s1) => True | _ => False )) then  
  (case  s5872 s51520 of
      (Some (s1)) =>
  Some (C_EBREAK () , ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s5876 s51520  ::  (( 5 Word.word *  5 Word.word * string))option)) of
       Some ((rsd, rs2, s1)) => ((((rsd \<noteq> zreg))) \<and> (((rs2 \<noteq> zreg))))
     | _ => False
     )) then  (case  (s5876 s51520 :: (( 5 Word.word * 5 Word.word * string)) option) of
     (Some ((rsd, rs2, s1))) =>
 Some (C_ADD (rsd, rs2), ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s5888 s51520
                     ::  ((bool * bool * bool *  5 Word.word *  5 Word.word *  5 Word.word * string))option)) of
       Some ((high, signed1, signed2, rd, rs1, rs2, s1)) => True
     | _ => False
     )) then  (case 
 (s5888 s51520 :: (( bool * bool * bool * 5 Word.word * 5 Word.word * 5 Word.word * string)) option) of
     (Some ((high, signed1, signed2, rd, rs1, rs2, s1))) =>
 Some
   (MUL (rs2, rs1, rd, high, signed1, signed2),
   ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s5905 s51520  ::  ((bool *  5 Word.word *  5 Word.word *  5 Word.word * string))option)) of
       Some ((s, rd, rs1, rs2, s2)) => True
     | _ => False
     )) then  (case 
 (s5905 s51520 :: (( bool * 5 Word.word * 5 Word.word * 5 Word.word * string)) option) of
     (Some ((s, rd, rs1, rs2, s2))) =>
 Some (DIV (rs2, rs1, rd, s), ((string_length arg1)) - ((string_length s2)))
 )
   else if ((case  ((s5923 s51520  ::  ((bool *  5 Word.word *  5 Word.word *  5 Word.word * string))option)) of
       Some ((s, rd, rs1, rs2, s2)) => True
     | _ => False
     )) then  (case 
 (s5923 s51520 :: (( bool * 5 Word.word * 5 Word.word * 5 Word.word * string)) option) of
     (Some ((s, rd, rs1, rs2, s2))) =>
 Some (REM (rs2, rs1, rd, s), ((string_length arg1)) - ((string_length s2)))
 )
   else if ((case  ((s5941 s51520  ::  (( 5 Word.word *  5 Word.word *  5 Word.word * string))option)) of
       Some ((rd, rs1, rs2, s1)) => ((( 64 :: int)::ii) = (( 64 :: int)::ii))
     | _ => False
     )) then  (case 
 (s5941 s51520 :: (( 5 Word.word * 5 Word.word * 5 Word.word * string)) option) of
     (Some ((rd, rs1, rs2, s1))) =>
 Some (MULW (rs2, rs1, rd), ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s5957 s51520  ::  ((bool *  5 Word.word *  5 Word.word *  5 Word.word * string))option)) of
       Some ((s, rd, rs1, rs2, s2)) => ((( 64 :: int)::ii) = (( 64 :: int)::ii))
     | _ => False
     )) then  (case 
 (s5957 s51520 :: (( bool * 5 Word.word * 5 Word.word * 5 Word.word * string)) option) of
     (Some ((s, rd, rs1, rs2, s2))) =>
 Some (DIVW (rs2, rs1, rd, s), ((string_length arg1)) - ((string_length s2)))
 )
   else if ((case  ((s5976 s51520  ::  ((bool *  5 Word.word *  5 Word.word *  5 Word.word * string))option)) of
       Some ((s, rd, rs1, rs2, s2)) => ((( 64 :: int)::ii) = (( 64 :: int)::ii))
     | _ => False
     )) then  (case 
 (s5976 s51520 :: (( bool * 5 Word.word * 5 Word.word * 5 Word.word * string)) option) of
     (Some ((s, rd, rs1, rs2, s2))) =>
 Some (REMW (rs2, rs1, rd, s), ((string_length arg1)) - ((string_length s2)))
 )
   else if ((case  ((s5995 s51520  ::  ((csrop *  5 Word.word *  12 Word.word *  5 Word.word * string))option)) of
       Some ((op1, rd, csr, rs1, s1)) => True
     | _ => False
     )) then  (case 
 (s5995 s51520 :: (( csrop * 5 Word.word * 12 Word.word * 5 Word.word * string)) option) of
     (Some ((op1, rd, csr, rs1, s1))) =>
 Some
   (CSR (csr, rs1, rd, True, op1), ((string_length arg1)) -
                                     ((string_length s1)))
 )
   else if ((case  ((s6013 s51520  ::  ((csrop *  5 Word.word *  12 Word.word *  5 Word.word * string))option)) of
       Some ((op1, rd, csr, rs1, s1)) => True
     | _ => False
     )) then  (case 
 (s6013 s51520 :: (( csrop * 5 Word.word * 12 Word.word * 5 Word.word * string)) option) of
     (Some ((op1, rd, csr, rs1, s1))) =>
 Some
   (CSR (csr, rs1, rd, False, op1), ((string_length arg1)) -
                                      ((string_length s1)))
 )
   else if ((case  ((s6030 s51520)) of   Some (s1) => True | _ => False )) then  
  (case  s6030 s51520 of
      (Some (s1)) =>
  Some (URET () , ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s6034 s51520  ::  (( 6 Word.word * string))option)) of
       Some ((imm, s1)) => True
     | _ => False
     )) then  (case  (s6034 s51520 :: (( 6 Word.word * string)) option) of
     (Some ((imm, s1))) =>
 Some (C_NOP_HINT imm, ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s6040 s51520  ::  (( 5 Word.word * string))option)) of
       Some ((rsd, s1)) => (rsd \<noteq> zreg)
     | _ => False
     )) then  (case  (s6040 s51520 :: (( 5 Word.word * string)) option) of
     (Some ((rsd, s1))) =>
 Some (C_ADDI_HINT rsd, ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s6046 s51520  ::  (( 6 Word.word * string))option)) of
       Some ((imm, s1)) => True
     | _ => False
     )) then  (case  (s6046 s51520 :: (( 6 Word.word * string)) option) of
     (Some ((imm, s1))) =>
 Some (C_LI_HINT imm, ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s6052 s51520  ::  (( 6 Word.word * string))option)) of
       Some ((imm, s1)) => (imm \<noteq> ( 0b000000 ::  6 Word.word))
     | _ => False
     )) then  (case  (s6052 s51520 :: (( 6 Word.word * string)) option) of
     (Some ((imm, s1))) =>
 Some (C_LUI_HINT imm, ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s6058 s51520  ::  (( 5 Word.word * string))option)) of
       Some ((rs2, s1)) => (rs2 \<noteq> zreg)
     | _ => False
     )) then  (case  (s6058 s51520 :: (( 5 Word.word * string)) option) of
     (Some ((rs2, s1))) =>
 Some (C_MV_HINT rs2, ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s6064 s51520  ::  (( 5 Word.word * string))option)) of
       Some ((rs2, s1)) => (rs2 \<noteq> zreg)
     | _ => False
     )) then  (case  (s6064 s51520 :: (( 5 Word.word * string)) option) of
     (Some ((rs2, s1))) =>
 Some (C_ADD_HINT rs2, ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s6070 s51520  ::  (( 5 Word.word *  6 Word.word * string))option)) of
       Some ((rsd, shamt, s1)) =>
        ((((shamt = ( 0b000000 ::  6 Word.word)))) \<or> (((rsd = zreg))))
     | _ => False
     )) then  (case  (s6070 s51520 :: (( 5 Word.word * 6 Word.word * string)) option) of
     (Some ((rsd, shamt, s1))) =>
 Some
   (C_SLLI_HINT (shamt, rsd), ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s6079 s51520  ::  (( 3 Word.word * string))option)) of
       Some ((rsd, s1)) => True
     | _ => False
     )) then  (case  (s6079 s51520 :: (( 3 Word.word * string)) option) of
     (Some ((rsd, s1))) =>
 Some (C_SRLI_HINT rsd, ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s6085 s51520  ::  (( 3 Word.word * string))option)) of
       Some ((rsd, s1)) => True
     | _ => False
     )) then  (case  (s6085 s51520 :: (( 3 Word.word * string)) option) of
     (Some ((rsd, s1))) =>
 Some (C_SRAI_HINT rsd, ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s6091 s51520
                     ::  (( 4 Word.word *  4 Word.word *  5 Word.word *  5 Word.word *  4 Word.word * string))option)) of
       Some ((pred, succ, rs, rd, fm, s1)) =>
        (((((((fm \<noteq> ( 0x0 ::  4 Word.word)))) \<and> (((fm \<noteq> ( 0x8 ::  4 Word.word))))))) \<or> ((((((rs \<noteq> ( 0b00000 ::  5 Word.word)))) \<or> (((rd \<noteq> ( 0b00000 ::  5 Word.word))))))))
     | _ => False
     )) then  (case 
 (s6091 s51520
 :: (( 4 Word.word * 4 Word.word * 5 Word.word * 5 Word.word * 4 Word.word * string)) option) of
     (Some ((pred, succ, rs, rd, fm, s1))) =>
 Some
   (FENCE_RESERVED (fm, pred, succ, rs, rd),
   ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s6109 s51520  ::  (( 5 Word.word *  5 Word.word *  12 Word.word * string))option)) of
       Some ((rd, rs, imm, s1)) =>
        ((((imm \<noteq> ( 0x000 ::  12 Word.word)))) \<or> ((((((rs \<noteq> zreg))) \<or> (((rd \<noteq> zreg)))))))
     | _ => False
     )) then  (case 
 (s6109 s51520 :: (( 5 Word.word * 5 Word.word * 12 Word.word * string)) option) of
     (Some ((rd, rs, imm, s1))) =>
 Some
   (FENCEI_RESERVED (imm, rs, rd), ((string_length arg1)) -
                                     ((string_length s1)))
 )
   else if ((case  ((s6121 s51520
                     ::  ((word_width *  5 Word.word *  12 Word.word *  5 Word.word * string))option)) of
       Some ((width, rd, imm, rs1, s1)) => True
     | _ => False
     )) then  (case 
 (s6121 s51520 :: (( word_width * 5 Word.word * 12 Word.word * 5 Word.word * string)) option) of
     (Some ((width, rd, imm, rs1, s1))) =>
 Some
   (LOAD_FP (imm, rs1, rd, width), ((string_length arg1)) -
                                     ((string_length s1)))
 )
   else if ((case  ((s6145 s51520
                     ::  ((word_width *  5 Word.word *  12 Word.word *  5 Word.word * string))option)) of
       Some ((width, rs2, imm, rs1, s1)) => True
     | _ => False
     )) then  (case 
 (s6145 s51520 :: (( word_width * 5 Word.word * 12 Word.word * 5 Word.word * string)) option) of
     (Some ((width, rs2, imm, rs1, s1))) =>
 Some
   (STORE_FP (imm, rs2, rs1, width), ((string_length arg1)) -
                                       ((string_length s1)))
 )
   else if ((case  ((s6169 s51520
                     ::  ((f_madd_op_S *  5 Word.word *  5 Word.word *  5 Word.word *  5 Word.word * rounding_mode * string))option)) of
       Some ((op1, rd, rs1, rs2, rs3, rm, s1)) => True
     | _ => False
     )) then  (case 
 (s6169 s51520
 :: (( f_madd_op_S * 5 Word.word * 5 Word.word * 5 Word.word * 5 Word.word * rounding_mode * string)) option) of
     (Some ((op1, rd, rs1, rs2, rs3, rm, s1))) =>
 Some
   (F_MADD_TYPE_S (rs3, rs2, rs1, rm, rd, op1),
   ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s6194 s51520
                     ::  ((f_bin_rm_op_S *  5 Word.word *  5 Word.word *  5 Word.word * rounding_mode * string))option)) of
       Some ((op1, rd, rs1, rs2, rm, s1)) => True
     | _ => False
     )) then  (case 
 (s6194 s51520
 :: (( f_bin_rm_op_S * 5 Word.word * 5 Word.word * 5 Word.word * rounding_mode * string)) option) of
     (Some ((op1, rd, rs1, rs2, rm, s1))) =>
 Some
   (F_BIN_RM_TYPE_S (rs2, rs1, rm, rd, op1),
   ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s6215 s51520
                     ::  ((f_un_rm_op_S *  5 Word.word *  5 Word.word * rounding_mode * string))option)) of
       Some ((FSQRT_S, rd, rs1, rm, s1)) => True
     | _ => False
     )) then  (case 
 (s6215 s51520 :: (( f_un_rm_op_S * 5 Word.word * 5 Word.word * rounding_mode * string)) option) of
     (Some ((FSQRT_S, rd, rs1, rm, s1))) =>
 Some
   (F_UN_RM_TYPE_S (rs1, rm, rd, FSQRT_S),
   ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s6232 s51520
                     ::  ((f_un_rm_op_S *  5 Word.word *  5 Word.word * rounding_mode * string))option)) of
       Some ((FCVT_W_S, rd, rs1, rm, s1)) => True
     | _ => False
     )) then  (case 
 (s6232 s51520 :: (( f_un_rm_op_S * 5 Word.word * 5 Word.word * rounding_mode * string)) option) of
     (Some ((FCVT_W_S, rd, rs1, rm, s1))) =>
 Some
   (F_UN_RM_TYPE_S (rs1, rm, rd, FCVT_W_S),
   ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s6249 s51520
                     ::  ((f_un_rm_op_S *  5 Word.word *  5 Word.word * rounding_mode * string))option)) of
       Some ((FCVT_WU_S, rd, rs1, rm, s1)) => True
     | _ => False
     )) then  (case 
 (s6249 s51520 :: (( f_un_rm_op_S * 5 Word.word * 5 Word.word * rounding_mode * string)) option) of
     (Some ((FCVT_WU_S, rd, rs1, rm, s1))) =>
 Some
   (F_UN_RM_TYPE_S (rs1, rm, rd, FCVT_WU_S),
   ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s6266 s51520
                     ::  ((f_un_rm_op_S *  5 Word.word *  5 Word.word * rounding_mode * string))option)) of
       Some ((FCVT_S_W, rd, rs1, rm, s1)) => True
     | _ => False
     )) then  (case 
 (s6266 s51520 :: (( f_un_rm_op_S * 5 Word.word * 5 Word.word * rounding_mode * string)) option) of
     (Some ((FCVT_S_W, rd, rs1, rm, s1))) =>
 Some
   (F_UN_RM_TYPE_S (rs1, rm, rd, FCVT_S_W),
   ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s6283 s51520
                     ::  ((f_un_rm_op_S *  5 Word.word *  5 Word.word * rounding_mode * string))option)) of
       Some ((FCVT_S_WU, rd, rs1, rm, s1)) => True
     | _ => False
     )) then  (case 
 (s6283 s51520 :: (( f_un_rm_op_S * 5 Word.word * 5 Word.word * rounding_mode * string)) option) of
     (Some ((FCVT_S_WU, rd, rs1, rm, s1))) =>
 Some
   (F_UN_RM_TYPE_S (rs1, rm, rd, FCVT_S_WU),
   ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s6300 s51520
                     ::  ((f_un_rm_op_S *  5 Word.word *  5 Word.word * rounding_mode * string))option)) of
       Some ((FCVT_L_S, rd, rs1, rm, s1)) => True
     | _ => False
     )) then  (case 
 (s6300 s51520 :: (( f_un_rm_op_S * 5 Word.word * 5 Word.word * rounding_mode * string)) option) of
     (Some ((FCVT_L_S, rd, rs1, rm, s1))) =>
 Some
   (F_UN_RM_TYPE_S (rs1, rm, rd, FCVT_L_S),
   ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s6317 s51520
                     ::  ((f_un_rm_op_S *  5 Word.word *  5 Word.word * rounding_mode * string))option)) of
       Some ((FCVT_LU_S, rd, rs1, rm, s1)) => True
     | _ => False
     )) then  (case 
 (s6317 s51520 :: (( f_un_rm_op_S * 5 Word.word * 5 Word.word * rounding_mode * string)) option) of
     (Some ((FCVT_LU_S, rd, rs1, rm, s1))) =>
 Some
   (F_UN_RM_TYPE_S (rs1, rm, rd, FCVT_LU_S),
   ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s6334 s51520
                     ::  ((f_un_rm_op_S *  5 Word.word *  5 Word.word * rounding_mode * string))option)) of
       Some ((FCVT_S_L, rd, rs1, rm, s1)) => True
     | _ => False
     )) then  (case 
 (s6334 s51520 :: (( f_un_rm_op_S * 5 Word.word * 5 Word.word * rounding_mode * string)) option) of
     (Some ((FCVT_S_L, rd, rs1, rm, s1))) =>
 Some
   (F_UN_RM_TYPE_S (rs1, rm, rd, FCVT_S_L),
   ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s6351 s51520
                     ::  ((f_un_rm_op_S *  5 Word.word *  5 Word.word * rounding_mode * string))option)) of
       Some ((FCVT_S_LU, rd, rs1, rm, s1)) => True
     | _ => False
     )) then  (case 
 (s6351 s51520 :: (( f_un_rm_op_S * 5 Word.word * 5 Word.word * rounding_mode * string)) option) of
     (Some ((FCVT_S_LU, rd, rs1, rm, s1))) =>
 Some
   (F_UN_RM_TYPE_S (rs1, rm, rd, FCVT_S_LU),
   ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s6368 s51520
                     ::  ((f_bin_op_S *  5 Word.word *  5 Word.word *  5 Word.word * string))option)) of
       Some ((FSGNJ_S, rd, rs1, rs2, s1)) => True
     | _ => False
     )) then  (case 
 (s6368 s51520 :: (( f_bin_op_S * 5 Word.word * 5 Word.word * 5 Word.word * string)) option) of
     (Some ((FSGNJ_S, rd, rs1, rs2, s1))) =>
 Some
   (F_BIN_TYPE_S (rs2, rs1, rd, FSGNJ_S),
   ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s6385 s51520
                     ::  ((f_bin_op_S *  5 Word.word *  5 Word.word *  5 Word.word * string))option)) of
       Some ((FSGNJN_S, rd, rs1, rs2, s1)) => True
     | _ => False
     )) then  (case 
 (s6385 s51520 :: (( f_bin_op_S * 5 Word.word * 5 Word.word * 5 Word.word * string)) option) of
     (Some ((FSGNJN_S, rd, rs1, rs2, s1))) =>
 Some
   (F_BIN_TYPE_S (rs2, rs1, rd, FSGNJN_S),
   ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s6402 s51520
                     ::  ((f_bin_op_S *  5 Word.word *  5 Word.word *  5 Word.word * string))option)) of
       Some ((FSGNJX_S, rd, rs1, rs2, s1)) => True
     | _ => False
     )) then  (case 
 (s6402 s51520 :: (( f_bin_op_S * 5 Word.word * 5 Word.word * 5 Word.word * string)) option) of
     (Some ((FSGNJX_S, rd, rs1, rs2, s1))) =>
 Some
   (F_BIN_TYPE_S (rs2, rs1, rd, FSGNJX_S),
   ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s6419 s51520
                     ::  ((f_bin_op_S *  5 Word.word *  5 Word.word *  5 Word.word * string))option)) of
       Some ((FMIN_S, rd, rs1, rs2, s1)) => True
     | _ => False
     )) then  (case 
 (s6419 s51520 :: (( f_bin_op_S * 5 Word.word * 5 Word.word * 5 Word.word * string)) option) of
     (Some ((FMIN_S, rd, rs1, rs2, s1))) =>
 Some
   (F_BIN_TYPE_S (rs2, rs1, rd, FMIN_S),
   ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s6436 s51520
                     ::  ((f_bin_op_S *  5 Word.word *  5 Word.word *  5 Word.word * string))option)) of
       Some ((FMAX_S, rd, rs1, rs2, s1)) => True
     | _ => False
     )) then  (case 
 (s6436 s51520 :: (( f_bin_op_S * 5 Word.word * 5 Word.word * 5 Word.word * string)) option) of
     (Some ((FMAX_S, rd, rs1, rs2, s1))) =>
 Some
   (F_BIN_TYPE_S (rs2, rs1, rd, FMAX_S),
   ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s6453 s51520
                     ::  ((f_bin_op_S *  5 Word.word *  5 Word.word *  5 Word.word * string))option)) of
       Some ((FEQ_S, rd, rs1, rs2, s1)) => True
     | _ => False
     )) then  (case 
 (s6453 s51520 :: (( f_bin_op_S * 5 Word.word * 5 Word.word * 5 Word.word * string)) option) of
     (Some ((FEQ_S, rd, rs1, rs2, s1))) =>
 Some
   (F_BIN_TYPE_S (rs2, rs1, rd, FEQ_S),
   ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s6470 s51520
                     ::  ((f_bin_op_S *  5 Word.word *  5 Word.word *  5 Word.word * string))option)) of
       Some ((FLT_S, rd, rs1, rs2, s1)) => True
     | _ => False
     )) then  (case 
 (s6470 s51520 :: (( f_bin_op_S * 5 Word.word * 5 Word.word * 5 Word.word * string)) option) of
     (Some ((FLT_S, rd, rs1, rs2, s1))) =>
 Some
   (F_BIN_TYPE_S (rs2, rs1, rd, FLT_S),
   ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s6487 s51520
                     ::  ((f_bin_op_S *  5 Word.word *  5 Word.word *  5 Word.word * string))option)) of
       Some ((FLE_S, rd, rs1, rs2, s1)) => True
     | _ => False
     )) then  (case 
 (s6487 s51520 :: (( f_bin_op_S * 5 Word.word * 5 Word.word * 5 Word.word * string)) option) of
     (Some ((FLE_S, rd, rs1, rs2, s1))) =>
 Some
   (F_BIN_TYPE_S (rs2, rs1, rd, FLE_S),
   ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s6504 s51520  ::  ((f_un_op_S *  5 Word.word *  5 Word.word * string))option)) of
       Some ((FMV_X_W, rd, rs1, s1)) => True
     | _ => False
     )) then  (case 
 (s6504 s51520 :: (( f_un_op_S * 5 Word.word * 5 Word.word * string)) option) of
     (Some ((FMV_X_W, rd, rs1, s1))) =>
 Some
   (F_UN_TYPE_S (rs1, rd, FMV_X_W), ((string_length arg1)) -
                                      ((string_length s1)))
 )
   else if ((case  ((s6517 s51520  ::  ((f_un_op_S *  5 Word.word *  5 Word.word * string))option)) of
       Some ((FMV_W_X, rd, rs1, s1)) => True
     | _ => False
     )) then  (case 
 (s6517 s51520 :: (( f_un_op_S * 5 Word.word * 5 Word.word * string)) option) of
     (Some ((FMV_W_X, rd, rs1, s1))) =>
 Some
   (F_UN_TYPE_S (rs1, rd, FMV_W_X), ((string_length arg1)) -
                                      ((string_length s1)))
 )
   else if ((case  ((s6530 s51520  ::  ((f_un_op_S *  5 Word.word *  5 Word.word * string))option)) of
       Some ((FCLASS_S, rd, rs1, s1)) => True
     | _ => False
     )) then  (case 
 (s6530 s51520 :: (( f_un_op_S * 5 Word.word * 5 Word.word * string)) option) of
     (Some ((FCLASS_S, rd, rs1, s1))) =>
 Some
   (F_UN_TYPE_S (rs1, rd, FCLASS_S), ((string_length arg1)) -
                                       ((string_length s1)))
 )
   else if ((case  ((s6543 s51520  ::  (( 5 Word.word *  6 Word.word * string))option)) of
       Some ((rd, imm, s1)) => ((( 64 :: int)::ii) = (( 32 :: int)::ii))
     | _ => False
     )) then  (case  (s6543 s51520 :: (( 5 Word.word * 6 Word.word * string)) option) of
     (Some ((rd, imm, s1))) =>
 Some (C_FLWSP (imm, rd), ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s6555 s51520  ::  (( 5 Word.word *  6 Word.word * string))option)) of
       Some ((rd, uimm, s1)) => ((( 64 :: int)::ii) = (( 32 :: int)::ii))
     | _ => False
     )) then  (case  (s6555 s51520 :: (( 5 Word.word * 6 Word.word * string)) option) of
     (Some ((rd, uimm, s1))) =>
 Some (C_FSWSP (uimm, rd), ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s6567 s51520  ::  (( 3 Word.word *  3 Word.word *  5 Word.word * string))option)) of
       Some ((rdc, rsc, uimm, s1)) => ((( 64 :: int)::ii) = (( 32 :: int)::ii))
     | _ => False
     )) then  (case 
 (s6567 s51520 :: (( 3 Word.word * 3 Word.word * 5 Word.word * string)) option) of
     (Some ((rdc, rsc, uimm, s1))) =>
 Some (C_FLW (uimm, rsc, rdc), ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s6583 s51520  ::  (( 3 Word.word *  3 Word.word *  5 Word.word * string))option)) of
       Some ((rsc1, rsc2, uimm, s1)) => ((( 64 :: int)::ii) = (( 32 :: int)::ii))
     | _ => False
     )) then  (case 
 (s6583 s51520 :: (( 3 Word.word * 3 Word.word * 5 Word.word * string)) option) of
     (Some ((rsc1, rsc2, uimm, s1))) =>
 Some
   (C_FSW (uimm, rsc1, rsc2), ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s6599 s51520
                     ::  ((f_madd_op_D *  5 Word.word *  5 Word.word *  5 Word.word *  5 Word.word * rounding_mode * string))option)) of
       Some ((op1, rd, rs1, rs2, rs3, rm, s1)) => True
     | _ => False
     )) then  (case 
 (s6599 s51520
 :: (( f_madd_op_D * 5 Word.word * 5 Word.word * 5 Word.word * 5 Word.word * rounding_mode * string)) option) of
     (Some ((op1, rd, rs1, rs2, rs3, rm, s1))) =>
 Some
   (F_MADD_TYPE_D (rs3, rs2, rs1, rm, rd, op1),
   ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s6624 s51520
                     ::  ((f_bin_rm_op_D *  5 Word.word *  5 Word.word *  5 Word.word * rounding_mode * string))option)) of
       Some ((op1, rd, rs1, rs2, rm, s1)) => True
     | _ => False
     )) then  (case 
 (s6624 s51520
 :: (( f_bin_rm_op_D * 5 Word.word * 5 Word.word * 5 Word.word * rounding_mode * string)) option) of
     (Some ((op1, rd, rs1, rs2, rm, s1))) =>
 Some
   (F_BIN_RM_TYPE_D (rs2, rs1, rm, rd, op1),
   ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s6645 s51520
                     ::  ((f_un_rm_op_D *  5 Word.word *  5 Word.word * rounding_mode * string))option)) of
       Some ((FSQRT_D, rd, rs1, rm, s1)) => True
     | _ => False
     )) then  (case 
 (s6645 s51520 :: (( f_un_rm_op_D * 5 Word.word * 5 Word.word * rounding_mode * string)) option) of
     (Some ((FSQRT_D, rd, rs1, rm, s1))) =>
 Some
   (F_UN_RM_TYPE_D (rs1, rm, rd, FSQRT_D),
   ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s6662 s51520
                     ::  ((f_un_rm_op_D *  5 Word.word *  5 Word.word * rounding_mode * string))option)) of
       Some ((FCVT_W_D, rd, rs1, rm, s1)) => True
     | _ => False
     )) then  (case 
 (s6662 s51520 :: (( f_un_rm_op_D * 5 Word.word * 5 Word.word * rounding_mode * string)) option) of
     (Some ((FCVT_W_D, rd, rs1, rm, s1))) =>
 Some
   (F_UN_RM_TYPE_D (rs1, rm, rd, FCVT_W_D),
   ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s6679 s51520
                     ::  ((f_un_rm_op_D *  5 Word.word *  5 Word.word * rounding_mode * string))option)) of
       Some ((FCVT_WU_D, rd, rs1, rm, s1)) => True
     | _ => False
     )) then  (case 
 (s6679 s51520 :: (( f_un_rm_op_D * 5 Word.word * 5 Word.word * rounding_mode * string)) option) of
     (Some ((FCVT_WU_D, rd, rs1, rm, s1))) =>
 Some
   (F_UN_RM_TYPE_D (rs1, rm, rd, FCVT_WU_D),
   ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s6696 s51520
                     ::  ((f_un_rm_op_D *  5 Word.word *  5 Word.word * rounding_mode * string))option)) of
       Some ((FCVT_D_W, rd, rs1, rm, s1)) => True
     | _ => False
     )) then  (case 
 (s6696 s51520 :: (( f_un_rm_op_D * 5 Word.word * 5 Word.word * rounding_mode * string)) option) of
     (Some ((FCVT_D_W, rd, rs1, rm, s1))) =>
 Some
   (F_UN_RM_TYPE_D (rs1, rm, rd, FCVT_D_W),
   ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s6713 s51520
                     ::  ((f_un_rm_op_D *  5 Word.word *  5 Word.word * rounding_mode * string))option)) of
       Some ((FCVT_D_WU, rd, rs1, rm, s1)) => True
     | _ => False
     )) then  (case 
 (s6713 s51520 :: (( f_un_rm_op_D * 5 Word.word * 5 Word.word * rounding_mode * string)) option) of
     (Some ((FCVT_D_WU, rd, rs1, rm, s1))) =>
 Some
   (F_UN_RM_TYPE_D (rs1, rm, rd, FCVT_D_WU),
   ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s6730 s51520
                     ::  ((f_un_rm_op_D *  5 Word.word *  5 Word.word * rounding_mode * string))option)) of
       Some ((FCVT_L_D, rd, rs1, rm, s1)) => True
     | _ => False
     )) then  (case 
 (s6730 s51520 :: (( f_un_rm_op_D * 5 Word.word * 5 Word.word * rounding_mode * string)) option) of
     (Some ((FCVT_L_D, rd, rs1, rm, s1))) =>
 Some
   (F_UN_RM_TYPE_D (rs1, rm, rd, FCVT_L_D),
   ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s6747 s51520
                     ::  ((f_un_rm_op_D *  5 Word.word *  5 Word.word * rounding_mode * string))option)) of
       Some ((FCVT_LU_D, rd, rs1, rm, s1)) => True
     | _ => False
     )) then  (case 
 (s6747 s51520 :: (( f_un_rm_op_D * 5 Word.word * 5 Word.word * rounding_mode * string)) option) of
     (Some ((FCVT_LU_D, rd, rs1, rm, s1))) =>
 Some
   (F_UN_RM_TYPE_D (rs1, rm, rd, FCVT_LU_D),
   ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s6764 s51520
                     ::  ((f_un_rm_op_D *  5 Word.word *  5 Word.word * rounding_mode * string))option)) of
       Some ((FCVT_D_L, rd, rs1, rm, s1)) => True
     | _ => False
     )) then  (case 
 (s6764 s51520 :: (( f_un_rm_op_D * 5 Word.word * 5 Word.word * rounding_mode * string)) option) of
     (Some ((FCVT_D_L, rd, rs1, rm, s1))) =>
 Some
   (F_UN_RM_TYPE_D (rs1, rm, rd, FCVT_D_L),
   ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s6781 s51520
                     ::  ((f_un_rm_op_D *  5 Word.word *  5 Word.word * rounding_mode * string))option)) of
       Some ((FCVT_D_LU, rd, rs1, rm, s1)) => True
     | _ => False
     )) then  (case 
 (s6781 s51520 :: (( f_un_rm_op_D * 5 Word.word * 5 Word.word * rounding_mode * string)) option) of
     (Some ((FCVT_D_LU, rd, rs1, rm, s1))) =>
 Some
   (F_UN_RM_TYPE_D (rs1, rm, rd, FCVT_D_LU),
   ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s6798 s51520
                     ::  ((f_un_rm_op_D *  5 Word.word *  5 Word.word * rounding_mode * string))option)) of
       Some ((FCVT_S_D, rd, rs1, rm, s1)) => True
     | _ => False
     )) then  (case 
 (s6798 s51520 :: (( f_un_rm_op_D * 5 Word.word * 5 Word.word * rounding_mode * string)) option) of
     (Some ((FCVT_S_D, rd, rs1, rm, s1))) =>
 Some
   (F_UN_RM_TYPE_D (rs1, rm, rd, FCVT_S_D),
   ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s6815 s51520
                     ::  ((f_un_rm_op_D *  5 Word.word *  5 Word.word * rounding_mode * string))option)) of
       Some ((FCVT_D_S, rd, rs1, rm, s1)) => True
     | _ => False
     )) then  (case 
 (s6815 s51520 :: (( f_un_rm_op_D * 5 Word.word * 5 Word.word * rounding_mode * string)) option) of
     (Some ((FCVT_D_S, rd, rs1, rm, s1))) =>
 Some
   (F_UN_RM_TYPE_D (rs1, rm, rd, FCVT_D_S),
   ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s6832 s51520
                     ::  ((f_bin_op_D *  5 Word.word *  5 Word.word *  5 Word.word * string))option)) of
       Some ((FSGNJ_D, rd, rs1, rs2, s1)) => True
     | _ => False
     )) then  (case 
 (s6832 s51520 :: (( f_bin_op_D * 5 Word.word * 5 Word.word * 5 Word.word * string)) option) of
     (Some ((FSGNJ_D, rd, rs1, rs2, s1))) =>
 Some
   (F_BIN_TYPE_D (rs2, rs1, rd, FSGNJ_D),
   ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s6849 s51520
                     ::  ((f_bin_op_D *  5 Word.word *  5 Word.word *  5 Word.word * string))option)) of
       Some ((FSGNJN_D, rd, rs1, rs2, s1)) => True
     | _ => False
     )) then  (case 
 (s6849 s51520 :: (( f_bin_op_D * 5 Word.word * 5 Word.word * 5 Word.word * string)) option) of
     (Some ((FSGNJN_D, rd, rs1, rs2, s1))) =>
 Some
   (F_BIN_TYPE_D (rs2, rs1, rd, FSGNJN_D),
   ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s6866 s51520
                     ::  ((f_bin_op_D *  5 Word.word *  5 Word.word *  5 Word.word * string))option)) of
       Some ((FSGNJX_D, rd, rs1, rs2, s1)) => True
     | _ => False
     )) then  (case 
 (s6866 s51520 :: (( f_bin_op_D * 5 Word.word * 5 Word.word * 5 Word.word * string)) option) of
     (Some ((FSGNJX_D, rd, rs1, rs2, s1))) =>
 Some
   (F_BIN_TYPE_D (rs2, rs1, rd, FSGNJX_D),
   ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s6883 s51520
                     ::  ((f_bin_op_D *  5 Word.word *  5 Word.word *  5 Word.word * string))option)) of
       Some ((FMIN_D, rd, rs1, rs2, s1)) => True
     | _ => False
     )) then  (case 
 (s6883 s51520 :: (( f_bin_op_D * 5 Word.word * 5 Word.word * 5 Word.word * string)) option) of
     (Some ((FMIN_D, rd, rs1, rs2, s1))) =>
 Some
   (F_BIN_TYPE_D (rs2, rs1, rd, FMIN_D),
   ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s6900 s51520
                     ::  ((f_bin_op_D *  5 Word.word *  5 Word.word *  5 Word.word * string))option)) of
       Some ((FMAX_D, rd, rs1, rs2, s1)) => True
     | _ => False
     )) then  (case 
 (s6900 s51520 :: (( f_bin_op_D * 5 Word.word * 5 Word.word * 5 Word.word * string)) option) of
     (Some ((FMAX_D, rd, rs1, rs2, s1))) =>
 Some
   (F_BIN_TYPE_D (rs2, rs1, rd, FMAX_D),
   ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s6917 s51520
                     ::  ((f_bin_op_D *  5 Word.word *  5 Word.word *  5 Word.word * string))option)) of
       Some ((FEQ_D, rd, rs1, rs2, s1)) => True
     | _ => False
     )) then  (case 
 (s6917 s51520 :: (( f_bin_op_D * 5 Word.word * 5 Word.word * 5 Word.word * string)) option) of
     (Some ((FEQ_D, rd, rs1, rs2, s1))) =>
 Some
   (F_BIN_TYPE_D (rs2, rs1, rd, FEQ_D),
   ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s6934 s51520
                     ::  ((f_bin_op_D *  5 Word.word *  5 Word.word *  5 Word.word * string))option)) of
       Some ((FLT_D, rd, rs1, rs2, s1)) => True
     | _ => False
     )) then  (case 
 (s6934 s51520 :: (( f_bin_op_D * 5 Word.word * 5 Word.word * 5 Word.word * string)) option) of
     (Some ((FLT_D, rd, rs1, rs2, s1))) =>
 Some
   (F_BIN_TYPE_D (rs2, rs1, rd, FLT_D),
   ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s6951 s51520
                     ::  ((f_bin_op_D *  5 Word.word *  5 Word.word *  5 Word.word * string))option)) of
       Some ((FLE_D, rd, rs1, rs2, s1)) => True
     | _ => False
     )) then  (case 
 (s6951 s51520 :: (( f_bin_op_D * 5 Word.word * 5 Word.word * 5 Word.word * string)) option) of
     (Some ((FLE_D, rd, rs1, rs2, s1))) =>
 Some
   (F_BIN_TYPE_D (rs2, rs1, rd, FLE_D),
   ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s6968 s51520  ::  ((f_un_op_D *  5 Word.word *  5 Word.word * string))option)) of
       Some ((FMV_X_D, rd, rs1, s1)) => True
     | _ => False
     )) then  (case 
 (s6968 s51520 :: (( f_un_op_D * 5 Word.word * 5 Word.word * string)) option) of
     (Some ((FMV_X_D, rd, rs1, s1))) =>
 Some
   (F_UN_TYPE_D (rs1, rd, FMV_X_D), ((string_length arg1)) -
                                      ((string_length s1)))
 )
   else if ((case  ((s6981 s51520  ::  ((f_un_op_D *  5 Word.word *  5 Word.word * string))option)) of
       Some ((FMV_D_X, rd, rs1, s1)) => True
     | _ => False
     )) then  (case 
 (s6981 s51520 :: (( f_un_op_D * 5 Word.word * 5 Word.word * string)) option) of
     (Some ((FMV_D_X, rd, rs1, s1))) =>
 Some
   (F_UN_TYPE_D (rs1, rd, FMV_D_X), ((string_length arg1)) -
                                      ((string_length s1)))
 )
   else if ((case  ((s6994 s51520  ::  ((f_un_op_D *  5 Word.word *  5 Word.word * string))option)) of
       Some ((FCLASS_D, rd, rs1, s1)) => True
     | _ => False
     )) then  (case 
 (s6994 s51520 :: (( f_un_op_D * 5 Word.word * 5 Word.word * string)) option) of
     (Some ((FCLASS_D, rd, rs1, s1))) =>
 Some
   (F_UN_TYPE_D (rs1, rd, FCLASS_D), ((string_length arg1)) -
                                       ((string_length s1)))
 )
   else if ((case  ((s7007 s51520  ::  (( 5 Word.word *  6 Word.word * string))option)) of
       Some ((rd, uimm, s1)) => (((((( 64 :: int)::ii) = (( 32 :: int)::ii)))) \<or> ((((( 64 :: int)::ii) = (( 64 :: int)::ii)))))
     | _ => False
     )) then  (case  (s7007 s51520 :: (( 5 Word.word * 6 Word.word * string)) option) of
     (Some ((rd, uimm, s1))) =>
 Some (C_FLDSP (uimm, rd), ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s7019 s51520  ::  (( 5 Word.word *  6 Word.word * string))option)) of
       Some ((rs2, uimm, s1)) => (((((( 64 :: int)::ii) = (( 32 :: int)::ii)))) \<or> ((((( 64 :: int)::ii) = (( 64 :: int)::ii)))))
     | _ => False
     )) then  (case  (s7019 s51520 :: (( 5 Word.word * 6 Word.word * string)) option) of
     (Some ((rs2, uimm, s1))) =>
 Some (C_FSDSP (uimm, rs2), ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s7031 s51520  ::  (( 3 Word.word *  3 Word.word *  5 Word.word * string))option)) of
       Some ((rdc, rsc, uimm, s1)) => (((((( 64 :: int)::ii) = (( 32 :: int)::ii)))) \<or> ((((( 64 :: int)::ii) = (( 64 :: int)::ii)))))
     | _ => False
     )) then  (case 
 (s7031 s51520 :: (( 3 Word.word * 3 Word.word * 5 Word.word * string)) option) of
     (Some ((rdc, rsc, uimm, s1))) =>
 Some (C_FLD (uimm, rsc, rdc), ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s7047 s51520  ::  (( 3 Word.word *  3 Word.word *  5 Word.word * string))option)) of
       Some ((rsc1, rsc2, uimm, s1)) => (((((( 64 :: int)::ii) = (( 32 :: int)::ii)))) \<or> ((((( 64 :: int)::ii) = (( 64 :: int)::ii)))))
     | _ => False
     )) then  (case 
 (s7047 s51520 :: (( 3 Word.word * 3 Word.word * 5 Word.word * string)) option) of
     (Some ((rsc1, rsc2, uimm, s1))) =>
 Some
   (C_FSD (uimm, rsc1, rsc2), ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s7063 s51520  ::  (( 32 Word.word * string))option)) of
       Some ((s, s2)) => True
     | _ => False
     )) then  (case  (s7063 s51520 :: (( 32 Word.word * string)) option) of
     (Some ((s, s2))) =>
 Some (ILLEGAL s, ((string_length arg1)) - ((string_length s2)))
 )
   else if ((case  ((s7071 s51520  ::  (( 16 Word.word * string))option)) of
       Some ((s, s2)) => True
     | _ => False
     )) then  (case  (s7071 s51520 :: (( 16 Word.word * string)) option) of
     (Some ((s, s2))) =>
 Some (C_ILLEGAL s, ((string_length arg1)) - ((string_length s2)))
 )
   else None))\<close> 
  for  arg1  :: " string "


definition print_insn  :: \<open> ast \<Rightarrow>((register_value),(string),(exception))monad \<close>  where 
     \<open> print_insn insn = ( assembly_forwards insn )\<close> 
  for  insn  :: " ast "


\<comment> \<open>\<open>val decode : mword ty32 -> M ast\<close>\<close>

definition decode  :: \<open>(32)Word.word \<Rightarrow>((register_value),(ast),(exception))monad \<close>  where 
     \<open> decode bv = ( encdec_backwards bv )\<close> 
  for  bv  :: "(32)Word.word "


\<comment> \<open>\<open>val decodeCompressed : mword ty16 -> M ast\<close>\<close>

definition decodeCompressed  :: \<open>(16)Word.word \<Rightarrow>((register_value),(ast),(exception))monad \<close>  where 
     \<open> decodeCompressed bv = ( encdec_compressed_backwards bv )\<close> 
  for  bv  :: "(16)Word.word "


\<comment> \<open>\<open>val ext_init : unit -> unit\<close>\<close>

definition ext_init  :: \<open> unit \<Rightarrow> unit \<close>  where 
     \<open> ext_init _ = ( ()  )\<close>


\<comment> \<open>\<open>val ext_fetch_hook : FetchResult -> FetchResult\<close>\<close>

definition ext_fetch_hook  :: \<open> FetchResult \<Rightarrow> FetchResult \<close>  where 
     \<open> ext_fetch_hook f = ( f )\<close> 
  for  f  :: " FetchResult "


\<comment> \<open>\<open>val ext_pre_step_hook : unit -> unit\<close>\<close>

definition ext_pre_step_hook  :: \<open> unit \<Rightarrow> unit \<close>  where 
     \<open> ext_pre_step_hook _ = ( ()  )\<close>


\<comment> \<open>\<open>val ext_post_step_hook : unit -> unit\<close>\<close>

definition ext_post_step_hook  :: \<open> unit \<Rightarrow> unit \<close>  where 
     \<open> ext_post_step_hook _ = ( ()  )\<close>


\<comment> \<open>\<open>val ext_post_decode_hook : ast -> M ast\<close>\<close>

definition ext_post_decode_hook  :: \<open> ast \<Rightarrow>((register_value),(ast),(exception))monad \<close>  where 
     \<open> ext_post_decode_hook x = ( return x )\<close> 
  for  x  :: " ast "


\<comment> \<open>\<open>val isRVC : mword ty16 -> bool\<close>\<close>

definition isRVC  :: \<open>(16)Word.word \<Rightarrow> bool \<close>  where 
     \<open> isRVC h = ( \<not> (((((subrange_vec_dec h (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b11 ::  2 Word.word)))))\<close> 
  for  h  :: "(16)Word.word "


\<comment> \<open>\<open>val fetch : unit -> M FetchResult\<close>\<close>

definition fetch  :: \<open> unit \<Rightarrow>((register_value),(FetchResult),(exception))monad \<close>  where 
     \<open> fetch _ = (
   (read_reg PC_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
   (read_reg PC_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
   (case  ((ext_fetch_check_pc w__0 w__1)) of
     Ext_FetchAddr_Error (e) => return (F_Ext_Error e)
   | Ext_FetchAddr_OK (use_pc) =>
      or_boolM (return (((((access_vec_dec use_pc (( 0 :: int)::ii))) \<noteq> B0))))
        (and_boolM (return (((((access_vec_dec use_pc (( 1 :: int)::ii))) \<noteq> B0))))
           (haveRVC ()  \<bind> ((\<lambda> (w__2 :: bool) .  return ((\<not> w__2)))))) \<bind> ((\<lambda> (w__4 :: bool) . 
      if w__4 then
        (read_reg PC_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__5 ::  64 Word.word) . 
        return (F_Error (E_Fetch_Addr_Align () , w__5))))
      else
        (translateAddr use_pc (Execute () )  :: ( (( 64 Word.word), ExceptionType)TR_Result) M) \<bind> ((\<lambda> (w__6 :: (( 64 Word.word), ExceptionType)
          TR_Result) . 
        (case  w__6 of
          TR_Failure ((e, _)) =>
           (read_reg PC_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__7 ::  64 Word.word) . 
           return (F_Error (e, w__7))))
        | TR_Address ((ppclo, _)) =>
           (mem_read (Execute () ) ppclo (( 2 :: int)::ii) False False False  :: ( ( 16 Word.word)MemoryOpResult) M) \<bind> ((\<lambda> (w__8 :: ( 16 Word.word)
             MemoryOpResult) . 
           (case  w__8 of
             MemException (e) =>
              (read_reg PC_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__9 ::  64 Word.word) . 
              return (F_Error (e, w__9))))
           | MemValue (ilo) =>
              if ((isRVC ilo)) then return (F_RVC ilo)
              else
                (read_reg PC_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__10 ::  64 Word.word) . 
                (let (PC_hi :: xlenbits) = ((add_vec_int w__10 (( 2 :: int)::ii)  ::  64 Word.word)) in
                (read_reg PC_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__11 ::  64 Word.word) . 
                (case  ((ext_fetch_check_pc w__11 PC_hi)) of
                  Ext_FetchAddr_Error (e) => return (F_Ext_Error e)
                | Ext_FetchAddr_OK (use_pc_hi) =>
                   (translateAddr use_pc_hi (Execute () )  :: ( (( 64 Word.word), ExceptionType)TR_Result) M) \<bind> ((\<lambda> (w__12 :: (( 64 Word.word), ExceptionType)
                     TR_Result) . 
                   (case  w__12 of
                     TR_Failure ((e, _)) => return (F_Error (e, PC_hi))
                   | TR_Address ((ppchi, _)) =>
                      (mem_read (Execute () ) ppchi (( 2 :: int)::ii) False False False
                        :: ( ( 16 Word.word)MemoryOpResult) M) \<bind> ((\<lambda> (w__13 :: ( 16 Word.word)
                        MemoryOpResult) . 
                      return ((case  w__13 of
                        MemException (e) => F_Error (e, PC_hi)
                      | MemValue (ihi) => F_Base ((concat_vec ihi ilo  ::  32 Word.word))
                      ))))
                   )))
                ))))))
           )))
        )))))
   ))))))\<close>


\<comment> \<open>\<open>val step : ii -> M bool\<close>\<close>

definition step  :: \<open> int \<Rightarrow>((register_value),(bool),(exception))monad \<close>  where 
     \<open> step step_no = (
   (let (_ :: unit) = (ext_pre_step_hook () ) in
   (write_reg minstret_written_ref False \<then>
   read_reg cur_privilege_ref) \<bind> ((\<lambda> (w__0 :: Privilege) . 
   dispatchInterrupt w__0 \<bind> ((\<lambda> (w__1 ::  ((InterruptType * Privilege))option) . 
   (case  w__1 of
     Some ((intr, priv)) =>
      (let (_ :: unit) =
        (if ((get_config_print_instr () )) then
          print_bits0 (''Handling interrupt: '') ((interruptType_to_bits intr  ::  8 Word.word))
        else () ) in
      handle_interrupt intr priv \<then> return (RETIRE_FAIL, False))
   | None =>
      fetch ()  \<bind> ((\<lambda> (w__2 :: FetchResult) . 
      (let (f :: FetchResult) = (ext_fetch_hook w__2) in
      (case  f of
        F_Ext_Error (e) =>
         (let (_ :: unit) = (ext_handle_fetch_check_error e) in
         return (RETIRE_FAIL, False))
      | F_Error ((e, addr)) => handle_mem_exception addr e \<then> return (RETIRE_FAIL, False)
      | F_RVC (h) =>
         decodeCompressed h \<bind> ((\<lambda> ast . 
         ((if ((get_config_print_instr () )) then
            read_reg cur_privilege_ref \<bind> ((\<lambda> (w__3 :: Privilege) . 
            (read_reg PC_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__4 ::  64 Word.word) . 
            print_insn ast \<bind> ((\<lambda> (w__5 :: string) . 
            return ((print_dbg
                       (((@) (''['')
                           (((@) ((stringFromInteger step_no))
                               (((@) (''] ['')
                                   (((@) ((privLevel_to_str w__3))
                                       (((@) ('']: '')
                                           (((@) ((string_of_bits w__4))
                                               (((@) ('' ('')
                                                   (((@) ((string_of_bits h))
                                                       (((@) ('') '') w__5))))))))))))))))))))))))))
          else return () ) \<then>
         haveRVC () ) \<bind> ((\<lambda> (w__6 :: bool) . 
         if w__6 then
           (read_reg PC_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__7 ::  64 Word.word) . 
           (write_reg nextPC_ref ((add_vec_int w__7 (( 2 :: int)::ii)  ::  64 Word.word)) \<then>
           ext_post_decode_hook ast) \<bind> ((\<lambda> (w__8 :: ast) . 
           execute w__8 \<bind> ((\<lambda> (w__9 :: Retired) .  return (w__9, True)))))))
         else handle_illegal ()  \<then> return (RETIRE_FAIL, True)))))
      | F_Base (w) =>
         decode w \<bind> ((\<lambda> ast . 
         ((if ((get_config_print_instr () )) then
            read_reg cur_privilege_ref \<bind> ((\<lambda> (w__11 :: Privilege) . 
            (read_reg PC_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__12 ::  64 Word.word) . 
            print_insn ast \<bind> ((\<lambda> (w__13 :: string) . 
            return ((print_dbg
                       (((@) (''['')
                           (((@) ((stringFromInteger step_no))
                               (((@) (''] ['')
                                   (((@) ((privLevel_to_str w__11))
                                       (((@) ('']: '')
                                           (((@) ((string_of_bits w__12))
                                               (((@) ('' ('')
                                                   (((@) ((string_of_bits w))
                                                       (((@) ('') '') w__13))))))))))))))))))))))))))
          else return () ) \<then>
         (read_reg PC_ref  :: ( 64 Word.word) M)) \<bind> ((\<lambda> (w__14 ::  64 Word.word) . 
         (write_reg nextPC_ref ((add_vec_int w__14 (( 4 :: int)::ii)  ::  64 Word.word)) \<then>
         ext_post_decode_hook ast) \<bind> ((\<lambda> (w__15 :: ast) . 
         execute w__15 \<bind> ((\<lambda> (w__16 :: Retired) .  return (w__16, True)))))))))
      ))))
   ) \<bind> ((\<lambda> varstup .  (let ((retired :: Retired), (stepped :: bool)) = varstup in
   (tick_pc ()  \<then>
   (case  retired of   RETIRE_SUCCESS => retire_instruction ()  | RETIRE_FAIL => return ()  )) \<then>
   ((let (_ :: unit) = (ext_post_step_hook () ) in
   return stepped)))))))))))\<close> 
  for  step_no  :: " int "


\<comment> \<open>\<open>val loop : unit -> M unit\<close>\<close>

definition loop  :: \<open> unit \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> loop _ = (
   (let insns_per_tick = (plat_insns_per_tick () ) in
   (let (i :: ii) = ((( 0 :: int)::ii)) in
   (let (step_no :: ii) = ((( 0 :: int)::ii)) in
   (whileM (i, step_no)
     ((\<lambda> varstup .  (let (i, step_no) = varstup in
       read_reg htif_done_ref \<bind> ((\<lambda> (w__0 :: bool) .  return ((\<not> w__0)))))))
     ((\<lambda> varstup .  (let (i, step_no) = varstup in
       step step_no \<bind> ((\<lambda> stepped . 
       (let (step_no :: ii) = (if stepped then step_no + (( 1 :: int)::ii) else step_no) in
       read_reg htif_done_ref \<bind> ((\<lambda> (w__1 :: bool) . 
       (if w__1 then
          (read_reg htif_exit_code_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__2 ::  64 Word.word) . 
          (let exit_val = (Word.uint w__2) in
          return ((let (_ :: unit) =
            (if (((exit_val = (( 0 :: int)::ii)))) then print_endline (''SUCCESS'')
            else print_int (''FAILURE: '') exit_val) in
          i)))))
        else
          (let i = (i + (( 1 :: int)::ii)) in
          if (((i = insns_per_tick))) then (tick_clock ()  \<then> tick_platform () ) \<then> return (( 0 :: int)::ii)
          else return i)) \<bind> ((\<lambda> (i :: ii) . 
       return (i, step_no)))))))))))) \<bind> ((\<lambda> varstup .  (let ((i :: ii), (step_no :: ii)) = varstup in
   return () )))))))\<close>


\<comment> \<open>\<open>val init_model : unit -> M unit\<close>\<close>

definition init_model  :: \<open> unit \<Rightarrow>((register_value),(unit),(exception))monad \<close>  where 
     \<open> init_model _ = (
   ((init_platform ()  \<then>
   init_sys () ) \<then>
   init_vmem () ) \<then>
   ((let (_ :: unit) = (ext_init () ) in
   ext_init_regs () )))\<close>


definition GPRstrs  :: \<open>(string)list \<close>  where 
     \<open> GPRstrs = (
  [(''x31''),(''x30''),(''x29''),(''x28''),(''x27''),(''x26''),(''x25''),(''x24''),(''x23''),(''x22''),(''x21''),(''x20''),(''x19''),(''x18''),(''x17''),(''x16''),
   (''x15''),(''x14''),(''x13''),(''x12''),(''x11''),(''x10''),(''x9''),(''x8''),(''x7''),(''x6''),(''x5''),(''x4''),(''x3''),(''x2''),(''x1''),(''x0'')])\<close>


\<comment> \<open>\<open>val GPRstr : mword ty5 -> string\<close>\<close>

definition GPRstr  :: \<open>(5)Word.word \<Rightarrow> string \<close>  where 
     \<open> GPRstr i = ( access_list_dec GPRstrs ((Word.uint i)))\<close> 
  for  i  :: "(5)Word.word "


definition CIA_fp  :: \<open> regfp \<close>  where 
     \<open> CIA_fp = ( RFull (''CIA''))\<close>


definition NIA_fp  :: \<open> regfp \<close>  where 
     \<open> NIA_fp = ( RFull (''NIA''))\<close>


\<comment> \<open>\<open>val initial_analysis : ast -> M (list regfp * list regfp * list regfp * list niafp * diafp * instruction_kind)\<close>\<close>

definition initial_analysis  :: \<open> ast \<Rightarrow>((register_value),((regfp)list*(regfp)list*(regfp)list*(niafp)list*diafp*instruction_kind),(exception))monad \<close>  where 
     \<open> initial_analysis instr = (
   (let iR = ([]) in
   (let oR = ([]) in
   (let aR = ([]) in
   (let ik = (IK_simple () ) in
   (let Nias = ([NIAFP_successor () ]) in
   (let Dia = (DIAFP_none () ) in
   (case  instr of
     EBREAK (_) => return (Nias, aR, iR, ik, oR)
   | UTYPE ((imm, rd, op1)) =>
      (let (oR :: regfp list) =
        (if (((rd = ( 0b00000 ::  5 Word.word)))) then oR
        else (RFull ((GPRstr rd))) # oR) in
      return (Nias, aR, iR, ik, oR))
   | RISCV_JAL ((imm, rd)) =>
      (let (oR :: regfp list) =
        (if (((rd = ( 0b00000 ::  5 Word.word)))) then oR
        else (RFull ((GPRstr rd))) # oR) in
      (let (offset :: 64 bits) = ((EXTS (( 64 :: int)::ii) imm  ::  64 Word.word)) in
      (read_reg PC_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__0 ::  64 Word.word) . 
      (let (Nias :: niafp list) = ([NIAFP_concrete_address ((add_vec w__0 offset  ::  64 Word.word))]) in
      (let (ik :: instruction_kind) = (IK_branch () ) in
      return (Nias, aR, iR, ik, oR)))))))
   | RISCV_JALR ((imm, rs, rd)) =>
      (let (iR :: regfp list) =
        (if (((rs = ( 0b00000 ::  5 Word.word)))) then iR
        else (RFull ((GPRstr rs))) # iR) in
      (let (oR :: regfp list) =
        (if (((rd = ( 0b00000 ::  5 Word.word)))) then oR
        else (RFull ((GPRstr rd))) # oR) in
      (let (offset :: 64 bits) = ((EXTS (( 64 :: int)::ii) imm  ::  64 Word.word)) in
      (let (Nias :: niafp list) = ([NIAFP_indirect_address () ]) in
      (let (ik :: instruction_kind) = (IK_branch () ) in
      return (Nias, aR, iR, ik, oR))))))
   | BTYPE ((imm, rs2, rs1, op1)) =>
      (let (iR :: regfp list) =
        (if (((rs2 = ( 0b00000 ::  5 Word.word)))) then iR
        else (RFull ((GPRstr rs2))) # iR) in
      (let (iR :: regfp list) =
        (if (((rs1 = ( 0b00000 ::  5 Word.word)))) then iR
        else (RFull ((GPRstr rs1))) # iR) in
      (let ik = (IK_branch () ) in
      (let (offset :: 64 bits) = ((EXTS (( 64 :: int)::ii) imm  ::  64 Word.word)) in
      (read_reg PC_ref  :: ( 64 Word.word) M) \<bind> ((\<lambda> (w__1 ::  64 Word.word) . 
      (let (Nias :: niafp list) =
        ([NIAFP_concrete_address ((add_vec w__1 offset  ::  64 Word.word)),NIAFP_successor () ]) in
      return (Nias, aR, iR, ik, oR))))))))
   | ITYPE ((imm, rs, rd, op1)) =>
      (let (iR :: regfp list) =
        (if (((rs = ( 0b00000 ::  5 Word.word)))) then iR
        else (RFull ((GPRstr rs))) # iR) in
      (let (oR :: regfp list) =
        (if (((rd = ( 0b00000 ::  5 Word.word)))) then oR
        else (RFull ((GPRstr rd))) # oR) in
      return (Nias, aR, iR, ik, oR)))
   | SHIFTIOP ((imm, rs, rd, op1)) =>
      (let (iR :: regfp list) =
        (if (((rs = ( 0b00000 ::  5 Word.word)))) then iR
        else (RFull ((GPRstr rs))) # iR) in
      (let (oR :: regfp list) =
        (if (((rd = ( 0b00000 ::  5 Word.word)))) then oR
        else (RFull ((GPRstr rd))) # oR) in
      return (Nias, aR, iR, ik, oR)))
   | RTYPE ((rs2, rs1, rd, op1)) =>
      (let (iR :: regfp list) =
        (if (((rs2 = ( 0b00000 ::  5 Word.word)))) then iR
        else (RFull ((GPRstr rs2))) # iR) in
      (let (iR :: regfp list) =
        (if (((rs1 = ( 0b00000 ::  5 Word.word)))) then iR
        else (RFull ((GPRstr rs1))) # iR) in
      (let (oR :: regfp list) =
        (if (((rd = ( 0b00000 ::  5 Word.word)))) then oR
        else (RFull ((GPRstr rd))) # oR) in
      return (Nias, aR, iR, ik, oR))))
   | CSR ((csr, rs1, rd, is_imm, op1)) =>
      (let (isWrite :: bool) =
        ((case  op1 of
          CSRRW => True
        | _ => if is_imm then (((Word.uint rs1)) \<noteq> (( 0 :: int)::ii)) else (((Word.uint rs1)) \<noteq> (( 0 :: int)::ii))
        )) in
      (let (iR :: regfp list) = ((RFull ((csr_name csr))) # iR) in
      (let (iR :: regfp list) = (if ((\<not> is_imm)) then (RFull ((GPRstr rs1))) # iR else iR) in
      (let (oR :: regfp list) = (if isWrite then (RFull ((csr_name csr))) # oR else oR) in
      (let (oR :: regfp list) = ((RFull ((GPRstr rd))) # oR) in
      return (Nias, aR, iR, ik, oR))))))
   | LOAD ((imm, rs, rd, unsign, width, aq, rl)) =>
      (let (iR :: regfp list) =
        (if (((rs = ( 0b00000 ::  5 Word.word)))) then iR
        else (RFull ((GPRstr rs))) # iR) in
      (let (oR :: regfp list) =
        (if (((rd = ( 0b00000 ::  5 Word.word)))) then oR
        else (RFull ((GPRstr rd))) # oR) in
      (let aR = iR in
      (case  (aq, rl) of
        (False, False) => return (IK_mem_read Read_plain)
      | (True, False) => return (IK_mem_read Read_RISCV_acquire)
      | (True, True) => return (IK_mem_read Read_RISCV_strong_acquire)
      | _ => internal_error (''LOAD type not implemented in initial_analysis'')
      ) \<bind> ((\<lambda> (w__3 :: instruction_kind) . 
      (let (ik :: instruction_kind) = w__3 in
      return (Nias, aR, iR, ik, oR)))))))
   | STORE ((imm, rs2, rs1, width, aq, rl)) =>
      (let (iR :: regfp list) =
        (if (((rs2 = ( 0b00000 ::  5 Word.word)))) then iR
        else (RFull ((GPRstr rs2))) # iR) in
      (let (iR :: regfp list) =
        (if (((rs1 = ( 0b00000 ::  5 Word.word)))) then iR
        else (RFull ((GPRstr rs1))) # iR) in
      (let (aR :: regfp list) =
        (if (((rs1 = ( 0b00000 ::  5 Word.word)))) then aR
        else (RFull ((GPRstr rs1))) # aR) in
      (case  (aq, rl) of
        (False, False) => return (IK_mem_write Write_plain)
      | (False, True) => return (IK_mem_write Write_RISCV_release)
      | (True, True) => return (IK_mem_write Write_RISCV_strong_release)
      | _ => internal_error (''STORE type not implemented in initial_analysis'')
      ) \<bind> ((\<lambda> (w__5 :: instruction_kind) . 
      (let (ik :: instruction_kind) = w__5 in
      return (Nias, aR, iR, ik, oR)))))))
   | ADDIW ((imm, rs, rd)) =>
      (let (iR :: regfp list) =
        (if (((rs = ( 0b00000 ::  5 Word.word)))) then iR
        else (RFull ((GPRstr rs))) # iR) in
      (let (oR :: regfp list) =
        (if (((rd = ( 0b00000 ::  5 Word.word)))) then oR
        else (RFull ((GPRstr rd))) # oR) in
      return (Nias, aR, iR, ik, oR)))
   | SHIFTW ((imm, rs, rd, op1)) =>
      (let (iR :: regfp list) =
        (if (((rs = ( 0b00000 ::  5 Word.word)))) then iR
        else (RFull ((GPRstr rs))) # iR) in
      (let (oR :: regfp list) =
        (if (((rd = ( 0b00000 ::  5 Word.word)))) then oR
        else (RFull ((GPRstr rd))) # oR) in
      return (Nias, aR, iR, ik, oR)))
   | RTYPEW ((rs2, rs1, rd, op1)) =>
      (let (iR :: regfp list) =
        (if (((rs2 = ( 0b00000 ::  5 Word.word)))) then iR
        else (RFull ((GPRstr rs2))) # iR) in
      (let (iR :: regfp list) =
        (if (((rs1 = ( 0b00000 ::  5 Word.word)))) then iR
        else (RFull ((GPRstr rs1))) # iR) in
      (let (oR :: regfp list) =
        (if (((rd = ( 0b00000 ::  5 Word.word)))) then oR
        else (RFull ((GPRstr rd))) # oR) in
      return (Nias, aR, iR, ik, oR))))
   | FENCE ((pred, succ)) =>
      (case  (pred, succ) of
        (v__1502, v__1503) =>
         if ((((((((subrange_vec_dec v__1502 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b11 ::  2 Word.word)))) \<and> (((((subrange_vec_dec v__1503 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b11 ::  2 Word.word)))))))
         then
           return (IK_barrier (Barrier_RISCV_rw_rw () ))
         else if ((((((((subrange_vec_dec v__1502 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b10 ::  2 Word.word)))) \<and> (((((subrange_vec_dec v__1503 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b11 ::  2 Word.word))))))) then
           return (IK_barrier (Barrier_RISCV_r_rw () ))
         else if ((((((((subrange_vec_dec v__1502 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b10 ::  2 Word.word)))) \<and> (((((subrange_vec_dec v__1503 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b10 ::  2 Word.word))))))) then
           return (IK_barrier (Barrier_RISCV_r_r () ))
         else if ((((((((subrange_vec_dec v__1502 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b11 ::  2 Word.word)))) \<and> (((((subrange_vec_dec v__1503 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b01 ::  2 Word.word))))))) then
           return (IK_barrier (Barrier_RISCV_rw_w () ))
         else if ((((((((subrange_vec_dec v__1502 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b01 ::  2 Word.word)))) \<and> (((((subrange_vec_dec v__1503 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b01 ::  2 Word.word))))))) then
           return (IK_barrier (Barrier_RISCV_w_w () ))
         else if ((((((((subrange_vec_dec v__1502 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b01 ::  2 Word.word)))) \<and> (((((subrange_vec_dec v__1503 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b11 ::  2 Word.word))))))) then
           return (IK_barrier (Barrier_RISCV_w_rw () ))
         else if ((((((((subrange_vec_dec v__1502 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b11 ::  2 Word.word)))) \<and> (((((subrange_vec_dec v__1503 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b10 ::  2 Word.word))))))) then
           return (IK_barrier (Barrier_RISCV_rw_r () ))
         else if ((((((((subrange_vec_dec v__1502 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b10 ::  2 Word.word)))) \<and> (((((subrange_vec_dec v__1503 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b01 ::  2 Word.word))))))) then
           return (IK_barrier (Barrier_RISCV_r_w () ))
         else if ((((((((subrange_vec_dec v__1502 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b01 ::  2 Word.word)))) \<and> (((((subrange_vec_dec v__1503 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b10 ::  2 Word.word))))))) then
           return (IK_barrier (Barrier_RISCV_w_r () ))
         else if ((((((((subrange_vec_dec v__1502 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b00 ::  2 Word.word)))) \<and> (((((subrange_vec_dec v__1503 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b00 ::  2 Word.word))))))) then
           return (IK_simple () )
         else internal_error (''barrier type not implemented in initial_analysis'')
      ) \<bind> ((\<lambda> (w__17 :: instruction_kind) . 
      (let (ik :: instruction_kind) = w__17 in
      return (Nias, aR, iR, ik, oR))))
   | FENCE_TSO ((pred, succ)) =>
      (case  (pred, succ) of
        (v__1542, v__1543) =>
         if ((((((((subrange_vec_dec v__1542 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b11 ::  2 Word.word)))) \<and> (((((subrange_vec_dec v__1543 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = ( 0b11 ::  2 Word.word)))))))
         then
           return (IK_barrier (Barrier_RISCV_tso () ))
         else internal_error (''barrier type not implemented in initial_analysis'')
      ) \<bind> ((\<lambda> (w__20 :: instruction_kind) . 
      (let (ik :: instruction_kind) = w__20 in
      return (Nias, aR, iR, ik, oR))))
   | FENCEI (_) =>
      (let (ik :: instruction_kind) = (IK_simple () ) in
      return (Nias, aR, iR, ik, oR))
   | LOADRES ((aq, rl, rs1, width, rd)) =>
      (let (iR :: regfp list) =
        (if (((rs1 = ( 0b00000 ::  5 Word.word)))) then iR
        else (RFull ((GPRstr rs1))) # iR) in
      (let (oR :: regfp list) =
        (if (((rd = ( 0b00000 ::  5 Word.word)))) then oR
        else (RFull ((GPRstr rd))) # oR) in
      (let aR = iR in
      (case  (aq, rl) of
        (False, False) => return (IK_mem_read Read_RISCV_reserved)
      | (True, False) => return (IK_mem_read Read_RISCV_reserved_acquire)
      | (True, True) => return (IK_mem_read Read_RISCV_reserved_strong_acquire)
      | (False, True) => internal_error (''LOADRES type not implemented in initial_analysis'')
      ) \<bind> ((\<lambda> (w__22 :: instruction_kind) . 
      (let (ik :: instruction_kind) = w__22 in
      return (Nias, aR, iR, ik, oR)))))))
   | STORECON ((aq, rl, rs2, rs1, width, rd)) =>
      (let (iR :: regfp list) =
        (if (((rs2 = ( 0b00000 ::  5 Word.word)))) then iR
        else (RFull ((GPRstr rs2))) # iR) in
      (let (iR :: regfp list) =
        (if (((rs1 = ( 0b00000 ::  5 Word.word)))) then iR
        else (RFull ((GPRstr rs1))) # iR) in
      (let (aR :: regfp list) =
        (if (((rs1 = ( 0b00000 ::  5 Word.word)))) then aR
        else (RFull ((GPRstr rs1))) # aR) in
      (let (oR :: regfp list) =
        (if (((rd = ( 0b00000 ::  5 Word.word)))) then oR
        else (RFull ((GPRstr rd))) # oR) in
      (case  (aq, rl) of
        (False, False) => return (IK_mem_write Write_RISCV_conditional)
      | (False, True) => return (IK_mem_write Write_RISCV_conditional_release)
      | (True, True) => return (IK_mem_write Write_RISCV_conditional_strong_release)
      | (True, False) => internal_error (''STORECON type not implemented in initial_analysis'')
      ) \<bind> ((\<lambda> (w__24 :: instruction_kind) . 
      (let (ik :: instruction_kind) = w__24 in
      return (Nias, aR, iR, ik, oR))))))))
   | AMO ((op1, aq, rl, rs2, rs1, width, rd)) =>
      (let (iR :: regfp list) =
        (if (((rs2 = ( 0b00000 ::  5 Word.word)))) then iR
        else (RFull ((GPRstr rs2))) # iR) in
      (let (iR :: regfp list) =
        (if (((rs1 = ( 0b00000 ::  5 Word.word)))) then iR
        else (RFull ((GPRstr rs1))) # iR) in
      (let (aR :: regfp list) =
        (if (((rs1 = ( 0b00000 ::  5 Word.word)))) then aR
        else (RFull ((GPRstr rs1))) # aR) in
      (let (oR :: regfp list) =
        (if (((rd = ( 0b00000 ::  5 Word.word)))) then oR
        else (RFull ((GPRstr rd))) # oR) in
      (let (ik :: instruction_kind) =
        ((case  (aq, rl) of
          (False, False) => IK_mem_rmw (Read_RISCV_reserved, Write_RISCV_conditional)
        | (False, True) => IK_mem_rmw (Read_RISCV_reserved, Write_RISCV_conditional_release)
        | (True, False) => IK_mem_rmw (Read_RISCV_reserved_acquire, Write_RISCV_conditional)
        | (True, True) => IK_mem_rmw (Read_RISCV_reserved_acquire, Write_RISCV_conditional_release)
        )) in
      return (Nias, aR, iR, ik, oR))))))
   | _ => return (Nias, aR, iR, ik, oR)
   ) \<bind> ((\<lambda> varstup .  (let ((Nias :: niafp list), (aR :: regfp list), (iR :: regfp list), (ik ::
     instruction_kind), (oR :: regfp list)) = varstup in
   return (iR, oR, aR, Nias, Dia, ik)))))))))))\<close> 
  for  instr  :: " ast "



end
